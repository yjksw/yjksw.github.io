---
emoji: 🧁
title: 운영체제와 정보기술의 원리 - CH7. 메모리 관리
date: '2021-10-16 23:10:00'
author: 코다
tags: 운영체제 책
categories: 운영체제 책
---

> 다음은 반효경 교수님의 '운영체제와 정보기술의 원리' *CH7. 메모리 관리*를 읽고 정리한 내용입니다 🙌

<br>
<br>

## 🌩 들어가기 전 

- 우리가 흔히 사용하는 컴퓨터 주소 체계는 32비트 혹은 64비트로 나뉘어져 있다.
    - 32비트면 32개의 비트로 주소를 표현할 수 있는 것이다.
    - 2^32가지 다른 메모리 위치를 구분할 수 있다.
    - 컴퓨터는 바이트 단위(8비트)로 주소를 부여한다. 따라서 2^32 바이트 만큼의 메모리 공간에 서로 다른 주소를 할당할 수 있다.
- 32 비트를 계층적으로 묶어서 관리한다.
- 보통 4KB (2^12 바이트) 단위로 묶어서 페이지(page)를 구성한다.
    - 페이지 내에서 주소를 구분하기 위해서는 12비트가 필요하다. 따라서 32비트 중 하위 12비트는 페이지 내에서 주소를 나타낸다.
    
<br>

## 🌩 1. 주소 바인딩

- 프로세스의 주소 공간 (address space)는 프로그램이 실행되기 위해 메모리에 적재되면 프로세스를 위한 독자적인 주소 공간이 생성된다.
    - 논리적 주소 (logical address) 혹은 가상 주소 (virtual address)라고 부른다.
    - CPU는 논리적 주소에 근거해 명령을 실행한다.
- 논리적 주소는 프로세스 마다 **독립적**으로 할당되고 모두 0번지부터 시작한다.
- 물리적 주소 (physical address)는 물리적 메모리에 실제로 올라가는 위치이다.
    - 물리적 메모리의 낮은 주소에는 운영체제가 올라가고 높은 주소에는 사용자 프로세스들이 올라간다.
- 메모리 참조를 할 때 프로세스의 논리적 주소가 물리적 주소의 어느 위치인지 확인해야하는 주소 바인딩 (address binding)이라는 작업이 필요하다.

### 주소 바인딩 방식

- 물리 메모리 주소가 결정되는 시기에 따라서 분류된다.
1. 컴파일 타임 바인딩 (compile time binding) 
    - 프로그램을 컴파일할 때 물리적 메모리 주소가 결정
    - 컴파일 시점에 해당 프로그램이 물리적 메모리 몇 번지에 위치할 것인지 결정
    - 프로그램이 절대주소로 적재된다는 뜻으로 절대코드를 생성하는 바인딩 (absolute code)
    - 프로그램의 물리적 주소를 변경하고 싶다면 프로그램을 다시 컴파일해야한다.
    - 비현실적이며 현대 시분할 컴퓨팅 환경에서는 잘 사용하지 않는다.
2. 로드 타임 바인딩 (load time binding)
    - 프로그램이 시작될 때 물리적 메모리 주소가 결정
    - loader의 책임하에 물리적 메모리 주소가 부여되고 프로그램 종료까지 물리적 메모리상의 위치가 고정
        - 로더는 사용자 프로그램을 메모리에 적재시키는 프로그램
    - 컴파일러가 재배치 가능 코드(relocatable code)를 생성한 경우에 가능한 주소 바인딩 방식
3. 실행시간 바인딩 (execution time binding or run time binding)
    - 프로그램 시작 후에도 물리적 메모리 주소가 변경될 수 있음
    - CPU가 메모리 주소를 참조할 때마다 데이터가 물리적 메모리의 어느 위치에 있는지 주소 매핑 테이블 (address mapping table)을 참조해 바인딩을 점검
    - 기준 레지스터 (base register)와 한계 레지스터 (limit register) 를 포함하여 MMU (Memeory Management Unit)이라는 하드웨어적 자원 뒷받침이 필요
        - MMU는 논리적 주소를 물리적 주소로 매핑해주는 하드웨어 장치

### MMU 기법

- MMU를 사용하여 주소 변환하는 기본적인 방식
- MMU 기법은 논리적 주소값에 기준 레지스터 값을 더해 물리적 주소값을 얻어낸다.
    - 기준 레지스터는 재배치 레지스터 (reload register)라고도 하며 프로세스의 물리적 메모리 시작 주소를 가지고 있다.
    - offset 개념
- MMU 기법은 프로그램의 주소가 물리적 메모리에 연속적으로 적재된 것을 가정한다.
- 따라서 물리적 메모리의 시작 주소만 알면 변환을 쉽게 할 수 있으며 사용자 프로그램이나 CPU는 물리적 메모리를 알 필요 없이 논리적 메모리 주소만 다룬다.
- 프로세스마다 고유의 메모리 주소를 가지고 있기 때문에 같은 주소 (논리적 메모리 주소 100번지)도 각기 다른 물리적 메모리 위치를 가리켜야한다.
    - 이것을 기준 레지스터를 해당 프로세스에 맞는 값으로 설정하므로 여러 프로세스에 대한 주소 매핑을 한다.

### 메모리 보안 Memory protection

- 메모리에 여러 프로세스가 올라가 있기 때문에 한 프로세스가 다른 프로세스의 물리적 주소를 참조하여 문제가 발생할수도 있다.
- 한계 레지스터 (limit register)를 이용하여 해당 프로세스가 자신의 주소 공간을 넘어 메모리를 참조하면 (base register + limit register) 트랩을 발생시켜 해당 프로세스를 종료시킨다.

<br>

## 🌩 2. 메모리 관리와 관련된 용어

### 1) 동적로딩 dynamic loading

- 여러 프로그램이 동시에 메모리에 올라가서 수행되는 다중 프로그래밍(multi-programming) 환경에서 메모리 효율을 높이는 기법이다.
- 프로세스가 시작될 때 그 프로세스의 주소 공간 전체를 물리적 메모리에 올리는 것이 아니라 해당 부분이 호출될 때 메모리에 적재되는 방식이다.
    - 프로그램의 오류 처리루틴 등등은 가끔씩만 사용되는 방어용 코드이므로 항상 적재될 필요는 없다.
- 필요하지 않은 코드가 한꺼번에 적재되어 메모리가 낭비되는 것을 막아 메모리를 효율적으로 사용할 수 있도록 한다.
    - 프로그램 자체에서 구현 가능하고 운영체제가 라이브러리로 지원하기도 한다.

### 2) 동적연결 dynamic linking

- 연결은 개발자가 작성한 소스코드를 컴파일하여 생성된 object file과 이미 컴파일된 라이브러리 파일 library file을 묶어 하나의 실행파일을 생성하는 과정이다.
- 동적연결은 이 연결을 프로그램 실행 시점까지 지연시키는 기법이다.
    - 정적 연결 static linking은 미리 작성된 코드와 라이브러리 코드가 합쳐져서 실행파일이 생성된다.
    - 따라서 실행파일의 크기가 크고 동일한 라이브러리를 각 프로세스가 개별적으로 메모리에 적재하여 물리적 메모리가 낭비된다.
- 동적연결은 라이브러리가 실행시점에 연결되어 실행파일에 라이브러리 코드가 포함되어 있지 않고 라이브러리 함수 호출 시 라이브러리에 연결된다.
- 동적연결을 위해 코드의 라이브러리 호출 부분에 스텁 stub이라는 작은 코드를 둔다.
    - stub으로 해당 라이브러리가 메모리에 존재하는지 보고 있다면 그 주소에서 직접 참조하고 없다면 디스크에서 라이브러리를 메모리로 적재한다.
- 공동으로 사용하는 라이브러리는 한번 적재하여 메모리 효율을 높인다.
- 운영체제의 지원이 필요하다.

### 3) 중첩 overlays

- 프로세스의 주소 공간을 분할해 실제 필요한 부분만 메모리에 적재하는 기법이다.
- 동적로딩과 비슷하나 중첩의 배경은 초창기에 물리적 메모리의 공간이 부족하여 프로세스의 주소 공간을 분할해 당장 필요한 부분을 올리고 해당 부분의 실행이 끝나면 나머지 부분을 올려서 실행한 기법이다. (단일 프로세스를 올릴 때 메모리가 부족한 경우..)
    - 동적로딩은 다중 프로그래밍 환경에서 메모리 이용률을 높이기 위한 기법이다.
- 중첩은 운영체제의 지원이 없고 프로그래머가 직접 구현되어야 했으며 따라서 수작업 중첩(manual overlays)라고도 부른다.

### 4) 스와핑 swapping

- 메모리에 올라온 프로세스의 주소공간 전체를 스왑 영역에 일시적으로 내려놓는 것이다.
- 스왑 영역을 백킹스토어 backing store 라고도 부른다.
    - 디스크 내에서 파일 시스템과는 별도로 존재한다.
    - 스왑 영역은 디스크에 일시적으로 저장하여 저장기간이 짧은 저장공간이다.
- 스왑 영역은 다수의 프로세스를 담을 수 있는 충분한 저장공간이면서 접근 속도가 보장되어야 한다.
- 스와핑은 프로세스 종료 후 디스크에 프로세스를 내려놓는 것이 아니라, 특정 이유로 **수행 중인 프로세스**를 메모리에서 디스크로 내려놓는 것이다.
    - 디스크 → 메모리 : 스왑인
    - 메모리 → 디스크: 스왑아웃
- 스와핑 과정
    - 스와퍼 swapper라고 불리는 중기 스캐줄러(medium-term scheduler)로 스왑시킬 프로세스를 선정
    - 해당 프로세스는 메모리에 올라가있는 전체 내용이 스왑 영역으로 스왑 아웃
- 스와핑의 중요 역할은 메모리의 프로세스 수를 조절하는 것이다.
    - degree of multiprogramming 다중 프로그래밍의 정도를 조절한다.
    - 메모리에 너무 많은 양의 프로세스가 올라와있으면 시스템 전체 성능이 떨어지기 때문이다.
- **컴파일 타임 바인딩**과 **로드 타임 바인딩**은 스왑 아웃된 프로세스가 스왑인 될 때 동일한 메모리 위치로 올라가야한다.
- 스와핑에서 스왑 영역에 프로세스의 주소 공간이 순차적으로 저장된다.
    - 스와핑 소요시간은 디스크 탐색시간이나 회전지연시간(rotational latency)보다 디스크 섹터에서 실제 데이터를 읽고 쓰는 전송시간 transfer time이 대부분을 차지한다.
    

<br>

## 🌩 3. 물리적 메모리의 할당방식

- 운영체제 상주 영역과 사용자 프로세스영역으로 나뉜다.
    - 운영체제 상주 영역은 인터럽트 벡터와 함께 낮은 주소 영역을 사용한다.
    - 운영체제 커널이 위치한다.
- 사용자 프로세스 영역은 연속할당(contiguous allocation)과 불연속할당(noncontiguous alloation) 방식으로 나뉜다.
    - 연속할당 - 각각의 프로세스를 물리적 메모리 연속적인 공간에 올림
        - 물리적 메모리를 다수의 분할로 나누어 하나의 분할에 하나의 프로세스가 적재
        - 분할은 고정분할(fixed partition allocation)과 가변분할(variable partition allocation) 방식으로 나뉜다. 고정분할은 미리 메모리를 나누어 놓는다.
    - 불연속 할당 - 하나의 프로세스를 물리적 메모리 여러 영역에 분산하여 적재하는 방식
        - 동일한 페이지로 잘라서 메모리에 페이지 단위로 적재시키는 페이징(paging) 기법
        - 프로그램 주소 공간을 코드, 데이터, 스택 등 의미있는 단위인 세그먼트로 나누는 세그멘테이션(segmentation) 기법이 있다.
    

### 1) 연속할당 방식

- 고정분할이나 가변분할로 나뉘어진 크기에 프로세스를 연속적으로 적재한다.
- 고정분할 방식
    - 물리적 메모리를 주어진 개수만큼 영구적인 분할(partition)으로 나누고 각 분할에 하나의 프로세스를 적재한다.
    - 분할의 크기가 모두 같을수도 다를수도 있다.
    - 메모리에 올릴 수 있는 프로세스의 수가 분할개수 만큼으로 고정되어 있고 수행 가능한 프로그램의 최대 크기가 정해져있다. (분할의 최대크기)
    - 외부조각(external fragmentation)과 내부조각(internal fragmentation)이 발생할 수 있다.
        - 외부조각은 분할이 비었는데 프로그램의 크기보다 작아서 적재하는 못하는 경우 발생
        - 내부조각은 프로그램에게 배정되었는데 조각의 크기가 상대적으로 커서 내부에 사용하지 않는 메모리 공간이 생기는 경우 발생
- 가변분할 방식
    - 적재되는 프로그램의 크기에 따라 분할의 크기와 개수가 동적으로 변하는 방식이다.
        - 관리를 위한 프로그래밍 기법이 필요하다.
    - 프로그램의 크기만큼 분할하므로 내부조각은 발생하지 않는다. 하지만 외부조각은 여전히 발생한다.
    - 중요한 점은 주소 공간의 크기가 n인 프로세스를 메모리에 올릴 때 메모리 가용공간 중 어느 위치에 올릴지 이다.
        - 동적 메모리 할당 문제 dynamic storage-allocation problem 이라고 한다.
        - 가용공간은 사용되지 않은 메모리 공간이고 산발적으로 존재한다.
        - 연속할당 기법에서는 프로세스 전체를 담을 수 있는 가용공간을 찾아야한다.
        - 운영체제는 이미 사용중인 메모리와 가용 공간에 대한 정보를 유지하여 가용 공간을 효율적으로 관리해야한다.
- 동적 메모리 할당 문제 해결 방법 3가지
    1. 크기가 n 이상인 가용 공간 중 가장 먼저 찾아지는 공간에 프로세스를 할당하는 최초적합 (first-fit) 방법
        - 가용공간을 모두 탐색하지 않으므로 시간적인 면에서 효율적이다.
    2. 크기가 n 이상인 가장 작은 가용 공간을 찾아가곳에 프로세스를 할당하는 최적적합(best-fit) 방법
        - 가용공간 리스트가 크기순으로 정렬되어 있지 않는다면 모든 가용공간 리스트를 탐색하여 시간적 오버헤드가 발생
        - 다수의 매우 작은 가용 공간들이 생성될 수 있다는 단점
        - 공간적인 면에서 효율적인 장점이 존재한다.
    3. 가용 공간 중 가장 크기가 큰 곳에 새로운 프로그램을 할당하는 최악적합(worst-fit) 방법
        - 가용 공간 리스트를 탐색하는 시간적 오버헤드 발생
        - 상대적으로 더 큰 프로그램을 담을 수 있는 가용 공간을 빨리 소진한다는 문제
    - 최초척합과 최적적합 방식이 최악적합 방식에 비해 속도와 공간 이용률 측면에서 효과적이다.
- 컴팩션 compaction - 가변분할 방식에서 외부조각 문제를 해결하는 방법
    - 물리적 메모리 중 프로세스에 의해 사용중인 메모리 영역을 한쪽으로 몰고 가용 공간들을 다른 한쪽으로 모아 하나의 큰 가용 공간을 만드는 방법
    - 수행 중인 프로세스의 메모리상의 위치를 상당 부분 이동시키므로 비용이 많이 든다.
    - 중간에 일부 가용 공간이 발생하더라도 적은 수의 메모리 이동으로 효율적인 컴팩션을 수행해야하는데 이론적으로 복잡하다.
    - 수행 중인 프로세스의 물리적 메모리 위치를 옮겨야하므로 프로그램 시간 도중에 프로세스의 주소가 동적으로 바뀌는 실행시간 바인딩 방식이 지원될 때만 가능하다.

### 2) 불연속할당 기법

- 하나의 프로세스가 물리적 메모리의 여러 위치에 분산되어 올라갈 수 있는 메모리 할당 기법이다.
- 하나의 프로그램을 동일한 크기로 나누는 페이징 기법
- 크기가 일정하지 않지만 의미 단위로 나누는 세그멘테이션 기법
- 세그멘테이션이 기본이지만 이것을 다시 동일한 크기의 페이지로 나누는 페이지드 세그멘테이션(paged segmentation)으로 나뉜다

<br>

## 🌩 4. 페이징 기법

- 프로세스 주소 공간을 **동일한 크기의 페이지 단위**로 나누어 **물리적 메모리의 서로 다른 위치**에 페이지들을 저장하는 방식
- 프로세스 일부는 백킹스토어, 일부는 물리 메모리에 혼재할 수 있다.
- 메모리를 페이지와 동일한 크기인 프레임(frame)으로 미리 나눈다.
    - 동적 메모리 할당 문제가 발생하지 않는 장점
- 주소 변환 절차가 연속할당 방식에 비해 다소 복잡하다.
    - 하나의 프로세스도 여러 페이지 단위로 물리적 메모리에서의 위치가 상이하기 때문이다.
    - 따라서 프로세스 별 페이지 테이블(page table)을 가져 각 페이지가 물리 프로세스의 어느 frame에 매핑되는지 아는 주소 변환 엔트리를 가진다.
        - 페이지 테이블은 페이지 개수만큼 엔트리를 가지고 있다.
- 프로세스 주소 공간과 물리적 메모리가 모두 같은 크기의 페이지 단위이기 때문에 빈 공간은 항상 활용 가능하다.
    - 하지만 프로세스가 페이지 단위로 나누어 떨어지지 않기 때문에 마지막 조각의 마지막 페이지에서 내부조각이 발생할 수도 있다.
    

### 1) 주소 변환 기법

- CPU가 사용하는 논리적 주소를 번호(p)와 페이지 오프셋(d)로 나누어 주소 변환(address translation)에 사용한다.
    - 페이지 번호는 페이지별 주소 변환 정보를 담고있는 페이지 테이블 접근 인덱스(index)로 사용
    - 해당 인덱스의 항목(entry)에는 페이지의 물리적 메모리상 기준 주소(base address) 시작 위치가 저장
    - 페이지 오프셋은 하나의 페이지 내에서의 변위(displacement)를 알려준다.
        - 기준 주소값 + 변위값으로 논리적 주소에 대응하는 물리적 주소를 얻는다.
        

### 2) 페이지 테이블의 구현

- 페이징 기법에서 주소 변환을 하기 위한 자료구조이다.
- 실행중인 프로세스의 페이지 테이블에 접근하기 위해 2개 레지스터를 사용한다.
    - 페이지 테이블 기준 레지스터(page-table base register) PTBR
        - 물리적 메모리 내에서 페이지 테이블의 시작위치
    - 페이지 테이블 길이 레지스터(page-table length register) PTLR
        - 페이지 테이블의 크기
- 페이징에서 메모리에 접근하려면 **1) 페이지 테이블 접근을 위해 메모리 접근 2) 주소 변환된 메모리에 접근** 이렇게 두번 메모리에 접근하여 오버헤드가 있다.
    - 페이지 테이블 접근 오버헤드를 줄이고 메모리 접근 속도를 향상시키기 위해 TLB(Translation Look-aside Buffer) 고속 주소 변환용 하드웨어 캐시가 사용되기도 한다.
    - 메모리에 비해 TLB는 비싸기 때문에 빈번히 참조되는 페이지에 대한 주소변환 정보만 담는다. 따라서 TLB에 요청 페이지의 주소 변환 정보가 있을 수도 있고 없을 수도 있다.
    - TLB에 존재한다면 얻고 그렇지 않다면 메인 메모리 페이지 테이블로부터 프레임 번호를 알아내도록 한다.
    - 문맥 교환시 이전 프로세스의 주소변환 정보를 담는 TLB를 초기화해야한다.
    
    <p align="center"><img width="85%" src="https://user-images.githubusercontent.com/63405904/141051950-79afbe37-5ee2-4627-876c-a51de9083ca5.png"></p>

    
- TLB와 페이지 테이블의 정보 구조 차이
    - 페이지 테이블에는 페이지 주소 변환 정보가 페이지 번호에 따라 순차적으로 들어있으므로 페이지 번호로 바로 항모겡 접근하여 프레임 번호를 구할 수 있다.
    - TLB는 모든 페이지에 대한 주소 변환 정보를 가지고 있는 것이 아니기 때문에 페이지 번호와 프레임 번호가 쌍으로 저장되어야 한다. (두 값이 모두 있어야한다. 페이징 테이블은 프레임 번호만 순차적으로 있다. 그림참조)
    - TLB에 있는지 확인하려면 모든 엔트리를 다 찾아봐야하는 오버헤드가 발생한다.
- TLB 엔트리를 모두 탐색하는 오버헤드를 줄이기위해 병렬탐색(parallel search)이 가능한 연관 레지스터(associative register)를 사용한다.
    - TLB 항목을 동시에 탐색할 수 있는 기능이다.

### 3) 계층적 페이징

- 페이지 테이블에 메모리의 상당 부분이 소요되어 실제 사용 가능한 메모리 공간이 줄어드는 문제가 발생한다.
- 페이지 테이블로 낭비되는 공간을 줄이기 위해 2단계 페이징(two-level paging)을 기법을 사용한다.
- 외부 페이지 테이블 (outer page table)과 내부 페이지 테이블 (inner page table)을 사용하고 사용하지 않는 주소 공간은 외부 페이지 테이블 항목을 null로 두어 대응하는 내부 페이지 테이블 항목을 설정하지 않아 메모리 낭비를 줄인다.
    - 하지만 주소변환을 위해 페이지 테이블을 2개 접근해야하므로 시간적 손해가 있다.
    - TLB를 사용해 접근 속도를 높일 수 있다.

<p align="center"><img width="85%" src="https://user-images.githubusercontent.com/63405904/141052309-99c2a925-799e-4da8-838c-816ca979b37d.png"></p>

### 4) 역페이지 테이블 inverted page table

- 물리적 메모리의 페이지 프레임 하나당 페이지 테이블 항목을 하나씩 둔다.
- 논리적 주소에 대한 페이지 테이블을 만드는 것이 아니라 물리적 주소에 대한 페이지 테이블을 만드는 것이다.
    - 각 프로세스마다 페이지 테이블을 두지 않고 시스템 전체에 대한 페이지 테이블을 하나만 둔다.
    - 페이지 테이블의 각 항목은 **어느 프로세스의 어느 페이지**가 이 프레임에 저장되었는지 정보를 보관한다.
        - pid와 페이지 번호 p를 담는다.
- 물리적 주소에서 논리적 주소를 얻기 수월한 방법이므로 어느 정도의 비효율적인 측면이 있다.
    - 주소 변환 요청이 들어오면 페이지 테이블을 다 탐색해야하고 시간을 소요한다.
    - 따라서 페이지 테이블을 메모리에 유지하는 대신 연관 레지스터 (associative register)에 보관히 전체 항목을 병렬 탐색 가능하게 한다.

<p align="center"><img width="85%" src="https://user-images.githubusercontent.com/63405904/141052223-35660eb2-db9c-4f94-8496-a89a587b06d0.png"></p>

### 5) 공유 페이지

- 공유 코드(shared code)는 여러 프로세스에 의해 공통으로 사용될 수 있도록 작성된 코드이다.
    - 메모리 공간의 효율적인 사용을 위함
- 재진입 가능 코드 (re-entrant code) 또는 순수 코드 (pure code)로 불리며 read-only 특성을 가진다.
- 공유 페이지(shared page)는 공유 코드를 담고있는 페이지이다.
- 공유 페이지는 여러 프로세스에 공유되기 때문에 물리 메모리에 하나만 적재되어 메모리를 효율적으로 사용할 수 있다.
    - 문서 편집기를 공유 페이지 사용해서 작성한 경우, 이 프로세스를 여러개 수행시켜도 공유 코드를 담은 페이지는 하나만 올라간다.
- 공유 코드는 읽기 전용이며 논리적 주소에서 같은 위치에 있어야하는 제약점도 있다.
- 대비되는 개념으로 사유 페이지(private page)가 있다.
    - 프로세스별로 독자적으로 사용하는 페이지이며 논리적 주소 공간 중 어디에 있어도 된다.

<p align="center"><img width="85%" src="https://user-images.githubusercontent.com/63405904/141052240-708a31c5-6b2e-48b4-beee-b6cf66b8fcca.png"></p>

### 6) 메모리 보호

- 메모리 보호를 위한 보호 비트(protection bit)와 유효-무효 비트(valid-invalid bit)를두고 있다.
- 보호 비트
    - 각 페이지에 대한 접근 권한 내용을 담는다.
    - 읽기-쓰기/읽기 전용 등의 접근 권한을 설정하여 '어떠한' 접근을 제한한다.
- 유효-무효 비트
    - 해당 페이지의 내용이 유효한지 내용을 담는다.
    - 유효로 세팅한다면 해당 메모리 프레임에 그 페이지가 존재하여 접근이 허용된다.
    - 무효라면 프로세스가 그 주소 부분을 사용하지 않거나 해당 페이지가 물리적 메모리가 아닌 백킹 스토에어에 존재하여 **해당 메모리 프레임**에 접근 권한이 없는 것이다.
    

<br>

## 🌩 5. 세그멘테이션

- 프로세스의 주소 공간을 의미있는 단위인 세그먼트(segment)로 나누어 물리적 메모리에 올리는 기법이다.
- 프로세스는 코드, 데이터, 스택 등인 논리적 단위로 구성된다. 이것에 따라서 나눈다.
    - 많게는 프로그램 함수 하나하나를 세그먼트로 정의할 수도 있다.
- 크기가 균일하지 않으며 통째로 메모리에 적재되지 않고 나누어져 메모리에 적재되어 페이징과 유사하다.
- 균일하지 않은 세그먼트들을 적재하기 때문에 그것을 관리하는 오버헤드가 있다.
- 논리적 주소가 **<세그먼트 번호, 오프셋>** 으로 나뉘어 사용되어 몇번째 세그먼트와 해당 세그먼트 내에서 오프셋 정보를 나타낸다.
- 세그먼트 테이블을 사용한다.
    - 기준점(base)와 한계점(limit)을 가지고 있다.
    - 기준점은 물리 메모리에서 시작위치, 한계점은 세그먼트의 길이이다.
- 두 register의 도움을 받는다.
    - 세그먼트 테이블 기준 레지스터 STBR (Segment Table Base Register)
        - 세그먼트 테이블이 물리 메모리 어느 위치에 있는지 시작주소
    - 세그먼트 테이블 길이 레지스터 STLR (Segment Table Legnth Register)
        - 해당 프로세스의 주소 공간이 몇개의 세그먼트로 구성되었는지 세그먼트 개수
- 논리적 주소를 물리적 주소로 변환하기 전 두 가지를 확인한다.
    1. 요청된 세그먼트 번호가 STLR에 저장된 값보다 작은 값인지
        1. 아니라면 존재하지 않는 세그먼트 접근이므로 예외상황 발생
    2. 논리적 주소의 오프셋 값이 그 세그먼트의 길이보다 작은지 
        1. 테이블의 해당 항목의 한계점과 논리적 주소의 오프셋을 비교
- 페이징 기법과 마찬가지로 보호비트와 유효비트를 둔다.

<p align="center"><img width="85%" src="https://user-images.githubusercontent.com/63405904/141052384-1976d0e9-efce-440b-bd42-469064f09aac.png"></p>

- 여러 프로세스가 특정 세그먼트를 공유해 사용하는 공유 세그먼트(shared segment) 개념이 있다.
    - 공유 세그먼트는 공유하는 모든 프로세스의 동일한 논리적 주소에 있어야한다.
- 세그먼트는 의미 단위로 나뉘어지므로 공유와 보안 측면에서 페이징 기법보다 효과적이다.
    - 주소 공간의 일부를 공유하거나 접근 권한 제어 등이 가능하다.
    - 의미 단위로 업무를 수행할 수 있다.
- 하지만 길이가 균일하지 않아서 물리적 메모리에 외부조각이 발생한다.
    - 세그먼트를 어느 가용 공간에 할당할 문제도 있다.
    - 최초적합과 최적적합 방식이 있다.

<br>

## 🌩 6. 페이지드 세그먼테이션

- 페이징과 세그먼테이션의 장점을 취하는 기법이다.
- 의미단위로 세그먼트를 나누고 세그먼트의 길이가 동일한 크기의 페이지들의 집합으로 이루어지도록 한다.
- 물리 메모리 적재는 페이지 단위로 한다.
- 하나의 세그먼트 크기를 페이지크기의 배수가 되도록 하여 외부조각 문제를 해결하고 세그먼트 단위로 공유나 접근 권한 보호가 이루어질 수 있도록 한다.
- 주소 변환을 위해 **1) 외부의 세그먼트 테이블 2) 내부의 페이지 테이블** 두가지를 사용한다.
- **<세그먼트 번호, 오프셋>** 으로 논리주소가 구성되었다.
    - 세그먼트 번호로 세그먼트 테이블에 접근하여 세그먼트의 길이와 세그먼트의 페이지 테이블 시작주소를 얻는다.
        - 세그먼트 길이와 논리주소의 오프셋을 비교하여 메모리 접근 유효성을 검사한다.
    - 오프셋을 상위, 하위로 나누어 상위는 세그먼트 내의 페이지 테이블 번호로 사용하고 하위는 페이지 내에서의 변위로 사용한다.
    - 페이지 번호로 페이지 테이블 항목에서 물리적 메모리의 프레임 위치를 얻는다.

```toc
```
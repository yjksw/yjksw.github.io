---
emoji: ✊
title: JVM 구조 알아보기
date: '2021-11-17 23:00:00'
author: 코다
tags: 자바
categories: 자바
---

## 💡 Intro

- JVM은 자바의 큰 장점 중 하나로 이 가상머신이 깔려있는 운영체제에서는 모두 동일하게 자바 클래스 파일이 실행될 수 있다.
- JVM의 기본 구조를 알아보자 🙌

<br>

## 🌩 JVM 메모리 구조

**1) Class Loader 2) Execution Engine 3) Garbage Collector 4) Runtime Data Area** 4가지로 나뉘어져 있다. 

### Class Loader

- JVM 내로 클래스 파일을 로드하고 링크를 통해 배치하는 작업을 수행한다.
- 런타임 시에 동적으로 클래스를 로드한다.

### Execution Engine

- 클래스 로더가 Runtime Data Area에 배치한 바이트 코드들을 명령어 단위로 읽어서 실행하는 작업을 수행한다.
- 최초 JVM에서는 인터프리터 방식이어서 느렸지만 JIT 컴파일러로 변경되면서 실행이 빠르다는 장점이 있다.
- 모든 코드 JIT으로 하지 않고 인터프리터로 하다가 일정한 기준이 넘어가면 JIT 컴파일러 방식으로 실행한다.
    - 한번 읽어서 기계어로 변경한 소스코드는 변역하지 않는다.
    - 저장소에 저장하여 반복되는 코드는 한꺼번에 컴파일하여서 사용한다.

### Garbage Collector

- 힙 메모리 영역에 객체 중 더이상 참조되지 않는 객체들을 제거하는 역할을 한다.
    - Reference Counting 혹은 Mark-and-sweep 방식을 사용
    - Minor GC(eden, survivor1, survivor2)와 Major GC(old)

### Runtime Data Area

- 애플리케이션이 실행할 때 사용되는 데이터를 적재하는 영역
    - **Method Area** → 모든 스레드가 공유하는 메모리 영역으로 클래스, 인터페이스, 메소드, 필드, static 변수 등의 바이트 코드를 보관
    - **Heap Area** → 모든 스레드가 공유하며 new 키워드로 생성된 객체와 배열이 생성되는 영역
    - **Stack Area** → 메서드 호출시마다 스택 프레임을 생성하여 매개변수, 지역변수, 리턴 값, 연산 시 값들을 임시로 저장하며 메서드 수행이 끝나면 프레임을 삭제
    - **PC Register** → 쓰레드 시작 시 생성되며 스레드마다 하나씩 존재하고 무슨 명령어를 실행할지 명령의 주소 보관
    - **Native Method Stack** → 자바 외 언어로 작성된 네이티브 코드를 저장하는 메모리

<br>

## 🛋 느낀 점

- JVM의 구조를 알고 있어야지 자바 코드가 실행되는 부분이 일종의 '매직'처럼 남아있지 않고 구체화 되어서 그려질 것 같다.
- 공부를 할수록 그냥 되는줄 알았던 부분들이 차츰차츰 명료해지는 것 같다.


```toc
```
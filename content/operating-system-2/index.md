---
emoji: 🧁
title: 운영체제와 정보기술의 원리 - CH3. 컴퓨터 시스템의 동작원리
date: '2021-10-11 23:20:00'
author: 코다
tags: 운영체제 책
categories: 운영체제 책
---

> 다음은 반효경 교수님의 '운영체제와 정보기술의 원리' *CH3. 컴퓨터 시스템의 동작원리*를 읽고 정리한 내용입니다 🙌

<br>
<br>

## 🌩 1. 컴퓨터 시스템의 구조

- 내부 장치 - CPU, 메모리
- 외부 장치 - 디스크, 키보드, 마우스, 모니터, 네트워크 장치 등등
    - 입출력장치라고 한다.
    - 각 하드웨어 장치를 각각의 컨트롤러가 제어한다.
- **컴퓨터는 외부장치에서 내부장치로 데이터를 읽어 연산한 후 결과를 외부장치로 내보내는 방식으로 동작한다.**
    - input - 내부로 들어오는 것
    - output - 외부로 내보내는 것
- 여러 프로그램을 동시에 수행할 수 있도록 하는 것이 운영체제이기 때문에 항상 메모리에 상주한다.
- 전체가 상주하기엔 너무 낭비이기 때문에 꼭 필요한 부분만 항상 메모리에 상주하고 그 부분을 **커널(kernel)**이라고 한다.

<br>

## 🌩 2. CPU 연산과 I/O 연산

- I/O 연산들은 **입출력 컨트롤러**가 담당하고 컴퓨터 내부의 연산은 **메인 CPU**가 담당한다.
    - 입출력 장치와 메인 CPU는 동시 수행이 가능하다.
- 각 장치마다 들어오고 나가는 데이터를 로컬버퍼(local buffer)라는 작은 메모리에 저장한다.
- 컨트롤러가 로컬버퍼로 읽어오는 일을 담당한다. 버퍼에 데이터가 다 들어왔으면 컨트롤러가 CPU에게 인터럽트로 알린다.
- CPU는 매 시점 메모리에서 명령(instruction)을 하나씩 읽어서 수행하는데, 옆에 인터럽트 라인(interrupt line)이 있어서 인터럽트 신호가 중간에 들어오면 작업을 멈추고 인터럽트 작업을 먼저 처리한다.
    - 즉, 매 명령 수행마다 인터럽트 발생 여부를 확인한다.

<br>

## 🌩 3. 인터럽트의 일반적 기능

- 운영체제에는 인터럽트가 들어왔을때 따라야하는 인터럽트 루틴이 저장되어 있다.
    - 각각의 인터럽트에 따라서 다르며 운영체제 개발자가 미리 구현하여 커널에 포함해둔다.
- 디스크 컨트롤러의 인터럽트 루틴에서 수행하는 일
    - 디스크의 로컬버퍼에 있는 내용을 사용자 프로그램 메모리로 전달하고 프로그램의 다음 명령을 수행할 수 있도록 표시
- **하드웨어 인터럽트** - 컨트롤러 등 하드웨어 장치가 CPU의 인터럽트 라인을 세팅 (통상적인 인터럽트)
    - CPU는 인터럽트가 발생하면 인터럽트 벡터(interrupt vector)에서 인터럽트 처리를 위한 루틴 코드를 커널에서 찾는다.
        - 인터럽트 종류 번호에 따른 처리 코드가 위치한 부분을 가리키는 자료구조이다.
        - 실제 처리 코드는 인터럽트 처리 루틴(interrupt service routine) 또는 인터럽트 핸들러(interrupt handler)라고 불리는 곳에 정의된다.
    - CPU가 인터럽트 처리 후 돌아갈 위치를 알기 위해 수행중이던 작업을 저장하는 장소를 운영체제가 별도로 가지고 있다.
- **소프트웨어 인터럽트** - 소프트웨어가 세팅
    - 트랩(trap)이라는 용어로 불리며 예외상황(exception)과 시스템 콜(system call)이 있다.
        - 예외상황 - 0으로 나누거나, 메모리 영역 바깥에 접근하려는 시도 등
        - 시스템 콜 - 운영체제에 서비스를 요청하는 경우로 화면출력, 키보드 입력 등의 커널 코드를 호출하여 CPU 제어권을 넘겨야하는 경우
    - 프로그램 코드가 인터럽트 라인을 세팅하는 명령을 실행하여 인터럽트를 발생시키고 CPU의 제어권을 운영체제에 넘기는 것이다.

<br>

## 🌩 4. 인터럽트 핸들링

인터럽트 발생한 후 처리해야할 절차를 의미한다. 

- 현재 진행중이던 프로그램의 상태를 저장한다.
    - 실행 중이던 명령어 메모리 주소 및 부가정보 등등
    - CPU에서 명령을 실행할 때 CPU 내부의 임시기억장치 레지스터의 데이터를 사용하는 데 이 값들을 미리 저장함
    - 프로그램을 관리하는 PCB에 현재 프로그램의 실행 상태를 저장하고 CPU의 제어권이 넘어간다.
    - 다시 실행될 경우 PCB에서 상태를 복원하고 실행을 이어한다.
- 오늘날은 운영체제(커널)이 인터럽트가 발생할 때만 실행된다. 인터럽트가 발생하지 않으면 사용자 프로그램이 CPU를 계속 점유한다.

<br>

## 🌩 5. 입출력 구조

컴퓨터 시스템이 외부 입출력 장치들과 데이터를 주고받는 것을 말한다. 

### 동기식 입출력 vs. 비동기식 입출력

- 동기식 입출력 (Synchronous I/O) - 어떤 프로그램이 입출력을 요청했을 때 입출력 작업이 완료해야 해당 프로그램의 다음 작업을 할 수 있는 것.
    - 입출력이 완료 되어야 인터럽트를 통해 CPU에게 알려 제어권이 다시 프로그램에게 넘어간다. 따라서 CPU는 입출력 연산이 끝날 때까지 인터럽트를 기다리며 자원을 낭비한다.
        - CPU 연산은 빠르지만 입출력 연산은 느리기 때문에 그동안 CPU를 사용하지 못하는 것은 자원의 낭비이다.
        - 또한 한번에 하나의 입출력만 수행될 수 있어 비효율적이다.
    - 따라서 주로 그 동안 다른 프로그램에게 CPU를 할당하고 이전에 입출력 연산중인 프로그램에는 CPU를 할당하지 않는다.
        - **이것을 관리하기 위해 입출력 중인 프로그램을 blocked state로 전환시켜 CPU를 할당하지 않도록  관리한다.**
    - 동기식으로 입출력이 연산되면 동기화가 자동으로 이루어진다. 하지만 그 사이 다른 프로그램이 CPU에 실행되면 동일한 데이터를 입출력할 때 결과가 틀어진다.
        - 해결하기 위해 입출력 요청을 순서대로 실행하기 위한 큐(queue)가 장치별로 있어서 동기화한다.
        - 입출력 연산이 끝나면 인터럽트로 CPU에 알리면 인터럽트 처리루틴에 따라서 해당 프로그램이 CPU를 할당받을 수 있도록 blocked state에서 해제시킨다.
- 비동기식 입출력 (asynchronous I/O) - CPU 제어권을 입출력 연산을 호출한 프로그램에게 바로 다시 부여하는 것
    - 입출력 데이터와 상관없이 다음 명령이 수행될 수 있는 경우는 입출력 연산과 상관없이 바로 수행하고 결과가 필요한 연산일 경우에만 기다렸다가 수행한다.
    - 쓰기 작업인 경우 다음 명령어 수행이 가능하므로 비동기식 입출력이 사용될 수 있다.
    - 입출력 연산이 완료되면 인터럽트로 알리고 그때부터 CPU는 읽어온 데이터를 필요로 하는 명령어를 수행한다.
- 입출력을 요청할 때, 완료했을 때 두번 인터럽트가 발생한다.
    - 요청할 때 인터럽트 처리루틴 - 진행중이던 프로세스의 상태를 저장하고 해당 컨트롤러에 입출력 요청을 한다. 해당 프로세스를 blocked state로 바꾸고 CPU를 다른 프로세스에게 할당한다.
    - 완료했을 때 인터럽트 처리루틴 - 진행중이던 프로세스의 상태를 저장하고 (디스크 입출력인 경우) 로컬 버퍼의 데이터를 메모리 영역으로 읽어온다. 해당 프로세스의 blocked state를 해제하고 CPU에 할당될 수 있도록 한다.
- 일반적으로는 동기식 입출력을 사용하며 동기화를 통해 queue를 사용한다.

<br>

## 🌩 6. DMA

- 메모리는 본래 CPU에서만 접근할 수 있는데 이렇다면 메모리 접근 연산이 모두 CPU의 인터럽트를 통해서 이루어지면서 CPU 작업이 중단되어 효율성이 떨어지는 문제가 발생한다.
- DMA (Direct Memory Access) - 위 문제를 해결하기 위한 컨트롤러로 메모리에 접근할 수 있는 장치
    - 로컬버퍼에서 데이터를 읽어오는 작업을 DMA가 CPU 대신 대행하여 CPU가 작업을 멈출 필요가 없다.
    - DMA는 바이트 단위가 아니라 블록(block)이라는 큰 단위로 정보를 메모리로 읽어온다.
    - 작업을 완료하면 CPU에 인터럽트로 알려준다.
    - CPU에 발생하는 인터럽트 빈도를 줄여 더 효율적으로 작업을 처리할 수 있도록 한다.

<br>

## 🌩 7. 저장장치의 구조

- 주기억장치
    - 메모리라고 부르며 휘발성이다.
    - RAM을 매체로 사용하는 경우가 대부분이다.
- 보조기억장치
    - 비휘발성이며
    - 마크네틱 디스크를 주로 사용한다.
- 보조기억장치의 용도
    1. 전원이 나가도 유지해야할 파일 시스템용 (file system)
    2. 메모리의 연장 공간인 스왑 영역 (swap area)
        - 운영체제는 당장 필요한 부분을 메모리에 올려놓고, 그렇지 않은 부분을 디스크의 스왑 영역에 내려놓는다 ⇒ swap out
        - 스왑 영역에 있는 부분을 필요할 때 다시 메모리 영역으로 가져온다 ⇒ swap in
        - 스왑 영역은 프로그램이 실행될 때 내용을 저장했다가 프로그램 종료될 때 삭제하는 메모리의 연장 공간이다.
        

<br>

## 🌩 8. 저장장치의 계층 구조

- primary 저장장치는 작고 빠르지만 비싸다.
    - 레지스터 → 캐시 메모리 → 메모리
    - 용량이 적지만 필요한 것만을 올리면서 용량이 큰 저장장치를 가지고 있는 것과 마찬가지로 성능효과를 낼 수 있다.
- secondary 저장장치는 크고 느리지만 싸다.
    - 마그네틱 디스크 → 광디스크 → 마그네틱 테이프

<br>

## 🌩 9. 하드웨어의 보안

- 운영체제에서는 여러 프로그램이 동시에 실행되는 다중 프로그래밍 환경에서 동작하기 때문에 다른 프로그램을 방해하거나 충돌하지 않도록 하드웨어적인 보안유지가 필요하다.
- 이것을 위해 운영체제는 **1) 커널모드**와 **2) 사용자모드** 두 가지를 지원한다.
    - 커널모드는 운영체제가 CPU의 제어권을 가지고 운영체제 코드를 실행하는 것이다.
    - 중요정보에 접근해 위험한 상황을 초래할 수 있는 연산은 커널모드에서만 실행되도록 한다.
    - 일반 사용자 프로그램은 시스템에 위험한 연산을 하지 못하도록 통제한다.
- 일반 사용자가 운영체제 내부의 코드를 실행하지 못하도록 하드웨어적인 지원을 한다.
    - CPU 내부에 mode bit 를 두어 사용자 프로그램을  통제한다.
    - mode bit = 0 ⇒ 커널모드이므로 모든 명령 수행 가능
    - mode bit = 1 ⇒ 사용자모드 이므로 제한된 명령 수행 가능
    - 사용자 프로그램 시 모드 비트를 1로 세팅해 넘겨준다. 만일 사용자 프로그램에서 제한된 명령을 수행하고자 할 때는 시스템 콜을 통해서 운영체제에 위임하여 해당 명령을 하도록 요청한다.
    - 인터럽트 발생시에는 모드 비트가 자동으로 0으로 세팅되며 요청이 끝나면 다시 1로 세팅된다.
    - 모드 비트 0일때만 수행가능한 명령을 **특권명령**이라고 한다.
- 각종 장치에서 특권 명령
    - 디스크에 저장된 파일에 자유롭게 접근하여 문제가 일어나지 않도록 모든 임출력 명령은 특권명령 규정을 사용한다.
    - 사용자 프로그램이 입출력을 하고 싶으면 system call로 운영체제에 요청을 한다.

<br>

## 🌩 10. 메모리 보안

- 여러 프로그램이 메모리에 한꺼번에 올라가서 실행되기 때문에 메모리도 보안이 필요하다.
    - 사용자 프로그램에서 다른 프로그램의 메모리에 잘못 접근해서 변경할 수 있다.
    - 인터러트 벡터와 인터럽트 처리루틴이 있는 곳을 변경하여 보안성이 침해될 수 있다.
- 메모리 보호를 위해 2가지 레지스터를 사용한다.
    - 기준 레지스터 (base register)
        - 해당 프로그램이 접근할 수 있는 가장 작은 주소
    - 한계 레지스터 (limit register)
        - 기준 레지스터로부터 접근할 수 있는 메모리 범위
    - 이 두 범위를 넘어가면 소프트웨어적인 인터럽트로 예외가 발생한다.
    - **프로그램이 메모리의 한 영역에 연속적으로 위치하는 경우에만 가능한 메모리 관리 기법이다.**
    - 메모리를 페이징 할 경우 다른 메모리 보호 기법이 필요하다.
- 메모리 접근 연산은 특권명령이 아니지만 두 레지스터 값을 지정하는 것은 특권명령이다.
- 입출력 연산은 모두 특권 명령이나 메모리 연산은 가능한 범위안에서는 사용자 모드에서 연산할 수 있다.

<br>

## 🌩 11. CPU 보호

- CPU가 하나의 프로그램에 독점되는 것을 막기 위해 타이머라는 하드웨어를 사용한다.
- CPU는 일정시간이 지나면 인터럽트를 발생시켜 운영체제가 CPU 제어하도록 하여 CPU를 다른 프로그램에게 이양한다.
- 타이머는 일정 시간 단위로 세팅되어 매 클럭마다 1씩 감소하며 0이 되면 인터럽트가 발생한다.
- 타이머 값 세팅은 load timer 명령이며 특권 명령이다.
- 타이머를 통해서 시분할 시스템에서 현재 시간을 계산하기도 한다.

<br>

## 🌩 12. 시스템 콜을 이용한 입출력 실행

- 디스크 파일 입출력, 키보드입출력 등은 모두 특권명령인 입출력 명령이다.
- 운영체제의 system call이라는 서비스를 이용하여 입출력 명령을 대신 요쳥해야한다.

```toc
```
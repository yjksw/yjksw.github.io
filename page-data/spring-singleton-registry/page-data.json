{"componentChunkName":"component---src-templates-blog-template-js","path":"/spring-singleton-registry/","result":{"data":{"cur":{"id":"6956dfc0-9e9b-5f82-936b-ebe795f54046","html":"<h2 id=\"-intro\" style=\"position:relative;\"><a href=\"#-intro\" aria-label=\" intro permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>💡 Intro</h2>\n<ul>\n<li>왜 하필 스프링 인가? 라는 질문을 던지게 되면서 스프링이 가지고 있느 장점에 대해서 고민해보았다.</li>\n<li>그 중 기존의 싱글톤 패턴의 한계를 뛰어넘은 스프링 싱글톤 레지스트리를 알게 되었다. 이전에 단순히 스프링이 싱글톤 scope으로 객체를 관리하여 여러 요청이 동시에 들어오는 환경에서 안정적으로 서비스할 수 있다는 장점을 들었지만 싱글톤 패턴과 어떻게 다른지 알지 못했다.</li>\n<li>그래서 알아보자 🙌</li>\n</ul>\n<br>\n<h2 id=\"-싱글톤-패턴이란\" style=\"position:relative;\"><a href=\"#-%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4%EC%9D%B4%EB%9E%80\" aria-label=\" 싱글톤 패턴이란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 싱글톤 패턴이란?</h2>\n<h3 id=\"왜-싱글톤-패턴이어야-할까\" style=\"position:relative;\"><a href=\"#%EC%99%9C-%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4%EC%9D%B4%EC%96%B4%EC%95%BC-%ED%95%A0%EA%B9%8C\" aria-label=\"왜 싱글톤 패턴이어야 할까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>왜 싱글톤 패턴이어야 할까</h3>\n<ul>\n<li>\n<p>하나의 서버에 초당 수많은 요청이 도착하고 처리되어야 한다. 요청이 올 때마다 서버에서 관련 객체를 생성하는 것은 굉장히 큰 오버헤드이다.</p>\n<ul>\n<li>\n<p>어떤 오버헤드가 발생할 수 있을까 ?</p>\n<p>주로 서버는 여러 계층의 레이어를 지나고 여러 비지니스 오브젝트들이 협력하여 요청을 처리한다. </p>\n<p>요청 하나당 대충 5개 정도의 오브젝트가 생성되고, 초딩 300개의 요청, 1분에 18000개의 요청이 발생한다면 18000 * 5 만큼의 새로운 오브젝트가 생성된다. </p>\n<p>오브젝트 생성도 비용이지만 생성된 오브젝트를 처리하여 메모리를 관리하는 GC도 오버헤드다. (GC의 동작원리를 살펴보자 🙌) </p>\n</li>\n</ul>\n</li>\n<li>따라서 스프링은 요청을 서비스 해주는 객체를 하나만 만들고 그것을 공유할 수 있도록 한다.</li>\n<li>하나의 객체만 생성하여 공유할 수 있는 것이 싱글톤 패턴이다.</li>\n</ul>\n<h3 id=\"싱글톤-패턴이-가지고-있는-단점\" style=\"position:relative;\"><a href=\"#%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4%EC%9D%B4-%EA%B0%80%EC%A7%80%EA%B3%A0-%EC%9E%88%EB%8A%94-%EB%8B%A8%EC%A0%90\" aria-label=\"싱글톤 패턴이 가지고 있는 단점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>싱글톤 패턴이 가지고 있는 단점</h3>\n<ul>\n<li>private 생성자 이므로 상속이 불가능하여 객체지향의 특징을 활용할 수 없다.</li>\n<li>\n<p>싱글톤은 테스트하기 어려우며 서버환경에서 동시에 여러 요청이 들어오기 때문에 하나만 만들어지는 것을 보장할 수 없다.</p>\n<ul>\n<li>싱글톤 객체는 만들어지는 방식이 제한적이므로 Mock 객체로 대체하는 것이 어렵다. 또한 생성자로 다이나믹하게 의존 객체를 주입하기 어렵기 때문에 일부 대체하려는 경우 해당 오브젝트를 테스트용으로 아예 만들어서 사용할 수밖에 없다.</li>\n</ul>\n</li>\n<li>\n<p>싱글톤은 전역상태를 만들기 때문에 객체지향적으로 보았을 때 바람직하지 못하다.</p>\n<ul>\n<li>static 필드와 메서드를 사용하며 싱글톤을 static 메서드를 통해 어느 곳에서든 접근할 수 있다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-싱글톤-레지스트리\" style=\"position:relative;\"><a href=\"#-%EC%8B%B1%EA%B8%80%ED%86%A4-%EB%A0%88%EC%A7%80%EC%8A%A4%ED%8A%B8%EB%A6%AC\" aria-label=\" 싱글톤 레지스트리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 싱글톤 레지스트리</h2>\n<ul>\n<li>스프링은 위에서 언급한 이유로 특정 서비스 객체들(빈)을 싱글톤으로 만든다. 하지만 위에서 나온 싱글톤 패턴을 그대로 사용하기보다 단점을 보완한 상태를 사용한다.</li>\n<li>\n<p>싱글톤 패턴의 단점을 보완하기 위해 나온 것이 스프링의 <strong>싱글톤 레지스트리</strong>이다. 스프링 컨테이너가 싱글톤 레지스트리의 역할을 하여 빈을 싱글톤으로 관리한다.</p>\n<ul>\n<li>private 생성자로 객체의 생성을 막는 방법이 아니라 일반 자바 클래스를 싱글톤으로 활용할 수 있도록 지원한다.</li>\n<li>생성, 관계설정, 사용에 대한 제어권이 컨테이너에게 있기 때문에 일반 자바 클래스도 싱글톤으로 관리될 수 있다.</li>\n</ul>\n</li>\n<li>public 생성자를 사용할 수 있기 때문에 필요하다면 새로운 오브젝트를 생성하고 Mock 오브젝트로 대체하는 등의 작업을 할 수 있다.</li>\n<li>객체지향적 설계와 디자인 패턴 적용이 가능하다.</li>\n</ul>\n<br>\n<h2 id=\"--싱글톤이기-때문에-주의할-점-️\" style=\"position:relative;\"><a href=\"#--%EC%8B%B1%EA%B8%80%ED%86%A4%EC%9D%B4%EA%B8%B0-%EB%95%8C%EB%AC%B8%EC%97%90-%EC%A3%BC%EC%9D%98%ED%95%A0-%EC%A0%90-%EF%B8%8F\" aria-label=\"  싱글톤이기 때문에 주의할 점 ️ permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩  싱글톤이기 때문에 주의할 점 ‼️</h2>\n<ul>\n<li>\n<p>멀티 스레드 환경에서 여러 스레드가 싱글톤에 동시접근 할 수 있기 때문에 상태 관리를 주의해야한다.</p>\n<ul>\n<li>대부분은 stateless하게 만들어져야 한다. 내부 상태값의 동시수정이 이루어지는 경우 매우 위험하기 때문이다.(읽기 전용은 제외)</li>\n</ul>\n</li>\n<li>\n<p>싱글톤에서 필요한 정보는 상태없이 어떻게 관리할까?</p>\n<ul>\n<li>파라미터, 로컬 변수, 리턴 값 등을 이용한다.</li>\n<li>위 변수들은 스택 영역에 독립적으로 저장이 되기 때문에 스레드마다 분리되어 있다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-스프링의-빈의-scope는-모두-싱글톤일까\" style=\"position:relative;\"><a href=\"#-%EC%8A%A4%ED%94%84%EB%A7%81%EC%9D%98-%EB%B9%88%EC%9D%98-scope%EB%8A%94-%EB%AA%A8%EB%91%90-%EC%8B%B1%EA%B8%80%ED%86%A4%EC%9D%BC%EA%B9%8C\" aria-label=\" 스프링의 빈의 scope는 모두 싱글톤일까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 스프링의 빈의 scope는 모두 싱글톤일까</h2>\n<ul>\n<li>\n<p>우선, scope 란?</p>\n<ul>\n<li>scope는 범위라는 뜻의 용어이고 여기서는 스프링의 빈이 <strong>1) 언제 생성되고 2) 언제까지 존재하며 3) 어디까지 적용되는지</strong>를 말한다.</li>\n<li>기본적인 스프링 빈의 scope는 싱글톤이며 빈의 생명주기는 스프링 컨테이너와 함께한다.</li>\n</ul>\n</li>\n<li>\n<p>이외의 scope도 존재한다!</p>\n<ul>\n<li>\n<p>프로토타입 Prototype scope</p>\n<ul>\n<li>컨테이너에 빈을 요청할 때마다 매번 새로운 오브젝트를 생성</li>\n</ul>\n</li>\n<li>\n<p>요청 Request scope</p>\n<ul>\n<li>새로운 HTTP 요청이 생길 때마다 생성</li>\n</ul>\n</li>\n<li>\n<p>세션 Session scope</p>\n<ul>\n<li>웹의 세션과 유사하게 생성</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-느낀-점\" style=\"position:relative;\"><a href=\"#-%EB%8A%90%EB%82%80-%EC%A0%90\" aria-label=\" 느낀 점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🛋 느낀 점</h2>\n<ul>\n<li><a href=\"https://github.com/yjksw/jwp-dashboard-mvc\">Spring MVC를 직접 구현해보는 미션</a>에서 component scanning으로 빈을 등록했던 것을 떠올리며 위 개념을 학습했더니 더 와닿았다.</li>\n<li>기존의 싱글톤 패턴이 안티패턴인데 멀티 스레드 환경에서는 싱글톤을 사용해야하는 것을 스프링 컨테이너로 해결한 것이 신선했다.</li>\n<li>스프링은 프레임워크이고 프레임워크에 종속적일수록 자바의 이점을 활용하기 어렵다고 생각했는데 이제야 조금씩 <em>토비의 스프링</em>에서 스프링 프레임워크가 자바의 객체지향적인 장점을 잘 살릴 수 있는 프레임워크라고 한 것이 이해되는 것 같다.</li>\n</ul>\n<br>\n<br>\n<p><strong>[참고자료]</strong></p>\n<ul>\n<li>토비의 스프링</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#-intro\">💡 Intro</a></li>\n<li>\n<p><a href=\"#-%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4%EC%9D%B4%EB%9E%80\">🌩 싱글톤 패턴이란?</a></p>\n<ul>\n<li><a href=\"#%EC%99%9C-%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4%EC%9D%B4%EC%96%B4%EC%95%BC-%ED%95%A0%EA%B9%8C\">왜 싱글톤 패턴이어야 할까</a></li>\n<li><a href=\"#%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4%EC%9D%B4-%EA%B0%80%EC%A7%80%EA%B3%A0-%EC%9E%88%EB%8A%94-%EB%8B%A8%EC%A0%90\">싱글톤 패턴이 가지고 있는 단점</a></li>\n</ul>\n</li>\n<li><a href=\"#-%EC%8B%B1%EA%B8%80%ED%86%A4-%EB%A0%88%EC%A7%80%EC%8A%A4%ED%8A%B8%EB%A6%AC\">🌩 싱글톤 레지스트리</a></li>\n<li><a href=\"#--%EC%8B%B1%EA%B8%80%ED%86%A4%EC%9D%B4%EA%B8%B0-%EB%95%8C%EB%AC%B8%EC%97%90-%EC%A3%BC%EC%9D%98%ED%95%A0-%EC%A0%90-%EF%B8%8F\">🌩  싱글톤이기 때문에 주의할 점 ‼️</a></li>\n<li><a href=\"#-%EC%8A%A4%ED%94%84%EB%A7%81%EC%9D%98-%EB%B9%88%EC%9D%98-scope%EB%8A%94-%EB%AA%A8%EB%91%90-%EC%8B%B1%EA%B8%80%ED%86%A4%EC%9D%BC%EA%B9%8C\">🌩 스프링의 빈의 scope는 모두 싱글톤일까</a></li>\n<li><a href=\"#-%EB%8A%90%EB%82%80-%EC%A0%90\">🛋 느낀 점</a></li>\n</ul>\n</div>","excerpt":"💡 Intro 왜 하필 스프링 인가? 라는 질문을 던지게 되면서 스프링이 가지고 있느 장점에 대해서 고민해보았다. 그 중 기존의 싱글톤 패턴의 한계를 뛰어넘은 스프링 싱글톤 레지스트리를 알게 되었다. 이전에 단순히 스프링이 싱글톤 scope으로 객체를 관리하여 여러 요청이 동시에 들어오는 환경에서 안정적으로 서비스할 수 있다는 장점을 들었지만 싱글톤 패턴과 어떻게 다른지 알지 못했다. 그래서 알아보자 🙌 🌩 싱글톤 패턴이란? 왜 싱글톤 패턴이어야 할까 하나의 서버에 초당 수많은 요청이 도착하고 처리되어야 한다. 요청이 올 때마다 서버에서 관련 객체를 생성하는 것은 굉장히 큰 오버헤드이다. 어떤 오버헤드가 발생할 수 있을까 ? 주로 서버는 여러 계층의 레이어를 지나고 여러 비지니스 오브젝트들이 협력하여 요청을 처리한다.  요청 하나당 대충 5개 정도의 오브젝트가 생성되고, 초딩 300개의 요청, 1분에 18000개의 요청이 발생한다면 18000 * 5 만큼의 새로운 오브젝트가 생성된…","frontmatter":{"date":"November 10, 2021","title":"스프링의 싱글톤 레지스트리","categories":"스프링 웹","author":"코다","emoji":"🍀"},"fields":{"slug":"/spring-singleton-registry/"}},"next":{"id":"a00c71d2-8668-58f5-a971-d074a917495f","html":"<blockquote>\n<p>다음은 우아한테크코스 막바지 글쓰기 미션 때 제출한 글 입니다. 진솔한 마음으로 써서 올려봅니다 😶</p>\n</blockquote>\n<h2 id=\"내가-꿈꾸는-프로그래머로서의-삶\" style=\"position:relative;\"><a href=\"#%EB%82%B4%EA%B0%80-%EA%BF%88%EA%BE%B8%EB%8A%94-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EB%A1%9C%EC%84%9C%EC%9D%98-%EC%82%B6\" aria-label=\"내가 꿈꾸는 프로그래머로서의 삶 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>내가 꿈꾸는 프로그래머로서의 삶</h2>\n<br>\n<p>처음 프로그래머를 꿈꾸게 된 명확한 이유가 있다. 프로그래밍은 많은 사람에게 영향을 줄 수 있는 가장 좋은 도구이기 때문이다. 나이가 많거나 적거나, 물질적으로 풍요롭거나 아니거나, 어떤 언어를 쓰거나 상관없이 대부분의 사람은 기술을 접할 수 있는 기기를 하나씩 가지고 있다. 한 애플리케이션을 전 세계가 쓰기도 하고, 특정 플랫폼을 통해 콘텐츠가 확 퍼지기도 한다. 그렇기에 내가 꿈꾸는 프로그래머로의 삶은 많은 사람에게 선한 영향력을 끼치는 것이다.</p>\n<br>\n<p>굉장히 붕 뜬 이상주의자처럼 들릴 수도 있지만 사실 나는 그런 사람은 아니다. 한때 MBTI 검사를 하면 감정을 나타내는 수치인 F가 빵점이 나올 정도로 (지금은 많이 바뀌었다) 기본이 이성적인 사람이다. 흔히 이성적이며 현실적인 사람에 대해서 이야기할 때 부정적이고 “현실적으로 안 된다”라고 말하는 사람이라고 형용한다. 나도 그런 사람 중 일인자라고 자부할 수 있는 사람이었는데, 그렇지 않은 현실을 만들고 그 현실 속에서 살아가는 좋은 사람들을 만나면서 바뀌었다. 그리고 누군가에게 이렇다 할 변화를 만들어내는 것도 현실에 안주하지 않고 그 이상을 꿈꾸는 사람들이라는 것을 목격하면서 내 가치관이 변했다.</p>\n<br>\n<p>그렇다고 붕 뜨면서 말도 안 되는 꿈만 꾸는 것은 아무래도 적성에 맞지 않는다. 곰곰이 고민해보았을 때 꿈을 현실로 만들 방법 중 가장 현실적이며 합리적인 리소스로 실현할 수 있는 방법이 프로그래밍이라고 생각했다. 지금은 그 프로그래밍에 대한 역량을 키워야 할 때다. 선한 목적과 꿈이 실력을 키워주지는 않는다. 다만 분명한 목적이 있다면 그것이 없는 다른 이들보다 훨씬 멀리 오래 갈 수 있을 거라 생각한다. 괜히 부푼 꿈만 말하면서 상응하는 실력이 없는 사람이 되기는 싫다.</p>\n<br>\n<p>프로그래밍을 처음 시작한 때부터 지금까지 내 가치관이 불분명했던 적은 없다. 나에게 프로그래밍은 그 자체가 목적이기보다 선한 목적을 이루기 위한 좋은 도구이다. 그 때문에 내 블로그 이름도 <em>FromCoding</em> 코딩으로 시작되는 무언가를 암시하는 이름으로 정했다. 깃헙에 소개 글도 마찬가지이다.</p>\n<blockquote>\n<p>일상에 스미는 좋은 기술로 사람이 사람을 돕는 문화를 꿈꾸는 개발자입니다👩‍💻</p>\n</blockquote>\n<p>오늘날에는 누구든지 기술을 사용하기 때문에 프로그래밍은 일상에 침투하기 가장 좋은 수단이다. 무언가가 많은 사람의 일상이 되면 그것은 하나의 문화가 된다. 마치 배달의 민족이 배달문화를 만들고 당근마켓이 또 하나의 문화가 된 것처럼 말이다. 그것이 선한 문화라면 사람이 사람을 돕는 가장 자연스러운 방법일 것이다.</p>\n<br>\n<p>마지막으로 쑥스러운 마음에 굳이 밝히지 않았던 <em>코다</em>라는 별명에 내재된 뜻을 말해보려고 한다. 누가 물어보면 그냥 우리 집 고양이 이름이라고 소개했지만 (맞는 말이긴 하다) ‘코딩이 다가 아닌 개발자’라는 나만의 의미를 담고 있다. 코딩이 다가 아니라 그것이 끼치는 영향까지 고려하는 개발자, 그래서 항상 선한 뜻을 실현하고자 하는 개발자가 내가 꿈꾸는 프로그래머로의 삶이다. 일단 코딩이 다가 아니라면 적어도 코딩은 잘해야 한다는 뜻이기도 하다.</p>\n<br>\n<p>마지막 글이라고 나름의 인생관을 적어보자면 나는 아무래도 나 혼자 행복하자고 사는 삶은 좀 시시한 것 같다. 언젠가는 끝나는 인생이기도 하고 행복 자체가 목적이라면 행복의 그릇을 조금 줄인다면 금방 행복해질 수 있다. (나만 해도 좋은 사람들과 때 되면 밥을 먹을 수 있기만 해도 매우 행복….) 또 나 혼자 잘 살기에는 세상에는 너무 많은 사람이 함께 살고 있다. 아직 걸음마 단계를 거치고 있는 예비 프로그래머이지만 내 꿈을 실현하기 위해 가장 좋은 방법을 찾고 열심히 발전하고 있는 것 같아서 나름 뿌듯하다. 그 과정이 재미있는 건 덤이다.</p>","frontmatter":{"date":"October 27, 2021","title":"내가 꿈꾸는 프로그래머에 대해 궁금한 사람들은 보시오 🙌","categories":"아무말","author":"코다","emoji":"💡"},"fields":{"slug":"/goal-as-programmer/"}},"prev":{"id":"1549b4b9-74b3-5275-b573-eb2609ad7eff","html":"<h2 id=\"-intro\" style=\"position:relative;\"><a href=\"#-intro\" aria-label=\" intro permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>💡 Intro</h2>\n<ul>\n<li>효율적인 프로그래밍을 위해 멀티 스레드 환경에서 구동을 할 때가 많다.</li>\n<li>멀티 스레드의 간단한 장점과 항상 헷갈렸던 사용자 레벨 스레드 vs. 커널 레벨 스레드에 대해서 알아보자.</li>\n</ul>\n<br>\n<h2 id=\"-multi-thread-장점\" style=\"position:relative;\"><a href=\"#-multi-thread-%EC%9E%A5%EC%A0%90\" aria-label=\" multi thread 장점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 Multi-thread 장점</h2>\n<h3 id=\"1-응답성\" style=\"position:relative;\"><a href=\"#1-%EC%9D%91%EB%8B%B5%EC%84%B1\" aria-label=\"1 응답성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 응답성</h3>\n<ul>\n<li>어플리케이션의 일부분이 봉쇄되거나 긴 작업을 실행하더라도 다른 부분의 프로그램이 계속 실행되는 것을 허용하기 때문에 사용자의 입장에서 응답성이 증가한다.</li>\n<li>예를 들어 다운로드가 오래 걸리는 파일을 다운로드 하면서 사용자와의 상호작용이 가능하다.</li>\n</ul>\n<h3 id=\"2-자원-공유-resource-sharing\" style=\"position:relative;\"><a href=\"#2-%EC%9E%90%EC%9B%90-%EA%B3%B5%EC%9C%A0-resource-sharing\" aria-label=\"2 자원 공유 resource sharing permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 자원 공유 resource sharing</h3>\n<ul>\n<li>프로세스는 완전히 별도의 메모리 공간을 할당받기 때문에 (code, data, heap) 서로 통신하기 위해서는 공유 메모리를 사용하거나 메세지 전달 기법 (IPC)를 사용해야한다.</li>\n<li>스레드는 속한 프로세스의 자원을 공유하기 때문에 한 프로그램이 <strong>같은 주소 내에서 여러개의 다른 작업을 하는 단위</strong>로 나뉘어질 수 있다는 이점이 있다.</li>\n</ul>\n<h3 id=\"3-경제성-economy\" style=\"position:relative;\"><a href=\"#3-%EA%B2%BD%EC%A0%9C%EC%84%B1-economy\" aria-label=\"3 경제성 economy permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 경제성 economy</h3>\n<ul>\n<li>프로세스의 자원을 공유하므로 메모리 측면과 문맥교환 오버헤드 측면에서 경제적이다.</li>\n</ul>\n<h3 id=\"4-규모-가변성-scalability\" style=\"position:relative;\"><a href=\"#4-%EA%B7%9C%EB%AA%A8-%EA%B0%80%EB%B3%80%EC%84%B1-scalability\" aria-label=\"4 규모 가변성 scalability permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. 규모 가변성 scalability</h3>\n<ul>\n<li>멀티코어 환경에서 각각의 스레드가 다른 코어에서 병렬로 실행될 수 있기 때문에 이점이 증가한다.</li>\n<li>단일 스레드라면 코어의 개수와 상관없이 한번에 한 개의 처리기에서만 실행되지만 멀티코어에 멀티스레드라면 병렬성을 증가시킨다.</li>\n</ul>\n<br>\n<h2 id=\"-multi-thread-모델\" style=\"position:relative;\"><a href=\"#-multi-thread-%EB%AA%A8%EB%8D%B8\" aria-label=\" multi thread 모델 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 Multi-thread 모델</h2>\n<ul>\n<li>\n<p>스레드는 사용자 스레드와 커널 스레드로 나뉜다.</p>\n<ul>\n<li>사용자 스레드는 사용자 수준에서 관리되며 os가 관여하지 않는다.</li>\n<li>사용자 수준의 라이브러리를 사용하여 생성되고 커널의 개입을 받지 않는다.</li>\n<li>커널 스레드는 os에 의해 직접 지원되고 관리된다.</li>\n</ul>\n</li>\n<li>다양한 Mutli-thread 모델이 있는 이유는 스레드가 작업을 처리하기 위해서는 CPU를 점유해야하기 때문에 궁극적으로는 사용자 스레드와 커널 스레드간의 어떠한 연관관계가 존재해야 하기 때문이다.</li>\n</ul>\n<h3 id=\"모델-3가지\" style=\"position:relative;\"><a href=\"#%EB%AA%A8%EB%8D%B8-3%EA%B0%80%EC%A7%80\" aria-label=\"모델 3가지 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>모델 3가지</h3>\n<ul>\n<li>\n<p>다대일 모델</p>\n<ul>\n<li>여러 사용자 스레드를 하나의 커널 스레드에 사상하며 스레드 관리는 사용자 레벨의 스레드 라이브러리가 수행한다.</li>\n<li>한 스레드가 봉쇄 상태에 들어가면 커널 스레드가 함께 봉쇄 상태에 들어가게 되므로 모두 봉쇄된다.</li>\n<li>한번에 하나의 스레드만 커널에 접근이 가능하기 때문에 멀티코어 환경에서 병렬로 실행될 수 없다.</li>\n</ul>\n</li>\n<li>\n<p>일대일 모델</p>\n<ul>\n<li>하나의 사용자 스레드를 각각 하나의 커널 스레드로 사상한다.</li>\n<li>하나의 스레드가 봉쇄상태에 들어가더라도 다른 스레드가 커널 스레드와 매핑되어 작업을 처리할 수 있으므로 멀티코어 환경에서 더 병렬성을 제공한다.</li>\n<li>사용자 레벨에서 스레드를 하나 생성할 때 커널의 스레도 생성해야 하기 대문에 오버헤드가 발생한다. 따라서 이 모델을 사용할 경우 대부분 시스템에 의해 지원되는 스레드 개수를 제한한다.</li>\n<li>Linux가 대표적인 일대일 모델을 사용하는 os이다.</li>\n</ul>\n</li>\n<li>\n<p>다대다 모델</p>\n<ul>\n<li>여러 사용자 스레드를 여러 커널 스레드에 사상한다. (사용자 스레드 ≤ 커널 스레드 숫자로 사상한다)</li>\n<li>\n<p>다대일 모델과 일대일 모델의 단점을 극복한다.</p>\n<ul>\n<li>진정한 동시성을 지원하지 못하는 단점과, 스레드 개수에 제한이 있는 단점을 커버한다.</li>\n</ul>\n</li>\n<li>개발자는 원하는 만큼 스레드를 생성하고 여러개의 커널 스레드에 의해 병렬성을 보장한다. 따라서 하나의 스레드가 봉쇄상태에 들어가더라도 다른 커널 스레드에 의해 실행을 스케줄 할 수 있다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-thread-스케줄링\" style=\"position:relative;\"><a href=\"#-thread-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81\" aria-label=\" thread 스케줄링 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 Thread 스케줄링</h2>\n<ul>\n<li>사용자 스레드와 커널 스레드가 나뉘지만 os에서 스캐줄링 되는 대상은 커널 스레드이다.</li>\n<li>사용자 스레드는 스레드 라이브러리에 의해서 관리되고 커널은 사용자 스레드의 존재에 대해서 알지 못하기 때문에 궁극적으로 사용자 스레드는 커널 스레드에 사상되어야 한다.</li>\n<li>따라서 사용자 수준과 커널 수준의 스레드 스케줄링에 대해서 간략히 다루어보자.</li>\n</ul>\n<h3 id=\"경쟁-범위-contention-scope\" style=\"position:relative;\"><a href=\"#%EA%B2%BD%EC%9F%81-%EB%B2%94%EC%9C%84-contention-scope\" aria-label=\"경쟁 범위 contention scope permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>경쟁 범위 Contention scope</h3>\n<ul>\n<li>\n<p><strong>Process-Contention scope(PCS)</strong></p>\n<ul>\n<li>다대일, 다대다 모델에서는 스레드 라이브러리가 사용자 스레드를 가용한 커널 스레드에 스케줄링한다.</li>\n<li>동일한 프로세스의 스레드들끼리 CPU를 경쟁하는 형태</li>\n<li>스레드 라이브러리가사용자 스레드를 ‘가용한 LWP(Light Weight Process) 상에서 스케줄한다’ 라고 하더라도 그것이 CPU 점유를 의미하지 않는다. CPU 점유는 커널 스레드의 스캐줄링이 필요하다.</li>\n<li>주로 우선순위에 따라서 행해지며 가장 높은 우선순위를 선점하여 스캐줄링한다.</li>\n</ul>\n</li>\n<li>\n<p><strong>System-Contention scope(SCS)</strong></p>\n<ul>\n<li>실제 CPU에서 실행되기 위해서 os가 커널 스레드를 물리적 CPU로 스캐줄링 해야한다.</li>\n<li>어느 커널 스레드가 CPU를 점유할 것인지 결정하는 형태</li>\n<li>SCS 스캐줄링은 시스템 상의 모든 스레드 사이에서 일어난다.</li>\n<li>일대일 모델 같은 경우 오직 SCS만 사용한다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-느낀-점\" style=\"position:relative;\"><a href=\"#-%EB%8A%90%EB%82%80-%EC%A0%90\" aria-label=\" 느낀 점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🛋 느낀 점</h2>\n<ul>\n<li>한번도 제대로 이해하지 못했는데 os를 처음부터 차근차근 공부하며 ‘커널’에 대한 이해도를 쌓은 후 공부하니 조금 더 감이 잡히는 듯 하다.</li>\n<li>사용자 스레드의 이점이 아직 그렇게 잘 와닿지 않는다. 우선 하나의 프로세스 내에서 여러 작업 단위를 나눈다는 점만 이해하고 넘어가야겠다.</li>\n<li>자바의 Thread와 스레드 라이브러리에 대해서 더 깊이 공부해 봐야겠다 🙌</li>\n</ul>\n<br>\n<p>[참고자료]</p>\n<ul>\n<li>Operating System 공룡책 </li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#-intro\">💡 Intro</a></li>\n<li>\n<p><a href=\"#-multi-thread-%EC%9E%A5%EC%A0%90\">🌩 Multi-thread 장점</a></p>\n<ul>\n<li><a href=\"#1-%EC%9D%91%EB%8B%B5%EC%84%B1\">1. 응답성</a></li>\n<li><a href=\"#2-%EC%9E%90%EC%9B%90-%EA%B3%B5%EC%9C%A0-resource-sharing\">2. 자원 공유 resource sharing</a></li>\n<li><a href=\"#3-%EA%B2%BD%EC%A0%9C%EC%84%B1-economy\">3. 경제성 economy</a></li>\n<li><a href=\"#4-%EA%B7%9C%EB%AA%A8-%EA%B0%80%EB%B3%80%EC%84%B1-scalability\">4. 규모 가변성 scalability</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-multi-thread-%EB%AA%A8%EB%8D%B8\">🌩 Multi-thread 모델</a></p>\n<ul>\n<li><a href=\"#%EB%AA%A8%EB%8D%B8-3%EA%B0%80%EC%A7%80\">모델 3가지</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-thread-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81\">🌩 Thread 스케줄링</a></p>\n<ul>\n<li><a href=\"#%EA%B2%BD%EC%9F%81-%EB%B2%94%EC%9C%84-contention-scope\">경쟁 범위 Contention scope</a></li>\n</ul>\n</li>\n<li><a href=\"#-%EB%8A%90%EB%82%80-%EC%A0%90\">🛋 느낀 점</a></li>\n</ul>\n</div>","frontmatter":{"date":"November 10, 2021","title":"사용자 레벨 스레드 vs. 커널 레벨 스레드","categories":"운영체제","author":"코다","emoji":"🧁"},"fields":{"slug":"/os-user-kernel-thread/"}},"site":{"siteMetadata":{"siteUrl":"https://yjksw.github.io","comments":{"utterances":{"repo":"yjksw/yjksw.github.io"}}}}},"pageContext":{"slug":"/spring-singleton-registry/","nextSlug":"/goal-as-programmer/","prevSlug":"/os-user-kernel-thread/"}},"staticQueryHashes":["1073350324","2938748437"]}
{"componentChunkName":"component---src-templates-blog-template-js","path":"/boolean-timestamp/","result":{"data":{"cur":{"id":"20c3cda7-77dd-5c04-b4a8-7982cb496eaa","html":"<ul>\n<li>이것은 정답이 아니라 한 블로그에 기술된 하나의 의견이다. 읽어보고 신선한 접근이라고 생각해서 정리해둔다. <a href=\"%5Bhttps://changelog.com/posts/you-might-as-well-timestamp-it%5D(https://changelog.com/posts/you-might-as-well-timestamp-it)\">링크</a></li>\n</ul>\n<p>데이터베이스에서 boolean 값을 지정해서 저장해야하는 경우들이 있다. <code class=\"language-text\">is_published</code>, <code class=\"language-text\">is_signed</code>, <code class=\"language-text\">is_finished</code> 등등을 기록해야하는 경우들이다. 이 경우에 boolean으로 저장하지 말고 timestamp로 저장하도록 해보자! 글쓴이의 말을 인용하자면 “단 한번도 후회한적이 없다”. <br></p>\n<p>Boolean 값으로 저장할만한 데이터는 언제 해당 데이터가 set 되었는지에 대한 timestamp를 제공함으로 잃는 것이 없다. 아무리 해당 시간 데이터가 필요하지 않더라도 말이다. 이렇게 구현을 하게 된다면 <code class=\"language-text\">null</code> 은 <code class=\"language-text\">false</code>로 <code class=\"language-text\">non-null</code>은 <code class=\"language-text\">true</code>로 간주되어 처리하면 될 것이다. <br></p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token comment\">//boolean 사용</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>is_finished<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">//timestamp 사용</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>finished_at<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>따라서 자연스럽게 <code class=\"language-text\">deleted_at</code>, <code class=\"language-text\">hidden_at</code>, <code class=\"language-text\">signed_in_at</code> 등등으로 변환될 것이다. </p>\n<h3 id=\"의견\" style=\"position:relative;\"><a href=\"#%EC%9D%98%EA%B2%AC\" aria-label=\"의견 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>의견</h3>\n<p>글쓴이의 말이 일리가 있다. 큰 구현의 차이나 처리의 차이 없이 동일한 연산을 수행할 수 있고, 더 많은 정보를 제공하는 이점이 있다. <br></p>\n<p>하지만 해당 데이터가 <code class=\"language-text\">null</code>로 지정이 되어 있는 시점이 있다는 것이 해당 코드를 취약하게 만들 수도 있을 것 같다. <br></p>\n<p> 이 부분에 대한 다른 크루들의 생각을 첨부! <br></p>\n<p align=\"center\"><img width=\"90%\" alt=\"_2021-04-25__7 01 27\" src=\"https://user-images.githubusercontent.com/63405904/134771368-791c2734-8e0e-49e4-9b58-b9608036c69f.png\"></p>","excerpt":"이것은 정답이 아니라 한 블로그에 기술된 하나의 의견이다. 읽어보고 신선한 접근이라고 생각해서 정리해둔다. 링크 데이터베이스에서 boolean 값을 지정해서 저장해야하는 경우들이 있다. , ,  등등을 기록해야하는 경우들이다. 이 경우에 boolean으로 저장하지 말고 timestamp로 저장하도록 해보자! 글쓴이의 말을 인용하자면 “단 한번도 후회한적이 없다”.  Boolean 값으로 저장할만한 데이터는 언제 해당 데이터가 set 되었는지에 대한 timestamp를 제공함으로 잃는 것이 없다. 아무리 해당 시간 데이터가 필요하지 않더라도 말이다. 이렇게 구현을 하게 된다면  은 로 은 로 간주되어 처리하면 될 것이다.  따라서 자연스럽게 , ,  등등으로 변환될 것이다.  의견 글쓴이의 말이 일리가 있다. 큰 구현의 차이나 처리의 차이 없이 동일한 연산을 수행할 수 있고, 더 많은 정보를 제공하는 이점이 있다.  하지만 해당 데이터가 로 지정이 되어 있는 시점이 있다는 것이 해당…","frontmatter":{"date":"March 17, 2021","title":"Boolean 대신 timestamp","categories":"설계","author":"코다","emoji":"🛠"},"fields":{"slug":"/boolean-timestamp/"}},"next":{"id":"21e10a37-af41-506b-8eda-5a0ffa60b567","html":"<p>스프링 강의 중 DAO vs. Repository의 차이점에 대해서 논의하다가 다음과 같은 표현이 나왔다. </p>\n<ul>\n<li>Repository의 추상 인터페이스는 Domain Layer에 속하며 Domain 객체들을 관리하고 생애주기를 같이한다. 그 구현체인 SimpleJpaRepository는 Infrastructure에 속한다. 추상화된 repository 인터페이스를 사용하면서 추상에 의존하고 구체에 의존하지 않도록 구성(DIP) 하여 유연성 있는 시스템을 구성한다.</li>\n</ul>\n<p>여기서 나오는 DIP는 무엇이고 위와 같은 구성이 어떻게 우연성을 제공하는 걸까? </p>\n<h3 id=\"dip-요약\" style=\"position:relative;\"><a href=\"#dip-%EC%9A%94%EC%95%BD\" aria-label=\"dip 요약 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>DIP 요약</h3>\n<ul>\n<li><strong>Dependency Inversion Principle</strong>의 약자이다.</li>\n</ul>\n<p>본래 객체는 상위 계층이 하위 계층에 의존한다. DIP는 그 관계를 역전시켜서 상위 계층이 하위 계층의 구현에서 독립하도록 한다. 그러기 위한 원칙 두가지는 다음과 같다. </p>\n<ol>\n<li>상위 모듈과 하위 모듈이 서로 의존하는 것이 아니라 모두 추상화에 의존한다. </li>\n<li>추상화가 구현에 의존하는 것이 아니라 구현이 추상화에 의존해야 한다. </li>\n</ol>\n<p>한마디로 요약하면 다음이다. <br></p>\n<p><strong>“The DIP is about inverting the classic dependency between high-level and low-level components by abstracting away the interacting between them.”</strong></p>\n<p>출처 : <a href=\"https://www.baeldung.com/java-dependency-inversion-principle\">https://www.baeldung.com/java-dependency-inversion-principle</a> <br></p>\n<p>즉 상위 모듈과 하위 모듈 사이에 추상화를 껴서 서로를 의존하는 것이 아니라 인터페이스를 통해서 협력하도록 하는 것이다. </p>\n<h3 id=\"dip-구현\" style=\"position:relative;\"><a href=\"#dip-%EA%B5%AC%ED%98%84\" aria-label=\"dip 구현 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>DIP 구현</h3>\n<p>다음과 같은 구현이 있을 때 어떤 것이 DIP 일까?</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">public</span> class StringProcessor {\n    \n    private final StringReader stringReader<span class=\"token punctuation\">;</span>\n    private final StringWriter stringWriter<span class=\"token punctuation\">;</span>\n    \n    <span class=\"token keyword\">public</span> StringProcessor<span class=\"token punctuation\">(</span>StringReader stringReader<span class=\"token punctuation\">,</span> StringWriter stringWriter<span class=\"token punctuation\">)</span> {\n        this<span class=\"token punctuation\">.</span>stringReader <span class=\"token operator\">=</span> stringReader<span class=\"token punctuation\">;</span>\n        this<span class=\"token punctuation\">.</span>stringWriter <span class=\"token operator\">=</span> stringWriter<span class=\"token punctuation\">;</span>\n    }\n\n    <span class=\"token keyword\">public</span> void printString<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> {\n        stringWriter<span class=\"token punctuation\">.</span><span class=\"token keyword\">write</span><span class=\"token punctuation\">(</span>stringReader<span class=\"token punctuation\">.</span>getValue<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    }\n}</code></pre></div>\n<ol>\n<li><code class=\"language-text\">StringReader</code>, <code class=\"language-text\">StringWriter</code> 가 인터페이스이고 <code class=\"language-text\">StringProcessor</code>와 같은 패키지에 존재한다. (구현체는 함께 있지 않다)</li>\n<li><code class=\"language-text\">StringReader</code>, <code class=\"language-text\">StringWriter</code>가 인터페이스이면서 <code class=\"language-text\">StringProcessor</code>와 다른 패키지에 존재한다. </li>\n</ol>\n<p>즉 구현체와 따로 분리되어 있어서 StringProcessor는 인터페이스에 의존하고 인터페이스는 언제나 변경이 가능하여 구현체에 존재하지 않도록 한다.</p>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#dip-%EC%9A%94%EC%95%BD\">DIP 요약</a></li>\n<li><a href=\"#dip-%EA%B5%AC%ED%98%84\">DIP 구현</a></li>\n</ul>\n</div>","frontmatter":{"date":"March 13, 2021","title":"DIP 의존관계 역전의 원칙","categories":"스프링 웹","author":"코다","emoji":"🍀"},"fields":{"slug":"/dip/"}},"prev":{"id":"c6060cb1-1a69-5cc5-8508-1df3c8357b5f","html":"<p>요약하자면 Stream과 Collection의 차이는 다음과 같다. </p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token number\">1.</span> 스트림은 요소를 보관하지 않고 필요할 때 생성되거나 하위 <span class=\"token class-name\">Collection</span>에 보관한다<span class=\"token punctuation\">.</span> \n<span class=\"token number\">2.</span> 스트림은 원본을 변경하기보다 새로운 스트림을 생성하여 반환한다<span class=\"token punctuation\">.</span> \n<span class=\"token number\">3.</span> 스트림 연산은 lazy operation이다<span class=\"token punctuation\">.</span> <span class=\"token punctuation\">(</span>따라서 무한 스트림도 가능한 것이다<span class=\"token punctuation\">)</span></code></pre></div>\n<p>개념적으로 접근했을 때 Collection의 경우에는 어떠한 데이터를 담는 자료구조의 역할을 주로 하지만, Stream의 경우는 연산과 관련된 것이 주라고 볼 수 있다. </p>\n<ul>\n<li>\n<p>Quote</p>\n<p>Java <em>Collection</em>s offer efficient mechanisms to store and process the data by providing data structures like <em><a href=\"https://drafts.baeldung.com/java-linkedlist\">List</a></em>, <em><a href=\"https://drafts.baeldung.com/java-hashset\">Set</a></em>, and <em><a href=\"https://drafts.baeldung.com/java-hashmap\">Map</a></em>.</p>\n<p>However, the Stream API is useful for performing various operations on the data without the need for intermediate storage.</p>\n<p>출처: <a href=\"https://www.baeldung.com/java-return-stream-collection\">https://www.baeldung.com/java-return-stream-collection</a></p>\n</li>\n</ul>\n<h3 id=\"traversal\" style=\"position:relative;\"><a href=\"#traversal\" aria-label=\"traversal permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Traversal</h3>\n<p>Collection은 여러번 데이터를 횡단할 수 있지만, Stream은 한번만 가능하며 source로부터 새로운 Stream을 추출해야 새롭게 traverse 할 수 있다. </p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">Stream</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> numbers <span class=\"token operator\">=</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">;</span>\nnumbers<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//error 없음</span>\nnumbers<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//error 발생</span></code></pre></div>\n<h3 id=\"lazy-operation\" style=\"position:relative;\"><a href=\"#lazy-operation\" aria-label=\"lazy operation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Lazy Operation</h3>\n<p>Collection은 요소를 보관하기 때문에 해당 Collection에 어떠한 요소가 추가되기 전에 operation을 우선 실행해야한다. <br></p>\n<p>하지만 Stream은 lazy하기 연산을 하기 때문에 우선 Stream에 담겨진 요소들에 대해서 선실행을 하지 않는다. 이후에 필요할 때 요소를 꺼내오고 연산을 하도록 한다. 또한 Stream은 불변이므로 요소를 추가하거나 삭제할 수 없다. </p>\n<h3 id=\"외부반복-vs-내부반복\" style=\"position:relative;\"><a href=\"#%EC%99%B8%EB%B6%80%EB%B0%98%EB%B3%B5-vs-%EB%82%B4%EB%B6%80%EB%B0%98%EB%B3%B5\" aria-label=\"외부반복 vs 내부반복 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>외부반복 vs. 내부반복</h3>\n<p>외부에서 값을 꺼내서 반복해야하는 Collection과 다르게 Stream은 내부적으로 알아서 반복문을 돌면서 명령한 연산을 수행한다. <br></p>\n<p>내부 반복을 했을 경우 1) 반복자를 사용하여 명시적으로 표시할 필요가 없고 2) 병렬처리시 스레드간 공유자원에 대한 관리를 할 필요가 없다. </p>\n<h3 id=\"유연성\" style=\"position:relative;\"><a href=\"#%EC%9C%A0%EC%97%B0%EC%84%B1\" aria-label=\"유연성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>유연성</h3>\n<p>Stream은 여러 operation의 조합으로 유연하게 데이터 연산이 가능한 장점이 있다. 어떤 특정 result set을 도출해서 consumer에게 넘겨줄 필요 없이 필요한 연산을 조합하여 바로바로 처리할 수 있다. </p>\n<h3 id=\"functional-behavior\" style=\"position:relative;\"><a href=\"#functional-behavior\" aria-label=\"functional behavior permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Functional Behavior</h3>\n<p>Stream은 functional 하기 때문에 기존 데이터를 변경시키지 않는다. 따라서 result set도 immutable (연산 중에) 하기 때문에 병렬 처리에 강하다. <br></p>\n<br>\n<p>참고 링크:</p>\n<ul>\n<li><a href=\"https://bk-investing.tistory.com/42\">https://bk-investing.tistory.com/42</a></li>\n<li><a href=\"https://javaconceptoftheday.com/collections-and-streams-in-java/#:~:text=Difference%20Between%20Collections%20Vs%20Streams%20In%20Java%20%3A&#x26;text=Collections%20are%20mainly%20used%20to%20store%20and%20group%20the%20data,or%20remove%20elements%20from%20streams\">https://javaconceptoftheday.com/collections-and-streams-in-java/#:~:text=Difference Between Collections Vs Streams In Java %3A&#x26;text=Collections are mainly used to store and group the data,or remove elements from streams</a>.</li>\n<li><a href=\"https://www.baeldung.com/java-return-stream-collection\">https://www.baeldung.com/java-return-stream-collection</a></li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#traversal\">Traversal</a></li>\n<li><a href=\"#lazy-operation\">Lazy Operation</a></li>\n<li><a href=\"#%EC%99%B8%EB%B6%80%EB%B0%98%EB%B3%B5-vs-%EB%82%B4%EB%B6%80%EB%B0%98%EB%B3%B5\">외부반복 vs. 내부반복</a></li>\n<li><a href=\"#%EC%9C%A0%EC%97%B0%EC%84%B1\">유연성</a></li>\n<li><a href=\"#functional-behavior\">Functional Behavior</a></li>\n</ul>\n</div>","frontmatter":{"date":"March 20, 2021","title":"Stream vs. Collection","categories":"자바","author":"코다","emoji":"✊"},"fields":{"slug":"/stream-vs-collection/"}},"site":{"siteMetadata":{"siteUrl":"https://yjksw.github.io","comments":{"utterances":{"repo":"yjksw/yjksw.github.io"}}}}},"pageContext":{"slug":"/boolean-timestamp/","nextSlug":"/dip/","prevSlug":"/stream-vs-collection/"}},"staticQueryHashes":["1073350324","2938748437"]}
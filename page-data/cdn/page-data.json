{"componentChunkName":"component---src-templates-blog-template-js","path":"/cdn/","result":{"data":{"cur":{"id":"ff4d68a5-f01f-5ae1-92ba-074f403b2c61","html":"<h2 id=\"intro\" style=\"position:relative;\"><a href=\"#intro\" aria-label=\"intro permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Intro</h2>\n<ul>\n<li>이번에 프로젝트를 진행하면서 보안상의 이유로 직접 S3 서버에 접근할 수 없었기 때문에 AWS에서 제공하는 CDN 서비스인 CloudFront를 통해서 이미지 등의 리소스에 접근해야 했다. (CDN서버의 본래 목적과는 다소 다른 이유로 사용했다.)</li>\n<li>CDN은 어떤 기술이며, 장점이 무엇이고, 어떻게 동작하는지에 대해서 알아본다. </li>\n<li>CDN을 퉁해 누릴 수 있는 보안적인 이점은 무엇이며, 프로젝트를 진행하면서 CloudFront를 어떻게 활용했는지에 대해서 작성한다. </li>\n</ul>\n<br>\n<h2 id=\"cdn이란-무엇인가\" style=\"position:relative;\"><a href=\"#cdn%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80\" aria-label=\"cdn이란 무엇인가 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CDN이란 무엇인가?</h2>\n<p>CDN은 Content Delivery Network의 약자이다. 직역하자면 컨텐츠를 전달해주는 네트워크이다. CDN 컨텐츠를 전송하는 물리적인 서버가 지리적으로 여러곳에 상주하며 유저와 가까이 위치한 서버에서 요청한 컨텐츠를 고속으로 제공해준다. </p>\n<p>CDN이 제공하는 컨텐츠는 <code class=\"language-text\">HTML</code>, <code class=\"language-text\">javascript</code> 파일, <code class=\"language-text\">css</code>, 이미지, 동영상 등의 대부분의 인터넷 콘텐츠이다. CDN 서비스에 대해서 설명하는 예시에 항상 등장하는 어플리케이션은 넷플릭스이다. 전세계 곳곳에서 유저들이 넷플릭스 컨텐츠를 요청하면 가장 가까이 상주하고 있는 CDN 서버에서 넷플릭스 컨텐츠를 빠르게 유저에게 제공한다. 이외에 Facebook, Amazon 등도 사용 중이다. </p>\n<p>CDN을 자체로 웹을 호스팅 할 수는 없다. 다만 웹의 컨텐츠를 <code class=\"language-text\">캐싱</code>하여 호스팅하는 웹을 대신하여 전송해서 웹의 성능을 개선한다.</p>\n<br>\n<h2 id=\"cdn-장점\" style=\"position:relative;\"><a href=\"#cdn-%EC%9E%A5%EC%A0%90\" aria-label=\"cdn 장점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CDN 장점</h2>\n<ol>\n<li>\n<p>캐싱으로 컨텐츠 고속 전송</p>\n<ul>\n<li>사용자와 물리적으로 가까운 CDN 서버에서 컨텐츠를 전송하므로 사용자의 입장에서 컨텐츠 로드 시간이 매우 단축된다. 또한 CDN 서버는 랜덤으로 배치되어 있는 것이 아니라, 전세계 트래픽이 많은 영역에 전략적으로 위치해 있다. </li>\n<li>\n<p>캐싱 과정 </p>\n<ol>\n<li>사용자가 컨텐츠를 요청하면 가장 가까운 CDN 엣지 서버로 요청이 간다. </li>\n<li>(최초 요청일 경우) CDN 엣지 서버에서 원본 서버로 요청을 보낸다. </li>\n<li>원본 서버가 해당 컨텐츠를 엣지 서버에 응답한다. </li>\n<li>\n<p>엣지 서버가 사용자에게 컨텐츠를 응답한다.\n<br></p>\n<p align=\"center\"><img width=\"450\" src=\"https://user-images.githubusercontent.com/63405904/130417611-508fcc23-79f2-4ae7-923b-5a0989a2cf54.png\"><br>이미지 출처: https://www.cloudflare.com/ko-kr/learning/cdn/performance/</p>\n</li>\n</ol>\n</li>\n<li>\n<p>그 이후부터는 동일한 컨텐츠에 대한 요청이 있을 때 해당 컨텐츠가 동일한 CDN 엣지 서버에 요청을 보내고 원본 서버에 요청을 보낼 필요 없이 CDN 엣지 서버가 컨텐츠를 반환한다. 이때 속도가 굉장히 향상된다.\n<br></p>\n<p align=\"center\"><img width=\"450\" src=\"https://user-images.githubusercontent.com/63405904/130417751-e2d97680-8446-401e-bdec-90b95560f87f.png\"><br>이미지 출처: https://www.cloudflare.com/ko-kr/learning/cdn/performance/</p>\n</li>\n</ul>\n</li>\n<li>\n<p>CDN의 failover</p>\n<ul>\n<li>failover란? 서버가 갑자기 중단되어 서버에 요청을 보내던 트래픽에 대해 정상적인 응답을 하지 못하는 것을 방지하는 것</li>\n<li>\n<p>CDN은 요청을 보내던 origin server가 죽으면 정상적으로 응답을 할 수 있는 서버로 reroute 하여 사용자가 안정적으로 그 응답을 받을 수 있도록 한다.\n<br></p>\n<p align=\"center\"><img width=\"433\" src=\"https://user-images.githubusercontent.com/63405904/130594395-77cf44f3-049c-4a4c-9be2-f59678f77b7c.png\"><br>이미지 출처: https://www.cloudflare.com/ko-kr/learning/cdn/cdn-load-balance-reliability/</p>\n</li>\n</ul>\n</li>\n<li>\n<p>로드밸런싱 및 DDos 공격 완화</p>\n<ul>\n<li>로드 밸런서는 네트워크 트래픽을 여러 서버에 분산해서 성능을 개선하는 것이다. </li>\n<li>CDN은 GSLB(Global Server Load Balancing)으로 로드 밸런싱 기술을 제공한다. (DNS와 GSLB의 차이점에 대해서 학습해도 좋다.) <a href=\"https://www.cloudflare.com/ko-kr/learning/cdn/glossary/global-server-load-balancing-gslb/\">GSLB 참고</a></li>\n<li>CDN은 데이터센터의 로드 밸런싱으로 사용자의 요청을 가능한 서버에 분산해서 요청한다. (GSLB를 사용하기 때문에 요청 서버에 대한 헬스체크도 수행하여 안정적이다.)</li>\n<li>\n<p>속도도 개선시키고, 트래픽도 감소시키므로 DDos 공격도 방지할 수 있다. </p>\n<p align=\"center\"><img width=\"630\" src=\"https://user-images.githubusercontent.com/63405904/130593424-74c410aa-b465-4fee-8dd1-e4213090064a.png\"><br>이미지 출처: https://www.cloudflare.com/ko-kr/learning/cdn/cdn-load-balance-reliability/</p>\n</li>\n</ul>\n</li>\n</ol>\n<br>\n<h2 id=\"프로젝트에서-cdn-사용-목적\" style=\"position:relative;\"><a href=\"#%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EC%97%90%EC%84%9C-cdn-%EC%82%AC%EC%9A%A9-%EB%AA%A9%EC%A0%81\" aria-label=\"프로젝트에서 cdn 사용 목적 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>프로젝트에서 CDN 사용 목적</h2>\n<ul>\n<li>\n<p>다음은 프로젝트의 인프라 구조이다. </p>\n<p align=\"center\"><img width=\"605\" src=\"https://user-images.githubusercontent.com/63405904/130720611-034be1a1-c358-4ce5-8fac-8383a87d19e0.png\"></p>\n</li>\n<li>일반적인지는 잘 모르겠지만, 현재 S3 버킷에 프론트 서버가 올라가있다. (그렇지 않더라도 이미지 및 동영상 리소스가 S3 버킷에 저장되어 있다.) </li>\n<li>프로젝트를 하는데 보안상의 이슈로 S3 버킷에 대한 접근을 전체공개할 수 없었고, Cloud Front를 통해서 우회하여 접근하도록 설계했다. </li>\n<li>CDN의 본래 목적은 리소스를 캐싱하여 빠르게 로딩하는 것이지만 이번 프로젝트에서는 S3 버킷 사용 목적으로 설계했다. </li>\n<li>프론트 서버를 분산하거나, 진행중인 프로젝트(개발자 친화적 SNS)의 특성상 이미지 및 동영상 리소스가 굉장히 많아져서 S3 버킷이 추가되면 로드 밸런싱, CDN failover 등의 이점을 누릴 수 있을 것이라고 생각한다. </li>\n</ul>\n<br>\n<br>\n<p><strong>[참고자료]</strong></p>\n<ul>\n<li><a href=\"https://www.cloudflare.com/ko-kr/learning/cdn/performance/\">https://www.cloudflare.com/ko-kr/learning/cdn/performance/</a></li>\n<li><a href=\"https://www.cloudflare.com/ko-kr/learning/cdn/cdn-load-balance-reliability/\">https://www.cloudflare.com/ko-kr/learning/cdn/cdn-load-balance-reliability/</a></li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#intro\">Intro</a></li>\n<li><a href=\"#cdn%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80\">CDN이란 무엇인가?</a></li>\n<li><a href=\"#cdn-%EC%9E%A5%EC%A0%90\">CDN 장점</a></li>\n<li><a href=\"#%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EC%97%90%EC%84%9C-cdn-%EC%82%AC%EC%9A%A9-%EB%AA%A9%EC%A0%81\">프로젝트에서 CDN 사용 목적</a></li>\n</ul>\n</div>","excerpt":"Intro 이번에 프로젝트를 진행하면서 보안상의 이유로 직접 S3 서버에 접근할 수 없었기 때문에 AWS에서 제공하는 CDN 서비스인 CloudFront를 통해서 이미지 등의 리소스에 접근해야 했다. (CDN서버의 본래 목적과는 다소 다른 이유로 사용했다.) CDN은 어떤 기술이며, 장점이 무엇이고, 어떻게 동작하는지에 대해서 알아본다.  CDN을 퉁해 누릴 수 있는 보안적인 이점은 무엇이며, 프로젝트를 진행하면서 CloudFront를 어떻게 활용했는지에 대해서 작성한다.  CDN이란 무엇인가? CDN은 Content Delivery Network의 약자이다. 직역하자면 컨텐츠를 전달해주는 네트워크이다. CDN 컨텐츠를 전송하는 물리적인 서버가 지리적으로 여러곳에 상주하며 유저와 가까이 위치한 서버에서 요청한 컨텐츠를 고속으로 제공해준다.  CDN이 제공하는 컨텐츠는 ,  파일, , 이미지, 동영상 등의 대부분의 인터넷 콘텐츠이다. CDN 서비스에 대해서 설명하는 예시에 항상 등장…","frontmatter":{"date":"September 02, 2021","title":"CDN 알아보기","categories":"인프라","author":"코다","emoji":"🚊"},"fields":{"slug":"/cdn/"}},"next":{"id":"41ff080c-8050-53a6-a648-d015de29c91e","html":"<h2 id=\"자바-io-스트림\" style=\"position:relative;\"><a href=\"#%EC%9E%90%EB%B0%94-io-%EC%8A%A4%ED%8A%B8%EB%A6%BC\" aria-label=\"자바 io 스트림 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>자바 I/O 스트림</h2>\n<ul>\n<li>Stream은 데이터의 연속이다. Sequence of Data</li>\n<li>다르게 말하면 <strong>Stream 이란 한쪽으로 흐르는 통로같은 것이다.</strong> 자바에서 Stream이란 한쪽 source에서 destination으로 흐르는 <strong>데이터를 위한 단방향 통로</strong>이다. 자바에서는 여러 매체를 읽거나 쓸 수 있고 각자를 위한 I/O Stream이 구현되어 있다. (disk files, devices, programs, memory arrays)</li>\n<li>Stream은 단방향 통신이기때문에 들어오는 데이터, 나가는 데이터에 따로 InputStream, OutputStream이 있는 것이다. </li>\n<li>I/O 스트림은 여러가지 종류의 데이터들을 처리할 수 있다: 바이트, primitive data type, characters, objects</li>\n<li>Stream은 단순히 데이터를 전달하는 역할만 하기도하고, 몇몇 stream은 데이터를 조작하고 편리하게 변환하는 역할을 수행하기도 한다.</li>\n<li>\n<p>모든 Stream은 사용 후 반드시 <code class=\"language-text\">close()</code> 해주어야 한다. (<code class=\"language-text\">try-with-resources</code>를 추천한다.)</p>\n<p align=\"center\"><img width=\"400\" src=\"https://user-images.githubusercontent.com/63405904/130890827-a907eff4-5edc-437c-b8d3-50cdb2cac0c9.png\"><br>TCP School</p>\n</li>\n</ul>\n<br>\n<h3 id=\"바이트-기반-stream\" style=\"position:relative;\"><a href=\"#%EB%B0%94%EC%9D%B4%ED%8A%B8-%EA%B8%B0%EB%B0%98-stream\" aria-label=\"바이트 기반 stream permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>바이트 기반 Stream</h3>\n<ul>\n<li>바이트를 기반으로 입출력하는 스트림이다. </li>\n<li>FileInputStream(파일), ByteArrayInputStream(메모리), PipeInputStream(프로세스), AudioInputStream(오디오 장치) 등등이 있다. </li>\n</ul>\n<br>\n<h3 id=\"보조-stream\" style=\"position:relative;\"><a href=\"#%EB%B3%B4%EC%A1%B0-stream\" aria-label=\"보조 stream permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>보조 Stream</h3>\n<ul>\n<li>실제로 데이터를 주고받는 스트림이 아니라, 다른 스트림의 기능을 추가적으로 보조하여 새로운 기능을 수행할 수 있도록 해주는 스트림이다. </li>\n<li>생성시 인자로 <code class=\"language-text\">InputStream</code>, <code class=\"language-text\">OutputStream</code> 등을 받기도 한다. </li>\n<li>\n<p>몇가지 예시)</p>\n<ol>\n<li>\n<p>BufferedInputStream / BufferedOutputStream - 버퍼를 이용한 입출력으로 데이터 처리 속도를 높일 수 있다. </p>\n<ul>\n<li>지정되지 않았을 때 기본 버퍼 사이즈는 <code class=\"language-text\">8192</code> 이다.</li>\n</ul>\n</li>\n<li>DataInputStream / DataOutputStream - 자바의 기본 타입으로 데이터를 읽음</li>\n<li>등등</li>\n</ol>\n</li>\n</ul>\n<br>\n<h3 id=\"문자-기반-stream\" style=\"position:relative;\"><a href=\"#%EB%AC%B8%EC%9E%90-%EA%B8%B0%EB%B0%98-stream\" aria-label=\"문자 기반 stream permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>문자 기반 Stream</h3>\n<ul>\n<li>\n<p>Reader, Writer 를 통해서 UTF-8 등등의 인코딩 텍스트를 처리할 수 있다. </p>\n<ul>\n<li>이것은 필터의 일종이다. </li>\n</ul>\n</li>\n<li>이것을 사용하면 데이터를 byte 단위가 아닌, char 단위로 처리할 수 있다. </li>\n<li>대표적으로 자주 사용하는 것이 <code class=\"language-text\">BufferedReader</code>가 있다. </li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">InputStream</span> inputStream <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ByteArrayInputStream</span><span class=\"token punctuation\">(</span>content<span class=\"token punctuation\">.</span><span class=\"token function\">getByte</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">BufferedReader</span> reader <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BufferedReader</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">InputStreamReader</span><span class=\"token punctuation\">(</span>inputStream<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li>또 많이 사용되는 것으로는 <code class=\"language-text\">FileReader</code>, <code class=\"language-text\">CharArrayReader</code>, <code class=\"language-text\">PipedReader</code>, <code class=\"language-text\">StringReader</code> 등등이 있다. (각각 Writer도 있다.)</li>\n</ul>\n<br>\n<br>\n<h2 id=\"inputstream\" style=\"position:relative;\"><a href=\"#inputstream\" aria-label=\"inputstream permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>InputStream</h2>\n<ul>\n<li>\n<p>InputStream 은 <em>프로그램 입장</em>에서 데이터를 읽어드리는 것이다. </p>\n<p align=\"center\"><img width=\"400\" src=\"https://user-images.githubusercontent.com/63405904/130889921-1ef178ae-5fa1-4597-a173-ffa3165cf897.png\"><br>이미지 출처: 오라클 docs</p>\n</li>\n<li>InputStream은 입출력 스트림의 기본 클래스이며 <code class=\"language-text\">read()</code> 메소드를 추상메소드를 지원한다. </li>\n<li><code class=\"language-text\">read()</code>메소드를 적절하게 구현하여 사용허던지, 이미 구현한 하위 기타 InputStream을 활용하면 된다. </li>\n<li>기본적으로 바이트를 읽어드린다. <code class=\"language-text\">read(byte[], int off, int len)</code>, <code class=\"language-text\">read(byte[])</code></li>\n</ul>\n<h4 id=\"바이트를-읽는다는데-왜-반환값은-int일까\" style=\"position:relative;\"><a href=\"#%EB%B0%94%EC%9D%B4%ED%8A%B8%EB%A5%BC-%EC%9D%BD%EB%8A%94%EB%8B%A4%EB%8A%94%EB%8D%B0-%EC%99%9C-%EB%B0%98%ED%99%98%EA%B0%92%EC%9D%80-int%EC%9D%BC%EA%B9%8C\" aria-label=\"바이트를 읽는다는데 왜 반환값은 int일까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>바이트를 읽는다는데 왜 반환값은 int일까?</h4>\n<ul>\n<li>보면 <code class=\"language-text\">InputStream</code>의 overloading 되어 있는 모든 <code class=\"language-text\">read()</code> 메소드의 반환값이 <code class=\"language-text\">int</code> 이다. </li>\n<li>그 이유는 스트림에 있는 데이터를 모두 읽었을 때 <code class=\"language-text\">-1</code> 을 반환하는데 반환값이 byte이면 <code class=\"language-text\">-1</code> 을 반환할 수 없기 때문이다. </li>\n<li>데이터를 읽을 때 우선 0-255 사이의 값을 int로 반환하고, 해당 값을 -128 부터 127 사이의 byte 타입으로 변환한다. </li>\n</ul>\n<br>\n<h3 id=\"inputstream-to-string\" style=\"position:relative;\"><a href=\"#inputstream-to-string\" aria-label=\"inputstream to string permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>InputStream to String</h3>\n<ul>\n<li>여러가지 방법이 있겠지만 가장 간단한 방법은 다음이다. </li>\n<li>InputStream에서 읽은 byte 데이터를 <code class=\"language-text\">new String()</code>을 통해 반환한다. </li>\n<li>\n<p>이때 두번째 인자로 인코딩 타입도 정할 수 있다. </p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">final</span> <span class=\"token class-name\">String</span> data <span class=\"token operator\">=</span> \n<span class=\"token keyword\">new</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">(</span>inputStream<span class=\"token punctuation\">.</span><span class=\"token function\">readAllBytes</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">StandardCharsets</span><span class=\"token punctuation\">.</span>UTF_8<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n</li>\n</ul>\n<br>\n<br>\n<h2 id=\"outputstream\" style=\"position:relative;\"><a href=\"#outputstream\" aria-label=\"outputstream permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>OutputStream</h2>\n<ul>\n<li>다른 매체 (콘솔, 모니터, 파일 등등)에 데이터를 쓸 때 사용되는 출력 스트림이다.\n<p align=\"center\"><img width=\"400\" src=\"https://user-images.githubusercontent.com/63405904/130900408-a052d0ba-0ac3-4818-8fc7-80c17f156d41.png\"><br>이미지 출처: 오라클 docs</p></li>\n<li>\n<p>그냥 <code class=\"language-text\">write()</code>는 바이트 단위로 쓰기 때문에 비효율적이다. <code class=\"language-text\">read()</code>와 마찬가지로 <code class=\"language-text\">write()</code>도 byte[]을 인자로 넣어서 1 바이트 이상을 효율적으로 쓸 수 있다. </p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token function\">write</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">write</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> off<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> len<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<br>\n</li>\n</ul>\n<h3 id=\"code-classlanguage-textbytearrayoutputstreamcode-vs-code-classlanguage-textbufferedoutputstreamcode\" style=\"position:relative;\"><a href=\"#code-classlanguage-textbytearrayoutputstreamcode-vs-code-classlanguage-textbufferedoutputstreamcode\" aria-label=\"code classlanguage textbytearrayoutputstreamcode vs code classlanguage textbufferedoutputstreamcode permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"language-text\">ByteArrayOutputStream</code> vs. <code class=\"language-text\">BufferedOutputStream</code></h3>\n<ul>\n<li><code class=\"language-text\">ByteArrayOutputStream</code>는 메모리에 데이터를 출력하는 스트림이다. </li>\n<li>\n<p><code class=\"language-text\">BufferedOutputStream</code>은 버퍼링 된 출력 스트림을 생성하는 filter stream의 일종으로 생성시 인자로 OutputStream을 받는다. </p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">BufferedOutputStream</span> stream <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BufferedOutputStream</span><span class=\"token punctuation\">(</span>outputStream<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li><code class=\"language-text\">BufferedOutputStream</code>이 직접 출력 스트림에 쓰는 것이 아니라 우선 버퍼에 써서 저장이 되도록 지원하는 것이다. 그렇기 때문에 인자로 출력 스트림을 받아야한다. </li>\n<li>버퍼의 사이즈는 지정할 수 있으며 default 버퍼 사이즈는 <code class=\"language-text\">8192</code>이다.</li>\n<li><code class=\"language-text\">BufferedOutputStream</code>의 <code class=\"language-text\">close()</code>가 호출되면 버퍼에 있는 내용이 출력 스트림에 쓰인다. </li>\n<li>스트림을 닫지 않은 채로 내용을 쓰고 싶다면 <code class=\"language-text\">flush()</code>를 호출하면 된다.  </li>\n</ul>\n</li>\n</ul>\n<h4 id=\"차이점\" style=\"position:relative;\"><a href=\"#%EC%B0%A8%EC%9D%B4%EC%A0%90\" aria-label=\"차이점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>차이점</h4>\n<ul>\n<li><code class=\"language-text\">ByteArrayOutputStream</code>은 unbuffered I/O이고, <code class=\"language-text\">BufferedOutputStream</code>은 buffered I/O 이다.\n<br></li>\n</ul>\n<h4 id=\"왜-buffered-io를-사용할까\" style=\"position:relative;\"><a href=\"#%EC%99%9C-buffered-io%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%A0%EA%B9%8C\" aria-label=\"왜 buffered io를 사용할까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>왜 buffered I/O를 사용할까?</h4>\n<ul>\n<li>unbuffered I/O를 사용한다는 것은 매번 입력 및 출력시 OS에 직접적인 요청이 간다는 것이다. 디스크 접근, 네트워크, 등등의 OS관련 요청이 많아지면서 그 비용으로 인해 프로그램의 효율이 배우 떨어진다. </li>\n<li>\n<p>그것을 해결하기 위해서 자바가 buffered I/O를 지원하도록 했다. </p>\n<ul>\n<li>Buffered input stream은 데이터를 buffer라는 메모리 공간에서 읽고 native input API 는 버퍼가 비었을때만 호출된다.   </li>\n<li>Buffered output stream은 반대로 출력하고자 하는 데이터가 buffer에 가득 찼을 때 native output API가 호출된다.</li>\n</ul>\n</li>\n<li>프로그램은 unbuffered I/O인 입출력 스트림을 buffered 스트림 선언시 인자로 넘겨 버퍼링 되도록 한다. </li>\n<li>바이트 버퍼링을 위해 <code class=\"language-text\">BufferedInputStream</code>, <code class=\"language-text\">BufferedOutputStream</code>이 있다.</li>\n<li>문자 버퍼링을 위해 <code class=\"language-text\">BufferedReader</code>, <code class=\"language-text\">BufferedWriter</code>가 있다.\n<br></li>\n</ul>\n<h4 id=\"code-classlanguage-textflushcode는-언제\" style=\"position:relative;\"><a href=\"#code-classlanguage-textflushcode%EB%8A%94-%EC%96%B8%EC%A0%9C\" aria-label=\"code classlanguage textflushcode는 언제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"language-text\">flush()</code>는 언제?</h4>\n<ul>\n<li>언제 buffer를 비우는지가 중요한 포인트이다. 버퍼를 비우고 target에 입출력을 반영하는 것을 flushing이라고 한다. </li>\n<li>\n<p>어떤 buffered output class들은 autoflush를 지원해서 특정 이벤트 동작시 자동 flush가 되도록 한다. </p>\n<ul>\n<li>예를 들어 <code class=\"language-text\">PrintWriter</code>가 <code class=\"language-text\">println</code>, <code class=\"language-text\">format</code> 등을 기점으로 <code class=\"language-text\">flush</code>를 한다. </li>\n</ul>\n</li>\n<li>버퍼에 있는 내용을 반영하고 싶을 때 수동으로 <code class=\"language-text\">flush()</code>를 호출하면 된다. 참고로 <code class=\"language-text\">flush()</code>는 모든 스트림에 존재하는 메소드이지만 버퍼링을 지원하는 스트림이 아니면 아무 효과가 없다. </li>\n</ul>\n<br>\n<br>\n<br>\n<h2 id=\"file\" style=\"position:relative;\"><a href=\"#file\" aria-label=\"file permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>File</h2>\n<h3 id=\"path-absolute-path-canonical-path\" style=\"position:relative;\"><a href=\"#path-absolute-path-canonical-path\" aria-label=\"path absolute path canonical path permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>path, absolute path, canonical path</h3>\n<ul>\n<li>파일 이름으로 경로를 찾아 해당 파일을 읽는 실습을 하면서 여러 종류의 path가 등장한다. </li>\n<li>path - 가장 기본적인 path로 주로 입력된 경로 그대로이다. </li>\n<li>\n<p>absolute path - 처음 root 부터 절대 경로를 나타낸다. </p>\n<ul>\n<li>solaris의 경우 <code class=\"language-text\">/home/sally/statusReport</code> 이런 형태를 지닌다. </li>\n<li>Windows의 경우 <code class=\"language-text\">C:\\home\\sally\\statusReport</code> 이런 형태를 지닌다. </li>\n<li>\n<p>루트 디렉토리부터 시작하면 절대경로이다. 그러니까 다음 두가지 경우도 모두 절대경로이다. </p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">/home/../home/originfile\n/home/./././originfile</code></pre></div>\n</li>\n</ul>\n</li>\n<li>\n<p>canonical path - 따라서 절대경로이면서 단 하나의 형식으로 유니크하게 표현하는 것이 canoncial path이다. 즉 위의 절대경로를 canonical path로 표현하면 다음과 같이 된다. 모든 파일의 canoncial path는 단 하나이며 같은 리소스일 경우 그 생김새는 항상 같다. </p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"> /home/originfile</code></pre></div>\n<br>\n</li>\n</ul>\n<h3 id=\"java에서-리소스-파일-읽기\" style=\"position:relative;\"><a href=\"#java%EC%97%90%EC%84%9C-%EB%A6%AC%EC%86%8C%EC%8A%A4-%ED%8C%8C%EC%9D%BC-%EC%9D%BD%EA%B8%B0\" aria-label=\"java에서 리소스 파일 읽기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Java에서 리소스 파일 읽기</h3>\n<ul>\n<li>\n<p>Java에서 리소스 파일을 읽을 때는 다음과 같이 하면 된다. </p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">URL</span> resource <span class=\"token operator\">=</span> <span class=\"token function\">getResource</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getClassLoader</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getResource</span><span class=\"token punctuation\">(</span>fileName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Path</span> path <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">File</span><span class=\"token punctuation\">(</span>resource<span class=\"token punctuation\">.</span><span class=\"token function\">getPath</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toPath</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> content <span class=\"token operator\">=</span> <span class=\"token class-name\">Files</span><span class=\"token punctuation\">.</span><span class=\"token function\">readlAllLines</span><span class=\"token punctuation\">(</span>path<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n</li>\n<li>하지만 위와 같이 실행하여 IDE에서 제대로 돌아가더라도 jar로 실행을 시켜보면 리소스를 찾지 못한다는 오류가 발생한다. jar 내부에서 되어있는 파일 구조가 조금 다르기 때문이다. </li>\n<li>\n<p>찾은 해결책은 resource를 inputStream으로 받아서 읽는 것이다. </p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">InputStream</span> in <span class=\"token operator\">=</span> <span class=\"token function\">getClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getResourceAsStream</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/\"</span> <span class=\"token operator\">+</span> fileName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">BufferedReader</span> bufferedReader <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BufferedReader</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">InputStreamReader</span><span class=\"token punctuation\">(</span>in<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token class-name\">String</span> content<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">final</span> <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> actual <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>content <span class=\"token operator\">=</span> bufferedReader<span class=\"token punctuation\">.</span><span class=\"token function\">readLine</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    actual<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>content<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>아직 테스트는 해보지 않았으나 조만한 해볼 예정이다. </li>\n</ul>\n</li>\n</ul>\n<br>\n<br>\n<p><strong>[참고링크]</strong></p>\n<ul>\n<li><a href=\"https://docs.oracle.com/javase/tutorial/essential/io/streams.html\">https://docs.oracle.com/javase/tutorial/essential/io/streams.html</a></li>\n<li><a href=\"http://tcpschool.com/java/java_io_stream\">http://tcpschool.com/java/java<em>io</em>stream</a></li>\n<li><a href=\"https://sgdev.tistory.com/23\">https://sgdev.tistory.com/23</a></li>\n<li><a href=\"https://docs.oracle.com/javase/tutorial/essential/io/buffers.html\">https://docs.oracle.com/javase/tutorial/essential/io/buffers.html</a></li>\n<li><a href=\"https://www.benjaminlog.com/entry/absolute-path-vs-canonical-path\">https://www.benjaminlog.com/entry/absolute-path-vs-canonical-path</a></li>\n<li><a href=\"https://docs.oracle.com/javase/tutorial/essential/io/path.html\">https://docs.oracle.com/javase/tutorial/essential/io/path.html</a></li>\n<li><a href=\"http://daplus.net/java-jar-%EB%82%B4%EC%97%90%EC%84%9C-%EB%A6%AC%EC%86%8C%EC%8A%A4-%ED%8C%8C%EC%9D%BC-%EC%9D%BD%EA%B8%B0/\">http://daplus.net/java-jar-내에서-리소스-파일-읽기/</a></li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#%EC%9E%90%EB%B0%94-io-%EC%8A%A4%ED%8A%B8%EB%A6%BC\">자바 I/O 스트림</a></p>\n<ul>\n<li><a href=\"#%EB%B0%94%EC%9D%B4%ED%8A%B8-%EA%B8%B0%EB%B0%98-stream\">바이트 기반 Stream</a></li>\n<li><a href=\"#%EB%B3%B4%EC%A1%B0-stream\">보조 Stream</a></li>\n<li><a href=\"#%EB%AC%B8%EC%9E%90-%EA%B8%B0%EB%B0%98-stream\">문자 기반 Stream</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#inputstream\">InputStream</a></p>\n<ul>\n<li>\n<ul>\n<li><a href=\"#%EB%B0%94%EC%9D%B4%ED%8A%B8%EB%A5%BC-%EC%9D%BD%EB%8A%94%EB%8B%A4%EB%8A%94%EB%8D%B0-%EC%99%9C-%EB%B0%98%ED%99%98%EA%B0%92%EC%9D%80-int%EC%9D%BC%EA%B9%8C\">바이트를 읽는다는데 왜 반환값은 int일까?</a></li>\n</ul>\n</li>\n<li><a href=\"#inputstream-to-string\">InputStream to String</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#outputstream\">OutputStream</a></p>\n<ul>\n<li>\n<p><a href=\"#bytearrayoutputstream-vs-bufferedoutputstream\"><code class=\"language-text\">ByteArrayOutputStream</code> vs. <code class=\"language-text\">BufferedOutputStream</code></a></p>\n<ul>\n<li><a href=\"#%EC%B0%A8%EC%9D%B4%EC%A0%90\">차이점</a></li>\n<li><a href=\"#%EC%99%9C-buffered-io%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%A0%EA%B9%8C\">왜 buffered I/O를 사용할까?</a></li>\n<li><a href=\"#flush%EB%8A%94-%EC%96%B8%EC%A0%9C\"><code class=\"language-text\">flush()</code>는 언제?</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#file\">File</a></p>\n<ul>\n<li><a href=\"#path-absolute-path-canonical-path\">path, absolute path, canonical path</a></li>\n<li><a href=\"#java%EC%97%90%EC%84%9C-%EB%A6%AC%EC%86%8C%EC%8A%A4-%ED%8C%8C%EC%9D%BC-%EC%9D%BD%EA%B8%B0\">Java에서 리소스 파일 읽기</a></li>\n</ul>\n</li>\n</ul>\n</div>","frontmatter":{"date":"August 26, 2021","title":"Java IOStream 과 파일 입출력","categories":"자바","author":"코다","emoji":"✊"},"fields":{"slug":"/java-iostream-file/"}},"prev":{"id":"9dcfc695-3e64-5efc-9b80-257d69dd5ae2","html":"<h2 id=\"1-intro\" style=\"position:relative;\"><a href=\"#1-intro\" aria-label=\"1 intro permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. INTRO</h2>\n<ul>\n<li>많은 어플리케이션에서 소셜 로그인을 지원하는데, 이때 사용되는 것이 OAuth 2.0 이다. </li>\n<li>\n<p>간단하게 이야기하면 OAuth 2.0 이란 사용자의 정보에 대한 권한을 부여하는 <code class=\"language-text\">산업 표준 프로토콜</code>의 일종이다. </p>\n<blockquote>\n<p>(정의) 제 3의 앱이 자원의 소유자인 서비스 이용자를 대신하여 서비스를 요청할 수 있도록 자원 접근 권한을 위임하는 방법 <br> <em>출처: 금융보안원 “OAuth 2.0 개요 및 보안 고려사항” 보안연구부-2015-030</em></p>\n</blockquote>\n</li>\n<li>즉, 정보 소유자 (서비스 이용자)를 대신하여 앱이 다른 서비스에 등록되어 있는 자원에 대한 접근을 요청하는 권한을 위임한다. </li>\n<li>아래 글은 <a href=\"https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2\">링크</a> 원문을 번역하고 일부 요약한 것이다. </li>\n</ul>\n<br>\n<h2 id=\"2-oauth-주요-개념\" style=\"position:relative;\"><a href=\"#2-oauth-%EC%A3%BC%EC%9A%94-%EA%B0%9C%EB%85%90\" aria-label=\"2 oauth 주요 개념 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. OAuth 주요 개념</h2>\n<ol>\n<li><strong>리소스 소유자</strong> (Resource Owner) - 어플리케이션이 인가 요청을 하는 정보의 소유자이다. 즉, 그 정보를 소유하고 있는 ‘사용자’를 말한다. </li>\n<li><strong>클라이언트</strong> (Client) - 리소스 소유자의 정보를 요청하는 어플리케이션이다. </li>\n<li><strong>리소스 서버</strong> (Resource Server) - 리소스 소유자의 정보를 보유하고 있는 서버이다. </li>\n<li><strong>인가 서버</strong> (Authorization Server) - 클라이언트가 사용자에 대한 정보 권한을 요청할 때, 그 사용자에 대해 검증하고 클라이언트 어플리케이션에 access token을 발급하는 인가 서버이다. 편의상 리소스 서버와 인가 서버를 구별하지 않고 이해해도 좋다. </li>\n</ol>\n<br> \n<h2 id=\"3-간단히-보는-oauth-프로토콜-흐름\" style=\"position:relative;\"><a href=\"#3-%EA%B0%84%EB%8B%A8%ED%9E%88-%EB%B3%B4%EB%8A%94-oauth-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-%ED%9D%90%EB%A6%84\" aria-label=\"3 간단히 보는 oauth 프로토콜 흐름 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 간단히 보는 OAuth 프로토콜 흐름</h2>\n<p align=\"center\"><img width=\"540\" alt=\"스크린샷 2021-08-17 오후 2 41 53\" src=\"https://user-images.githubusercontent.com/63405904/129669922-d91d3405-3315-4b29-9e47-f8015dec6b13.png\">출처 : Digital Ocean의 An Introduction to OAuth 2.0</p>\n<br>\n<ol>\n<li>어플리케이션 유저에게 리소스에 대한 인가를 요청한다. </li>\n<li>유저는 해당 인가를 승인한다. </li>\n<li>어플리케이션은 리소스를 보유하고 있는 인가 서버에 access token을 요청한다. </li>\n<li>본 어플리케이션이 인증이 되고, 인가 승인을 인증하면 인가 서버는 해당 어플리케이션에 access token을 발급하고 인가 절차가 마무리된다. </li>\n<li>인가를 받은 어플리케이션은 리소스 서버에 access token과 함께 리소스를 요청한다.</li>\n<li>리소스 서버에서 access token을 확인하면 해당 리소스를 어플리케이션에 제공한다. </li>\n</ol>\n<br>\n<h2 id=\"4-어플리케이션-등록\" style=\"position:relative;\"><a href=\"#4-%EC%96%B4%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EB%93%B1%EB%A1%9D\" aria-label=\"4 어플리케이션 등록 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. 어플리케이션 등록</h2>\n<ul>\n<li>OAuth 기능을 추가하기 이전 본 어플리케이션(클라이언트)를 리소스를 요청하고자 하는 제 3 서비스(Google, Kakao, Github 등등)에 등록해야한다. </li>\n<li>\n<p>등록 정보 </p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">- 어플리케이션 이름\n- 어플리케이션 웹사이트\n- Redirect URI or Callback URL</code></pre></div>\n</li>\n<li>위에서 리다이렉트 URI는 인가 후, 인가 서버(리소스 서버)에서 code를 전송해줄 주소를 말한다. </li>\n</ul>\n<br>\n<ul>\n<li>\n<p>어플리케이션 등록 시 다음 정보를 발급 받는다. 다음은 <code class=\"language-text\">Client Credentials</code>이라고 도 한다. </p>\n<ol>\n<li>Client Id - 외부에 노출되는 어플리케이션 identity 이다.</li>\n<li>Client Secret - 외부에 공개되어서는 안되는 key로 어플리케이션을 인증하고 유저의 계정에 접근을 요청할 때 사용한다. (Access Token 발급 시)</li>\n</ol>\n</li>\n</ul>\n<br>\n<h2 id=\"5-authorization-부여하기\" style=\"position:relative;\"><a href=\"#5-authorization-%EB%B6%80%EC%97%AC%ED%95%98%EA%B8%B0\" aria-label=\"5 authorization 부여하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5. Authorization 부여하기</h2>\n<ul>\n<li>\n<p>OAuth 2.0은 3가지 종류로 인가를 부여한다. </p>\n<ol>\n<li>Authorization Code</li>\n<li>Client Credentials</li>\n<li>Device Code</li>\n</ol>\n</li>\n<li>위 3가지 중 이번 프로젝트에서는 <code class=\"language-text\">Authorization Code</code>를 사용했다. <code class=\"language-text\">Authorization Code</code>가 가장 빈번하게 사용이 되는데 server-side applications에 가장 최적화 되어 있기 때문이다. </li>\n<li>아래가 <code class=\"language-text\">Authorization Code</code>를 발급받는 기본 흐름인데, 보면 어플리케이션이 user-agent(유저의 웹 브라우저)와 소통할 수 있어야 하며 user-agent를 통해 라우팅 된 API authorization 코드를 받을 수 있어야 한다. </li>\n</ul>\n<p align=\"center\"><img width=\"688\" alt=\"스크린샷 2021-08-17 오후 4 08 28\" src=\"https://user-images.githubusercontent.com/63405904/129680013-50c21f7f-e1a2-4bb7-89fc-361450ef6c3e.png\">출처 : Digital Ocean의 An Introduction to OAuth 2.0</p>\n<ol>\n<li>\n<p>리소스를 요청하고자 하는 서버에 기재되어 있는 API authorization endpoint URI 에 1) client<em>id 2) redirect</em>uri 3) response_type 4) scope 등을 지정해서 요청을 보낸다. </p>\n<ul>\n<li>본인은 프로젝트에서 Github 소셜 로그인을 구현했었는데 <code class=\"language-text\">https://github.com/login/oauth/authorize?client_id=%s&amp;redirect_uri=%s&amp;scope=%s</code> 로 유저 인가 request를 보내도록 되어 있었다. </li>\n</ul>\n</li>\n<li>그럼 해당 리소스 서버(Github 등)에서 인가를 허가할지 말지 여부를 물어보는 페이지로 이동하여 유저가 허가 또는 거절을 누른다. </li>\n<li>유저가 허가한다면 리소스 서버(인가 서버)는 user-agent(브라우저)가  어플리케이션 등록 시 기재한 redirect URI로 authorization code와 함께 리다이렉트 하도록 한다. </li>\n<li>어플리케이션은 리소스 서버(인가 서버)에 1) client<em>id 2) client</em>secrete 3) grant<em>type 4) code 5) redirect</em>uri 와 함께 Access Token 발급 request를 보낸다. </li>\n<li>리소스 서버(인가 서버)에서 요청을 검사하고 유효하다면 AccessToken을 반환한다.\n<code class=\"language-text\">{\"access_token\":\"ACCESS_TOKEN\",\"token_type\":\"bearer\",\"expires_in\":2592000,\"refresh_token\":\"REFRESH_TOKEN\",\"scope\":\"read\",\"uid\":100101,\"info\":{\"name\":\"developer_coda\",\"email\":\"coda@coda.com\"}}</code></li>\n</ol>\n<br> \n<h2 id=\"6-access-token-활용하기\" style=\"position:relative;\"><a href=\"#6-access-token-%ED%99%9C%EC%9A%A9%ED%95%98%EA%B8%B0\" aria-label=\"6 access token 활용하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>6. Access Token 활용하기</h2>\n<ul>\n<li>이후 어플리케이션은 리소스 서버에 원하는 정보 또는 행위를 요청할 때 헤더에 access token을 담아서 요청하도록 한다. </li>\n<li>Access token을 어플리케이션에 어떻게 관리할지는 내부 논의 후 정해서 저장하면 된다. (Redis, JWT 등등 이 있다.)</li>\n<li>본인은 프로젝트에서 JWT 토큰의 value로 저장하고 유저에게 JWT 토큰을 반환했다. </li>\n</ul>\n<br>\n<h2 id=\"7-전체적인-흐름도\" style=\"position:relative;\"><a href=\"#7-%EC%A0%84%EC%B2%B4%EC%A0%81%EC%9D%B8-%ED%9D%90%EB%A6%84%EB%8F%84\" aria-label=\"7 전체적인 흐름도 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>7. 전체적인 흐름도</h2>\n<p align=\"center\"><img width=\"700\" alt=\"스크린샷 2021-08-17 오후 4 44 00\" src=\"https://user-images.githubusercontent.com/63405904/129685067-5d0bbbdc-0224-42e8-bed4-fe984cb036ec.png\">출처 : NHN Cloud - OAuth 2.0 대표 취약점과 보안 고려 사항 알아보기</p>\n<br>\n<h2 id=\"8-번외-oauth의-대표-취약점\" style=\"position:relative;\"><a href=\"#8-%EB%B2%88%EC%99%B8-oauth%EC%9D%98-%EB%8C%80%ED%91%9C-%EC%B7%A8%EC%95%BD%EC%A0%90\" aria-label=\"8 번외 oauth의 대표 취약점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>8. 번외) OAuth의 대표 취약점</h2>\n<h3 id=\"81-csrfcross-site-request-forgery-공격\" style=\"position:relative;\"><a href=\"#81-csrfcross-site-request-forgery-%EA%B3%B5%EA%B2%A9\" aria-label=\"81 csrfcross site request forgery 공격 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>8.1. CSRF(Cross Site Request Forgery) 공격</h3>\n<ul>\n<li>OAuth 인증 진행 시, 발급받은 <code class=\"language-text\">Authorization Code</code>와 이전에 발급받은 <code class=\"language-text\">client_secret</code>을 함께 보내어 리소스 서버에 Access Token을 요청하는 단계가 있다. </li>\n<li><code class=\"language-text\">client_secret</code>은 CSRF token과 같은 역할을 해서 중간에 CSRF 공격을 예방하는 역할을 하는데, 만일 이것에 대한 검증이 누락되거나 취약하면 CSRF 공격에 의해 Authorization Code가 탈취되어 사용자의 계정이 노출될 수 있다.</li>\n<li><code class=\"language-text\">client_secret</code>에 대한 검증이 필요하다. </li>\n</ul>\n<br>\n<h3 id=\"82-convert-redirect\" style=\"position:relative;\"><a href=\"#82-convert-redirect\" aria-label=\"82 convert redirect permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>8.2. Convert Redirect</h3>\n<ul>\n<li>유저가 로그인한 후 인가를 승인하고 Authorization Code에 대해서 발급할 때 리다이렉트 되는 redirect_uri에 대한 검증이 안될 경우 공격자가 해당 공격 서버의 uri로 대체하여 Authorization Token을 탈취할 수 있다. </li>\n<li>Redirect URI에 대한 Full path 검증을 진행해야한다. </li>\n</ul>\n<br>\n<br>\n<p><strong>[출처]</strong> </p>\n<ul>\n<li><a href=\"https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2\">https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2</a></li>\n<li><a href=\"https://meetup.toast.com/posts/105\">https://meetup.toast.com/posts/105</a></li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#1-intro\">1. INTRO</a></li>\n<li><a href=\"#2-oauth-%EC%A3%BC%EC%9A%94-%EA%B0%9C%EB%85%90\">2. OAuth 주요 개념</a></li>\n<li><a href=\"#3-%EA%B0%84%EB%8B%A8%ED%9E%88-%EB%B3%B4%EB%8A%94-oauth-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-%ED%9D%90%EB%A6%84\">3. 간단히 보는 OAuth 프로토콜 흐름</a></li>\n<li><a href=\"#4-%EC%96%B4%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EB%93%B1%EB%A1%9D\">4. 어플리케이션 등록</a></li>\n<li><a href=\"#5-authorization-%EB%B6%80%EC%97%AC%ED%95%98%EA%B8%B0\">5. Authorization 부여하기</a></li>\n<li><a href=\"#6-access-token-%ED%99%9C%EC%9A%A9%ED%95%98%EA%B8%B0\">6. Access Token 활용하기</a></li>\n<li><a href=\"#7-%EC%A0%84%EC%B2%B4%EC%A0%81%EC%9D%B8-%ED%9D%90%EB%A6%84%EB%8F%84\">7. 전체적인 흐름도</a></li>\n<li>\n<p><a href=\"#8-%EB%B2%88%EC%99%B8-oauth%EC%9D%98-%EB%8C%80%ED%91%9C-%EC%B7%A8%EC%95%BD%EC%A0%90\">8. 번외) OAuth의 대표 취약점</a></p>\n<ul>\n<li><a href=\"#81-csrfcross-site-request-forgery-%EA%B3%B5%EA%B2%A9\">8.1. CSRF(Cross Site Request Forgery) 공격</a></li>\n<li><a href=\"#82-convert-redirect\">8.2. Convert Redirect</a></li>\n</ul>\n</li>\n</ul>\n</div>","frontmatter":{"date":"September 03, 2021","title":"OAuth 알아보기","categories":"웹","author":"코다","emoji":"🖥"},"fields":{"slug":"/oauth/"}},"site":{"siteMetadata":{"siteUrl":"https://yjksw.github.io","comments":{"utterances":{"repo":"yjksw/yjksw.github.io"}}}}},"pageContext":{"slug":"/cdn/","nextSlug":"/java-iostream-file/","prevSlug":"/oauth/"}},"staticQueryHashes":["1073350324","2938748437"]}
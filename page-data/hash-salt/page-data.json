{"componentChunkName":"component---src-templates-blog-template-js","path":"/hash-salt/","result":{"data":{"cur":{"id":"89cc4854-91bf-5d0c-abe5-c82fe6e01006","html":"<h2 id=\"들어가기-전에\" style=\"position:relative;\"><a href=\"#%EB%93%A4%EC%96%B4%EA%B0%80%EA%B8%B0-%EC%A0%84%EC%97%90\" aria-label=\"들어가기 전에 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>들어가기 전에</h2>\n<p>암호화(Encryption)과 해싱은 다른 개념</p>\n<ul>\n<li>암호화 - 양방향이므로 복호화가 가능</li>\n<li>해싱 - 단방향이므로 복호화가 불가능</li>\n</ul>\n<br>\n<h2 id=\"단방향-해시-함수-one-way-hash-function\" style=\"position:relative;\"><a href=\"#%EB%8B%A8%EB%B0%A9%ED%96%A5-%ED%95%B4%EC%8B%9C-%ED%95%A8%EC%88%98-one-way-hash-function\" aria-label=\"단방향 해시 함수 one way hash function permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>단방향 해시 함수 (One-Way Hash Function)</h2>\n<p>기본적으로 패스워드 등의 보안의 문제가 걸린 정보를 DB에 저장할 때 평문으로 저장하지 않고 해싱한 값을 저장한다. (평문으로 저장할 경우 DB가 해킹되었을 때 심각한 문제가 발생한다) <br></p>\n<p>단방향 해시 함수를 사용해서 원본 내용을 완전히 새로운 내용으로 <strong>다이제스트</strong>(<strong>digest</strong>)로 매핑한다. 이때 매핑하는 것을 <strong>해시</strong>라고 한다. 이것은 단방향이므로 복호화할 수 없다. <br></p>\n<p align=\"center\"><img width=\"90%\" src=\"https://user-images.githubusercontent.com/63405904/135313771-acb38bc5-e482-41a0-a0b8-2a7415bd2903.png\"></p>\n<ul>\n<li>\n<p>해시 함수 종류</p>\n<ol>\n<li>SHA</li>\n<li>MD</li>\n<li>HAS</li>\n<li>WHIRLPOOL</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"한계점\" style=\"position:relative;\"><a href=\"#%ED%95%9C%EA%B3%84%EC%A0%90\" aria-label=\"한계점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>한계점</h3>\n<ul>\n<li>\n<p>Rainbow Table</p>\n<p>동일한 데이터를 동일한 해시 함수로 연산한 <strong>다이제스트</strong>는 동일한 값을 가진다. 따라서 여러 값들에 대한 다이제스트를 모아놓은 <strong>Rainbow Table</strong>이라는 것이 존재하고 이것을 통해서 원본 데이터를 유추할 수 있다. </p>\n</li>\n<li>\n<p>Brute-force</p>\n<p>해싱 자체가 빠른 검색을 하기 때문에 반대로 다이제스트를 얻는 과정도 빠르게 실행된다. 무작위 데이터를 대입하여 다이제스트를 비교(해싱이므로 더 빠르게 수행됨)하여 원본 데이터를 유추할 수 있다. </p>\n</li>\n</ul>\n<br>\n<h2 id=\"단방향-해시-함수-보완\" style=\"position:relative;\"><a href=\"#%EB%8B%A8%EB%B0%A9%ED%96%A5-%ED%95%B4%EC%8B%9C-%ED%95%A8%EC%88%98-%EB%B3%B4%EC%99%84\" aria-label=\"단방향 해시 함수 보완 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>단방향 해시 함수 보완</h2>\n<h3 id=\"key-stretching\" style=\"position:relative;\"><a href=\"#key-stretching\" aria-label=\"key stretching permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Key Stretching</h3>\n<p>n번의 해시를 통해서 다이제스트의 다이제스트를 얻어내어 해커 입장에서 원문 데이터를 얻는데 시간을 더 오래 소요하게 한다. (Brute-force 무력화) <br></p>\n<p align=\"center\"><img width=\"90%\" src=\"https://user-images.githubusercontent.com/63405904/135314064-923f6f7a-d9bf-4987-9996-05c371b77aa9.png\"></p>\n<h3 id=\"salt\" style=\"position:relative;\"><a href=\"#salt\" aria-label=\"salt permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Salt</h3>\n<p>원본 데이터에 임의의 문자열을 덧붙여서 해싱을 해서 다이제스트를 얻어내는 방법이다. 따라서 다이제스트의 원문을 알아낸다고 하더라도 사용자가 입력한 원본 password를 알아내는 것은 어려워진다. <br></p>\n<p align=\"center\"><img width=\"90%\" src=\"https://user-images.githubusercontent.com/63405904/135314140-e59783ad-2587-4ba2-98d0-32763bb66f49.png\"></p>\n<p>위 두가지 방법을 모두 사용하여 다이제스트에 대한 보안성을 더 높인다. <br></p>\n<p align=\"center\"><img width=\"90%\" src=\"https://user-images.githubusercontent.com/63405904/135314236-2f313ce8-33aa-4c3a-9c39-2ec9fb18ea45.png\"></p>\n<br>\n<h2 id=\"간단하게-구현해보기\" style=\"position:relative;\"><a href=\"#%EA%B0%84%EB%8B%A8%ED%95%98%EA%B2%8C-%EA%B5%AC%ED%98%84%ED%95%B4%EB%B3%B4%EA%B8%B0\" aria-label=\"간단하게 구현해보기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>간단하게 구현해보기</h2>\n<ol>\n<li>\n<p>SALT 크기를 지정</p>\n<p>너무 짧으면 안전하지 않다. <br></p>\n<p>랜덤 함수를 하용해 SALT를 생성하는 것이 좋으나, <code class=\"language-text\">java.util.Random</code> 은 암호학적으로 안전하지 않아서<code class=\"language-text\">java.security.SecureRandom</code>을 사용한다.</p>\n</li>\n<li>해시 함수를 쓰기 위해서 <code class=\"language-text\">java.security.MessageDigest</code> 외부 라이브러리를 Import 한다. (이외의 다른 라이브러리도 존재한다)</li>\n<li>랜덤 함수를 통해서 SALT를 얻어 사용자 입력 password에 덧붙인다.</li>\n<li><code class=\"language-text\">MessageDigest</code> 라이브러리의 <code class=\"language-text\">update()</code>를 통해서 문자열을 해싱하여 해당 라이브러리에 저장한다. </li>\n<li><code class=\"language-text\">MessageDigest</code> 라이브러리의 <code class=\"language-text\">digest()</code> 를 통해서 다이제스트를 얻는다. </li>\n</ol>\n<br>\n<br>\n<p><strong>[참고링크]</strong></p>\n<ul>\n<li><a href=\"https://st-lab.tistory.com/100\">https://st-lab.tistory.com/100</a></li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#%EB%93%A4%EC%96%B4%EA%B0%80%EA%B8%B0-%EC%A0%84%EC%97%90\">들어가기 전에</a></li>\n<li>\n<p><a href=\"#%EB%8B%A8%EB%B0%A9%ED%96%A5-%ED%95%B4%EC%8B%9C-%ED%95%A8%EC%88%98-one-way-hash-function\">단방향 해시 함수 (One-Way Hash Function)</a></p>\n<ul>\n<li><a href=\"#%ED%95%9C%EA%B3%84%EC%A0%90\">한계점</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EB%8B%A8%EB%B0%A9%ED%96%A5-%ED%95%B4%EC%8B%9C-%ED%95%A8%EC%88%98-%EB%B3%B4%EC%99%84\">단방향 해시 함수 보완</a></p>\n<ul>\n<li><a href=\"#key-stretching\">Key Stretching</a></li>\n<li><a href=\"#salt\">Salt</a></li>\n</ul>\n</li>\n<li><a href=\"#%EA%B0%84%EB%8B%A8%ED%95%98%EA%B2%8C-%EA%B5%AC%ED%98%84%ED%95%B4%EB%B3%B4%EA%B8%B0\">간단하게 구현해보기</a></li>\n</ul>\n</div>","excerpt":"들어가기 전에 암호화(Encryption)과 해싱은 다른 개념 암호화 - 양방향이므로 복호화가 가능 해싱 - 단방향이므로 복호화가 불가능 단방향 해시 함수 (One-Way Hash Function) 기본적으로 패스워드 등의 보안의 문제가 걸린 정보를 DB에 저장할 때 평문으로 저장하지 않고 해싱한 값을 저장한다. (평문으로 저장할 경우 DB가 해킹되었을 때 심각한 문제가 발생한다)  단방향 해시 함수를 사용해서 원본 내용을 완전히 새로운 내용으로 다이제스트(digest)로 매핑한다. 이때 매핑하는 것을 해시라고 한다. 이것은 단방향이므로 복호화할 수 없다.  해시 함수 종류 SHA MD HAS WHIRLPOOL 한계점 Rainbow Table 동일한 데이터를 동일한 해시 함수로 연산한 다이제스트는 동일한 값을 가진다. 따라서 여러 값들에 대한 다이제스트를 모아놓은 Rainbow Table이라는 것이 존재하고 이것을 통해서 원본 데이터를 유추할 수 있다.  Brute-force 해싱…","frontmatter":{"date":"June 21, 2021","title":"Hash와 Salt","categories":"웹 자바","author":"코다","emoji":"🖥"},"fields":{"slug":"/hash-salt/"}},"next":{"id":"2696e70c-e746-5fb0-96cc-3b651a5c3483","html":"<h2 id=\"requestbody\" style=\"position:relative;\"><a href=\"#requestbody\" aria-label=\"requestbody permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>@RequestBody</h2>\n<p>request body를 method argument로 바꿀 때 <code class=\"language-text\">HttpMessageConverter</code>를 사용한다.</p>\n<ul>\n<li><code class=\"language-text\">HttpMessageConverter</code> 는 두가지를 담당한다. 첫번째는 Http request message를 객체로 변환하는 것, 두번째는 객체를 Http response body로 변환하는 작업이다.</li>\n</ul>\n<h3 id=\"동작원리\" style=\"position:relative;\"><a href=\"#%EB%8F%99%EC%9E%91%EC%9B%90%EB%A6%AC\" aria-label=\"동작원리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>동작원리</h3>\n<p><code class=\"language-text\">DispatcherServlet</code>에 의해서 호출되는 handler의 method parameters은 스프링의 <code class=\"language-text\">HandlerMethodArgumentResolver</code>에 의해 생성이 되고, handler의 return value는 <code class=\"language-text\">HandlerMethodReturnValueHandler</code>에 의해서 처리된다. <code class=\"language-text\">@ResponseBody</code>와 <code class=\"language-text\">@RequestBody</code>를 다루는 구현체는 <code class=\"language-text\">RequestResponseBodyMethodProcess</code>이다. </p>\n<ul>\n<li>\n<p>DispatcherServlet의 handle에서부터 Argument resolve 하는 과정</p>\n<p><code class=\"language-text\">DispatcherServlet#handle()</code> → <code class=\"language-text\">AbstractHandlerMethodAdapter#handle()</code> → <code class=\"language-text\">RequestMappingHandlerAdapter#handleInternal()</code> → <code class=\"language-text\">RequestMappingHandlerAdapter#invokeHandlerMethod()</code> → <code class=\"language-text\">ServletInvocableHandlerMethod#invokeAndHandle()</code> → <code class=\"language-text\">InvocableHandlerMethod#invokeForRequest()</code> → <code class=\"language-text\">InvocableHandlerMethod #getMethodArgumentValues()</code> → <em>(Interface)</em><code class=\"language-text\">HandlerMethodArgumentResolver#resolveArgument()</code> → <em>(Imp)</em><code class=\"language-text\">RequestResponseBodyMethodProcessor#resolveArgument()</code></p>\n</li>\n<li>\n<p><code class=\"language-text\">RequestResponseBodyMethodProcessor#resolveArgument()</code> 내부에서 HttpMessageConverter를 사용해서 변환시키는 과정</p>\n<p><code class=\"language-text\">RequestResponseBodyMethodProcessor#resolveArgument()</code> → (e<em>xtends  AbstractMessageConverterMethodArgumentResolver</em>)<code class=\"language-text\">RequestResponseBodyMethodProcessor#readWithMessageConverters()</code> → (<em>Imp HandlerMethodArgumentResolver</em>)<code class=\"language-text\">AbstractMessageConverterMethodArgumentResolver#readWithMessageConverters()</code> 에서 변환 로직을 시행한다. </p>\n</li>\n</ul>\n<p>이때 HttpMessageConverter default 인스턴스들은 <code class=\"language-text\">WebMvcConfigurationSupport#addDefaultHttpMessageConverters()</code> 를 통해 등록된다. </p>\n<h3 id=\"httpmessageconverter-로직\" style=\"position:relative;\"><a href=\"#httpmessageconverter-%EB%A1%9C%EC%A7%81\" aria-label=\"httpmessageconverter 로직 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>HttpMessageConverter 로직</h3>\n<ul>\n<li>\n<p><code class=\"language-text\">@RequestBody</code> 일때</p>\n<p><code class=\"language-text\">HttpMessageConverter#canRead()</code> 로 converter가 해당 content의 인스턴스를 읽고 생성할 수 있는지 확인한다. 이후에 argument를 생성하여 반환한다. </p>\n</li>\n<li>\n<p><code class=\"language-text\">@ResponseBody</code> 일때</p>\n<p><code class=\"language-text\">HttpMessageConverter#canWrite()</code> 를 통해서 <code class=\"language-text\">HttpMessageConverter</code>가 해당 반환값을 serialize 할 수 있는지 확인하고 response content를 생성하고, <code class=\"language-text\">Accept</code> 헤더가 있다면 해당 content-type에 매칭되는지도 확인한다. </p>\n</li>\n</ul>\n<p><code class=\"language-text\">MessagConverter</code>를 사용하는 <code class=\"language-text\">@RequestBody</code>는 값을 바인딩하는 것이 아니라, 해당 내용을 Java Object로 변환한다. 그렇기 때문에 Body가 존재하지 않은 <code class=\"language-text\">GET</code> 메서드에 <code class=\"language-text\">@RequestBody</code>를 적용하려고 하면 예외가 발생한다. </p>\n<h3 id=\"4가지-default-messageconverters\" style=\"position:relative;\"><a href=\"#4%EA%B0%80%EC%A7%80-default-messageconverters\" aria-label=\"4가지 default messageconverters permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4가지 Default MessageConverters</h3>\n<ol>\n<li>\n<p><code class=\"language-text\">ByteArrayHttpMessageConverter</code></p>\n<p><code class=\"language-text\">byte[]</code> 오브젝트 타입을 지원하여 들어오는 요청을 모두 바이트 배열로 받을 수 있다. 또한 리턴 타입이 <code class=\"language-text\">byte[]</code> 일 경우 <code class=\"language-text\">Content-type</code>이 <code class=\"language-text\">applcation/octet-stream</code>으로 설정된다. </p>\n</li>\n<li>\n<p><code class=\"language-text\">StringHttpMessageConverter</code></p>\n<p><code class=\"language-text\">String</code> 오브젝트 타입을 지원하여 HTTP 본문을 그대로 <code class=\"language-text\">String</code>으로 가져오고, 그대로 리턴할 경우 <code class=\"language-text\">Content-type</code>은 <code class=\"language-text\">text/plain</code>으로 전달된다. </p>\n</li>\n<li>\n<p><code class=\"language-text\">FormHttpMessageConverter</code></p>\n<p>MultiValueMap&#x3C;String, String>을 지원하는데, 지원하는 미디어 타입은 <code class=\"language-text\">application/x-www-form-urlencoded</code>이다. 하지만 form 데이터의 경우 <code class=\"language-text\">@ModelAttribute</code>가 더 유용하다. </p>\n</li>\n<li>\n<p><code class=\"language-text\">SourceHttpMessageConverter</code></p>\n<p>XML 문서를 Source 타입 객체로 변환하고 싶을 때 사용하지만 요즘에는 잘 쓰이지 않는다. </p>\n</li>\n</ol>\n<h3 id=\"자주-쓰이는-messageconverters-3가지\" style=\"position:relative;\"><a href=\"#%EC%9E%90%EC%A3%BC-%EC%93%B0%EC%9D%B4%EB%8A%94-messageconverters-3%EA%B0%80%EC%A7%80\" aria-label=\"자주 쓰이는 messageconverters 3가지 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>자주 쓰이는 MessageConverters 3가지</h3>\n<ol>\n<li>\n<p><code class=\"language-text\">Jaxb2RootElementHttpMessageConverter</code></p>\n<p>JAXB의 @XmlRootElement와 @XmlType이 붙은 클래스로 XML과 오브젝트 사이의 변환을 해준다. </p>\n</li>\n<li>\n<p><code class=\"language-text\">MashallingHttpMessageConverter</code></p>\n<p>스프링 OXM 추상화 <code class=\"language-text\">Mashaller</code>와 <code class=\"language-text\">Unmarshaller</code>를 이용해서 <code class=\"language-text\">XML</code>과 오브젝트 사이의 변환을 해준다. </p>\n</li>\n<li>\n<p><code class=\"language-text\">MappingJacksonHttpMessageConverter</code></p>\n<p><code class=\"language-text\">Jackson</code>의 <code class=\"language-text\">ObjectMapper</code>를 사용해서 <code class=\"language-text\">JSON</code>과 오브젝트 사이의 변환을 해주고 지원하는 미디어타입은 <code class=\"language-text\">application/json</code>이다.</p>\n</li>\n<li>참고링크: <a href=\"https://joont92.github.io/spring/MessageConverter/\">https://joont92.github.io/spring/MessageConverter/</a></li>\n</ol>\n<br>\n<h2 id=\"modelattribute\" style=\"position:relative;\"><a href=\"#modelattribute\" aria-label=\"modelattribute permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>@ModelAttribute</h2>\n<p>흔히 <code class=\"language-text\">@ModelAttribute</code>를 들어온 요청에 대해서 method parameter를 매핑시키는 용도로만 알고 있는데, 이외에 return value를 지정된 model attribute로 바인딩하고 웹 뷰에 표현하는 작업도 담당한다. <br></p>\n<p>따라서 <code class=\"language-text\">@ModelAttribute</code>는 두 가지 level에서 사용되는데 <strong>1) method parameter</strong>와 <strong>2) method level</strong>이다. <br></p>\n<p>일반적으로 <code class=\"language-text\">@ModelAttribute</code>는 form data에 사용이 되는데, 이때 value 속성의 값을 함께 넘겨준다. <br></p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token namespace\">form:</span>form</span> <span class=\"token attr-name\">method</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>POST<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">action</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>/spring-mvc-basics/addEmployee<span class=\"token punctuation\">\"</span></span> \n  <span class=\"token attr-name\">modelAttribute</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>employee<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token namespace\">form:</span>label</span> <span class=\"token attr-name\">path</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>name<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>Name<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span><span class=\"token namespace\">form:</span>label</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token namespace\">form:</span>input</span> <span class=\"token attr-name\">path</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>name<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span>\n    \n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token namespace\">form:</span>label</span> <span class=\"token attr-name\">path</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>id<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>Id<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span><span class=\"token namespace\">form:</span>label</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token namespace\">form:</span>input</span> <span class=\"token attr-name\">path</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>id<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span>\n    \n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>input</span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>submit<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">value</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>Submit<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span><span class=\"token namespace\">form:</span>form</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p>하지만 만일 <code class=\"language-text\">value</code> 속성이 함께 제공되지 않았다면 default로 Method level에 적용되는 <code class=\"language-text\">@ModelAttribute</code>에게는 반환 타입이, Method-argument에는 parameter 타입이  지정된다. </p>\n<h3 id=\"at-method-level\" style=\"position:relative;\"><a href=\"#at-method-level\" aria-label=\"at method level permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>At Method Level</h3>\n<p>Method level에서 <code class=\"language-text\">@ModelAttribute</code>이 추가되어 있다면 해당 메서드는 Model에 하나 또는 여러개의 속성(attribute)을 추가한다는 것을 의미한다. <code class=\"language-text\">@RequestMapping</code> 어노테이션이 붙어있는 메서드와 마찬가지로 같은 argument(Model mode)을 제공하는것은 동일하지만, 들어오는 request에 직접적으로 매핑되지는 않는다. </p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token comment\">//하나의 model attribute를 추가할 때</span>\n<span class=\"token annotation punctuation\">@ModelAttribute</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">addAccount</span><span class=\"token punctuation\">(</span><span class=\"token annotation punctuation\">@RequestParam</span> <span class=\"token class-name\">String</span> number<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">return</span> accountManager<span class=\"token punctuation\">.</span><span class=\"token function\">findAccount</span><span class=\"token punctuation\">(</span>number<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">//하나 이상의 model attributes를 추가할 때 </span>\n<span class=\"token annotation punctuation\">@ModelAttribute</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">addAttributes</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Model</span> model<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\tmodel<span class=\"token punctuation\">.</span><span class=\"token function\">addAttribute</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"msg\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Welcome to the Netherlands\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\tmodel<span class=\"token punctuation\">.</span><span class=\"token function\">addAttribute</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"name\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"This is name\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>일반적으로 Spring MVC는 위 메서드를 request handler를 호출하기 이전에 우선적으로 호출한다.  <br></p>\n<p><strong>!!! <code class=\"language-text\">@ModelAttribute</code> 메서드들이 controller에서 <code class=\"language-text\">@RequestMapping</code>으로 지정된 메서드들 보다 먼저 실행된다는 것이다. (같은 controller에 있는 경우)</strong> <br></p>\n<p>만일 global하게 들어오는 모든 요청에 대해서 특정 model attribute을 추가하고 싶다면, 해당 controller를 <code class=\"language-text\">@ControllerAdvice</code>을 지정하는 것이 좋다. <br></p>\n<p>일반적으로 method level의 <code class=\"language-text\">@ModelAttribute</code>의 목적은 하나 또는 하나 이상의 model attributes를 추가하기 위해서이다. Controller는 여러개의 <code class=\"language-text\">@MethodAttribute</code> 메소드들을 가지고 있을 수 있는데, 그 어떤 요청이 들어오면 같은 controller 안에 있는 그 모든 메소드들이 실행된다. 전역적으로 실행하고 싶다면 <code class=\"language-text\">@ControllerAdvice</code> 어노테이션을 추가하면 된다. <br></p>\n<h3 id=\"at-method-argument\" style=\"position:relative;\"><a href=\"#at-method-argument\" aria-label=\"at method argument permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>At Method Argument</h3>\n<p>만일 method argument 레벨에서 <code class=\"language-text\">@ModelAttribute</code>가 사용된다면 model 에서 인자가 추출되어야 한다는 것을 의미한다. </p>\n<blockquote>\n<p>“An @ModelAttribute on a method argument indicates the argument should be retrieved from the model. If not present in the model, the argument should be instantiated first and then added to the model.”</p>\n</blockquote>\n<p>즉, Method Argument 레벨에서 <code class=\"language-text\">@ModelAttribute</code>를 사용하면, 우선 model에 해당 attribute가 있는지 확인하여 반환하고, 없다면 <strong>1) arguments를 초기화</strong> <strong>2)model에 추가</strong>한다. </p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@RequestMapping</span><span class=\"token punctuation\">(</span>value<span class=\"token operator\">=</span><span class=\"token string\">\"/owners/{ownerId}/pets/{petId}/edit\"</span><span class=\"token punctuation\">,</span> method <span class=\"token operator\">=</span> <span class=\"token class-name\">RequestMethod</span><span class=\"token punctuation\">.</span>POST<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">processSubmit</span><span class=\"token punctuation\">(</span><span class=\"token annotation punctuation\">@ModelAttribute</span> <span class=\"token class-name\">Pet</span> pet<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위와 같이 Method Argument에서 <code class=\"language-text\">@ModelAttribute</code>가 사용되었을 경우 인자인 Pet instance의 출처는 다음 4가지 중 하나일 수 있다. </p>\n<ol>\n<li><code class=\"language-text\">@SessionAttributes</code> 에 의해 이미 존재하는 model attribute</li>\n<li><code class=\"language-text\">@ModelAttribute</code> 메소드에 의해 이미 존재하는 model attribute</li>\n<li>URI template와 type converter에 의해 추출된 instance</li>\n<li>default constructor에 의해 초기화된 instance</li>\n</ol>\n<br>\n<br>\n<p><strong>[참고자료]</strong></p>\n<ul>\n<li><a href=\"https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html#rest-message-conversion\">https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html#rest-message-conversion</a></li>\n<li><a href=\"https://mangkyu.tistory.com/72\">https://mangkyu.tistory.com/72</a></li>\n<li><a href=\"https://stackoverflow.com/questions/29517613/how-exactly-works-requestbody-annotation-and-how-it-is-related-to-the-httpmessa\">https://stackoverflow.com/questions/29517613/how-exactly-works-requestbody-annotation-and-how-it-is-related-to-the-httpmessa</a></li>\n<li><a href=\"https://stackoverflow.com/questions/17362177/how-does-the-modelattribute-annotation-work-why-cant-i-got-the-value\">https://stackoverflow.com/questions/17362177/how-does-the-modelattribute-annotation-work-why-cant-i-got-the-value</a></li>\n<li><a href=\"https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html#mvc-ann-modelattrib-methods\">https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html#mvc-ann-modelattrib-methods</a></li>\n</ul>\n<br>\n<br>\n<p><strong>[MORE]</strong></p>\n<ul>\n<li>\n<p>HttpMessageConverters 내부동작원리</p>\n<p><a href=\"https://www.baeldung.com/spring-httpmessageconverter-rest\">https://www.baeldung.com/spring-httpmessageconverter-rest</a></p>\n</li>\n<li>언제 무엇? 장단점</li>\n<li>URI template와 type converter에 의해 추출된 instance 동작원리</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#requestbody\">@RequestBody</a></p>\n<ul>\n<li><a href=\"#%EB%8F%99%EC%9E%91%EC%9B%90%EB%A6%AC\">동작원리</a></li>\n<li><a href=\"#httpmessageconverter-%EB%A1%9C%EC%A7%81\">HttpMessageConverter 로직</a></li>\n<li><a href=\"#4%EA%B0%80%EC%A7%80-default-messageconverters\">4가지 Default MessageConverters</a></li>\n<li><a href=\"#%EC%9E%90%EC%A3%BC-%EC%93%B0%EC%9D%B4%EB%8A%94-messageconverters-3%EA%B0%80%EC%A7%80\">자주 쓰이는 MessageConverters 3가지</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#modelattribute\">@ModelAttribute</a></p>\n<ul>\n<li><a href=\"#at-method-level\">At Method Level</a></li>\n<li><a href=\"#at-method-argument\">At Method Argument</a></li>\n</ul>\n</li>\n</ul>\n</div>","frontmatter":{"date":"June 19, 2021","title":"@ModelAttribute vs. @RequestBody 더 깊이 파헤치기","categories":"스프링부트","author":"코다","emoji":"🖥"},"fields":{"slug":"/request-body-model-attribute-advanced/"}},"prev":{"id":"a6cc1d2b-0f6b-57b4-afda-42f7b4ab4500","html":"<h2 id=\"intro\" style=\"position:relative;\"><a href=\"#intro\" aria-label=\"intro permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Intro</h2>\n<p>암호화(encryption)에는 3가지 기술이 있다. </p>\n<ol>\n<li>Symmetric encryption - 대칭키</li>\n<li>Asymmestric encryption - 비대칭키</li>\n<li>Hash functions(keyless) - 해싱</li>\n</ol>\n<p>여기서는 대칭키, 비대칭키에 대해서만 다룰 것인데 둘다 각각의 장단점이 있다. <br></p>\n<p>대칭키와 비대칭키의 간단한 차이점 </p>\n<ul>\n<li>우선 모두 key를 사용해서 데이터를 encrypt/decrypt 한다.</li>\n<li>대칭키의 경우 동일한 key를 가지고 암호화/복호화를 하기 때문에 사용하기가 쉽다.</li>\n<li>비대칭키의 경우 public key를 사용해서 데이터를 암호화하고, private key를 사용해서 복호화한다.</li>\n</ul>\n<br>\n<h2 id=\"symmetric-encryption-대칭키\" style=\"position:relative;\"><a href=\"#symmetric-encryption-%EB%8C%80%EC%B9%AD%ED%82%A4\" aria-label=\"symmetric encryption 대칭키 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Symmetric encryption 대칭키?</h2>\n<p>대칭키를 사용하면 데이터의 암호화/복호화 모두 하나의 key를 사용한다. 그리고 해당 키를 수령인과 공유한다. (수령인이 암호화된 데이터를 받았을 때 복호화를 위해서 필요) <br></p>\n<p align=\"center\"><img width=\"90%\" src=\"https://user-images.githubusercontent.com/63405904/135317204-d0bcfee1-fc3a-4fc8-ab1a-dc3e644d772c.png\"></p>\n<h3 id=\"대칭키-장단점\" style=\"position:relative;\"><a href=\"#%EB%8C%80%EC%B9%AD%ED%82%A4-%EC%9E%A5%EB%8B%A8%EC%A0%90\" aria-label=\"대칭키 장단점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>대칭키 장단점</h3>\n<p><strong>장점</strong></p>\n<ul>\n<li>세팅이 쉽고 간단하다. (jiffy 순간적으로 처리된다)</li>\n<li>개념이 간단하기 때문에 여러 환경에서 거의 모두 적용이 가능하다.</li>\n</ul>\n<p><strong>단점</strong></p>\n<ul>\n<li>비밀키가 수령인과 공유되어야 한다.</li>\n<li>따라서 보안적 측면에서 다소 위험한 부분이 있다.</li>\n</ul>\n<br>\n<h2 id=\"asymmetric-encryption-비대칭키\" style=\"position:relative;\"><a href=\"#asymmetric-encryption-%EB%B9%84%EB%8C%80%EC%B9%AD%ED%82%A4\" aria-label=\"asymmetric encryption 비대칭키 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Asymmetric encryption 비대칭키?</h2>\n<p>비대칭키 방식은 데이터를 암호화/복호화 하는데 두개의 key가 필요하다. public key를 사용해서 데이터를 암호화하고, private key를 통해서 데이터를 복호화한다. <br></p>\n<p>암호화된 데이터를 수령하는 수령인은 반드시 private key를 가지고 있어야 하는데, 그것을 private하게 유지하기 위해서 local 하게 저장하는 것이 가장 좋다. </p>\n<h3 id=\"비대칭키-장단점\" style=\"position:relative;\"><a href=\"#%EB%B9%84%EB%8C%80%EC%B9%AD%ED%82%A4-%EC%9E%A5%EB%8B%A8%EC%A0%90\" aria-label=\"비대칭키 장단점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>비대칭키 장단점</h3>\n<p><strong>장점</strong></p>\n<ul>\n<li>비밀키를 공유하지 않아도 된다.</li>\n<li>digital sigining을 지원하기 때문에 수령인의 identity를 보장할 수 있고, 메세지의 오염여부를 알 수 있다.</li>\n</ul>\n<p><strong>단점</strong></p>\n<ul>\n<li>시간과 이외의 다른 많은 노력들이 소요된다.</li>\n<li>이메일이나 데이터를 보낼 때, 상대방이 key pair를 생성했는지 항상 확인해야한다.</li>\n<li>만일 key을 잃어버리면 복구할 수 없다.</li>\n</ul>\n<br>\n<h2 id=\"언제-무엇을-사용할까\" style=\"position:relative;\"><a href=\"#%EC%96%B8%EC%A0%9C-%EB%AC%B4%EC%97%87%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%A0%EA%B9%8C\" aria-label=\"언제 무엇을 사용할까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>언제 무엇을 사용할까?</h2>\n<ul>\n<li>만일 빠르게 암호화된 메세지를 전송하고 싶을 경우 Symmetric encryption 대칭키를 사용하기를 추천한다.</li>\n</ul>\n<br>\n<br>\n<p><strong>[참고링크]</strong></p>\n<ul>\n<li><a href=\"https://blog.mailfence.com/symmetric-vs-asymmetric-encryption/\">https://blog.mailfence.com/symmetric-vs-asymmetric-encryption/</a></li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#intro\">Intro</a></li>\n<li>\n<p><a href=\"#symmetric-encryption-%EB%8C%80%EC%B9%AD%ED%82%A4\">Symmetric encryption 대칭키?</a></p>\n<ul>\n<li><a href=\"#%EB%8C%80%EC%B9%AD%ED%82%A4-%EC%9E%A5%EB%8B%A8%EC%A0%90\">대칭키 장단점</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#asymmetric-encryption-%EB%B9%84%EB%8C%80%EC%B9%AD%ED%82%A4\">Asymmetric encryption 비대칭키?</a></p>\n<ul>\n<li><a href=\"#%EB%B9%84%EB%8C%80%EC%B9%AD%ED%82%A4-%EC%9E%A5%EB%8B%A8%EC%A0%90\">비대칭키 장단점</a></li>\n</ul>\n</li>\n<li><a href=\"#%EC%96%B8%EC%A0%9C-%EB%AC%B4%EC%97%87%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%A0%EA%B9%8C\">언제 무엇을 사용할까?</a></li>\n</ul>\n</div>","frontmatter":{"date":"June 21, 2021","title":"대칭키와 비대칭키 비교하기","categories":"웹","author":"코다","emoji":"🖥"},"fields":{"slug":"/symmetric-vs-asymmetric-encryption/"}},"site":{"siteMetadata":{"siteUrl":"https://yjksw.github.io","comments":{"utterances":{"repo":"yjksw/yjksw.github.io"}}}}},"pageContext":{"slug":"/hash-salt/","nextSlug":"/request-body-model-attribute-advanced/","prevSlug":"/symmetric-vs-asymmetric-encryption/"}},"staticQueryHashes":["1073350324","2938748437"]}
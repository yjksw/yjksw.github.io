{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/hash-salt/",
    "result": {"data":{"cur":{"id":"89cc4854-91bf-5d0c-abe5-c82fe6e01006","html":"<h2 id=\"들어가기-전에\" style=\"position:relative;\"><a href=\"#%EB%93%A4%EC%96%B4%EA%B0%80%EA%B8%B0-%EC%A0%84%EC%97%90\" aria-label=\"들어가기 전에 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>들어가기 전에</h2>\n<p>암호화(Encryption)과 해싱은 다른 개념</p>\n<ul>\n<li>암호화 - 양방향이므로 복호화가 가능</li>\n<li>해싱 - 단방향이므로 복호화가 불가능</li>\n</ul>\n<br>\n<h2 id=\"단방향-해시-함수-one-way-hash-function\" style=\"position:relative;\"><a href=\"#%EB%8B%A8%EB%B0%A9%ED%96%A5-%ED%95%B4%EC%8B%9C-%ED%95%A8%EC%88%98-one-way-hash-function\" aria-label=\"단방향 해시 함수 one way hash function permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>단방향 해시 함수 (One-Way Hash Function)</h2>\n<p>기본적으로 패스워드 등의 보안의 문제가 걸린 정보를 DB에 저장할 때 평문으로 저장하지 않고 해싱한 값을 저장한다. (평문으로 저장할 경우 DB가 해킹되었을 때 심각한 문제가 발생한다) <br></p>\n<p>단방향 해시 함수를 사용해서 원본 내용을 완전히 새로운 내용으로 <strong>다이제스트</strong>(<strong>digest</strong>)로 매핑한다. 이때 매핑하는 것을 <strong>해시</strong>라고 한다. 이것은 단방향이므로 복호화할 수 없다. <br></p>\n<p align=\"center\"><img width=\"90%\" src=\"https://user-images.githubusercontent.com/63405904/135313771-acb38bc5-e482-41a0-a0b8-2a7415bd2903.png\"></p>\n<ul>\n<li>해시 함수 종류\n<ol>\n<li>SHA</li>\n<li>MD</li>\n<li>HAS</li>\n<li>WHIRLPOOL</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"한계점\" style=\"position:relative;\"><a href=\"#%ED%95%9C%EA%B3%84%EC%A0%90\" aria-label=\"한계점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>한계점</h3>\n<ul>\n<li>\n<p>Rainbow Table</p>\n<p>동일한 데이터를 동일한 해시 함수로 연산한 <strong>다이제스트</strong>는 동일한 값을 가진다. 따라서 여러 값들에 대한 다이제스트를 모아놓은 <strong>Rainbow Table</strong>이라는 것이 존재하고 이것을 통해서 원본 데이터를 유추할 수 있다.</p>\n</li>\n<li>\n<p>Brute-force</p>\n<p>해싱 자체가 빠른 검색을 하기 때문에 반대로 다이제스트를 얻는 과정도 빠르게 실행된다. 무작위 데이터를 대입하여 다이제스트를 비교(해싱이므로 더 빠르게 수행됨)하여 원본 데이터를 유추할 수 있다.</p>\n</li>\n</ul>\n<br>\n<h2 id=\"단방향-해시-함수-보완\" style=\"position:relative;\"><a href=\"#%EB%8B%A8%EB%B0%A9%ED%96%A5-%ED%95%B4%EC%8B%9C-%ED%95%A8%EC%88%98-%EB%B3%B4%EC%99%84\" aria-label=\"단방향 해시 함수 보완 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>단방향 해시 함수 보완</h2>\n<h3 id=\"key-stretching\" style=\"position:relative;\"><a href=\"#key-stretching\" aria-label=\"key stretching permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Key Stretching</h3>\n<p>n번의 해시를 통해서 다이제스트의 다이제스트를 얻어내어 해커 입장에서 원문 데이터를 얻는데 시간을 더 오래 소요하게 한다. (Brute-force 무력화) <br></p>\n<p align=\"center\"><img width=\"90%\" src=\"https://user-images.githubusercontent.com/63405904/135314064-923f6f7a-d9bf-4987-9996-05c371b77aa9.png\"></p>\n<h3 id=\"salt\" style=\"position:relative;\"><a href=\"#salt\" aria-label=\"salt permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Salt</h3>\n<p>원본 데이터에 임의의 문자열을 덧붙여서 해싱을 해서 다이제스트를 얻어내는 방법이다. 따라서 다이제스트의 원문을 알아낸다고 하더라도 사용자가 입력한 원본 password를 알아내는 것은 어려워진다. <br></p>\n<p align=\"center\"><img width=\"90%\" src=\"https://user-images.githubusercontent.com/63405904/135314140-e59783ad-2587-4ba2-98d0-32763bb66f49.png\"></p>\n<p>위 두가지 방법을 모두 사용하여 다이제스트에 대한 보안성을 더 높인다. <br></p>\n<p align=\"center\"><img width=\"90%\" src=\"https://user-images.githubusercontent.com/63405904/135314236-2f313ce8-33aa-4c3a-9c39-2ec9fb18ea45.png\"></p>\n<br>\n<h2 id=\"간단하게-구현해보기\" style=\"position:relative;\"><a href=\"#%EA%B0%84%EB%8B%A8%ED%95%98%EA%B2%8C-%EA%B5%AC%ED%98%84%ED%95%B4%EB%B3%B4%EA%B8%B0\" aria-label=\"간단하게 구현해보기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>간단하게 구현해보기</h2>\n<ol>\n<li>\n<p>SALT 크기를 지정</p>\n<p>너무 짧으면 안전하지 않다. <br></p>\n<p>랜덤 함수를 하용해 SALT를 생성하는 것이 좋으나, <code class=\"language-text\">java.util.Random</code> 은 암호학적으로 안전하지 않아서<code class=\"language-text\">java.security.SecureRandom</code>을 사용한다.</p>\n</li>\n<li>\n<p>해시 함수를 쓰기 위해서 <code class=\"language-text\">java.security.MessageDigest</code> 외부 라이브러리를 Import 한다. (이외의 다른 라이브러리도 존재한다)</p>\n</li>\n<li>\n<p>랜덤 함수를 통해서 SALT를 얻어 사용자 입력 password에 덧붙인다.</p>\n</li>\n<li>\n<p><code class=\"language-text\">MessageDigest</code> 라이브러리의 <code class=\"language-text\">update()</code>를 통해서 문자열을 해싱하여 해당 라이브러리에 저장한다.</p>\n</li>\n<li>\n<p><code class=\"language-text\">MessageDigest</code> 라이브러리의 <code class=\"language-text\">digest()</code> 를 통해서 다이제스트를 얻는다.</p>\n</li>\n</ol>\n<br>\n<br>\n<p><strong>[참고링크]</strong></p>\n<ul>\n<li><a href=\"https://st-lab.tistory.com/100\">https://st-lab.tistory.com/100</a></li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#%EB%93%A4%EC%96%B4%EA%B0%80%EA%B8%B0-%EC%A0%84%EC%97%90\">들어가기 전에</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%8B%A8%EB%B0%A9%ED%96%A5-%ED%95%B4%EC%8B%9C-%ED%95%A8%EC%88%98-one-way-hash-function\">단방향 해시 함수 (One-Way Hash Function)</a></p>\n<ul>\n<li><a href=\"#%ED%95%9C%EA%B3%84%EC%A0%90\">한계점</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EB%8B%A8%EB%B0%A9%ED%96%A5-%ED%95%B4%EC%8B%9C-%ED%95%A8%EC%88%98-%EB%B3%B4%EC%99%84\">단방향 해시 함수 보완</a></p>\n<ul>\n<li><a href=\"#key-stretching\">Key Stretching</a></li>\n<li><a href=\"#salt\">Salt</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EA%B0%84%EB%8B%A8%ED%95%98%EA%B2%8C-%EA%B5%AC%ED%98%84%ED%95%B4%EB%B3%B4%EA%B8%B0\">간단하게 구현해보기</a></p>\n</li>\n</ul>\n</div>","excerpt":"들어가기 전에 암호화(Encryption)과 해싱은 다른 개념 암호화 - 양방향이므로 복호화가 가능 해싱 - 단방향이므로 복호화가 불가능 단방향 해시 함수 (One-Way Hash Function) 기본적으로 패스워드 등의 보안의 문제가 걸린 정보를 DB에 저장할 때 평문으로 저장하지 않고 해싱한 값을 저장한다. (평문으로 저장할 경우 DB가 해킹되었을 때 심각한 문제가 발생한다)  단방향 해시 함수를 사용해서 원본 내용을 완전히 새로운 내용으로 다이제스트(digest)로 매핑한다. 이때 매핑하는 것을 해시라고 한다. 이것은 단방향이므로 복호화할 수 없다.  해시 함수 종류 SHA MD HAS WHIRLPOOL 한계점 Rainbow Table 동일한 데이터를 동일한 해시 함수로 연산한 다이제스트는 동일한 값을 가진다. 따라서 여러 값들에 대한 다이제스트를 모아놓은 Rainbow Table이라는 것이 존재하고 이것을 통해서 원본 데이터를 유추할 수 있다. Brute-force 해싱 …","frontmatter":{"date":"June 21, 2021","title":"Hash와 Salt","categories":"웹 자바","author":"코다","emoji":"🖥"},"fields":{"slug":"/hash-salt/"}},"next":{"id":"aa4dffec-9907-5cba-91ed-6988835a5453","html":"<ul>\n<li><code class=\"language-text\">@ControllerAdvice</code>를 통해서 어플리케이션 전역적으로 exception을 핸들링 할 수 있다. 다르게 표현하면 <code class=\"language-text\">@RequestMapping</code> 메서드에서 던져지는 exceptions들의 interceptor라고 할 수 있다. (shared across multiple @Controller classes)</li>\n<li>주로 <code class=\"language-text\">@ControllerAdvice</code>에서 전역적으로 처리하고 싶은 어노테이션은 <code class=\"language-text\">@ExceptionHandler</code>, <code class=\"language-text\">@InitBinder</code>, <code class=\"language-text\">@ModelAttribute</code> 등이 있다.</li>\n<li><code class=\"language-text\">ResponseEntityExceptionHandler</code> 클래스가 <code class=\"language-text\">@ControllerAdvice</code> 어노테이션에서 전역적인 exception handling 을 구현할 수 있도록 하는 base class이다. 해당 클래스에서 Spring MVC 내부에서 발생한 예외들을 처리할 수 있는 메서드들을 제공한다. (<code class=\"language-text\">DefaultHandlerExceptionResolver</code>는 <code class=\"language-text\">ModelAndView</code>를 반환하는 반면 <code class=\"language-text\">ResponseEntityExceptionHandler</code>는 <code class=\"language-text\">ResponseEntity</code>를 반환한다)</li>\n</ul>\n<h2 id=\"여러-controlleradvice-간의-우선순위\" style=\"position:relative;\"><a href=\"#%EC%97%AC%EB%9F%AC-controlleradvice-%EA%B0%84%EC%9D%98-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84\" aria-label=\"여러 controlleradvice 간의 우선순위 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>여러 @ControllerAdvice 간의 우선순위</h2>\n<p>@ControllerAdvice 클래스들은 Bean으로 등록이 되도록 하는데, 해당 빈들은 <code class=\"language-text\">Ordered</code> 인터페이스를 구현하여 orderable 한 속성을 부여하거나, <code class=\"language-text\">@Order</code>/ <code class=\"language-text\">@Priority</code>를 사용해서 우선순위를 부여할 수 있다. (여기서 <code class=\"language-text\">Ordered</code> semantic이 <code class=\"language-text\">@Order</code>/ <code class=\"language-text\">@Priority</code> 에 우선순위를 가진다)</p>\n<ul>\n<li>\n<p>예외를 처리하는 경우</p>\n<p>매칭이 되는 exception handler method가 있는 가장 처음 매칭되는 advice의 <code class=\"language-text\">@ExceptionHandler</code>가 실행된다.</p>\n</li>\n<li>\n<p>model attribute와 data binding 초기화 경우</p>\n<p><code class=\"language-text\">@ModelAttribute</code>와 <code class=\"language-text\">@InitBinder</code> 메소드가 <code class=\"language-text\">ControllerAdvice</code>의 우선순위 순서에 따라서 실행된다.</p>\n</li>\n<li>\n<p><code class=\"language-text\">@ControlerAdvice</code>의 우선순위에 따른 ExceptionHandler 선언 팁</p>\n<p align=\"center\"><img width=\"85%\" src=\"https://user-images.githubusercontent.com/63405904/135494123-1441631a-7277-4b6f-b82e-30610bcf4b5e.png\"></p>\n</li>\n</ul>\n<p>기본적으로 <code class=\"language-text\">@ControllerAdvice</code>는 모든 controller에 전역적으로 적용이 되기 때문에, 더 구체적인 controller에 적용하기 위해서는 selectors를 사용해야한다. (<code class=\"language-text\">annotations()</code> , <code class=\"language-text\">basePackageClasses()</code> , <code class=\"language-text\">basePackages()</code>)만일 여러 selectors가 있으면 OR 로 적용이되면 이 selectors 체크는 runtime에 실행이 되므로, 만일 너무 많은 selectors를 사용하면 런타임 퍼포먼스 효율이 떨어지게 된다.</p>\n<br>\n<br>\n<p><strong>[참고자료]</strong></p>\n<ul>\n<li><a href=\"https://zetcode.com/springboot/controlleradvice/\">https://zetcode.com/springboot/controlleradvice/</a></li>\n<li><a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/bind/annotation/ControllerAdvice.html\">https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/bind/annotation/ControllerAdvice.html</a></li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#%EC%97%AC%EB%9F%AC-controlleradvice-%EA%B0%84%EC%9D%98-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84\">여러 @ControllerAdvice 간의 우선순위</a></li>\n</ul>\n</div>","frontmatter":{"date":"June 19, 2021","title":"@ControllerAdvice 알아보기","categories":"스프링부트","author":"코다","emoji":"🖥"},"fields":{"slug":"/springboot-controller-advice/"}},"prev":{"id":"a6cc1d2b-0f6b-57b4-afda-42f7b4ab4500","html":"<h2 id=\"intro\" style=\"position:relative;\"><a href=\"#intro\" aria-label=\"intro permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Intro</h2>\n<p>암호화(encryption)에는 3가지 기술이 있다.</p>\n<ol>\n<li>Symmetric encryption - 대칭키</li>\n<li>Asymmestric encryption - 비대칭키</li>\n<li>Hash functions(keyless) - 해싱</li>\n</ol>\n<p>여기서는 대칭키, 비대칭키에 대해서만 다룰 것인데 둘다 각각의 장단점이 있다. <br></p>\n<p>대칭키와 비대칭키의 간단한 차이점</p>\n<ul>\n<li>우선 모두 key를 사용해서 데이터를 encrypt/decrypt 한다.</li>\n<li>대칭키의 경우 동일한 key를 가지고 암호화/복호화를 하기 때문에 사용하기가 쉽다.</li>\n<li>비대칭키의 경우 public key를 사용해서 데이터를 암호화하고, private key를 사용해서 복호화한다.</li>\n</ul>\n<br>\n<h2 id=\"symmetric-encryption-대칭키\" style=\"position:relative;\"><a href=\"#symmetric-encryption-%EB%8C%80%EC%B9%AD%ED%82%A4\" aria-label=\"symmetric encryption 대칭키 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Symmetric encryption 대칭키?</h2>\n<p>대칭키를 사용하면 데이터의 암호화/복호화 모두 하나의 key를 사용한다. 그리고 해당 키를 수령인과 공유한다. (수령인이 암호화된 데이터를 받았을 때 복호화를 위해서 필요) <br></p>\n<p align=\"center\"><img width=\"90%\" src=\"https://user-images.githubusercontent.com/63405904/135317204-d0bcfee1-fc3a-4fc8-ab1a-dc3e644d772c.png\"></p>\n<h3 id=\"대칭키-장단점\" style=\"position:relative;\"><a href=\"#%EB%8C%80%EC%B9%AD%ED%82%A4-%EC%9E%A5%EB%8B%A8%EC%A0%90\" aria-label=\"대칭키 장단점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>대칭키 장단점</h3>\n<p><strong>장점</strong></p>\n<ul>\n<li>세팅이 쉽고 간단하다. (jiffy 순간적으로 처리된다)</li>\n<li>개념이 간단하기 때문에 여러 환경에서 거의 모두 적용이 가능하다.</li>\n</ul>\n<p><strong>단점</strong></p>\n<ul>\n<li>비밀키가 수령인과 공유되어야 한다.</li>\n<li>따라서 보안적 측면에서 다소 위험한 부분이 있다.</li>\n</ul>\n<br>\n<h2 id=\"asymmetric-encryption-비대칭키\" style=\"position:relative;\"><a href=\"#asymmetric-encryption-%EB%B9%84%EB%8C%80%EC%B9%AD%ED%82%A4\" aria-label=\"asymmetric encryption 비대칭키 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Asymmetric encryption 비대칭키?</h2>\n<p>비대칭키 방식은 데이터를 암호화/복호화 하는데 두개의 key가 필요하다. public key를 사용해서 데이터를 암호화하고, private key를 통해서 데이터를 복호화한다. <br></p>\n<p>암호화된 데이터를 수령하는 수령인은 반드시 private key를 가지고 있어야 하는데, 그것을 private하게 유지하기 위해서 local 하게 저장하는 것이 가장 좋다.</p>\n<h3 id=\"비대칭키-장단점\" style=\"position:relative;\"><a href=\"#%EB%B9%84%EB%8C%80%EC%B9%AD%ED%82%A4-%EC%9E%A5%EB%8B%A8%EC%A0%90\" aria-label=\"비대칭키 장단점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>비대칭키 장단점</h3>\n<p><strong>장점</strong></p>\n<ul>\n<li>비밀키를 공유하지 않아도 된다.</li>\n<li>digital sigining을 지원하기 때문에 수령인의 identity를 보장할 수 있고, 메세지의 오염여부를 알 수 있다.</li>\n</ul>\n<p><strong>단점</strong></p>\n<ul>\n<li>시간과 이외의 다른 많은 노력들이 소요된다.</li>\n<li>이메일이나 데이터를 보낼 때, 상대방이 key pair를 생성했는지 항상 확인해야한다.</li>\n<li>만일 key을 잃어버리면 복구할 수 없다.</li>\n</ul>\n<br>\n<h2 id=\"언제-무엇을-사용할까\" style=\"position:relative;\"><a href=\"#%EC%96%B8%EC%A0%9C-%EB%AC%B4%EC%97%87%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%A0%EA%B9%8C\" aria-label=\"언제 무엇을 사용할까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>언제 무엇을 사용할까?</h2>\n<ul>\n<li>만일 빠르게 암호화된 메세지를 전송하고 싶을 경우 Symmetric encryption 대칭키를 사용하기를 추천한다.</li>\n</ul>\n<br>\n<br>\n<p><strong>[참고링크]</strong></p>\n<ul>\n<li><a href=\"https://blog.mailfence.com/symmetric-vs-asymmetric-encryption/\">https://blog.mailfence.com/symmetric-vs-asymmetric-encryption/</a></li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#intro\">Intro</a></p>\n</li>\n<li>\n<p><a href=\"#symmetric-encryption-%EB%8C%80%EC%B9%AD%ED%82%A4\">Symmetric encryption 대칭키?</a></p>\n<ul>\n<li><a href=\"#%EB%8C%80%EC%B9%AD%ED%82%A4-%EC%9E%A5%EB%8B%A8%EC%A0%90\">대칭키 장단점</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#asymmetric-encryption-%EB%B9%84%EB%8C%80%EC%B9%AD%ED%82%A4\">Asymmetric encryption 비대칭키?</a></p>\n<ul>\n<li><a href=\"#%EB%B9%84%EB%8C%80%EC%B9%AD%ED%82%A4-%EC%9E%A5%EB%8B%A8%EC%A0%90\">비대칭키 장단점</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%96%B8%EC%A0%9C-%EB%AC%B4%EC%97%87%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%A0%EA%B9%8C\">언제 무엇을 사용할까?</a></p>\n</li>\n</ul>\n</div>","frontmatter":{"date":"June 21, 2021","title":"대칭키와 비대칭키 비교하기","categories":"웹","author":"코다","emoji":"🖥"},"fields":{"slug":"/symmetric-vs-asymmetric-encryption/"}},"site":{"siteMetadata":{"siteUrl":"https://yjksw.github.io","comments":{"utterances":{"repo":"yjksw/yjksw.github.io"}}}}},"pageContext":{"slug":"/hash-salt/","nextSlug":"/springboot-controller-advice/","prevSlug":"/symmetric-vs-asymmetric-encryption/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}
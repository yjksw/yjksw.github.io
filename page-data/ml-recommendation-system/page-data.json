{"componentChunkName":"component---src-templates-blog-template-js","path":"/ml-recommendation-system/","result":{"data":{"cur":{"id":"3abdc3c5-1be2-5f00-abea-96176b99fce9","html":"<p>모 기업에서 인턴을 하면서 맡은 업무가 <mark>개인화 추천 모델 구현</mark>이었다. 맡은 업무는 딥러닝 기반의 개인화 추천 모델을 제작하는 것이지만 기존에 회사에서 가지고 있는 추천 시스템의 경우 협업 필터링 등으로 이미 구현이 되어 있었기 때문에 간단히 개인화 추천 시스템에 대한 브리핑을 해주시면서 감을 잡을 수 있도록 해주셨다. <br></p>\n<p>추천 시스템 기술을 처음 접해보면서 어떠한 것인지 공부하며 기록해보려고 한다. <br></p>\n<h2 id=\"추천이란\" style=\"position:relative;\"><a href=\"#%EC%B6%94%EC%B2%9C%EC%9D%B4%EB%9E%80\" aria-label=\"추천이란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>추천이란?</h2>\n<p>추천이란 간단히 말해서 사용자(user)에게 관심이 있을 것으로 예상이 되는 아이템(item)을 제안하는 것이다. 특정 아이템에 대한 특정 사용자의 선호도 또는 평가를 예측하는 것이 매우 중요하다. <br></p>\n<p>우리가 흔히 생각해 낼 수 있는 추천 시스템은 페이스북과 같은 것에서의 광고 추천, 넷플릭스나 왓챠와 같은 OTT 서비스에서의 영화 추천 시스템이다. <br></p>\n<h2 id=\"접근-방식\" style=\"position:relative;\"><a href=\"#%EC%A0%91%EA%B7%BC-%EB%B0%A9%EC%8B%9D\" aria-label=\"접근 방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>접근 방식</h2>\n<p>추천 시스템 기술에서의 접근 방식은 크게 다음과 같은 3가지가 있다. <br></p>\n<ul>\n<li>내용 기반 필터링 (Content-based Filtering) <br></li>\n<li>협업 필터링 (Collaborative Filtering) <br></li>\n<li>하이브리드 (Hybrid) <br></li>\n</ul>\n<h3 id=\"1-내용-기반-필터링\" style=\"position:relative;\"><a href=\"#1-%EB%82%B4%EC%9A%A9-%EA%B8%B0%EB%B0%98-%ED%95%84%ED%84%B0%EB%A7%81\" aria-label=\"1 내용 기반 필터링 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1) 내용 기반 필터링</h3>\n<p>사용자의 프로필이나 아이템의 content 정보를 이용하는 방법이다. 사용자의 선호도, 취향 등을 파악하는 방법이 핵심이다. 예를 들어, 회원가입 시 사용자에게 선호하는 아이템 또는 분야 등에 대해서 선택하도록 하여 선호도를 파악하여 해당 정보를 기반으로 추천을 한다. 또는 사용자의 과거에 평가한 아이템 분석을 통해서 선호도를 파악할 수 있다. <br></p>\n<p><img src=\"https://user-images.githubusercontent.com/63405904/110242569-0590d100-7f9a-11eb-8799-e9fe186779e6.jpeg\" alt=\"contentbased\"></p>\n<h3 id=\"2-협업-필터링\" style=\"position:relative;\"><a href=\"#2-%ED%98%91%EC%97%85-%ED%95%84%ED%84%B0%EB%A7%81\" aria-label=\"2 협업 필터링 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2) 협업 필터링</h3>\n<p>협업 필터링은 여러 사용자들의 활동, 기호 정보들을 분석하여, 각 사아요자에게 적합한 아이템을 추천하도록 한다. 예를 들어서 사용자 A와 유사하다고 판단되는 사용자 B가 최근 구매한 상품을 사용자 A에게도 추천하도록 하는 것이다. <br></p>\n<p><img src=\"https://user-images.githubusercontent.com/63405904/110242548-f14cd400-7f99-11eb-927e-2e1000c04eba.jpeg\" alt=\"collaborative\"></p>\n<h3 id=\"3-내용-기반-필터링--협업-필터링의-장단점\" style=\"position:relative;\"><a href=\"#3-%EB%82%B4%EC%9A%A9-%EA%B8%B0%EB%B0%98-%ED%95%84%ED%84%B0%EB%A7%81--%ED%98%91%EC%97%85-%ED%95%84%ED%84%B0%EB%A7%81%EC%9D%98-%EC%9E%A5%EB%8B%A8%EC%A0%90\" aria-label=\"3 내용 기반 필터링  협업 필터링의 장단점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3) 내용 기반 필터링 &#x26; 협업 필터링의 장단점</h3>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>내용 기반 필터링</th>\n<th>협업 필터링</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>장점</td>\n<td>사용자의 명시적인 기호 정보를 직접적으로 반영한다. <br>다른 사용자의 정보나 평가, 행동 등이 필요하지 않다.<br>새로 추가된 아이템에 대한 추천이 가능하다.</td>\n<td>대부분의 경우 추천 성과가 우수하다.<br>잠재적인 특징을 고려하여 다양한 범위의 추천이 가능하다.</td>\n</tr>\n<tr>\n<td>단점</td>\n<td>사용자의 명시적인 프로필 얻기 어려움이 있다.<br>명시적으로 표현된 특징만 다룰 수 있고 잠재적인 것을 캐치하기 어렵다.<br>추천하는 항목이 비슷한 장르에 머무르는 한계가 있다.</td>\n<td>초기 사용자에 대한 믿을만한 추천이 어렵다. Cold start가 존재한다.<br>한번도 평가되지 않은 아이템은 추천 대상에서 제외된다. sparsity, coverage</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"4-하이브리드\" style=\"position:relative;\"><a href=\"#4-%ED%95%98%EC%9D%B4%EB%B8%8C%EB%A6%AC%EB%93%9C\" aria-label=\"4 하이브리드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4) 하이브리드</h3>\n<p>위에서의 내용 기반 필터링과 협업 필터링을 결합하여 사용한다. 결합하는 방식을 다양하기 때문에 어떠한 하이브리드 방식을 택하는지는 매우 광범위 하다. 하지만 간단히 보아서 위의 두가지 방식을 같이 사용함으로 각자의 단점을 보완한다는 장점을 가지고 있다. 다만 시스템적으로 매우 복잡해질 수 있는 단점이 있다. </p>\n<h3 id=\"5-협업-필터링-기술-분류\" style=\"position:relative;\"><a href=\"#5-%ED%98%91%EC%97%85-%ED%95%84%ED%84%B0%EB%A7%81-%EA%B8%B0%EC%88%A0-%EB%B6%84%EB%A5%98\" aria-label=\"5 협업 필터링 기술 분류 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5) 협업 필터링 기술 분류</h3>\n<p>본 기업에서 중점적으로 사용하고 있는 협업 필터링 기술은 다음과 같이 분류된다. <br></p>\n<ul>\n<li>\n<p>메모리 기반(Memory-based) 협업 필터링 <br></p>\n<ul>\n<li>사용자 또는 아이템 간의 유사도를 계산하고 그것을 바탕을 추천 결과를 생성하는 방식으로 유사도를 계산하는 방식이 매우 중요함. <br></li>\n<li><strong>대표 알고리즘</strong>: User-based CF / Item-based CF <br></li>\n<li><strong>장점</strong>: 구현이 간단하고 이해하기 쉬움. <br></li>\n<li><strong>한계</strong>: 1) 새로운 사용자와 아이템에 대한 cold start 문제 2) Rating matrix의 sparsity 문제 3) 큰 데이터 셋에 대해 제한된 scalability <br></li>\n</ul>\n</li>\n<li>\n<p>모델 기반(Model-based) 협업 필터링 <br></p>\n<ul>\n<li>데이터(rating matrix)에 내재되어 있는 패턴이나 속성을 학습한 모델을 만들고, 이것을 바탕으로 추천 결과를 생성하는 방식. <br></li>\n<li><strong>대표 알고리즘</strong>: Slope-One EF / Matrix Facotrization <br></li>\n<li><strong>장점:</strong> sparsity, scalability 문제에 상대적으로 더 잘 대처하는 것이 가능하고 예측 성능이 향상됨. <br></li>\n<li><strong>한계:</strong> 1) 모델 구축 비용이 큼 2) 예측 성능과 scalability 사이의 trade-off 3) 차원 감소로 인한 정보손실(SVD 실행 시 발생) <br></li>\n</ul>\n</li>\n<li>\n<p>하이브리드(Hybrid) 방식 협업 필터링 <br></p>\n<ul>\n<li>메모리 기반 방식과 모델 기반 방식을 결합하여 사용하는 방식 <br></li>\n<li><strong>대표 알고리즘</strong>: 메모리 기반과 모델 기반의 조합 <br></li>\n<li><strong>장점</strong>: 각 방식의 단점을 보완하고 장점만을 취합할 수 있음 <br></li>\n<li><strong>한계:</strong> 구현이 복잡해지고 비용이 증가함. <br></li>\n</ul>\n</li>\n</ul>\n<br>\n<p><strong><small>[참고 자료]: <a href=\"https://www.samsungsemiconstory.com/2265\">https://www.samsungsemiconstory.com/2265</a>, </small></strong></p>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#%EC%B6%94%EC%B2%9C%EC%9D%B4%EB%9E%80\">추천이란?</a></li>\n<li>\n<p><a href=\"#%EC%A0%91%EA%B7%BC-%EB%B0%A9%EC%8B%9D\">접근 방식</a></p>\n<ul>\n<li><a href=\"#1-%EB%82%B4%EC%9A%A9-%EA%B8%B0%EB%B0%98-%ED%95%84%ED%84%B0%EB%A7%81\">1) 내용 기반 필터링</a></li>\n<li><a href=\"#2-%ED%98%91%EC%97%85-%ED%95%84%ED%84%B0%EB%A7%81\">2) 협업 필터링</a></li>\n<li><a href=\"#3-%EB%82%B4%EC%9A%A9-%EA%B8%B0%EB%B0%98-%ED%95%84%ED%84%B0%EB%A7%81--%ED%98%91%EC%97%85-%ED%95%84%ED%84%B0%EB%A7%81%EC%9D%98-%EC%9E%A5%EB%8B%A8%EC%A0%90\">3) 내용 기반 필터링 &#x26; 협업 필터링의 장단점</a></li>\n<li><a href=\"#4-%ED%95%98%EC%9D%B4%EB%B8%8C%EB%A6%AC%EB%93%9C\">4) 하이브리드</a></li>\n<li><a href=\"#5-%ED%98%91%EC%97%85-%ED%95%84%ED%84%B0%EB%A7%81-%EA%B8%B0%EC%88%A0-%EB%B6%84%EB%A5%98\">5) 협업 필터링 기술 분류</a></li>\n</ul>\n</li>\n</ul>\n</div>","excerpt":"모 기업에서 인턴을 하면서 맡은 업무가 개인화 추천 모델 구현이었다. 맡은 업무는 딥러닝 기반의 개인화 추천 모델을 제작하는 것이지만 기존에 회사에서 가지고 있는 추천 시스템의 경우 협업 필터링 등으로 이미 구현이 되어 있었기 때문에 간단히 개인화 추천 시스템에 대한 브리핑을 해주시면서 감을 잡을 수 있도록 해주셨다.  추천 시스템 기술을 처음 접해보면서 어떠한 것인지 공부하며 기록해보려고 한다.  추천이란? 추천이란 간단히 말해서 사용자(user)에게 관심이 있을 것으로 예상이 되는 아이템(item)을 제안하는 것이다. 특정 아이템에 대한 특정 사용자의 선호도 또는 평가를 예측하는 것이 매우 중요하다.  우리가 흔히 생각해 낼 수 있는 추천 시스템은 페이스북과 같은 것에서의 광고 추천, 넷플릭스나 왓챠와 같은 OTT 서비스에서의 영화 추천 시스템이다.  접근 방식 추천 시스템 기술에서의 접근 방식은 크게 다음과 같은 3가지가 있다.  내용 기반 필터링 (Content-based …","frontmatter":{"date":"August 10, 2020","title":"[머신러닝] 추천 시스템 기술","categories":"머신러닝","author":"코다","emoji":"🪄"},"fields":{"slug":"/ml-recommendation-system/"}},"next":{"id":"e6f0d0ff-4840-58a3-a95a-131f2cc9d72d","html":"<br>\n<p>자바에서 LIST 인터페이스를 구현한 Collection 구현체 중 가장 많이 쓰고 헷갈리는 것이 ArrayList와 LinkedList의 차이이다. 알고리즘 코딩을 공부하다가 특정 답을 배열 구조에 담을 일이 있어서 찾아보다 문득 ArrayList, LinkedList 중 무엇을 쓸까 고민하는 김에 정리하게 되었다. <br></p>\n<p>인터페이스도 같고 사용하는 방식도 비슷한 부분이 많기 때문에 ArrayList를 써야할 때 LinkedList를 쓰거나 그 반대로 사용하더라도 큰 차이가 없이 느껴지기도 한다. 하지만 두 가지 자료구조가 구분되어 있는 만큼 더 적절한 부분이 있다. 간단히 한번 알아보자. <br></p>\n<p>Java에서는 변수를 저장하기 위해서 배열을 사용한다. 하지만 배열의 단점은 초기에 길이를 저장해서 미리 메모리를 확보해 놓아야 한다는 것이다. 다라서 동적으로 메모리 할당이 어려울 뿐만 아니라, 예상하지 못하는 입력크기에 대해서는 애초에 크게 배열의 크기를 잡아놓는 비효율적인 방법을 택해야 한다. 이런 문제를 해결할 수 있도록 자바 Collection에서는 ArrayList와 LinkedList 자료구조를 제공한다. <br></p>\n<h2 id=\"arraylist\" style=\"position:relative;\"><a href=\"#arraylist\" aria-label=\"arraylist permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ArrayList</h2>\n<p>ArrayList는 데이터를 배열로 관리하고 데이터를 추가, 삭제하기 위해서 임시 배열을 생성해서 데이터를 복사하여 하나씩 index를 모두 미룬다. <br></p>\n<p>다르게 말하면 많은 양의 데이터를 추가/삭제하는 경우에는 복사가 매우 많이 일어나게 되며, 그만큼의 성능저하를 일으킨다. 하지만 ArrayList가 LinkedList에 비해서 유용하게 작동하는 부분은 바로 탐색이다. 각 데이터는 각자의 인덱스를 가지고 있기 때문에 참조를 할 때 한번에 참조가 가능하며 매우 유리하게 작동하는 구현체가 된다. <br></p>\n<h2 id=\"linkedlist\" style=\"position:relative;\"><a href=\"#linkedlist\" aria-label=\"linkedlist permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>LinkedList</h2>\n<p>LinkedList는 각 노드가 자기 이전의 노드와 다음 노드를 알고 있다. 따라서 데이터를 추가하고 삭제할 시, 위에서 보이는 것처럼 그 앞과 뒤의 연결만 신경쓰면 되기 때문에 매우 유용하다. 하지만 탐색의 경우 각 노드가 정해진 인덱스에 저장되어 있는 것은 아니기 때문에 처음부터 순차적으로 노드를 방문해서 검색해야 한다는 단점을 가지고 있다. </p>\n<h2 id=\"데이터-검색삽입삭제-성능-비교\" style=\"position:relative;\"><a href=\"#%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B2%80%EC%83%89%EC%82%BD%EC%9E%85%EC%82%AD%EC%A0%9C-%EC%84%B1%EB%8A%A5-%EB%B9%84%EA%B5%90\" aria-label=\"데이터 검색삽입삭제 성능 비교 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>데이터 검색/삽입/삭제 성능 비교</h2>\n<h3 id=\"검색\" style=\"position:relative;\"><a href=\"#%EA%B2%80%EC%83%89\" aria-label=\"검색 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>검색</h3>\n<p>검색은 ArrayList가 LinkedList에 비해 훨씬 빠르다. ArrayList는 인덱스 기반으로 바로 해당 인덱스를 참조할 수 있기 때문에 O(1)의 시간 복잡도를 가진다. 그에 비해 LinkedList는 검색 시 모든 요소 탐색을 하기 때문에 최악의 경우 O(n)의 시간 복잡도를 가진다. <br></p>\n<h3 id=\"삽입삭제\" style=\"position:relative;\"><a href=\"#%EC%82%BD%EC%9E%85%EC%82%AD%EC%A0%9C\" aria-label=\"삽입삭제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>삽입/삭제</h3>\n<p>LinkedList의 삽입, 삭제는 ArrayList에 비해서 빠른데 LinkedList는 앞뒤 노드의 참조 형태만 변경하면 되기 때문에 따라서 삽입과 삭제가 일어날 때 O(1)의 시간 복잡도를 가지는 반면 ArrayList는 O(n)의 시간복잡도를 가진다. <br></p>\n<h2 id=\"코드-응용에서의-성능-비교\" style=\"position:relative;\"><a href=\"#%EC%BD%94%EB%93%9C-%EC%9D%91%EC%9A%A9%EC%97%90%EC%84%9C%EC%9D%98-%EC%84%B1%EB%8A%A5-%EB%B9%84%EA%B5%90\" aria-label=\"코드 응용에서의 성능 비교 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>코드 응용에서의 성능 비교</h2>\n<p>알고리즘 문제를 풀 때, 각 문제에 대한 정답을 배열에 저장하여 한꺼번에 출력을 해야하는 문제가 있었다. 해당 문제에서는 각 문제에 대해서 매번 그 답을 삽입해야 하기 때문에 LinkedList가 훨씬 좋은 성능을 보였다. <br></p>\n<p>예를 들어 다음과 같은 코드를 보자. </p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Character</span><span class=\"token punctuation\">></span></span> arr <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">LinkedList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Character</span><span class=\"token punctuation\">></span></span> link <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">LinkedList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">//어떠한 조건이 충족되었을 때, </span>\narr<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token string\">'-'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nlink<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token string\">'-'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">//댜른 조건이 충족되었을 때,</span>\narr<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token string\">'+'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nlink<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token string\">'+'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>크게 중요하지 않기 때문에 전체 코드를 적지는 않았다. 대충 위와 같은 코드에서 각각 ArrayList와 LinkedList로 비교해보았을 때 다음과 같은 성능 차이를 보였다. <br></p>\n<p><img src=\"https://user-images.githubusercontent.com/63405904/113716079-2d07c480-9725-11eb-99d8-f9696839f3d6.png\" alt=\"result\">{: width=80%}</p>\n<p>첫번째 나온 라인이 LinkedList을 사용했을 때 1700ms 의 시간 효율을 보였고, 동일한 코드에 ArrayList를 사용했을 때, 잦은 삽입으로 다소 낮은 2056ms의 시간 효율을 보인 것을 볼 수 있다. <br></p>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#arraylist\">ArrayList</a></li>\n<li><a href=\"#linkedlist\">LinkedList</a></li>\n<li>\n<p><a href=\"#%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B2%80%EC%83%89%EC%82%BD%EC%9E%85%EC%82%AD%EC%A0%9C-%EC%84%B1%EB%8A%A5-%EB%B9%84%EA%B5%90\">데이터 검색/삽입/삭제 성능 비교</a></p>\n<ul>\n<li><a href=\"#%EA%B2%80%EC%83%89\">검색</a></li>\n<li><a href=\"#%EC%82%BD%EC%9E%85%EC%82%AD%EC%A0%9C\">삽입/삭제</a></li>\n</ul>\n</li>\n<li><a href=\"#%EC%BD%94%EB%93%9C-%EC%9D%91%EC%9A%A9%EC%97%90%EC%84%9C%EC%9D%98-%EC%84%B1%EB%8A%A5-%EB%B9%84%EA%B5%90\">코드 응용에서의 성능 비교</a></li>\n</ul>\n</div>","frontmatter":{"date":"August 09, 2020","title":"[JAVA] ArrayList와 LinkedList 차이점","categories":"자바","author":"코다","emoji":"✊"},"fields":{"slug":"/java-list/"}},"prev":{"id":"00f6784d-9c1b-544a-bbc9-c05f7ea73ba6","html":"<p>인턴을 하는 중에 요즘에 중요한 머신러닝의 한 분야가 되고 있는 개인화 추천에 대한 개발을 맡게 되었다. 요즘 넷플릭스, 왓챠와 같은 OTT 서비스는 물론이고, SNS에 표기되는 광고, 당근마켓 등등과 같은 중고거래 및 쇼핑 어플리케이션에서도 중요한 것이 사용자의 취향을 분석하여서 알맞은 아이템을 추천하는 기술이 핵심이다. 어쩌면 사용자가 의식적으로 파악하고 있는 이상의 취향을 파악해서 추천해야 할 때도 있다. 이전 포스트에서 다루었듯이 개인화 추천에는 여러 통계기반 머신러닝 기법들이 있다. 그리고 인공 신경망이라는 딥러닝 기법이 등장하게 되면서 더욱 세밀하고 정확한 개인화 추천이 가능해졌다. <br></p>\n<p>처음 접했기 때문에 매우 생소하고 낯선 분야였지만 많은 자료들을 찾아보면서 현재 내 삶(<small>유튜브나 넷플릭스의 노예…</small>)과 아주 밀접하게 연관이 되어 있는 많은 어플리케이션과 서비스등에 실제로 사용되고 있는 인공지능 기법이라는 것이 금방 흥미를 불러 일으켰다. 조금 어렵긴 하지만 facebook에서 공개한 DLRM(Deep Learning Recommendation Model) <a href=\"https://ai.facebook.com/blog/dlrm-an-advanced-open-source-deep-learning-recommendation-model/\">자료</a>나 구글에서 공개한 유튜브 개인화 추천 <a href=\"https://research.google/pubs/pub45530/\">논문</a>, 국내의 당근마켓에서 쓴 개인화 추천 관련 블로그 <a href=\"%5Bhttps://medium.com/daangn/%EB%94%A5%EB%9F%AC%EB%8B%9D-%EA%B0%9C%EC%9D%B8%ED%99%94-%EC%B6%94%EC%B2%9C-1eda682c2e8c%5D(https://medium.com/daangn/%EB%94%A5%EB%9F%AC%EB%8B%9D-%EA%B0%9C%EC%9D%B8%ED%99%94-%EC%B6%94%EC%B2%9C-1eda682c2e8c)\">포스트</a> 등을 참고하면서 개인화 추천에 대한 대략적인 아이디어나 개념을 잡았다. <small>물론 매우 매우 어렵기 때문에 모든 것을 이해하는 것은 (나는) 힘들다. 가볍지만 꼼꼼하게 읽으면서 대략적인 맥락을 파악하는 것을 추천한다!</small> <br></p>\n<p>이후에 구현되어 있었던 pytorch를 활용한 딥러닝 모델 예시를 보게 되었고 참고하여 응용하면서 아주 간단한 딥러닝 영화 개인화 추천 모델을 구현하였다. 이번 포스트는 해당 개발의 초반, 데이터 전처리에 관한 내용을 다룰 예정이다. 전체 코드를 보고 싶다면 다음 <a href=\"https://github.com/yjksw/DeepLearning_Movie_Recommendation_System\">github repo</a>를 참고하시길. <br></p>\n<h2 id=\"데이터-모양새\" style=\"position:relative;\"><a href=\"#%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%AA%A8%EC%96%91%EC%83%88\" aria-label=\"데이터 모양새 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>데이터 모양새</h2>\n<p>딥러닝 개인화 추천 모델 구현을 시작하면서 가장 먼저 한 일은 입력 데이터의 형식에 대해서 파악한 것이다. 본 모델을 사용자와 영화 아이템, 그리고 해당  영화에 대한 각 사용자의 ratings 데이터를 담고 있는 MovieLens 데이터를 사용하였다. 해당 사이트에 가서 원하는 파일을 다운받아서 열면 다음과 같은 형식으로 데이터가 담겨져 있다. <br></p>\n<p><img src=\"https://user-images.githubusercontent.com/63405904/110306953-c027de80-8041-11eb-838e-1ca3bf9957f2.png\" alt=\"image\"> <br></p>\n<p>해당 csv. 파일을 읽어서 validation 과 test 데이터를 나누어야 한다. 다음 명령어를 써서 읽은 csv 파일 data frame에 대한 마스크를 씌울 수 있다. <br></p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">msk <span class=\"token operator\">=</span> np<span class=\"token punctuation\">.</span>random<span class=\"token punctuation\">.</span>rand<span class=\"token punctuation\">(</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">0.8</span></code></pre></div>\n<p>나는 구현할 때 80% 정도의 데이터를 학습 데이터로, 나머지 20%의 데이터를 검증 데이터로 사용했다. <br></p>\n<h2 id=\"데이터-전처리\" style=\"position:relative;\"><a href=\"#%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%A0%84%EC%B2%98%EB%A6%AC\" aria-label=\"데이터 전처리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>데이터 전처리</h2>\n<p>데이터 전처리에서 해야할 일들은 매우 간단하다. 기본적으로 학습 데이터와 검증 데이터는 모두 비슷한 과정의 데이터 전처리 과정을 거치지만 개인화 추천을 위한 영화 데이터에 대해서 구현할 때는 검증 데이터 전처리에 관해 조금 다른 부분이 필요하기도 하다. <br></p>\n<p>학습에서 사용되는 데이터는 ratings.csv 파일에서도 특히 <em>userId</em>와 <em>movieId</em> 부분이다. 따라서 해당 column를 하나씩 끌어다가 전처리를 해주어야 한다. 여기서 필요한 전처리 과정은 다음과 같다. <br></p>\n<ol>\n<li>중복을 제거하여 순수한 유저와 아이템 리스트 갯수 및 리스트 생성</li>\n<li>학습 데이터가 아닌 검증 또는 테스트 데이터일 경우, 학습 데이터에 존재하지 않는 유저와 아이템에 대하여 -1 처리하여 제외</li>\n</ol>\n<p><strong>1번</strong> 과정이 필요한 이유는 이후에 신경망 layers를 쌓고 임베딩 할 때에 pytorch의 모듈을 사용하여서 임베딩 테이블을 생성해야하기 때문이다. <strong>2번</strong> 과정이 필요한 이유는 검증 또는 테스트 데이터에 학습 데이터로 학습되지 않은 전혀 새로운 유저나 영화가 나왔을 경우, 제대로 예측할 수 없기 때문에 미리 제거해 주는 것이다. <br></p>\n<h2 id=\"코드\" style=\"position:relative;\"><a href=\"#%EC%BD%94%EB%93%9C\" aria-label=\"코드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>코드</h2>\n<p>위의 데이터 전처리를 하기 위해서 유용한 몇가지 파이썬 코드를 소개한다. <br></p>\n<ol>\n<li>데이터 columns의 중복제거</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">uni <span class=\"token operator\">=</span> train_col<span class=\"token punctuation\">.</span>unique<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>위 메소드는 입력으로 들어온 column에 대해서 중복을 제거한 리스트를 uni 변수에 저장해준다. </p>\n<ol start=\"2\">\n<li>존재하지 않는 아이템에 대하여 -1 처리하기</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">np<span class=\"token punctuation\">.</span>array<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>name2idx<span class=\"token punctuation\">.</span>get<span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">for</span> x <span class=\"token keyword\">in</span> col<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>여기서 name2idx는 중복이 없는 순수한 유저 또는 아이템 리스트와 해당 index이다. 위와 같은 코드를 실행하면 name2idx에서 해당 col에 있는 x 값이 있다면 해당 값을 가져오고, 그렇지 않다면 -1을 입력하도록 하는 간편한 파이썬 문법이다. <br></p>\n<p>이후에 학습 데이터에 존재하지 않는 유저 또는 아이템이 음수로 들어와 있으니 해당 처리를 다음과 같이하면 제외하고 검증 및 테스트 할 수 있다. <br></p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">df <span class=\"token operator\">=</span> df<span class=\"token punctuation\">[</span>df<span class=\"token punctuation\">[</span>col_name<span class=\"token punctuation\">]</span> <span class=\"token operator\">>=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">]</span></code></pre></div>\n<h2 id=\"결과-화면\" style=\"position:relative;\"><a href=\"#%EA%B2%B0%EA%B3%BC-%ED%99%94%EB%A9%B4\" aria-label=\"결과 화면 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>결과 화면</h2>\n<p>위와 같은 데이터 전처리를 끝내면 다음과 같은 전처리된 데이터가 생성된다. 물론 임베딩하는 전처리가 추가로 필요하지만 다음 포스트에서 학습과 함께 다루도록 하겠다. 결과 화면의 데이터는 csv의 데이터와 크게 차이가 없이 지저분한 데이터들을 제외하고 처리해 놓은 데이터라고 생각하면 된다. <br></p>\n<p><img src=\"https://user-images.githubusercontent.com/63405904/110306884-b00fff00-8041-11eb-91f0-51660920fbcf.png\" alt=\"image\"></p>\n<p><strong><small> [참고 자료]: <a href=\"https://jyoondev.tistory.com/65\">https://jyoondev.tistory.com/65</a> </small></strong></p>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%AA%A8%EC%96%91%EC%83%88\">데이터 모양새</a></li>\n<li><a href=\"#%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%A0%84%EC%B2%98%EB%A6%AC\">데이터 전처리</a></li>\n<li><a href=\"#%EC%BD%94%EB%93%9C\">코드</a></li>\n<li><a href=\"#%EA%B2%B0%EA%B3%BC-%ED%99%94%EB%A9%B4\">결과 화면</a></li>\n</ul>\n</div>","frontmatter":{"date":"August 21, 2020","title":"[머신러닝] 딥러닝 영화 개인화 추천 - Part.1","categories":"머신러닝","author":"코다","emoji":"🪄"},"fields":{"slug":"/movie-dlrm-1/"}},"site":{"siteMetadata":{"siteUrl":"https://yjksw.github.io","comments":{"utterances":{"repo":"yjksw/yjksw.github.io"}}}}},"pageContext":{"slug":"/ml-recommendation-system/","nextSlug":"/java-list/","prevSlug":"/movie-dlrm-1/"}},"staticQueryHashes":["1073350324","2938748437"]}
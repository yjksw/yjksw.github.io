{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/java-cqs/",
    "result": {"data":{"cur":{"id":"8316d4d6-553f-5d70-b995-11dc98735d16","html":"<h2 id=\"intro\" style=\"position:relative;\"><a href=\"#intro\" aria-label=\"intro permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Intro</h2>\n<p>함수는 <strong>시스템의 상태를 바꾸는지</strong>에 따라서 크게 두 가지로 나뉜다. 1) Command 2) Query. 이 두 가지 분류법에 대해서 하나의 함수가 두 가지 경우를 모두 담당하는 것은 좋지 않다.</p>\n<br>\n<h2 id=\"command-vs-query\" style=\"position:relative;\"><a href=\"#command-vs-query\" aria-label=\"command vs query permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Command vs. Query</h2>\n<ul>\n<li>\n<p><strong>Query</strong></p>\n<p>주어진 쿼리에 대한 결과값을 반환하고 시스템의 상태를 변화시키지는 않는다.</p>\n<p>다른 값을 바꾸지 않고 오직 질문에만 대답한다.</p>\n<p>부작용에서 자유롭다. (read-only)</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\">list <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">print</span><span class=\"token punctuation\">(</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token number\">5</span></code></pre></div>\n</li>\n<li>\n<p><strong>Command</strong></p>\n<p>값을 반환하지 않아도 시스템의 상태를 변화시킨다. (영구적)</p>\n<p>부작용이 생길 여기자 있다. (mutator, modifier)</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\">list <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nlist<span class=\"token punctuation\">.</span><span class=\"token function\">reverse</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">print</span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">)</span>\n\n<span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span></code></pre></div>\n</li>\n</ul>\n<p>이렇게 함수를 두 가지로 나누는 것은 유용하다. 현재 사용하는 함수가 상태를 바꾸지 않는 query 라면 신뢰를 가지고 사용할 수 있다. 하지만 상태를 바꾸는 command라면 함수간 순서에 주의를 기울이고 부작용이 생길 여지를 인지하고 있어야 한다.</p>\n<br>\n<h2 id=\"cqs---command-query-separation\" style=\"position:relative;\"><a href=\"#cqs---command-query-separation\" aria-label=\"cqs   command query separation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CQS - Command Query Separation</h2>\n<p><em><strong>Betrand Meyer</strong></em>라는 프랑스 학자는 하나의 함수가 command 이거나 query 이어야 한다고 주장한다. 이러한 프로그램 원칙을 CQS라고 하며 한 함수에서는 둘은 분명히 구분해야 한다고 말했다. <br></p>\n<p>하지만 스택의 pop() 연산 같은 경우는 위 두가지를 모두 담당하기도 한다. 이러한 예외 상황은 융통성 있게 허용하는 것이 전반적으로 더 효율적일 수 있다. <br></p>\n<p>위 개념은 현재 진행중인 프로젝트에서 다음과 같은 코드에 대한 크루의 코드리뷰로 접하게 되었다. <br></p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">Post</span> newPost <span class=\"token operator\">=</span> post<span class=\"token punctuation\">.</span><span class=\"token function\">update</span><span class=\"token punctuation\">(</span>updatedContent<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>위와 같은 경우 CQS를 준수하지 않은 것이므로 둘 중 하나를 담당하도록 구현로직을 바꾸고 필요하면 재조회하는 방향으로 리팩토링 했다. <br></p>\n<br>\n<br>\n<p><strong>[참고자료]</strong></p>\n<ul>\n<li><a href=\"https://shoark7.github.io/programming/knowledge/command-and-query-method\">https://shoark7.github.io/programming/knowledge/command-and-query-method</a></li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#intro\">Intro</a></li>\n<li><a href=\"#command-vs-query\">Command vs. Query</a></li>\n<li><a href=\"#cqs---command-query-separation\">CQS - Command Query Separation</a></li>\n</ul>\n</div>","excerpt":"Intro 함수는 시스템의 상태를 바꾸는지에 따라서 크게 두 가지로 나뉜다. 1) Command 2) Query. 이 두 가지 분류법에 대해서 하나의 함수가 두 가지 경우를 모두 담당하는 것은 좋지 않다. Command vs. Query Query 주어진 쿼리에 대한 결과값을 반환하고 시스템의 상태를 변화시키지는 않는다. 다른 값을 바꾸지 않고 오직 질문에만 대답한다. 부작용에서 자유롭다. (read-only) Command 값을 반환하지 않아도 시스템의 상태를 변화시킨다. (영구적) 부작용이 생길 여기자 있다. (mutator, modifier) 이렇게 함수를 두 가지로 나누는 것은 유용하다. 현재 사용하는 함수가 상태를 바꾸지 않는 query 라면 신뢰를 가지고 사용할 수 있다. 하지만 상태를 바꾸는 command라면 함수간 순서에 주의를 기울이고 부작용이 생길 여지를 인지하고 있어야 한다. CQS - Command Query Separation Betrand Meyer라는 프…","frontmatter":{"date":"July 17, 2021","title":"CQS(Command Query Separation) 간단히 알아보기","categories":"자바","author":"코다","emoji":"✊"},"fields":{"slug":"/java-cqs/"}},"next":{"id":"0574f453-d5ef-573e-bcb2-ee85bc19c34e","html":"<h2 id=\"동시성-문제-발생-가능-상황\" style=\"position:relative;\"><a href=\"#%EB%8F%99%EC%8B%9C%EC%84%B1-%EB%AC%B8%EC%A0%9C-%EB%B0%9C%EC%83%9D-%EA%B0%80%EB%8A%A5-%EC%83%81%ED%99%A9\" aria-label=\"동시성 문제 발생 가능 상황 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>동시성 문제 발생 가능 상황</h2>\n<p>두개의 트랜잭션이 모두 읽는 연산을 하는 경우 문제가 되지 않는다.</p>\n<ul>\n<li>하나의 트랜잭션은 read, 하나는 write인 경우 (<strong>Isolation</strong>으로 해결)\n<ul>\n<li>\n<p><strong>Dirty Read</strong></p>\n<p><strong>상황</strong>: 트랜잭션1이 write 할 때 트랜잭션2가 update된 데이터를 읽었지만 트랜잭션1이 rollback 되었을 때 발생 <br></p>\n<p><strong>문제</strong>: 트랜잭션2가 무효된 데이터를 읽었음 <br></p>\n</li>\n<li>\n<p><strong>Non-repeatable Read</strong></p>\n<p><strong>상황</strong>: 트랜잭션1이 데이터를 read하고, 트랜잭션2가 데이터를 write 한 후, 트랜잭션1이 다시 동일한 데이터를 read 할 경우에 발생 <br></p>\n<p><strong>문제</strong>: 트랜잭션이 1이 동일한 read를 했음에도 불구하고 바뀐 데이터를 읽음 <br></p>\n</li>\n<li>\n<p><strong>Phantom Read</strong></p>\n<p><strong>상황</strong>: 트랜잭션1이 데이터(범위)를 read하고, 트랜잭션 2가 데이터를 추가(insert) 했는데, 트랜잭션1이 다시 데이터를 read한 경우 <br></p>\n<p><strong>문제</strong>: 동일한 read를 실행하였는데, 이전에 없었던 값이 추가됨 <br></p>\n</li>\n</ul>\n</li>\n<li>두개의 트랜잭션이 모두 wrtie인 경우 (<strong>Currency Control</strong>로 해결)\n<ul>\n<li>\n<p><strong>Lost Update</strong></p>\n<p><strong>상황</strong>: 두개의 트랜잭션이 한 개의 데이터를 동시에 update 할 때 발생 <br></p>\n<p><strong>문제</strong>: 하나의 트랜잭션의 내용을 다른 트랜잭션이 덮어씀으로 이전에 update 한 내용이 손실됨 <br></p>\n</li>\n<li>\n<p><strong>Inconsistency(or Unrecoverability)</strong></p>\n<p><strong>상황</strong>: 한 트랜잭션(T1)이 두개의 일관된 값을 읽어야하는데 다른 트랜잭션(T2)이 그 사이에 실행될 때 발생 <br></p>\n<p><strong>문제</strong>: <code class=\"language-text\">T1</code>이 두개의 값 <code class=\"language-text\">X</code>, <code class=\"language-text\">Y</code>를 읽어 수정할 때, <code class=\"language-text\">T1</code>이 <code class=\"language-text\">X</code>만 읽어서 수정한 상태에서 <code class=\"language-text\">T2</code>가 <code class=\"language-text\">X</code>와 <code class=\"language-text\">Y</code>를 수정하고 이후에 <code class=\"language-text\">T1</code>이 <code class=\"language-text\">Y</code>를 읽어 수정함. 이때 <code class=\"language-text\">T1</code>의 입장에서 하나는 갱신 이전의 값, 또 하나는 갱신 이후의 값을 읽어서 데이터가 불일치한 모순이 일어남. <br></p>\n</li>\n<li>\n<p><strong>Cascading Rollback</strong></p>\n<p><strong>상황</strong>: 한 트랜잭션(T1)이 두개의 값을 읽고 수정하는 사이에 다른 트랜잭션(T2)이 완료되었지만 T1이 rollback 되어야 할 때 발생<br></p>\n<p><strong>문제</strong>: <code class=\"language-text\">T1</code>이 두개의 값 <code class=\"language-text\">X</code>, <code class=\"language-text\">Y</code>를 읽어서 수정할 때, <code class=\"language-text\">T1</code>이 <code class=\"language-text\">X</code>를 수정한 상태에서 <code class=\"language-text\">T2</code>가 <code class=\"language-text\">X</code>를 수정하고 해당 트랜잭션을 완료함. 이후 <code class=\"language-text\">T1</code>에서 오류가 발생해 rollback이 되어야하는 상황에서 <code class=\"language-text\">T2</code>는 이미 완료되었으므로 <code class=\"language-text\">X</code> 값에 대한 rollback이 되지 못하여 문제가 발생함. <br></p>\n</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"트랜잭션-스케줄\" style=\"position:relative;\"><a href=\"#%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EC%8A%A4%EC%BC%80%EC%A4%84\" aria-label=\"트랜잭션 스케줄 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>트랜잭션 스케줄</h2>\n<p>위 문제를 해결하기 위해서 트랜잭션 스케줄을 통해 연산들의 실행 순서를 제어하여 데이터에 오류가 없도록 해야한다.</p>\n<ol>\n<li>\n<p>Serial Schedule 직렬 스케줄</p>\n<p>모든 트랜잭션이 순차적으로 실행</p>\n</li>\n<li>\n<p>Nonsercial Schedule 비직렬 스케줄</p>\n<p>트랜잭션이 상관없이 병행하여 실행</p>\n</li>\n<li>\n<p>Serializable Schedule 직렬 가능 스케줄</p>\n<p>서로 영향을 주지 않는 스케줄의 경우 병행 실행하고, 나머지는 실행 순서를 제어하여 실행</p>\n</li>\n</ol>\n<p>직렬 스케줄의 경우 오류가 생기지 않도록 보장할 수는 있지만, 효율이 떨어진다는 단점이 있다. 따라서 트랜잭션을 최대한 직렬 가능한 스케줄로 만드는 것이 중요하고 <strong>Locking</strong> 기법을 통해서 트랜잭션 실행 순서를 제어해 직렬 가능한 스케줄로 만들어 데이터에 생길 수 있는 오류를 제어한다. <br></p>\n<p>예를 들어, 두개의 트랜잭션이 모두 READ 연산을 한다면 연산 순서가 중요하지 않으므로 병행 실행한다. <br></p>\n<p>또 두개의 트랜잭션이 다른 데이터에 접근한다면 연산 순서가 중요하지 않으므로 병행 실행한다. <br></p>\n<p>만일 한 데이터에 대해서 읽고 쓰는 작업이 한꺼번에 발생한다면 실행순서가 중요하므로 Lock을 통해서 그 순서를 제어한다. <br></p>\n<br>\n<h2 id=\"locking-기법\" style=\"position:relative;\"><a href=\"#locking-%EA%B8%B0%EB%B2%95\" aria-label=\"locking 기법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Locking 기법</h2>\n<p>여러 트랜잭션이 동일한 데이터에 대해서 병행 접근을 하지 못하도록 제어해서 데이터간 문제가 발생하지 않도록 하는 기법</p>\n<ul>\n<li>\n<p>Shared-lock 공유락</p>\n<p>읽기를 할 때 거는 lock <br></p>\n<p>read 트랜잭션은 서로 영향을 주지 않으므로 shared-lock이 걸린 상태에서 추가 shared-lock을 걸 수 있음 <br></p>\n<p>read 트랜잭션 중 쓰기가 발생할 경우 데이터가 손상되어 문제가 발생하므로 추가 exclusive-lock은 걸 수 없음 <br></p>\n</li>\n<li>\n<p>Exclusive-lock 베타락</p>\n<p>읽고 쓰기를 할 때 거는 lock <br></p>\n<p>write 트랜잭션은 읽거나 쓰는 트랜잭션 모두에게 영향을 주기 때문에 exclusive-lock이 걸린 상태에서는 다른 lock을 걸 수 없음 <br></p>\n</li>\n</ul>\n<h3 id=\"2단계-로킹-규약-2plp\" style=\"position:relative;\"><a href=\"#2%EB%8B%A8%EA%B3%84-%EB%A1%9C%ED%82%B9-%EA%B7%9C%EC%95%BD-2plp\" aria-label=\"2단계 로킹 규약 2plp permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2단계 로킹 규약 2PLP</h3>\n<p>lock을 걸고 해제할 때 제한을 두어서 두 트랜잭션이 동시 실행되면서 생기는 데이터 일관성이 깨지는 현상을 방지하는 것이다. 로킹 단계를 2가지로 구분 지어서, 각 단계에 다른 제한을 두어 트랜잭션 동시 실행으로 발생할만한 데이터 오류를 방지한다.</p>\n<ul>\n<li>\n<p>Growing Phase 확장 단계</p>\n<p>해당 트랜잭션이 새로운 Lock 연산은 가능하나 unlock 연산을 가능하지 않은 상태</p>\n</li>\n<li>\n<p>Shrinking Phase 축소 단계</p>\n<p>해당 트랜잭션이 unlock 연산만 가능하고 lock 연산은 가능하지 않은 상태</p>\n</li>\n</ul>\n<p>하지만 2PLP을 준수하므로 <strong>deadlock</strong>이 발생할 여지가 있다. <br></p>\n<p>→ 2단계 로킹 규약을 적용하지 않아서 데이터의 일관성이 깨진 경우 <br></p>\n<p align=\"center\"><img width=\"85%\" src=\"https://user-images.githubusercontent.com/63405904/135496848-c9c42362-63c5-493f-a2e9-fcd05f5cf6c6.png\"></p>\n<p>→ 2단계 로킹 기법을 사용하여 일관성 문제 해결한 경우 <br></p>\n<p align=\"center\"><img width=\"85%\" src=\"https://user-images.githubusercontent.com/63405904/135496984-e425dd70-3f11-4718-a42e-28513c3452bb.png\"></p>\n<h3 id=\"deadlock-데드락-교착상태\" style=\"position:relative;\"><a href=\"#deadlock-%EB%8D%B0%EB%93%9C%EB%9D%BD-%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9C\" aria-label=\"deadlock 데드락 교착상태 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Deadlock 데드락 (교착상태)</h3>\n<p>두개의 트랜잭션이 각자의 데이터에 lock을 걸어놓고 상대의 데이터에 요청을 하므로 무한 대기 상태에 빠지게 되는 문제</p>\n<br>\n<h2 id=\"트랜잭션-isolation-level\" style=\"position:relative;\"><a href=\"#%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-isolation-level\" aria-label=\"트랜잭션 isolation level permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>트랜잭션 Isolation Level</h2>\n<ul>\n<li>\n<p><strong>READ UNCOMMITTED (LEVEL 0)</strong></p>\n<p>데이터를 읽을 때 shared-lock을 걸지 않고, write 작업 시 exclusive-lock만 거는 것(갱신손실문제 방지) <br></p>\n<p>다른 트랜잭션에 shared-lock/exclusive-lock이 걸렸더라도 데이터를 대기하지 않고 읽는 것<br></p>\n<p>따라서 Dirty read, non-repeatable read, phantom read 모두 방지할 수 없다.<br></p>\n</li>\n<li>\n<p><strong>READ COMMITED (LEVEL 1)</strong></p>\n<p>데이터를 읽을 때 shared-lock을 걸지만, 트랜잭션이 끝나기 전에도 unlock 가능<br></p>\n<p>다른 트랜잭션에 shared-lock이 걸렸다면 데이터를 읽지만, exclusive-lock이 걸린 경우에는 읽지 못함<br></p>\n<p>Dirty read 방지 가능, non-repeatable read, phantom read 방지 불가능<br></p>\n</li>\n<li>\n<p><strong>REPEATABLE READ (LEVEL 2)</strong></p>\n<p>본 데이터에 설정된 shared-lock과 exclusive-lock을 트랜잭션 종료시까지 유지<br></p>\n<p>트랜잭션이 완료될 때까지 SELECT문이 사용하는 모든 데이터에 대해서 shared-lock이 걸린다. 따라서 update가 불가능하지만, insert에 대해서는 다른 제약이 없다.<br></p>\n<p>다른 트랜잭션이 공유한 공유락은 읽고, 배타락은 읽지 않음<br></p>\n<p>다른 isolation level에 비해서 동시성이 낮아 잘 사용하지 않는 것을 추천<br></p>\n<p>Dirty read, non-repeatable read 방지, phantom read 방지 불가능<br></p>\n</li>\n<li>\n<p><strong>SERIALIZABLE (LEVEL 3)</strong></p>\n<p>데이터의 집합 범위에 잠금을 설정함<br></p>\n<p>다른 사용자가 데이터를 update 혹은 insert 할 때 모두 트랜잭션을 격리함<br></p>\n<p>트랜잭션이 완료될 때까지 SELECT문이 사용하는 모든 데이터에 대해서 shared-lock이 걸린다.<br></p>\n<p><strong>인덱스에 공유락을 설정</strong>한다. 따라서 다른 트랜잭션의 insert가 불가능<br></p>\n<p>Dirty read, non-repeatable read, phantom read 방지 <br></p>\n</li>\n</ul>\n<br>\n<br>\n<p><strong>[참고링크]</strong></p>\n<ul>\n<li><a href=\"https://mangkyu.tistory.com/30\">https://mangkyu.tistory.com/30</a></li>\n<li><a href=\"https://medium.com/pocs/%EB%8F%99%EC%8B%9C%EC%84%B1-%EC%A0%9C%EC%96%B4-%EA%B8%B0%EB%B2%95-%EC%9E%A0%EA%B8%88-locking-%EA%B8%B0%EB%B2%95-319bd0e6a68a\">https://medium.com/pocs/동시성-제어-기법-잠금-locking-기법-319bd0e6a68a</a></li>\n<li><a href=\"https://goodmilktea.tistory.com/62\">https://goodmilktea.tistory.com/62</a>## 동시성 문제 발생 가능 상황</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#%EB%8F%99%EC%8B%9C%EC%84%B1-%EB%AC%B8%EC%A0%9C-%EB%B0%9C%EC%83%9D-%EA%B0%80%EB%8A%A5-%EC%83%81%ED%99%A9\">동시성 문제 발생 가능 상황</a></p>\n</li>\n<li>\n<p><a href=\"#%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EC%8A%A4%EC%BC%80%EC%A4%84\">트랜잭션 스케줄</a></p>\n</li>\n<li>\n<p><a href=\"#locking-%EA%B8%B0%EB%B2%95\">Locking 기법</a></p>\n<ul>\n<li><a href=\"#2%EB%8B%A8%EA%B3%84-%EB%A1%9C%ED%82%B9-%EA%B7%9C%EC%95%BD-2plp\">2단계 로킹 규약 2PLP</a></li>\n<li><a href=\"#deadlock-%EB%8D%B0%EB%93%9C%EB%9D%BD-%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9C\">Deadlock 데드락 (교착상태)</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-isolation-level\">트랜잭션 Isolation Level</a></p>\n</li>\n</ul>\n</div>","frontmatter":{"date":"July 01, 2021","title":"Transaction의 동시성 제어(Currency Control)","categories":"데이터베이스","author":"코다","emoji":"💾"},"fields":{"slug":"/database-transaction-currency-control/"}},"prev":{"id":"21638d95-ab20-5ddc-8832-ed946e1a5c04","html":"<h2 id=\"lazyinitialization-에러-발생-이유\" style=\"position:relative;\"><a href=\"#lazyinitialization-%EC%97%90%EB%9F%AC-%EB%B0%9C%EC%83%9D-%EC%9D%B4%EC%9C%A0\" aria-label=\"lazyinitialization 에러 발생 이유 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>LazyInitialization 에러 발생 이유</h2>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\">    <span class=\"token class-name\">LazyInitializationException</span><span class=\"token operator\">:</span> could not initialize proxy <span class=\"token operator\">-</span> no session</code></pre></div>\n<ul>\n<li>Lazy Loading을 하려고 하는데 세션이 사라져서 프록시 초기화가 불가능해 지연로딩을 못하는 경우에 발생하는 에러</li>\n<li>가장 단순한 방법으로는 <code class=\"language-text\">FetchType</code> 을 <code class=\"language-text\">EAGER</code>로 설정해서 일괄적으로 부모 호출시 자식이 모두 즉시로딩으로 초기화되도록 하면 되지만, 비니지스적인 이유가 아닌 <code class=\"language-text\">LazyInitialization</code>을 피하기 위해 <code class=\"language-text\">EAGER</code>로 설정하는 것은 좋지 않다.</li>\n<li>위 에러는 Lazy Loading을 하는 시점까지 session을 유지시켜주는 것이 핵심이며 주로 <code class=\"language-text\">@Transactional</code> 추가로 해당 문제는 해결된다.</li>\n</ul>\n<br>\n<h2 id=\"서비스-외부에서-lazyloading-collection-호출-시\" style=\"position:relative;\"><a href=\"#%EC%84%9C%EB%B9%84%EC%8A%A4-%EC%99%B8%EB%B6%80%EC%97%90%EC%84%9C-lazyloading-collection-%ED%98%B8%EC%B6%9C-%EC%8B%9C\" aria-label=\"서비스 외부에서 lazyloading collection 호출 시 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>서비스 외부에서 LazyLoading Collection 호출 시</h2>\n<p>서비스에서 LazyLoading을 하고 싶다면 <code class=\"language-text\">@Transactional</code> 을 붙여서 해결할 수 있지만 간혹 서비스 클래스 밖에서 지연로딩 지정되어 있는 컬렉션을 조회해야할 때가 있다. 그럴 때 <code class=\"language-text\">LazyInitialization</code> 에러를 피할 수 있는 방법은 두가지이다.</p>\n<h3 id=\"1-code-classlanguage-texthibernateinitializecode를-사용해-서비스-내에서-조회\" style=\"position:relative;\"><a href=\"#1-code-classlanguage-texthibernateinitializecode%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%B4-%EC%84%9C%EB%B9%84%EC%8A%A4-%EB%82%B4%EC%97%90%EC%84%9C-%EC%A1%B0%ED%9A%8C\" aria-label=\"1 code classlanguage texthibernateinitializecode를 사용해 서비스 내에서 조회 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. <code class=\"language-text\">Hibernate.initialize()</code>를 사용해 서비스 내에서 조회</h3>\n<p>만일 서비스가 아닌 다른 클래스 내에서 JPA 조회를 하고 싶다면 세션이 유지되지 않는다. (<code class=\"language-text\">@Transactional</code> 어노테이션을 붙이는 것이나, <code class=\"language-text\">FetchType.EAGER</code> 을 붙이는 것이 모두 부적합하거나 비효율적이다) <br></p>\n<p>이때는 해당 컬렉션을 조회하는 메서드를 서비스 내에 만들어 호출하여 사용하고, 해당 메서드 내에서 <code class=\"language-text\">Hibernate.initialize(Entity)</code> 를 사용해서 프록시가 즉시 초기화 되도록 하면 된다. <br></p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Transactional</span><span class=\"token punctuation\">(</span>readOnly <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">public</span> <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Task</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">getTaskListEager</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Long</span> taskId<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Task</span><span class=\"token punctuation\">></span></span> taskList <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>tasksRepository<span class=\"token punctuation\">.</span><span class=\"token function\">findOne</span><span class=\"token punctuation\">(</span>taskId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getTaskList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token class-name\">Hibernate</span><span class=\"token punctuation\">.</span><span class=\"token function\">initialize</span><span class=\"token punctuation\">(</span>taskList<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">return</span> taskList<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li><strong>주의할 점:</strong> <code class=\"language-text\">Hibernate.initialize()</code> 는 그 안에 중첩되어 있는 LazyCollection에 대해서는 가지고오지 못하므로 그것에 대한 <code class=\"language-text\">Hibernate.initialize()</code>는 따로 해줘야한다.</li>\n</ul>\n<h3 id=\"2-transactionmanager-사용\" style=\"position:relative;\"><a href=\"#2-transactionmanager-%EC%82%AC%EC%9A%A9\" aria-label=\"2 transactionmanager 사용 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. TransactionManager 사용</h3>\n<p>어노테이션이 아니라 Spring에서 제공해주는 TransactionManager를 직접 사용해서 session을 직접 지정하도록 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Autowired</span>\n<span class=\"token keyword\">private</span> <span class=\"token class-name\">PlatformTransactioinManager</span> transactionManager<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Task</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">getTaskListEager</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Long</span> tasksId<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token class-name\">TransactionStatus</span> transactionStatus <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>transactionManager<span class=\"token punctuation\">.</span><span class=\"token function\">getTransaction</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">DefaultTransactionDefinition</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Task</span><span class=\"token punctuation\">></span></span> taskList <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n\t\ttaskList <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>tasksRepository<span class=\"token punctuation\">.</span><span class=\"token function\">findOne</span><span class=\"token punctuation\">(</span>tasksId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getTaskList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>transactionManager<span class=\"token punctuation\">.</span><span class=\"token function\">commit</span><span class=\"token punctuation\">(</span>transactionStatus<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>transactionManager<span class=\"token punctuation\">.</span><span class=\"token function\">rollback</span><span class=\"token punctuation\">(</span>transactionStatus<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\n\t<span class=\"token keyword\">return</span> taskList<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><strong>[참고자료]</strong></p>\n<ul>\n<li><a href=\"https://thorben-janssen.com/lazyinitializationexception/\">https://thorben-janssen.com/lazyinitializationexception/</a></li>\n<li><a href=\"https://github.com/HomoEfficio/dev-tips/blob/master/Spring%20Data%20JPA%20-%20LazyInitialization%20%EC%97%90%EB%9F%AC%20-%20getOne().md\">https://github.com/HomoEfficio/dev-tips/blob/master/Spring Data JPA - LazyInitialization 에러 - getOne().md</a></li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#lazyinitialization-%EC%97%90%EB%9F%AC-%EB%B0%9C%EC%83%9D-%EC%9D%B4%EC%9C%A0\">LazyInitialization 에러 발생 이유</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%84%9C%EB%B9%84%EC%8A%A4-%EC%99%B8%EB%B6%80%EC%97%90%EC%84%9C-lazyloading-collection-%ED%98%B8%EC%B6%9C-%EC%8B%9C\">서비스 외부에서 LazyLoading Collection 호출 시</a></p>\n<ul>\n<li><a href=\"#1-hibernateinitialize%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%B4-%EC%84%9C%EB%B9%84%EC%8A%A4-%EB%82%B4%EC%97%90%EC%84%9C-%EC%A1%B0%ED%9A%8C\">1. <code class=\"language-text\">Hibernate.initialize()</code>를 사용해 서비스 내에서 조회</a></li>\n<li><a href=\"#2-transactionmanager-%EC%82%AC%EC%9A%A9\">2. TransactionManager 사용</a></li>\n</ul>\n</li>\n</ul>\n</div>","frontmatter":{"date":"August 04, 2021","title":"LazyInitializationException 란?","categories":"JPA","author":"코다","emoji":"🚀"},"fields":{"slug":"/jpa-lazyinitialization-exception/"}},"site":{"siteMetadata":{"siteUrl":"https://yjksw.github.io","comments":{"utterances":{"repo":"yjksw/yjksw.github.io"}}}}},"pageContext":{"slug":"/java-cqs/","nextSlug":"/database-transaction-currency-control/","prevSlug":"/jpa-lazyinitialization-exception/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}
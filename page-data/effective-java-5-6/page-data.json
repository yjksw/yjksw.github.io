{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/effective-java-5-6/",
    "result": {"data":{"cur":{"id":"a5553174-ae11-5345-ad78-f1dd71b83e72","html":"<blockquote>\n<p>이 글은 몇몇 크루들과 이펙티브 자바 스터디를 하며 정리한 내용입니다. 🙌</p>\n</blockquote>\n<h2 id=\"-아이템-5-자원을-직접-명시하지-말고-의존-객체-주입을-사용하라\" style=\"position:relative;\"><a href=\"#-%EC%95%84%EC%9D%B4%ED%85%9C-5-%EC%9E%90%EC%9B%90%EC%9D%84-%EC%A7%81%EC%A0%91-%EB%AA%85%EC%8B%9C%ED%95%98%EC%A7%80-%EB%A7%90%EA%B3%A0-%EC%9D%98%EC%A1%B4-%EA%B0%9D%EC%B2%B4-%EC%A3%BC%EC%9E%85%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC\" aria-label=\" 아이템 5 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 [아이템 5] 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라</h2>\n<p>하나의 클래스에서 다른 자원에 의존하는 경우가 많다. 또한 해당 클래스가 유틸리티 클래스라면 싱글톤이나 정적 클래스로 사용되는 경우가 많다.</p>\n<blockquote>\n<p>정적 클래스로 구현한 경우</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">SpellChecker</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">Lexicon</span> dictionary <span class=\"token operator\">=</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">;</span>\n\t\n\tpriavte <span class=\"token class-name\">SpellChecker</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n\t<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">isValid</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> word<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<br>\n<blockquote>\n<p>싱글톤으로 구현한 경우</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">SpellChecker</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">Lexicon</span> dictionary <span class=\"token operator\">=</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">SpellChecker</span> INSTANCE <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SpellChecker</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\n\tpriavte <span class=\"token class-name\">SpellChecker</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n\t<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">isValid</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> word<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>그런 경우 여러 단점이 발생한다.</p>\n<ol>\n<li>유연하지 않다.\n<ul>\n<li>안에 의존하고 있는 객체를 런타임 시점에 바꾸거나 조작하기가 어렵다.</li>\n<li>여러 다른 사전들을 이용하고 싶을 때 변경에 자유롭지 못하다.</li>\n</ul>\n</li>\n<li>테스트하기 어렵다.\n<ul>\n<li>정적으로 의존 객체를 내부에서 생성하므로 모킹하거나 해당 객체에 대한 조작으로 테스트를 하기 어렵다.</li>\n</ul>\n</li>\n</ol>\n<br>\n<h3 id=\"의존성-주입di을-통해-해결하기\" style=\"position:relative;\"><a href=\"#%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%A3%BC%EC%9E%85di%EC%9D%84-%ED%86%B5%ED%95%B4-%ED%95%B4%EA%B2%B0%ED%95%98%EA%B8%B0\" aria-label=\"의존성 주입di을 통해 해결하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>의존성 주입(DI)을 통해 해결하기</h3>\n<p>위 문제에 대한 가능한 해결방법이 DI 말고 하나가 더 있다.</p>\n<ul>\n<li>변경에 대한 유연성을 부여하기 위해 <code class=\"language-text\">final</code>을 제거하고 여러 사전들을 바꿔서 사용할 수 있도록 한다.\n<ul>\n<li>이렇게 할 경우 멀티스레드 환경에 취약하고 오류를 내기가 쉽다.</li>\n</ul>\n</li>\n</ul>\n<p>따라서 DI를 통해서 문제를 해결해본다.</p>\n<p>DI란 클래스에서 필요한 자원을 내부에서 생성하는 것이 아니라 인스턴스를 생성할 때 생성자에 필요한 자원을 넘겨주는 방식으로 구현하는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">SpellChecker</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">Lexicon</span> dictionary<span class=\"token punctuation\">;</span>\n\t\n\tpriavte <span class=\"token class-name\">SpellChecker</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Lexicon</span> dictionary<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>dictionary <span class=\"token operator\">=</span> <span class=\"token class-name\">Objects</span><span class=\"token punctuation\">.</span><span class=\"token function\">requireNonNul</span><span class=\"token punctuation\">(</span>dictionary<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\n\t<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">isValid</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> word<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>여러 자원에 대한 의존 관계에 자유로우며 유연하다.</li>\n<li>불변을 보장하여 여러 클라이언트에 대한 공유에 안정적이다.</li>\n</ul>\n<p>추가적으로 특정 자원을 직접 넘겨주기보다 팩터리를 넘겨주어 필요시 자원을 클래스 내부에서 직접 생성할 수 있도록 할 수도 있다. 이때 <code class=\"language-text\">Supplier&lt;T></code> 처럼 한정적 와일드카드 타입(타입 안정성을 지원하는 Generic을 사용)을 통해 팩터리 매개변수를 넘겨서 필요한 자원을 생성하도록 한다.</p>\n<br>\n<h3 id=\"요약\" style=\"position:relative;\"><a href=\"#%EC%9A%94%EC%95%BD\" aria-label=\"요약 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>요약</h3>\n<ul>\n<li>클래스가 다른 자원에 의존한다면 그것을 직접 싱글톤이나 정적 클래스로 구현하는 것은 좋은 방법이 아니다.</li>\n<li>또한 그 자원들을 그 클래스가 직접 생성하도록 하지 않는 것이 더 좋다.</li>\n<li>대신 의존 객체 주입으로 외부에서 해당 자원이나 팩터리를 생성자나 정적 팩터리에 넘겨주도록 하자.</li>\n</ul>\n<br>\n<h2 id=\"-아이템-6-불필요한-객체-생성을-피하라\" style=\"position:relative;\"><a href=\"#-%EC%95%84%EC%9D%B4%ED%85%9C-6-%EB%B6%88%ED%95%84%EC%9A%94%ED%95%9C-%EA%B0%9D%EC%B2%B4-%EC%83%9D%EC%84%B1%EC%9D%84-%ED%94%BC%ED%95%98%EB%9D%BC\" aria-label=\" 아이템 6 불필요한 객체 생성을 피하라 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 [아이템 6] 불필요한 객체 생성을 피하라</h2>\n<p>현재 JVM의 성능이 좋아져 객체 생성이 이전만큼 비싼 작업은 아니지만 여전히 매번 생성하기에 무겁거나 지나치게 반복적으로 생성하여 성능에 안좋은 영향을 미치는 경우가 있다.</p>\n<p><strong>따라서 객체는 (특히 불변 객체는) 재사용할 수 있다면 재사용하는 것이 좋다.</strong></p>\n<br>\n<h3 id=\"string을-재사용-하자\" style=\"position:relative;\"><a href=\"#string%EC%9D%84-%EC%9E%AC%EC%82%AC%EC%9A%A9-%ED%95%98%EC%9E%90\" aria-label=\"string을 재사용 하자 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>String을 재사용 하자</h3>\n<ul>\n<li><code class=\"language-text\">new String(\"woowa\")</code> 는 만들때마다 heap영역에 새로운 객체를 생성한다. 만일 <code class=\"language-text\">new String(\"woowa\")</code> 를 두번 호출한다면 두개의 객체가 생성된다.</li>\n<li>반면 <code class=\"language-text\">String s = \"woowa\"</code> 를 호출한다면 heap영역 내부에 String constant pool에 객체가 생성되고 동일한 스트링이라면 재사용 한다.</li>\n</ul>\n<br>\n<h3 id=\"불변-클래스의-정적-팩터리-메서드로-객체를-재사용-하자\" style=\"position:relative;\"><a href=\"#%EB%B6%88%EB%B3%80-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%9D%98-%EC%A0%95%EC%A0%81-%ED%8C%A9%ED%84%B0%EB%A6%AC-%EB%A9%94%EC%84%9C%EB%93%9C%EB%A1%9C-%EA%B0%9D%EC%B2%B4%EB%A5%BC-%EC%9E%AC%EC%82%AC%EC%9A%A9-%ED%95%98%EC%9E%90\" aria-label=\"불변 클래스의 정적 팩터리 메서드로 객체를 재사용 하자 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>불변 클래스의 정적 팩터리 메서드로 객체를 재사용 하자</h3>\n<p>예를 들어 <code class=\"language-text\">Boolean(String)</code> 보다 <code class=\"language-text\">Boolean.valueOf(String)</code>을 사용하여 불변 객체를 재사용 하는 것이 더 빠르고 세련된 구현 방식이다.</p>\n<br>\n<h3 id=\"객체-생성이-비싼-객체라면-재사용-하자\" style=\"position:relative;\"><a href=\"#%EA%B0%9D%EC%B2%B4-%EC%83%9D%EC%84%B1%EC%9D%B4-%EB%B9%84%EC%8B%BC-%EA%B0%9D%EC%B2%B4%EB%9D%BC%EB%A9%B4-%EC%9E%AC%EC%82%AC%EC%9A%A9-%ED%95%98%EC%9E%90\" aria-label=\"객체 생성이 비싼 객체라면 재사용 하자 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>객체 생성이 비싼 객체라면 재사용 하자</h3>\n<p><code class=\"language-text\">String.matches()</code> 내부에서 사용되는 <code class=\"language-text\">Pattern</code> 객체는 매우 생성이 비싼 객체이다. 이 메서드를 반복해서 사용하면 내부에서 위 객체를 계속 생성하여 사용한다. 따라서 필요하다면 비교하고자 하는 정규식에 대한 <code class=\"language-text\">Pattern</code>을 미리 만들어두고 그것을 재사용하는 형식으로 사용하는 것이 훨씬 성능이 좋다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">RomanNumerals</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">Pattern</span> ROMAN <span class=\"token operator\">=</span> <span class=\"token class-name\">Pattern</span><span class=\"token punctuation\">.</span><span class=\"token function\">compile</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"정규식 ..\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">isRomanNumeral</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> s<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">return</span> ROMAN<span class=\"token punctuation\">.</span><span class=\"token function\">matcher</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">matches</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<br>\n<h3 id=\"오토박싱으로-생성되는-불필요한-객체를-주의하자\" style=\"position:relative;\"><a href=\"#%EC%98%A4%ED%86%A0%EB%B0%95%EC%8B%B1%EC%9C%BC%EB%A1%9C-%EC%83%9D%EC%84%B1%EB%90%98%EB%8A%94-%EB%B6%88%ED%95%84%EC%9A%94%ED%95%9C-%EA%B0%9D%EC%B2%B4%EB%A5%BC-%EC%A3%BC%EC%9D%98%ED%95%98%EC%9E%90\" aria-label=\"오토박싱으로 생성되는 불필요한 객체를 주의하자 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>오토박싱으로 생성되는 불필요한 객체를 주의하자</h3>\n<p>오토박싱으로 기본타입을 자동적으로 박싱된 타입으로 변환시켜준다. 하지만 명시적으로 객체를 생성하는 부분이 개발자에게 노출되지는 않기 때문에 예기치 않게 굉장히 많은 객체를 생성하고 있을 수도 있다. 따라서 성능에 큰 영향을 미칠수도 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">long</span> <span class=\"token function\">sum</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token class-name\">Long</span> sum <span class=\"token operator\">=</span> <span class=\"token number\">0L</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">long</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">.</span>MAX_VALUE<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\tsum <span class=\"token operator\">+=</span> i<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\n\t<span class=\"token keyword\">return</span> sum<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>예를 들어 위와 같은 코드는 sum 이라는 변수가 박싱타입으로 선언되어 있으므로 누적되는 <code class=\"language-text\">i</code>는 매번 <code class=\"language-text\">Long</code>으로 오토박싱되며 새로운 객체가 2^31개나 생성되는 일이 발생한다.</p>\n<p>이런 의도치 않은 오토박싱을 주의하고 되도록 기본타입을 사용하기를 추천한다.</p>\n<br>\n<h3 id=\"주의할-점\" style=\"position:relative;\"><a href=\"#%EC%A3%BC%EC%9D%98%ED%95%A0-%EC%A0%90\" aria-label=\"주의할 점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>주의할 점</h3>\n<p>객체 생성을 최대한 안하기 위해서 지나친 재사용을 하라는 뜻이 아니다. JVM에서 객체를 생성하는 것이 대부분 크게 부담되는 일이 아니기 때문에 프로그램의 안정성, 명확성, 간결성을 위해서 객체를 자주 생성하는 것은 바람직한 것이다.</p>\n<p>객체를 재사용하기 위해 무리하여 pool을 생성하는 것을 지양하자. 코드에서 직관적이지 않고 오히려 메모리 사용량을 늘릴 수 있다. 다만 엄청 비싼 자원이라면(DB 커넥션과 같이) pool을 사용하는 것이 적합하다.</p>\n<p>객체를 새로 생성하는 것이(예를 들면 방어적 복사) 프로그램 안정성 측면에서 훨씬 좋을 수 있다. 이럴때는 주저없이 객체를 재사용하기보다 새로 생성하는 것이 훨씬 좋다.</p>\n<br>\n<h3 id=\"느낀-점\" style=\"position:relative;\"><a href=\"#%EB%8A%90%EB%82%80-%EC%A0%90\" aria-label=\"느낀 점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>느낀 점</h3>\n<p>불필요하다고 명확히 느낄 때만 객체 생성을 지양하라는 것이지 무조건 객체를 재사용하기 위해서 무리하라는 것이 아니다. 마지막 부분에서 저자가 강조한 것처럼 트레이드 오프를 고려하고 지혜로운 결정을 내리는 것이 매우 중요하다.</p>\n<p>가끔 개발을 하다가 보면 “어디서 이렇게 하라고 했다.” 라고 이야기하면서 특정 방식을 적용하자고 하는 말을 자주 듣곤 한다. 하지만 대부분 그 지령은 절대 진리는 아니다. 상황에 따라서 적합한 것을 선택하는 것이 매우 중요한 개발자 역량이라고 생각한다.</p>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#-%EC%95%84%EC%9D%B4%ED%85%9C-5-%EC%9E%90%EC%9B%90%EC%9D%84-%EC%A7%81%EC%A0%91-%EB%AA%85%EC%8B%9C%ED%95%98%EC%A7%80-%EB%A7%90%EA%B3%A0-%EC%9D%98%EC%A1%B4-%EA%B0%9D%EC%B2%B4-%EC%A3%BC%EC%9E%85%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC\">🌩 [아이템 5] 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라</a></p>\n<ul>\n<li><a href=\"#%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%A3%BC%EC%9E%85di%EC%9D%84-%ED%86%B5%ED%95%B4-%ED%95%B4%EA%B2%B0%ED%95%98%EA%B8%B0\">의존성 주입(DI)을 통해 해결하기</a></li>\n<li><a href=\"#%EC%9A%94%EC%95%BD\">요약</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-%EC%95%84%EC%9D%B4%ED%85%9C-6-%EB%B6%88%ED%95%84%EC%9A%94%ED%95%9C-%EA%B0%9D%EC%B2%B4-%EC%83%9D%EC%84%B1%EC%9D%84-%ED%94%BC%ED%95%98%EB%9D%BC\">🌩 [아이템 6] 불필요한 객체 생성을 피하라</a></p>\n<ul>\n<li><a href=\"#string%EC%9D%84-%EC%9E%AC%EC%82%AC%EC%9A%A9-%ED%95%98%EC%9E%90\">String을 재사용 하자</a></li>\n<li><a href=\"#%EB%B6%88%EB%B3%80-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%9D%98-%EC%A0%95%EC%A0%81-%ED%8C%A9%ED%84%B0%EB%A6%AC-%EB%A9%94%EC%84%9C%EB%93%9C%EB%A1%9C-%EA%B0%9D%EC%B2%B4%EB%A5%BC-%EC%9E%AC%EC%82%AC%EC%9A%A9-%ED%95%98%EC%9E%90\">불변 클래스의 정적 팩터리 메서드로 객체를 재사용 하자</a></li>\n<li><a href=\"#%EA%B0%9D%EC%B2%B4-%EC%83%9D%EC%84%B1%EC%9D%B4-%EB%B9%84%EC%8B%BC-%EA%B0%9D%EC%B2%B4%EB%9D%BC%EB%A9%B4-%EC%9E%AC%EC%82%AC%EC%9A%A9-%ED%95%98%EC%9E%90\">객체 생성이 비싼 객체라면 재사용 하자</a></li>\n<li><a href=\"#%EC%98%A4%ED%86%A0%EB%B0%95%EC%8B%B1%EC%9C%BC%EB%A1%9C-%EC%83%9D%EC%84%B1%EB%90%98%EB%8A%94-%EB%B6%88%ED%95%84%EC%9A%94%ED%95%9C-%EA%B0%9D%EC%B2%B4%EB%A5%BC-%EC%A3%BC%EC%9D%98%ED%95%98%EC%9E%90\">오토박싱으로 생성되는 불필요한 객체를 주의하자</a></li>\n<li><a href=\"#%EC%A3%BC%EC%9D%98%ED%95%A0-%EC%A0%90\">주의할 점</a></li>\n<li><a href=\"#%EB%8A%90%EB%82%80-%EC%A0%90\">느낀 점</a></li>\n</ul>\n</li>\n</ul>\n</div>","excerpt":"이 글은 몇몇 크루들과 이펙티브 자바 스터디를 하며 정리한 내용입니다. 🙌 🌩 [아이템 5] 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라 하나의 클래스에서 다른 자원에 의존하는 경우가 많다. 또한 해당 클래스가 유틸리티 클래스라면 싱글톤이나 정적 클래스로 사용되는 경우가 많다. 정적 클래스로 구현한 경우 싱글톤으로 구현한 경우 그런 경우 여러 단점이 발생한다. 유연하지 않다. 안에 의존하고 있는 객체를 런타임 시점에 바꾸거나 조작하기가 어렵다. 여러 다른 사전들을 이용하고 싶을 때 변경에 자유롭지 못하다. 테스트하기 어렵다. 정적으로 의존 객체를 내부에서 생성하므로 모킹하거나 해당 객체에 대한 조작으로 테스트를 하기 어렵다. 의존성 주입(DI)을 통해 해결하기 위 문제에 대한 가능한 해결방법이 DI 말고 하나가 더 있다. 변경에 대한 유연성을 부여하기 위해 을 제거하고 여러 사전들을 바꿔서 사용할 수 있도록 한다. 이렇게 할 경우 멀티스레드 환경에 취약하고 오류를 내기가 …","frontmatter":{"date":"December 16, 2021","title":"이펙티브 자바 - 아이템 5 & 6","categories":"책 자바","author":"코다","emoji":"🐡"},"fields":{"slug":"/effective-java-5-6/"}},"next":{"id":"6a1f88a3-be3c-517e-b002-34f037e42eeb","html":"<blockquote>\n<p>이 글은 몇몇 크루들과 이펙티브 자바 스터디를 하며 정리한 내용입니다. 🙌</p>\n</blockquote>\n<h2 id=\"-아이템-3-private-생성자나-열거-타입으로-싱글턴임을-보증하라\" style=\"position:relative;\"><a href=\"#-%EC%95%84%EC%9D%B4%ED%85%9C-3-private-%EC%83%9D%EC%84%B1%EC%9E%90%EB%82%98-%EC%97%B4%EA%B1%B0-%ED%83%80%EC%9E%85%EC%9C%BC%EB%A1%9C-%EC%8B%B1%EA%B8%80%ED%84%B4%EC%9E%84%EC%9D%84-%EB%B3%B4%EC%A6%9D%ED%95%98%EB%9D%BC\" aria-label=\" 아이템 3 private 생성자나 열거 타입으로 싱글턴임을 보증하라 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 [아이템 3] private 생성자나 열거 타입으로 싱글턴임을 보증하라</h2>\n<p>하나의 인스턴스만 생성할 수 있는 것이 싱글턴(Singleton) 패턴이다. 참고로 싱글턴을 사용할 경우 이것을 사용하는 클라이언트를 테스트하기가 어렵다. 싱글턴 객체의 생성지점을 제어하기 어려우므로 mock으로 대체하기가 어렵기 때문이다. 싱글턴 객체를 구현하기 위해서는 다음 <strong>3가지 방법</strong>을 사용할 수 있다.</p>\n<br>\n<h3 id=\"1-private-생성자--public-static-final-필드\" style=\"position:relative;\"><a href=\"#1-private-%EC%83%9D%EC%84%B1%EC%9E%90--public-static-final-%ED%95%84%EB%93%9C\" aria-label=\"1 private 생성자  public static final 필드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1) private 생성자 &#x26; public static final 필드</h3>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Earth</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">Earth</span> INSTANCE <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Earth</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">Earth</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>생성자의 접근제어자가 private이므로 인스턴스는 오직 <code class=\"language-text\">INSTANCE</code> 필드를 초기화할 때 단 한번만 생성된다. 일반적인 경우 클라이언트는 이 부분에 대한 권한이 전혀 없지만 예외적으로 <code class=\"language-text\">AccessibleObject.setAccessible</code>을 사용한다면 private 생성자를 호출할 수 있기는 하다. (방어를 위해서는 두번째 생성자 호출시 예외발생)</p>\n<ul>\n<li>장점\n<ul>\n<li><code class=\"language-text\">public static final</code> 필드를 사용할 경우 싱글턴이라는 것이 분명히 드러난다. (<code class=\"language-text\">final</code>이므로 재정의 할 수 없다.)</li>\n<li>간결하다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h3 id=\"2-private-생성자--정적-팩터리-메서드\" style=\"position:relative;\"><a href=\"#2-private-%EC%83%9D%EC%84%B1%EC%9E%90--%EC%A0%95%EC%A0%81-%ED%8C%A9%ED%84%B0%EB%A6%AC-%EB%A9%94%EC%84%9C%EB%93%9C\" aria-label=\"2 private 생성자  정적 팩터리 메서드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2) private 생성자 &#x26; 정적 팩터리 메서드</h3>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Earth</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">Earth</span> INSTANCE <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Earth</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>'\n\n\tpirvate <span class=\"token class-name\">Earth</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t<span class=\"token punctuation\">}</span>\n\n\t<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">Earth</span> <span class=\"token function\">getInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">return</span> INSTANCE<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>장점\n<ul>\n<li>싱글턴이 아닌 경우로 리팩토링 할 경우 변경에 유연하다.</li>\n<li>정적 팩터리를 제네링 싱글턴 팩터리로 만들 수 있다.</li>\n<li>정적 팩터리 메소드를 Supplier로 사용할 수 있다. (일급 함수로 사용 가능)</li>\n</ul>\n</li>\n</ul>\n<br>\n<h3 id=\"위-방법에서-직렬화-시-주의할-점\" style=\"position:relative;\"><a href=\"#%EC%9C%84-%EB%B0%A9%EB%B2%95%EC%97%90%EC%84%9C-%EC%A7%81%EB%A0%AC%ED%99%94-%EC%8B%9C-%EC%A3%BC%EC%9D%98%ED%95%A0-%EC%A0%90\" aria-label=\"위 방법에서 직렬화 시 주의할 점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>위 방법에서 직렬화 시 주의할 점</h3>\n<p>직렬화는 객체를 바이트로 변환해 데이터를 외부 시스템에 영구적으로 저장하거나 사용할 수 있도록 하는 것을 말한다. 직렬화 후 다시 역직렬화 할 때(<code class=\"language-text\">readObject()</code> 사용시) 싱글톤임에도 불구하고 새로운 인스턴스가 생성된다.</p>\n<p>이를 방지하기 위해서는 직렬화 하는 객체의 필드를 <code class=\"language-text\">transient</code> 선언(직렬화 대상에서 제외하고 <code class=\"language-text\">readResolve()</code> 메서드를 정의하여 기존에 생성된 객체를 반환하도록 해야 한다. 이때도 <code class=\"language-text\">readObject()</code> 호출 시 새로운 인스턴스가 생성되기는 하지만 해당 인스턴스를 가짜 인스턴스로 간주하고 무시하여 GC가 처리한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token class-name\">Object</span> <span class=\"token function\">readResolve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">return</span> INSTANCE<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<br>\n<h3 id=\"3-enum-타입으로-선언\" style=\"position:relative;\"><a href=\"#3-enum-%ED%83%80%EC%9E%85%EC%9C%BC%EB%A1%9C-%EC%84%A0%EC%96%B8\" aria-label=\"3 enum 타입으로 선언 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3) Enum 타입으로 선언</h3>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">enum</span> <span class=\"token class-name\">Earth</span> <span class=\"token punctuation\">{</span>\n\tINSTANCE<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token comment\">// 관련 메서드 정의</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>열거타입으로 선언할 경우 매우 간결하고 특별한 노력 없이 직렬화 관련 문제도 해결된다. 또한 리플렉션 시에도 싱글톤임을 보장해준다. 하지만 열거 타입의 본래 사용의도와 어긋나므로 어색해보일 수 있다.</p>\n<br>\n<br>\n<h2 id=\"-아이템-4-인스턴스화를-막으려거든-private-생성자를-사용하라\" style=\"position:relative;\"><a href=\"#-%EC%95%84%EC%9D%B4%ED%85%9C-4-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4%ED%99%94%EB%A5%BC-%EB%A7%89%EC%9C%BC%EB%A0%A4%EA%B1%B0%EB%93%A0-private-%EC%83%9D%EC%84%B1%EC%9E%90%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC\" aria-label=\" 아이템 4 인스턴스화를 막으려거든 private 생성자를 사용하라 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 [아이템 4] 인스턴스화를 막으려거든 private 생성자를 사용하라</h2>\n<p>객체지향적으로 보았을 때 안티패턴이기는 하지만 필요시 정적 필드와 정적 메서드만을 모아둔 utility 성향의 클래스를 생성하게 될 때가 있다.</p>\n<ul>\n<li>자바의 경우 java.util.Arrays, java.util.Collections와 같이 배열과 관련된 메서드를 모아 놓거나 특정 인터페이스 구현체를 생성해주는 팩터리 역할을 하는 경우 필요하다.</li>\n</ul>\n<p>이 경우 클래스의 인스턴스화를 막아야 하는데 이때는 기본 생성자를 <code class=\"language-text\">private</code>으로 선언하여 명시해주어야 한다.</p>\n<ul>\n<li>컴파일러는 기본 생성자가 명시되어 있지 않으면 자동으로 기본 생성자를 만들어서 인스턴스화가 가능하도록 한다.</li>\n<li>실수로 클래스 내에서 private 생성자를 사용하지 않도록 주의해야 한다.</li>\n<li>기본 생성자가 막혀있다면 하위 클래스에서 상위 클래스의 생성자에 접근할 수 없으므로 상속을 불가능하게 하는 효과도 있다.</li>\n</ul>\n<p>사용하지 않을 생성자를 코드에 명시하는 것이므로 직관적인 코드는 아니라는 단점도 있다.</p>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#-%EC%95%84%EC%9D%B4%ED%85%9C-3-private-%EC%83%9D%EC%84%B1%EC%9E%90%EB%82%98-%EC%97%B4%EA%B1%B0-%ED%83%80%EC%9E%85%EC%9C%BC%EB%A1%9C-%EC%8B%B1%EA%B8%80%ED%84%B4%EC%9E%84%EC%9D%84-%EB%B3%B4%EC%A6%9D%ED%95%98%EB%9D%BC\">🌩 [아이템 3] private 생성자나 열거 타입으로 싱글턴임을 보증하라</a></p>\n<ul>\n<li><a href=\"#1-private-%EC%83%9D%EC%84%B1%EC%9E%90--public-static-final-%ED%95%84%EB%93%9C\">1) private 생성자 &#x26; public static final 필드</a></li>\n<li><a href=\"#2-private-%EC%83%9D%EC%84%B1%EC%9E%90--%EC%A0%95%EC%A0%81-%ED%8C%A9%ED%84%B0%EB%A6%AC-%EB%A9%94%EC%84%9C%EB%93%9C\">2) private 생성자 &#x26; 정적 팩터리 메서드</a></li>\n<li><a href=\"#%EC%9C%84-%EB%B0%A9%EB%B2%95%EC%97%90%EC%84%9C-%EC%A7%81%EB%A0%AC%ED%99%94-%EC%8B%9C-%EC%A3%BC%EC%9D%98%ED%95%A0-%EC%A0%90\">위 방법에서 직렬화 시 주의할 점</a></li>\n<li><a href=\"#3-enum-%ED%83%80%EC%9E%85%EC%9C%BC%EB%A1%9C-%EC%84%A0%EC%96%B8\">3) Enum 타입으로 선언</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-%EC%95%84%EC%9D%B4%ED%85%9C-4-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4%ED%99%94%EB%A5%BC-%EB%A7%89%EC%9C%BC%EB%A0%A4%EA%B1%B0%EB%93%A0-private-%EC%83%9D%EC%84%B1%EC%9E%90%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC\">🌩 [아이템 4] 인스턴스화를 막으려거든 private 생성자를 사용하라</a></p>\n</li>\n</ul>\n</div>","frontmatter":{"date":"December 15, 2021","title":"이펙티브 자바 - 아이템 3 & 4","categories":"책 자바","author":"코다","emoji":"🐡"},"fields":{"slug":"/effective-java-3-4/"}},"prev":null,"site":{"siteMetadata":{"siteUrl":"https://yjksw.github.io","comments":{"utterances":{"repo":"yjksw/yjksw.github.io"}}}}},"pageContext":{"slug":"/effective-java-5-6/","nextSlug":"/effective-java-3-4/","prevSlug":""}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}
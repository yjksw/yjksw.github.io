{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/spring-interceptor/",
    "result": {"data":{"cur":{"id":"90dcdd48-5814-5261-9fed-a768d1269d4a","html":"<h2 id=\"개요\" style=\"position:relative;\"><a href=\"#%EA%B0%9C%EC%9A%94\" aria-label=\"개요 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>개요</h2>\n<p>Handler interceptors는 어떤 요청들에 대한 특정 기능을 적용하고 싶을 때 사용이 되는데, 특히 어떤 조건 및 원칙들을 검증하는데 많이 사용된다.</p>\n<br>\n<h2 id=\"interceptor-구성\" style=\"position:relative;\"><a href=\"#interceptor-%EA%B5%AC%EC%84%B1\" aria-label=\"interceptor 구성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Interceptor 구성</h2>\n<p>Interceptor를 구현하기 위해서는 HandlerInterceptor를 구현해야 한다. 해당 인터페이스에는 interceptor가 실행되는 3가지 경우에 대한 메소드가 정의되어 있다.</p>\n<ol>\n<li>handler가 실행되기 이전</li>\n<li>handler가 실행된 이후</li>\n<li>전체 요청 처리가 모두 수행된 이후</li>\n</ol>\n<p>이것들 중 handler 실행 이전에 수행되는 메소드인 <code class=\"language-text\">preHandle()</code> 은 boolean 값을 반환한다. <code class=\"language-text\">postHandle()</code>과 <code class=\"language-text\">afterCompletion()</code>은 void를 반환한다.</p>\n<p>위 세가지 메소드 모두 공통된 인자로 Servlet에 의해서 생성된 <code class=\"language-text\">HttpServletRequest</code>, <code class=\"language-text\">HttpServletResponse</code>, <code class=\"language-text\">handler</code>(Object 타입)을 받는다. 따라서 void 반환타입인 경우 HttpServletResponse에 후처리를 할 수 있다. (<code class=\"language-text\">postHandle()</code>의 경우에는 <code class=\"language-text\">ModelAndView</code>를 <code class=\"language-text\">afterCompletion()</code>은 <code class=\"language-text\">Exception</code>을 <code class=\"language-text\">@Nullable</code> 속성으로 받는다)</p>\n<h3 id=\"prehandle-동작원리\" style=\"position:relative;\"><a href=\"#prehandle-%EB%8F%99%EC%9E%91%EC%9B%90%EB%A6%AC\" aria-label=\"prehandle 동작원리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>preHandle() 동작원리</h3>\n<p><code class=\"language-text\">DispatcherServlet</code>은 <code class=\"language-text\">interceptors</code>와 <code class=\"language-text\">handler</code>를 execution chain으로 실행한다. (마지막에 handler가 실행이 되는 형태)</p>\n<p>이 <code class=\"language-text\">preHandle()</code> 메소드를 통해서 이 execution chain 중단 여부를 결정할 수 있다. 만일 체이닝 되어 있는 interceptor가 true를 반환한다면 그 다음 interceptor 혹은 handler를 실행한다. 만일 false를 반환한다면 체이닝 된 interceptor 혹은 handler 실행을 멈추고 <strong>DispatcherServlet은 해당 interceptor가 알아서 response에 필요한 처리를 했다고 간주한다.</strong></p>\n<br>\n<br>\n<p><strong>[참고링크]</strong></p>\n<ul>\n<li><a href=\"https://docs.spring.io/spring-framework/docs/3.0.x/reference/mvc.html#mvc-handlermapping-interceptor\">https://docs.spring.io/spring-framework/docs/3.0.x/reference/mvc.html#mvc-handlermapping-interceptor</a></li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#%EA%B0%9C%EC%9A%94\">개요</a></p>\n</li>\n<li>\n<p><a href=\"#interceptor-%EA%B5%AC%EC%84%B1\">Interceptor 구성</a></p>\n<ul>\n<li><a href=\"#prehandle-%EB%8F%99%EC%9E%91%EC%9B%90%EB%A6%AC\">preHandle() 동작원리</a></li>\n</ul>\n</li>\n</ul>\n</div>","excerpt":"개요 Handler interceptors는 어떤 요청들에 대한 특정 기능을 적용하고 싶을 때 사용이 되는데, 특히 어떤 조건 및 원칙들을 검증하는데 많이 사용된다. Interceptor 구성 Interceptor를 구현하기 위해서는 HandlerInterceptor를 구현해야 한다. 해당 인터페이스에는 interceptor가 실행되는 3가지 경우에 대한 메소드가 정의되어 있다. handler가 실행되기 이전 handler가 실행된 이후 전체 요청 처리가 모두 수행된 이후 이것들 중 handler 실행 이전에 수행되는 메소드인  은 boolean 값을 반환한다. 과 은 void를 반환한다. 위 세가지 메소드 모두 공통된 인자로 Servlet에 의해서 생성된 , , (Object 타입)을 받는다. 따라서 void 반환타입인 경우 HttpServletResponse에 후처리를 할 수 있다. (의 경우에는 를 은 을  속성으로 받는다) preHandle() 동작원리 은 와 를 execu…","frontmatter":{"date":"June 23, 2021","title":"초간단 Interceptor 알아보기","categories":"스프링 웹","author":"코다","emoji":"🍀"},"fields":{"slug":"/spring-interceptor/"}},"next":{"id":"a6cc1d2b-0f6b-57b4-afda-42f7b4ab4500","html":"<h2 id=\"intro\" style=\"position:relative;\"><a href=\"#intro\" aria-label=\"intro permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Intro</h2>\n<p>암호화(encryption)에는 3가지 기술이 있다.</p>\n<ol>\n<li>Symmetric encryption - 대칭키</li>\n<li>Asymmestric encryption - 비대칭키</li>\n<li>Hash functions(keyless) - 해싱</li>\n</ol>\n<p>여기서는 대칭키, 비대칭키에 대해서만 다룰 것인데 둘다 각각의 장단점이 있다. <br></p>\n<p>대칭키와 비대칭키의 간단한 차이점</p>\n<ul>\n<li>우선 모두 key를 사용해서 데이터를 encrypt/decrypt 한다.</li>\n<li>대칭키의 경우 동일한 key를 가지고 암호화/복호화를 하기 때문에 사용하기가 쉽다.</li>\n<li>비대칭키의 경우 public key를 사용해서 데이터를 암호화하고, private key를 사용해서 복호화한다.</li>\n</ul>\n<br>\n<h2 id=\"symmetric-encryption-대칭키\" style=\"position:relative;\"><a href=\"#symmetric-encryption-%EB%8C%80%EC%B9%AD%ED%82%A4\" aria-label=\"symmetric encryption 대칭키 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Symmetric encryption 대칭키?</h2>\n<p>대칭키를 사용하면 데이터의 암호화/복호화 모두 하나의 key를 사용한다. 그리고 해당 키를 수령인과 공유한다. (수령인이 암호화된 데이터를 받았을 때 복호화를 위해서 필요) <br></p>\n<p align=\"center\"><img width=\"90%\" src=\"https://user-images.githubusercontent.com/63405904/135317204-d0bcfee1-fc3a-4fc8-ab1a-dc3e644d772c.png\"></p>\n<h3 id=\"대칭키-장단점\" style=\"position:relative;\"><a href=\"#%EB%8C%80%EC%B9%AD%ED%82%A4-%EC%9E%A5%EB%8B%A8%EC%A0%90\" aria-label=\"대칭키 장단점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>대칭키 장단점</h3>\n<p><strong>장점</strong></p>\n<ul>\n<li>세팅이 쉽고 간단하다. (jiffy 순간적으로 처리된다)</li>\n<li>개념이 간단하기 때문에 여러 환경에서 거의 모두 적용이 가능하다.</li>\n</ul>\n<p><strong>단점</strong></p>\n<ul>\n<li>비밀키가 수령인과 공유되어야 한다.</li>\n<li>따라서 보안적 측면에서 다소 위험한 부분이 있다.</li>\n</ul>\n<br>\n<h2 id=\"asymmetric-encryption-비대칭키\" style=\"position:relative;\"><a href=\"#asymmetric-encryption-%EB%B9%84%EB%8C%80%EC%B9%AD%ED%82%A4\" aria-label=\"asymmetric encryption 비대칭키 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Asymmetric encryption 비대칭키?</h2>\n<p>비대칭키 방식은 데이터를 암호화/복호화 하는데 두개의 key가 필요하다. public key를 사용해서 데이터를 암호화하고, private key를 통해서 데이터를 복호화한다. <br></p>\n<p>암호화된 데이터를 수령하는 수령인은 반드시 private key를 가지고 있어야 하는데, 그것을 private하게 유지하기 위해서 local 하게 저장하는 것이 가장 좋다.</p>\n<h3 id=\"비대칭키-장단점\" style=\"position:relative;\"><a href=\"#%EB%B9%84%EB%8C%80%EC%B9%AD%ED%82%A4-%EC%9E%A5%EB%8B%A8%EC%A0%90\" aria-label=\"비대칭키 장단점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>비대칭키 장단점</h3>\n<p><strong>장점</strong></p>\n<ul>\n<li>비밀키를 공유하지 않아도 된다.</li>\n<li>digital sigining을 지원하기 때문에 수령인의 identity를 보장할 수 있고, 메세지의 오염여부를 알 수 있다.</li>\n</ul>\n<p><strong>단점</strong></p>\n<ul>\n<li>시간과 이외의 다른 많은 노력들이 소요된다.</li>\n<li>이메일이나 데이터를 보낼 때, 상대방이 key pair를 생성했는지 항상 확인해야한다.</li>\n<li>만일 key을 잃어버리면 복구할 수 없다.</li>\n</ul>\n<br>\n<h2 id=\"언제-무엇을-사용할까\" style=\"position:relative;\"><a href=\"#%EC%96%B8%EC%A0%9C-%EB%AC%B4%EC%97%87%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%A0%EA%B9%8C\" aria-label=\"언제 무엇을 사용할까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>언제 무엇을 사용할까?</h2>\n<ul>\n<li>만일 빠르게 암호화된 메세지를 전송하고 싶을 경우 Symmetric encryption 대칭키를 사용하기를 추천한다.</li>\n</ul>\n<br>\n<br>\n<p><strong>[참고링크]</strong></p>\n<ul>\n<li><a href=\"https://blog.mailfence.com/symmetric-vs-asymmetric-encryption/\">https://blog.mailfence.com/symmetric-vs-asymmetric-encryption/</a></li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#intro\">Intro</a></p>\n</li>\n<li>\n<p><a href=\"#symmetric-encryption-%EB%8C%80%EC%B9%AD%ED%82%A4\">Symmetric encryption 대칭키?</a></p>\n<ul>\n<li><a href=\"#%EB%8C%80%EC%B9%AD%ED%82%A4-%EC%9E%A5%EB%8B%A8%EC%A0%90\">대칭키 장단점</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#asymmetric-encryption-%EB%B9%84%EB%8C%80%EC%B9%AD%ED%82%A4\">Asymmetric encryption 비대칭키?</a></p>\n<ul>\n<li><a href=\"#%EB%B9%84%EB%8C%80%EC%B9%AD%ED%82%A4-%EC%9E%A5%EB%8B%A8%EC%A0%90\">비대칭키 장단점</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%96%B8%EC%A0%9C-%EB%AC%B4%EC%97%87%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%A0%EA%B9%8C\">언제 무엇을 사용할까?</a></p>\n</li>\n</ul>\n</div>","frontmatter":{"date":"June 21, 2021","title":"대칭키와 비대칭키 비교하기","categories":"웹","author":"코다","emoji":"🖥"},"fields":{"slug":"/symmetric-vs-asymmetric-encryption/"}},"prev":{"id":"1f652c1c-da4d-5aba-86ee-d66e7a606fcb","html":"<h2 id=\"intro\" style=\"position:relative;\"><a href=\"#intro\" aria-label=\"intro permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>INTRO</h2>\n<ul>\n<li><code class=\"language-text\">HandlerMethodArgumentResolver</code>는 Spring framework에서 제공하는 인터페이스로 request에서 메소드의 parameters를 해당하는 인자값으로 변환 혹은 바인딩 하는 resolver이다.</li>\n</ul>\n<br>\n<h2 id=\"인터페이스-내용\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-%EB%82%B4%EC%9A%A9\" aria-label=\"인터페이스 내용 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>인터페이스 내용</h2>\n<p><code class=\"language-text\">HandelrMethodArgumentResolver</code>에는 두가지 메소드가 있다.</p>\n<ol>\n<li><code class=\"language-text\">supportsParameter()</code></li>\n<li><code class=\"language-text\">resolveArgument()</code></li>\n</ol>\n<br>\n<h2 id=\"첫번째-parameter가-해당-resolver를-지원하는-여부-확인\" style=\"position:relative;\"><a href=\"#%EC%B2%AB%EB%B2%88%EC%A7%B8-parameter%EA%B0%80-%ED%95%B4%EB%8B%B9-resolver%EB%A5%BC-%EC%A7%80%EC%9B%90%ED%95%98%EB%8A%94-%EC%97%AC%EB%B6%80-%ED%99%95%EC%9D%B8\" aria-label=\"첫번째 parameter가 해당 resolver를 지원하는 여부 확인 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>첫번째, Parameter가 해당 resolver를 지원하는 여부 확인</h2>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token function\">supportsParameter</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">MethodParameter</span> parameter<span class=\"token punctuation\">)</span></code></pre></div>\n<p><strong>[참고]</strong> 아래 설명은 <code class=\"language-text\">@RequestBody</code>가 붙은 인자의 경우를 보는 것이므로 그 구현체가 <code class=\"language-text\">RequestResponseBodyMethodProcess.java</code>의 예시로 설명한 것이다. <br></p>\n<ul>\n<li>Parameter가 있는 수만큼 <code class=\"language-text\">InvocableHanderMethod#InvokeForRequest()</code> → <code class=\"language-text\">getMethodArgumentValues()</code> 안에서 for문을 돌면서 해당 parameter에 대한 argument resolve를 한다. 이때 resolve를 하기 위해서 현재 클래스가 가지고 있는 <code class=\"language-text\">resolvers</code> 가 해당 parameter 지원 하는지 여부를 확인한다.</li>\n<li>→ 확인하는 로직은 <code class=\"language-text\">HandlerMethodArgumentResolverComposite</code> 안에 있는 resolver들의 배열을 돌면서(한번 찾으면 캐싱함) 해당 parameter를 지원하는 resolver를 찾아서 반환하고, null인지 여부를 체크해 boolean을 반환한다. 이때 <code class=\"language-text\">supportsParameter()</code> 메소드가 수행된다.</li>\n<li>→ 다시 <code class=\"language-text\">InvocableHanderMethod#InvokeForRequest()</code> → <code class=\"language-text\">getMethodArgumentValues()</code> 의 반복문 안에서  <code class=\"language-text\">HandlerMethodArgumentResolver#resolveArgument()</code> 가 실행이 되면서(어노테이션에 따라서 구현체가 각기 따로 있음 ex. <code class=\"language-text\">RequestResponseBodyMethodProcess</code> 등등) controller 메서드에서 사용되는 인자를 배열에 저장한다.</li>\n</ul>\n<br>\n<h2 id=\"두번째-해당-parameter를-argument-value로-변환-및-바인딩\" style=\"position:relative;\"><a href=\"#%EB%91%90%EB%B2%88%EC%A7%B8-%ED%95%B4%EB%8B%B9-parameter%EB%A5%BC-argument-value%EB%A1%9C-%EB%B3%80%ED%99%98-%EB%B0%8F-%EB%B0%94%EC%9D%B8%EB%94%A9\" aria-label=\"두번째 해당 parameter를 argument value로 변환 및 바인딩 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>두번째, 해당 parameter를 argument value로 변환 및 바인딩</h2>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token function\">resolveArgument</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">MethodParameter</span> parameter<span class=\"token punctuation\">,</span> <span class=\"token class-name\">ModelAndViewContainer</span> mavContainer<span class=\"token punctuation\">,</span> <span class=\"token class-name\">NativeWebRequest</span> webRequest<span class=\"token punctuation\">,</span> <span class=\"token class-name\">WebDataBinderFactory</span> binderFactory<span class=\"token punctuation\">)</span></code></pre></div>\n<p>Method parameter를 argument value로 변환 및 바인딩 하는 역할을 한다.</p>\n<ul>\n<li><code class=\"language-text\">ModelAndViewContainer</code> 는 request의 model에 접근할 수 있도록 한다.</li>\n<li><code class=\"language-text\">WebDataBinderFactory</code>는 <code class=\"language-text\">WebDataBinder</code> 인스턴스를 추출해 데이터 바인딩이나 타입 변환을 지원한다.</li>\n</ul>\n<p>성공 시 argument value를 리턴하고, 없다면 <code class=\"language-text\">null</code>을 리턴한다.</p>\n<p>만일 <code class=\"language-text\">@Valid</code> 어노테이션이 해당 인자에 붙어있다면 해당하는 validation도 이 메소드에서 처리한다.</p>\n<br>\n<h2 id=\"custom-resolver-구현\" style=\"position:relative;\"><a href=\"#custom-resolver-%EA%B5%AC%ED%98%84\" aria-label=\"custom resolver 구현 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Custom Resolver 구현</h2>\n<ol>\n<li><code class=\"language-text\">HandlerMethodArgumentResolver</code> 인터페이스를 구현하는 custom resovler 클래스를 구현</li>\n<li><code class=\"language-text\">@Override</code> 한 <code class=\"language-text\">supportParameter()</code> 메소드에서 원하는 타입의 인자인 경우 <code class=\"language-text\">true</code>를 반환하도록 구현</li>\n<li><code class=\"language-text\">@Override</code>한 <code class=\"language-text\">resolveArgument()</code>에서 controller의 메서드 인자로 보면 값을 반환하도록 구현</li>\n<li><code class=\"language-text\">WebMvcConfiguration</code> 를 구현하는 클래스의 <code class=\"language-text\">addArgumentResolver()</code>라는 메소드를 override하여 위 구현한 custom resolver를 추가해준다.</li>\n</ol>\n<br>\n<br>\n<p><strong>[참고링크]</strong></p>\n<ul>\n<li><a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/method/support/HandlerMethodArgumentResolver.html\">https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/method/support/HandlerMethodArgumentResolver.html</a></li>\n<li><a href=\"https://enai.tistory.com/31\">https://enai.tistory.com/31</a></li>\n</ul>\n<br>\n<p><strong>[유용링크]</strong></p>\n<ul>\n<li>스프링에서 요청을 처리하는 과정\n<a href=\"https://m.blog.naver.com/PostView.nhn?blogId=duco777&#x26;logNo=220605479481&#x26;proxyReferer=https:%2F%2Fwww.google.com%2F\">https://m.blog.naver.com/PostView.nhn?blogId=duco777&#x26;logNo=220605479481&#x26;proxyReferer=https:%2F%2Fwww.google.com%2F</a></li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#intro\">INTRO</a></li>\n<li><a href=\"#%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-%EB%82%B4%EC%9A%A9\">인터페이스 내용</a></li>\n<li><a href=\"#%EC%B2%AB%EB%B2%88%EC%A7%B8-parameter%EA%B0%80-%ED%95%B4%EB%8B%B9-resolver%EB%A5%BC-%EC%A7%80%EC%9B%90%ED%95%98%EB%8A%94-%EC%97%AC%EB%B6%80-%ED%99%95%EC%9D%B8\">첫번째, Parameter가 해당 resolver를 지원하는 여부 확인</a></li>\n<li><a href=\"#%EB%91%90%EB%B2%88%EC%A7%B8-%ED%95%B4%EB%8B%B9-parameter%EB%A5%BC-argument-value%EB%A1%9C-%EB%B3%80%ED%99%98-%EB%B0%8F-%EB%B0%94%EC%9D%B8%EB%94%A9\">두번째, 해당 parameter를 argument value로 변환 및 바인딩</a></li>\n<li><a href=\"#custom-resolver-%EA%B5%AC%ED%98%84\">Custom Resolver 구현</a></li>\n</ul>\n</div>","frontmatter":{"date":"June 25, 2021","title":"HandlerMethodArgumentResolver 내부동작 원리 알아보기","categories":"스프링 웹","author":"코다","emoji":"🍀"},"fields":{"slug":"/handler-method-argument-resolver/"}},"site":{"siteMetadata":{"siteUrl":"https://yjksw.github.io","comments":{"utterances":{"repo":"yjksw/yjksw.github.io"}}}}},"pageContext":{"slug":"/spring-interceptor/","nextSlug":"/symmetric-vs-asymmetric-encryption/","prevSlug":"/handler-method-argument-resolver/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}
{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/growing-together-2/",
    "result": {"data":{"cur":{"id":"5d66f499-7ded-5464-b17b-2a9fd515ad76","html":"<h2 id=\"intro\" style=\"position:relative;\"><a href=\"#intro\" aria-label=\"intro permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>💡 Intro</h2>\n<ul>\n<li>주로 협력이라고 하면 초반에 일을 나누고 선을 그어 따로 진행하는 것처럼 생각한다.</li>\n<li>실제로 일을 나누는 것은 초반에 하기 어렵다. 왜냐면 그 일이 무엇인지 잘 모르기 때문이다. 그럼에도 불구하고 사람들은 일을 초반에 나누고 따로 진행하면서 협력이 아닌 협력을 한다.</li>\n<li>요즘에 ‘함께’라는 것이 중요 키워드다. 회사와 구성원이 함께, 팀원들이 함께 성장하는 것에 관심이 많다.</li>\n<li>이 글은 두 번째 파트인 <strong>함께</strong> 파트이다.</li>\n</ul>\n<br>\n<h2 id=\"소프트웨어-관리자의-우선순위\" style=\"position:relative;\"><a href=\"#%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4-%EA%B4%80%EB%A6%AC%EC%9E%90%EC%9D%98-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84\" aria-label=\"소프트웨어 관리자의 우선순위 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 소프트웨어 관리자의 우선순위</h2>\n<p>다음 4가지 영역이 소프트웨어 개발의 관리에 영향을 미치는 요소들이다.</p>\n<ol>\n<li>도구: 소프트웨어 개발에 사용하는 도구</li>\n<li>사람: 사람의 능력과 경험</li>\n<li>시스템: 제품의 복잡도, 요구 신뢰성, DB 크기 등등</li>\n<li>관리: 사람을 배정하고 작업을 분배하고 위임. 작업을 모니터링, 동기 고취 환경 개선, 리스트 확인 및 적절한 조치 등등</li>\n</ol>\n<p>주로 개발 비용을 개선하려면 도구나 사람을 개선한다. 즉, 더 좋은 도구로 바꾸거나 더 실력있는 사람을 데리고 오는 것이다. 하지만 실제로 개발할 때 문제가 생겼던 부분이나 비용을 크게 개선하는 부분은 관리 부분이다. 역순으로 실제 중요도가 매겨진다.</p>\n<br>\n<h2 id=\"협력을-통한-추상화\" style=\"position:relative;\"><a href=\"#%ED%98%91%EB%A0%A5%EC%9D%84-%ED%86%B5%ED%95%9C-%EC%B6%94%EC%83%81%ED%99%94\" aria-label=\"협력을 통한 추상화 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 협력을 통한 추상화</h2>\n<p>이때까지 프로그래머에게 중요하다고 생각되지 않았던 영역은 소프트 스킬이라고 한다. “개발만 하는 천재”라는 표현이 익숙하다. 하지만 사실 진짜로 뛰어난 프로그래머는 사회적인 면을 더 언급하여 협력의 중요성을 상기시킨다.</p>\n<p>협력을 하면 그 효용성이 떨어진다는 결과가 많다. 같이 할수록 일도 더디게 진행이 되고 혼자서 낼 수 있는 최고의 아웃풋 만큼의 결과가 나오지 않는 경우가 많기 때문이다.</p>\n<p><strong>하지만 협력을 하기 위해서는 일에 대해서 추상적으로 표현하고 설명해야 할 필요가 생기기 때문에 작업에 대한 추상화가 진행될 수 있다. 그런 과정 중에게 문제를 해결하기도 한다.</strong> 혼자서 작업을 할 때에는 추상화 작업이 덜 필요하기 때문에 작업을 추상적으로 바라보면서 해결을 하기가 어렵다.</p>\n<p>다른 두 시각을 가진 두 사람이 협력을 하면 자연스럽게 추상화를 하게 된다. 그것은 작업에 큰 효용을 가지고 온다. 추상화를 높이고 싶다면 다른 사람과 함께 진행하면서 대화해라!</p>\n<br>\n<h2 id=\"신뢰는-깎는-공유인가-신뢰를-쌓는-공유인가\" style=\"position:relative;\"><a href=\"#%EC%8B%A0%EB%A2%B0%EB%8A%94-%EA%B9%8E%EB%8A%94-%EA%B3%B5%EC%9C%A0%EC%9D%B8%EA%B0%80-%EC%8B%A0%EB%A2%B0%EB%A5%BC-%EC%8C%93%EB%8A%94-%EA%B3%B5%EC%9C%A0%EC%9D%B8%EA%B0%80\" aria-label=\"신뢰는 깎는 공유인가 신뢰를 쌓는 공유인가 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 신뢰는 깎는 공유인가 신뢰를 쌓는 공유인가</h2>\n<ul>\n<li>신뢰 자산이 높은 조직은 커뮤니케이션 효율이나 생산성이 높다.</li>\n</ul>\n<p>흔히 신뢰를 쌓는데 사용되는 방법은 투명서와 공유, 인터랙션이다. 누군가 한 작업물을 공유하면서 피드백을 주고 받으며 상호작용하는 것이다. 그런데 그 모든 공유와 소통을 하면 반드시 신뢰가 쌓이는 것은 아니다.</p>\n<p>실험을 해보았을 때 자신이 한 작업물을 하나만 공유하거나(하나 공유), 여러개의 작업물 중 최고만 공유하거나(최고 공유) 한 경우 신뢰는 더욱 떨어졌다. 반대로 자신이 한 작업물을 모두 공유(복수 공유) 했을 때는 신뢰도가 높아졌다. 하나만 공유했을 때 상대의 의견에 지나치게 방어적이게 되면서 자기효능감이 떨어지기 때문이다.</p>\n<p><strong>따라서 복수 공유를 하는 것이 신뢰를 쌓는 공유이다.</strong> 복수 공유를 하면 인터랙션이 더 많아지고 피드백을 더 잘 수용하게 된다. 그래서 결과물이 더 잘 나오게 된다. 즉, 복수 공유는 신뢰도도 높아지고 성과도 더 좋다.</p>\n<br>\n<h2 id=\"객관성의-주관성\" style=\"position:relative;\"><a href=\"#%EA%B0%9D%EA%B4%80%EC%84%B1%EC%9D%98-%EC%A3%BC%EA%B4%80%EC%84%B1\" aria-label=\"객관성의 주관성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 객관성의 주관성</h2>\n<p>새로운 개념을 적용하기 위해서는 주변을 설득해야한다. 혹시 본인이 팀장이더라도 설득을 해야한다. 이때 수치를 가지고 설득을 하거나 여러 자료를 사용하기도 한다. 하지만 무엇보다 중요한 것은 설득을 하는 그 상대에 대해서 잘 알고 이야기 해보았는지다. 그렇지 않으면 설득에 성공할 확률은 낮아진다.</p>\n<p>어떠한 공동체 내에서 사용하는 단어는 매우 주관적으로 사용이 된다. 누군가가 ‘품질’에 대해서 이야기할 때 그것에 대해 각기 다른 의미를 가지고 있을 것이다. <strong>‘객관성’ 또한 마찬가지이다. 누군가를 설득하려면 객관성이 있어야 한다고 말하는데 이 객관성이라는 것 자체가 주관적인 의미를 담고 있다.</strong> 따라서 설득을 하려고 한다면 그 상대를 이해해야 한다. 어떤 사람이며 어떤 가치관을 가지고 있는지 알고 그것을 바탕으로 설득을 해야한다. 그것 없이 객관적인 설득은 어렵다. <strong>결국 결정하는 것은 ‘객관적 사실’이기보다 사람이기 때문이다.</strong></p>\n<p>아무리 객관적인 의사결정을 하더라도 감정을 배제할 수는 없다. 인간이 그렇다. 그렇기 때문에 누군가를 설득하고 싶다면 그 상대와 신뢰를 쌓고, 그 사람이 중요하게 생각하는 것과, 어떤 설명 방식을 선호하는지 이해해야 한다.</p>\n<br>\n<h2 id=\"효과적인-코칭\" style=\"position:relative;\"><a href=\"#%ED%9A%A8%EA%B3%BC%EC%A0%81%EC%9D%B8-%EC%BD%94%EC%B9%AD\" aria-label=\"효과적인 코칭 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 효과적인 코칭</h2>\n<ul>\n<li>코칭 능력이 없을수록 상대를 비난한다.</li>\n<li>사람은 스스로 한 약속일수록 지킬 확률이 높아진다.</li>\n<li>어떠한 방법을 택해서 해왔는지 물어보면서 상태를 파악한다.</li>\n<li>할 수 있는 방향을 제시해서 이행하도록 유도한다.</li>\n</ul>\n<br>\n<h2 id=\"하향식-접근의-함정\" style=\"position:relative;\"><a href=\"#%ED%95%98%ED%96%A5%EC%8B%9D-%EC%A0%91%EA%B7%BC%EC%9D%98-%ED%95%A8%EC%A0%95\" aria-label=\"하향식 접근의 함정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 하향식 접근의 함정</h2>\n<p>주로 일을 할 때 탑 다운 형식(추상적 → 구체적)으로 가는 것이 깔끔하게 느껴진다. 하지만 전문가일수록 일을 처리하는 것을 확인해보니 추상화의 정도와 구체적인 정도를 왔다갔다 하면서 일을 처리했다.</p>\n<p>비전문가일수록 처음에 설계한 것을 고집하며 따라간다. 전문가는 자신의 초기 계획을 자주 수정하며 바꿔나간다.</p>\n<p>보면 프로그램을 이해하는 고수는 <strong>상호 참조 전략</strong>을 쓴다. 프로그램을 이해한 것을 도메인의 어휘로 바꿔보고 다시 이것을 프로그램의 어휘로 바꾼다. <strong>즉, 추상과 구상의 차원을 자주 오간다.</strong>  반면 하수는 둘 중 한족에만 집중한다.</p>\n<p>조직에 일을 할 때는 주로 여러 팀이 바통 터치를 하면서 일을 진행한다. 이때 협력이 잘 되게 하려면 바통 터치 모델보다 <strong>삼투압 모형</strong>으로 가야한다.</p>\n<h3 id=\"삼투압-모형\" style=\"position:relative;\"><a href=\"#%EC%82%BC%ED%88%AC%EC%95%95-%EB%AA%A8%ED%98%95\" aria-label=\"삼투압 모형 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>삼투압 모형</h3>\n<p>삼투압 모형은 기존에 발신, 수신인이 정해져 있는 화살 모형의 의사소통이 아니라 은연중에 서로 간에 정보가 스며드는 것이다. 이것이 되려면 우선 물리적으로 가까운 공간에 있어서 대화를 나누는 것이 주변에 잘 스며들어야 한다. 또한 한꺼번에 처리되는 일의 양을 줄여야한다. 따라서 지속적 흐름을 만들고 짧은 시간 내에 탑, 바텀을 오가게 해야한다.</p>\n<br>\n<h2 id=\"전문가팀이-실패하는-이유\" style=\"position:relative;\"><a href=\"#%EC%A0%84%EB%AC%B8%EA%B0%80%ED%8C%80%EC%9D%B4-%EC%8B%A4%ED%8C%A8%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0\" aria-label=\"전문가팀이 실패하는 이유 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 전문가팀이 실패하는 이유</h2>\n<ul>\n<li>전문가팀을 모아도 음의 성능을 낼 수 있다. 정보를 공유하고 협력을 잘하기 위한 도움이 필요하며 소셜 스킬이 뛰어나서 정보 공유를 잘하는 팀의 퍼포먼스가 훨씬 뛰어나다.</li>\n<li>구글이 어떠한 팀이 뛰어난지 조사해본 결과 다음 3가지 중요 포인트를 발견했다.\n<ol>\n<li>팀에 누가 있는지보다 팀원들이 서로 어떻게 상호작용하고 일을 어떻게 바라보는지가 훨씬 중요하다.</li>\n<li>성공적 팀의 특징을 찾았는데 압도적으로 높은 예측력을 보인 변수는 심리적 안전감이었다.</li>\n<li>팀 토론 등을 통해 심리적 안전감을 높일 수 있다.</li>\n</ol>\n</li>\n<li>심리적 안전감이란 내 생각이나 의견, 질문, 걱정, 혹은 실수가 드러났을 때 처벌 받거나 놀림받지 않을 거라는 믿음이다.</li>\n<li>심리적 안전감을 통해서 팀 토론 등으로 개선시킬 수 있다. 또한 새로운 것을 도입할 때 팀 리더와 관리자가 매일매일 팀원들과 마이크로 인터랙션을 하는 형태를 보여주어야 한다. 일상에서 조금씩 신뢰를 쌓는 것이 중요하다.</li>\n</ul>\n<br>\n<h2 id=\"쾌속-학습팀\" style=\"position:relative;\"><a href=\"#%EC%BE%8C%EC%86%8D-%ED%95%99%EC%8A%B5%ED%8C%80\" aria-label=\"쾌속 학습팀 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 쾌속 학습팀</h2>\n<p>IT 업계에 있다보면 빠르게 기술적 변화를 해야하는 경우가 많다. 그런데 학습 속도는 이 사람이 기존에 얼마나 연차가 높고 수술 성공률이 높았는지와는 상관이 없다.</p>\n<p>빠른 학습을 하는 팀의 리더는 기술적 탁월함만을 지닌 리더가 아니라 학습 환경을 만들 수 있는 리더였다. 팀원을 선발할 때 협동적으로 하고, 선발 기준도 얼마나 협력을 잘하는지 등을 보고 뽑는다. 또한 새로운 것에 대해서 기술적 도전보다 조직적 도전으로 받아드려서 개개인이 새로운 기술을 익힌다는 것보다 함께 일하는 새로운 방법을 만든다고 생각하도록 했다.</p>\n<p>빠르게 학습하지 못하는 팀은 냉소적이었다. 또한 냉소주의는 전염성이 강하다. 학습 속도가 빠른 팀은 이 팀원이 된 것을 자랑스럽게 생각하고 자부심을 느낀다. 학습이 빠른 팀은 심리적으로 보호가 되어 있었다. 새로운 것을 제안하고 시도하는데 열려 있다.</p>\n<p>현실에서는 팀이 없거나 내가 팀장이 아닌 경우가 많다. 이럴 때는 나의 학습 환경을 만드는 것에서 출발해야 한다. 학습과 일을 분리하지 말고 하나로 만들어야 한다. 계획만 짜지 말고 지금 당상 시도해서 업무를 개선하는 것을 시도해 보아야한다. “작지만 유용한 프로그램들을 매일 작성할 것을 추천한다.”</p>\n<br>\n<h2 id=\"프로젝트-확률론\" style=\"position:relative;\"><a href=\"#%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%ED%99%95%EB%A5%A0%EB%A1%A0\" aria-label=\"프로젝트 확률론 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 프로젝트 확률론</h2>\n<p>여러 명이 자기의 작업을 가지고 진행을 할 때 특정 날짜까지 모두 완료할 수 있는(AND 조건) 확률은 매우 낮다. 애자일로 일을 진행하면 <strong>애자일은 좋은 일에 대해서는 ‘그리고’ 확률을 ‘또는’ 확률로, 나쁜 일에 대해서는 ‘또는’ 확률을 ‘그리고’ 확률로 바꾼다</strong>. 좋은 것을 알았으면 그것을 공유하여 또는 확률로 바꾸고 나쁜일에 대해서는 여러 사람이 중복 검토를 해서 구멍이 나지 않도록 그리고 확률로 바꾸는 식으로 진행을 한다.</p>\n<br>\n<h2 id=\"느낀-점\" style=\"position:relative;\"><a href=\"#%EB%8A%90%EB%82%80-%EC%A0%90\" aria-label=\"느낀 점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🛋 느낀 점</h2>\n<ul>\n<li>어떠한 조직이 성공적인 성과를 내는 데에 가장 중요한 것은 도구도, 각 사람의 역량도 아닌 ‘관리’이다. 여기서 관리라고 하는 것은 사람에게 일을 효과적으로 분배하고 동기를 고취시키는 것이다.</li>\n<li>‘객관성 자체가 주관적이다.’,  ‘감정을 배제하고는 결정을 내릴 수 없다.’ 등등의 문장들이 와 닿았다. 항상 동의했던 말이다. 결국 사람이 사람과 소통하는 것이고 무엇보다 중요한 것은 사람대 사람간의 신뢰이다!!</li>\n<li>고독한 영웅적인 천재는 조직에 이득이 되지 않을 수 있다.. 💡</li>\n<li>조직원들에게 신뢰적인 안정감을 주는 것, 그래서 더 좋은 의견을 마음껏 내세울 수 있는 것이 중요하다. (다음 팀 프로젝트에서는 이 부분을 더욱 신경써보고 싶다.)</li>\n<li>왜 협력하는 것이 더 좋은가? 에 대한 질문에 그냥 좋은게 좋은거지 라고 생각했다. 하지만 여기서 확실한 이유를 말해준다. 두 명 이상의 사람이 협력하려면 서로 다른 시각을 가진 것을 설명하기 위해서 <strong>추상성</strong>을 더해 설명해야 한다. 이 과정에서 많은 해결책이 나올 수 있다 !!!</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#intro\">💡 Intro</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4-%EA%B4%80%EB%A6%AC%EC%9E%90%EC%9D%98-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84\">🌩 소프트웨어 관리자의 우선순위</a></p>\n</li>\n<li>\n<p><a href=\"#%ED%98%91%EB%A0%A5%EC%9D%84-%ED%86%B5%ED%95%9C-%EC%B6%94%EC%83%81%ED%99%94\">🌩 협력을 통한 추상화</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%8B%A0%EB%A2%B0%EB%8A%94-%EA%B9%8E%EB%8A%94-%EA%B3%B5%EC%9C%A0%EC%9D%B8%EA%B0%80-%EC%8B%A0%EB%A2%B0%EB%A5%BC-%EC%8C%93%EB%8A%94-%EA%B3%B5%EC%9C%A0%EC%9D%B8%EA%B0%80\">🌩 신뢰는 깎는 공유인가 신뢰를 쌓는 공유인가</a></p>\n</li>\n<li>\n<p><a href=\"#%EA%B0%9D%EA%B4%80%EC%84%B1%EC%9D%98-%EC%A3%BC%EA%B4%80%EC%84%B1\">🌩 객관성의 주관성</a></p>\n</li>\n<li>\n<p><a href=\"#%ED%9A%A8%EA%B3%BC%EC%A0%81%EC%9D%B8-%EC%BD%94%EC%B9%AD\">🌩 효과적인 코칭</a></p>\n</li>\n<li>\n<p><a href=\"#%ED%95%98%ED%96%A5%EC%8B%9D-%EC%A0%91%EA%B7%BC%EC%9D%98-%ED%95%A8%EC%A0%95\">🌩 하향식 접근의 함정</a></p>\n<ul>\n<li><a href=\"#%EC%82%BC%ED%88%AC%EC%95%95-%EB%AA%A8%ED%98%95\">삼투압 모형</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%A0%84%EB%AC%B8%EA%B0%80%ED%8C%80%EC%9D%B4-%EC%8B%A4%ED%8C%A8%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0\">🌩 전문가팀이 실패하는 이유</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%BE%8C%EC%86%8D-%ED%95%99%EC%8A%B5%ED%8C%80\">🌩 쾌속 학습팀</a></p>\n</li>\n<li>\n<p><a href=\"#%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%ED%99%95%EB%A5%A0%EB%A1%A0\">🌩 프로젝트 확률론</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%8A%90%EB%82%80-%EC%A0%90\">🛋 느낀 점</a></p>\n</li>\n</ul>\n</div>","excerpt":"💡 Intro 주로 협력이라고 하면 초반에 일을 나누고 선을 그어 따로 진행하는 것처럼 생각한다. 실제로 일을 나누는 것은 초반에 하기 어렵다. 왜냐면 그 일이 무엇인지 잘 모르기 때문이다. 그럼에도 불구하고 사람들은 일을 초반에 나누고 따로 진행하면서 협력이 아닌 협력을 한다. 요즘에 ‘함께’라는 것이 중요 키워드다. 회사와 구성원이 함께, 팀원들이 함께 성장하는 것에 관심이 많다. 이 글은 두 번째 파트인 함께 파트이다. 🌩 소프트웨어 관리자의 우선순위 다음 4가지 영역이 소프트웨어 개발의 관리에 영향을 미치는 요소들이다. 도구: 소프트웨어 개발에 사용하는 도구 사람: 사람의 능력과 경험 시스템: 제품의 복잡도, 요구 신뢰성, DB 크기 등등 관리: 사람을 배정하고 작업을 분배하고 위임. 작업을 모니터링, 동기 고취 환경 개선, 리스트 확인 및 적절한 조치 등등 주로 개발 비용을 개선하려면 도구나 사람을 개선한다. 즉, 더 좋은 도구로 바꾸거나 더 실력있는 사람을 데리고 오는 …","frontmatter":{"date":"December 05, 2021","title":"함께 자라기 🌱 읽자 - Part 2. 함께","categories":"책","author":"코다","emoji":"🧸"},"fields":{"slug":"/growing-together-2/"}},"next":{"id":"6b0ec85a-51f4-542d-8096-ff0d0e0e9096","html":"<h2 id=\"intro\" style=\"position:relative;\"><a href=\"#intro\" aria-label=\"intro permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>💡 Intro</h2>\n<ul>\n<li>앞에서 리액티브 프로그래밍에 대해서 다뤘었다.</li>\n<li>한마디로 리액티브 프로그래밍에 대해서 정의하자면 <strong>비동기/논블로킹 이벤트 드리븐 개발과 배압을 통해 적은 수의 쓰레드로 생상자가 소비자를 압도하지 못하며 확장성있는 개발이 가능하게 하는 프로그래밍 기법</strong>이라고 할 수 있다.</li>\n<li>리액티브 프로그래밍은 가용성(CPU utilization이라고 볼 수 있는 영역)과 응답성(오류가 생겨도 빠르게 응답 가능)을 향상시키므로 프로그램의 효율성과 성능을 높인다.</li>\n<li>함수형 프로그래밍도 관련 중요 키워드이다. 리액티브 프로그래밍은 함수형 프로그래밍(선언형, 함수 조합, 등등)을 활용한다.</li>\n<li>Spring WebFlux는 Spring Framework5에서 추가된 모듈이다. 스프링이 리액티브 스택 웹 어플리케이션을 구축할 수 있도록 리액티브 스트림 API를 지원해 <strong>논블로킹/비동기식</strong>으로 동작할 수 있도록 한다.</li>\n</ul>\n<br> \n<h2 id=\"spring-webflux-란\" style=\"position:relative;\"><a href=\"#spring-webflux-%EB%9E%80\" aria-label=\"spring webflux 란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 Spring WebFlux 란?</h2>\n<ul>\n<li>기존의 Spring Web MVC는 Servlet API, Servlet Container에서 동작하도록 되어 있으므로 전통적인 동기/블로킹 방식만 지원했다.</li>\n<li>리액티브 스택 프레임워크인 Spring WebFlux는 <strong>fully non-blocking backpressure</strong>로 동작하는 <strong>리액티브 스트림</strong>을 지원한다.</li>\n<li>스프링 프레임워크에서 spring-webmvc와 spring-webflux는 <strong>공존</strong>할 수 있으며 각 모듈은 optional이다. 즉, 둘다 사용할 수도 있고 하나의 모듈만 사용할 수도 있다.</li>\n</ul>\n<br> \n<h2 id=\"spring-webflux-탄생이유\" style=\"position:relative;\"><a href=\"#spring-webflux-%ED%83%84%EC%83%9D%EC%9D%B4%EC%9C%A0\" aria-label=\"spring webflux 탄생이유 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 Spring WebFlux 탄생이유</h2>\n<p>한 문장으로 말하면 <strong>1) 적은 수의 스레드</strong>로 <strong>2) 최대한의 동시성</strong>을 핸들링하여 <strong>3)적은 하드웨어 리소스</strong>를 사용하기 위한 <strong>4) 비동기 웹 스택</strong>이 필요했기 때문이라고 할 수 있다.</p>\n<p>기존의 Servlet API에도 논블로킹 I/O를 할 수 있지만 해당 API를 사용하면 기본적으로 동기적(<code class=\"language-text\">Filter</code>, <code class=\"language-text\">Servlet</code>)이며 블로킹(<code class=\"language-text\">getParameter</code>, <code class=\"language-text\">getPart</code>)한 나머지 Servlet API를 사용하기 어려워진다. 따라서 완전히 논블로킹한 환경에서 동작할 수 있는 공통 API가 생겨나게 되었다.</p>\n<p><strong>또 다른 이유는 함수형 프로그래밍 때문이다.</strong> 자바8에 람다 및 스트림 등의 문법이 추가되면서 자바로 함수형 API를 구현할 수 있는 환경이 갖추어지기 시작했다. 이는 비동기 로직을 지원하고 논블로킹 어플리케이션을 구현할 수 있는 통로가 되며 Spring에서도 그러한 특성을 지원하는 WebFlux를 탄생시키게 되었다.</p>\n<h3 id=\"웹에서-비동기논블로킹의-필요성\" style=\"position:relative;\"><a href=\"#%EC%9B%B9%EC%97%90%EC%84%9C-%EB%B9%84%EB%8F%99%EA%B8%B0%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9%EC%9D%98-%ED%95%84%EC%9A%94%EC%84%B1\" aria-label=\"웹에서 비동기논블로킹의 필요성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>웹에서 비동기/논블로킹의 필요성</h3>\n<p>스프링은 웹 프레임워크이니 근본적인 개념보다 웹에 국한한여 생각해보자.</p>\n<ul>\n<li>\n<p>웹에서 병목을 유발하는 것은 외부 장치에 대한 I/O 작업인 경우가 많다. 즉, 요청당 하나의 스레드가 할당되어야 하지만 해당 스레드가 블로킹 되어 있는 상태인 경우가 훨씬 많다.</p>\n</li>\n<li>\n<p>이때 수많은 요청이 들어오게 되어 thread pool에 있는 스레드 개수 이상의 요청이 들어오게 되면 스레드에 대한 대기로 인해 latency가 급격히 느려지는 Thread Pool Hell이 발생하게 된다.</p>\n<p align=\"center\"><img width=\"75%\" src=\"https://user-images.githubusercontent.com/63405904/144712817-0bea67a0-5be8-4f10-b403-19e09721a383.png\"></p>\n</li>\n<li>\n<p>그렇다고 스레드를 추가로 생성하는 것은 오버헤드가 큰 작업이며 잦은 context switching으로 오히려 CPU utilization이 떨어져 비효율이 발생한다.</p>\n</li>\n<li>\n<p>따라서 적은 수의 스레드로 동시성을 높이기 위해서는 스레드가 블로킹 되어 있지 않고 외부 I/O 작업이 일어날 때 필요한 다른 작업을 수행하도록 해야한다.</p>\n</li>\n<li>\n<p>점점 더 MSA가 대두되면서 다수의 마이크로서비스로 분리되어 서비스간 메시지 통신을 하는 경우가 잦아졌다. 이런 외부 통신이 많아진 만큼 이 모든 요청을 동기/블로킹 방식으로 처리하면 동시성이 떨어지게 된다.</p>\n</li>\n<li>\n<p>따라서 비동기/논블로킹 형식의 프로그래밍의 필요성이 더욱 강조되기 시작한다.</p>\n</li>\n</ul>\n<br> \n<h2 id=\"spring-mvc-vs-spring-webflux\" style=\"position:relative;\"><a href=\"#spring-mvc-vs-spring-webflux\" aria-label=\"spring mvc vs spring webflux permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 Spring MVC vs. Spring WebFlux</h2>\n<h3 id=\"구체적으로-어떻게-더-좋은-걸까\" style=\"position:relative;\"><a href=\"#%EA%B5%AC%EC%B2%B4%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%8D%94-%EC%A2%8B%EC%9D%80-%EA%B1%B8%EA%B9%8C\" aria-label=\"구체적으로 어떻게 더 좋은 걸까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>구체적으로 어떻게 더 좋은 걸까?</h3>\n<p>우선 동기/비동기, 블록/논블록에 대한 기본적인 이해가 있다는 것을 전제하에 설명한다. 비동기/논블록 방식이 적용되면 여러 외부 I/O 작업이나 API 호출이 필요할 때 각 경과시간의 합 만큼의 시간이 소요된다. 하지만 비동기/논블록 방식이 적용되는 리액티브라면 각 경과시간 중 최대시간 만큼의 시간이 소요된다.</p>\n<p>어떻게 이런 효과를 (적은 스레드를 가지고!!) 내는지 이해하기 위해서는 리액티브에 빠질 수 없는 키워드인 <strong>event-driven</strong>을 잘 이해해야한다. 일반적으로 event-driven이라고 한다면 다음 그림을 떠올리면 된다.</p>\n<p align=\"center\"><img width=\"75%\" src=\"https://user-images.githubusercontent.com/63405904/144712827-31460842-a91c-4d90-a53d-91eb797c6421.png\"></p>\n<p>주 업무를 하는 주체는 Event loop, Events, Event Handlers이다. 사용자나 외부 요인에 의해 이벤트가 발생하면 이벤트 루프는 해당 이벤트를 받아서 관리하고 알맞은 핸들러에 넘기는 역할을 한다. 핸들러는 해당 이벤트를 처리한다.</p>\n<p>여기서 Event loop는 적은 스레드를 가지고 운용할 수 있다. 따라서 이전에는 각 이벤트에 대한 스레드가 각각 필요했다면 event-driven 형태에선 아무리 이벤트가 많이 발생하더라도 스레드 풀에 있는 적정량의 스레드(주로 CPU 코어 개수거나 두배)로 관리 및 처리할 수 있다.</p>\n<p>번외로 event-driven의 탄생이유에 대해서 말해보자면, 이전에는 예상 가능하게 순차적으로 프로그래밍 진행되곤 했다. 하지만 최근이 GUI가 발전하고 점점 더 사용자와의 인터랙션이 많아지면서 제어할 수 없는 유저 이벤트가 많아지면서 이런 방식이 생겨나고 많이 사용되게 되었다.</p>\n<h3 id=\"spring-webflux-구조\" style=\"position:relative;\"><a href=\"#spring-webflux-%EA%B5%AC%EC%A1%B0\" aria-label=\"spring webflux 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Spring WebFlux 구조</h3>\n<p align=\"center\"><img width=\"75%\" src=\"https://user-images.githubusercontent.com/63405904/144713050-4d280534-1b6c-43c6-8bd1-fa37d4f7fa31.png\"></p>\n<p>전반적인 Spring WebFlux의 구조를 보면서 리액티브 프로그래밍이 어떻게 적용되었는지 살펴보자.</p>\n<p>사용자 요청이 들어오면 Event loop를 통해서 event가 되어 관리가 된다. 이때 하나의 요청에 하나의 스레드가 배정되는 것이 아니라 적은 스레드로 이벤트 루프에서 관리할 수 있다. 이후 이벤트는 비동기/논블록으로 연산을 처리한다. 연산이 끝나면 콜백 함수로 처리하고 응답한다.</p>\n<p>이렇게 Spring WebFlux는 더 효율적으로 I/O를 제어하여 좋은 성능을 낸다. 앞서 언급했던 점점 더 MSA 추세로 여러 서비스가 네트워크 호출을 해야하는 시기에는 더욱 효율적일 수 있다.</p>\n<p>주의해야할 점은 한 곳이라도 동기/블로킹이 되는 곳이 있다면 아무런 효용이 없다는 것이다. 결국 동기/블로킹 호출하는 API에서 병목이 일어나기 때문이다.</p>\n<p>현재 Spring WebFlux의 WebClient로 외부 API를 리액티브 방식으로 처리할 수 있지만 여전히 DB connection과 관련해서는 논블로킹 라이브러리가 많이 사용되고 있지 않다. (R2DBC, jasync sql 등등이 개발중이라고 한다.)</p>\n<br> \n<h2 id=\"spring-webflux-무조건-좋을까\" style=\"position:relative;\"><a href=\"#spring-webflux-%EB%AC%B4%EC%A1%B0%EA%B1%B4-%EC%A2%8B%EC%9D%84%EA%B9%8C\" aria-label=\"spring webflux 무조건 좋을까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 Spring WebFlux 무조건 좋을까?</h2>\n<p>당연한 이야기겠지만 Spring WebFlux가 무조건 좋지는 않다. (개발에 트레이드 오프는 항상 있으므로!) 그럼 언제 무엇을 쓰는 것이 좋을까? 정답은 없지만 스프링 공식문서에 Spring MVC와 WebFlux를 비교하고 설명한 포인트들을 짚어보자.</p>\n<p>아래 그림은 두개의 공통점과 차이점을 표현한 다이어그램이다.</p>\n<p align=\"center\"><img width=\"75%\" src=\"https://user-images.githubusercontent.com/63405904/144713072-84bc054d-8073-4090-b2c9-3433ad45db2b.png\"></p>\n<p>스프링 공식문서에서는 몇가지 상황에 어떠한 것을 제안하는지 적혀있다.</p>\n<ul>\n<li>우선 Spring MVC로 어플리케이션이 정상동작하면 굳이 바꿀필요는 없다. 명령형 프로그래밍은 개발하기도, 이해하기도, 디버깅하기도 더 좋다. 즉, 생산성이 더 좋다는 것이다. 리액티브 개념은 이제 막 발전중이기 때문에 기존의 명령형에 비해 라이브러리도 부족하다.</li>\n<li>만일 자바8의 람다나 코틀린을 사용하는 가벼운 함수형 웹 프레임워크에 관심이 있다면 WebFlux는 좋은 선택이다. WebFlux는 작은 어플리케이션이나 복잡하지 않은 요구사항을 구현한 마이크로서비스에 적합하다.</li>\n<li>MSA에서는 각 어플리케이션이 Spring MVC나 Spring WebFlux를 혼합해서 사용하고 있을 수 있다. 어노테이션 기반의 프로그래밍 모델은 위 두 프레임워크를 재사용하기도 편하게 해준다.</li>\n<li>어느 어플리케이션에 무엇을 쓸지 헷갈린다면 가장 간단한 방법은 의존성을 체크해보는 것이다. 만일 플로킹 persistence API의 일종인 JPA, JDBC 등을 사용하거나 블로킹 네트워크 API를 사용하고 있다면 Spring MVC가 더 적합하다. 물론 Reactor나 RxJava등을 통해 블로킹 작업을 별도의 스레드에서 처리하도록 하는 것이 가능하지만 여전히 논블로킹 웹 스택의 장점을 온전히 활용하지 못하는 경우다.</li>\n<li>만일 지금 Spring MVC 어플리케이션을 쓰고 있고 외부 API를 호출해야 한다면 리액티브 <code class=\"language-text\">webClient</code>를 활용해보는 것을 추천한다. 각 요청에 대한 latency가 향상되며 그 장점이 극대화된다.</li>\n<li>스프링 공식 문서에 이런 내용도 있어서 놀랐다. 공식문서에 따르면 만일 팀에서 적용하고자 한다면 논블로킹이나 선언형 프로그래밍으로 전환하기 위해서는 매우 가파른 러닝커브가 존재한다는 것을 염두해두라고 한다.</li>\n</ul>\n<p>우선 가장 효율적으로 전환하는 방식은 현재 구조에서 reactive한 <code class=\"language-text\">webClient</code> 부터 적용해보는 것이다. 그리고 나서 점진적으로 적용을 시작하고 변화로부터 얻는 효용을 계산해보기를 추천한다. 공식문서에서 말하기를 “예상하건데 어플리케이션 전반적인 측면에서 논블로킹 선언형으로의 전환은 불필요할 것이다” 라고 언급한다. 따라서 만일 전환으로 인한 분명한 효용이 눈에 보이지 않거든 우선 논블로킹 I/O가 어떻게 동작하는지부터 공부하기를 추천한다.</p>\n<p align=\"center\"><img width=\"75%\" src=\"https://user-images.githubusercontent.com/63405904/144713083-097806d8-8c1a-4a39-a480-9704274c4bc4.png\"></p>\n<p>다음 <a href=\"https://dzone.com/articles/raw-performance-numbers-spring-boot-2-webflux-vs-s\">링크</a>에서는 Springboot와 webFlux의 성능을 측정해 보았다. 초반에 성능이 비슷한 구간이 분명히 있다. 만일 지금 환경이 그 구간이라면 전환은 불필요하다. 오히려 단점이 될 수 있는 것이 기존의 방식은 매우 직관적으고 코드를 작성하고, 디버깅하고, 이해하기 쉽기 때문에 생상성 측면에서 훨씬 뛰어나다.</p>\n<br> \n<h2 id=\"느낀-점\" style=\"position:relative;\"><a href=\"#%EB%8A%90%EB%82%80-%EC%A0%90\" aria-label=\"느낀 점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🛋 느낀 점</h2>\n<ul>\n<li>먼저, 스프링 공식문서는 매우 친절하다!!</li>\n<li>리액티브에 대해서 나름 깊이(힘들게) 공부하고 난 뒤에 WebFlux에 대해서 다시보니 좀 이해가 되는 것 같다.</li>\n<li>그래서 여기서 러닝커브가 높으므로 이것이 생산성을 떨어뜨릴 수 있으므로 반드시 꼭 필요한 효용성이 눈에 보일 때 적용하라고 한 것이 무엇보다 많이 와닿았다.</li>\n<li>점점 더 요청이 많아지고 Thread pool의 스레드가 부족하니 나온 해결책이라는 배경을 알게되니 굉장히 흥미로웠다. 불편함을 찾고 문제를 해결하는 것이 멋있다고 느껴졌다.</li>\n<li>나는 기술로 불편을 해결한 적이 있나 하는 고민을 요즘 많이 하게 된다. 비생산적이고 비효율적인 환경이나 루틴을 문제의식 없이 받아드리기 보다 적극적으로 해결해보자는 생각이 든다.</li>\n<li>번외로 <a href=\"https://www.reactivemanifesto.org/\">Reactive Manifesto</a> 내용과 내장되어 있는 용어집도 정리해보고 싶다 🙌</li>\n<li>처음에 정말 이해가 안갔는데… 일단 계속 또 보고 또 보고 또 보면 결국 이해가 되는구나 …💦</li>\n</ul>\n<br> \n<br> \n<p><strong>[참고자료]</strong></p>\n<ul>\n<li><a href=\"https://heeyeah.github.io/spring/2020-02-29-web-flux/\">https://heeyeah.github.io/spring/2020-02-29-web-flux/</a></li>\n<li><a href=\"https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html\">https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html</a></li>\n<li><a href=\"https://www.baeldung.com/spring-webflux\">https://www.baeldung.com/spring-webflux</a></li>\n<li><a href=\"https://alwayspr.tistory.com/44\">https://alwayspr.tistory.com/44</a></li>\n<li><a href=\"https://deepakpol.wordpress.com/2015/09/29/event-driven-and-reactive-architecture/\">https://deepakpol.wordpress.com/2015/09/29/event-driven-and-reactive-architecture/</a></li>\n<li><a href=\"https://dzone.com/articles/raw-performance-numbers-spring-boot-2-webflux-vs-s\">https://dzone.com/articles/raw-performance-numbers-spring-boot-2-webflux-vs-s</a></li>\n<li><a href=\"https://juneyr.dev/reactive-programming\">https://juneyr.dev/reactive-programming</a></li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#intro\">💡 Intro</a></p>\n</li>\n<li>\n<p><a href=\"#spring-webflux-%EB%9E%80\">🌩 Spring WebFlux 란?</a></p>\n</li>\n<li>\n<p><a href=\"#spring-webflux-%ED%83%84%EC%83%9D%EC%9D%B4%EC%9C%A0\">🌩 Spring WebFlux 탄생이유</a></p>\n<ul>\n<li><a href=\"#%EC%9B%B9%EC%97%90%EC%84%9C-%EB%B9%84%EB%8F%99%EA%B8%B0%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9%EC%9D%98-%ED%95%84%EC%9A%94%EC%84%B1\">웹에서 비동기/논블로킹의 필요성</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#spring-mvc-vs-spring-webflux\">🌩 Spring MVC vs. Spring WebFlux</a></p>\n<ul>\n<li><a href=\"#%EA%B5%AC%EC%B2%B4%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%8D%94-%EC%A2%8B%EC%9D%80-%EA%B1%B8%EA%B9%8C\">구체적으로 어떻게 더 좋은 걸까?</a></li>\n<li><a href=\"#spring-webflux-%EA%B5%AC%EC%A1%B0\">Spring WebFlux 구조</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#spring-webflux-%EB%AC%B4%EC%A1%B0%EA%B1%B4-%EC%A2%8B%EC%9D%84%EA%B9%8C\">🌩 Spring WebFlux 무조건 좋을까?</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%8A%90%EB%82%80-%EC%A0%90\">🛋 느낀 점</a></p>\n</li>\n</ul>\n</div>","frontmatter":{"date":"December 04, 2021","title":"리액티브 시리즈 - 2. Spring WebFlux","categories":"스프링 웹","author":"코다","emoji":"🍀"},"fields":{"slug":"/reactive-programming-2/"}},"prev":null,"site":{"siteMetadata":{"siteUrl":"https://yjksw.github.io","comments":{"utterances":{"repo":"yjksw/yjksw.github.io"}}}}},"pageContext":{"slug":"/growing-together-2/","nextSlug":"/reactive-programming-2/","prevSlug":""}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}
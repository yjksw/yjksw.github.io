{"componentChunkName":"component---src-templates-blog-template-js","path":"/high-traffic-service_2/","result":{"data":{"cur":{"id":"54e8cac2-addf-5b3e-a5e3-602ffc1f3a3d","html":"<blockquote>\n<p>다음은 웹 개발자를 위한 대규모 서비스를 지탱하는 기술을 읽고 정리한 내용입니다 🙌</p>\n</blockquote>\n<br>\n<h2 id=\"강의4\" style=\"position:relative;\"><a href=\"#%EA%B0%95%EC%9D%984\" aria-label=\"강의4 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[강의4]</h2>\n<h2 id=\"어느정도가-대규모-데이터인가-\" style=\"position:relative;\"><a href=\"#%EC%96%B4%EB%8A%90%EC%A0%95%EB%8F%84%EA%B0%80-%EB%8C%80%EA%B7%9C%EB%AA%A8-%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%9D%B8%EA%B0%80-\" aria-label=\"어느정도가 대규모 데이터인가  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>어느정도가 대규모 데이터인가 ?</h2>\n<blockquote>\n<p>이때 당시의 수치임을 감안하고 보자 !! </p>\n</blockquote>\n<ul>\n<li>\n<p>하테나의 경우</p>\n<ul>\n<li>레코드 건수 1500만, 5000만</li>\n<li>entry 테이블이 3기가, bookmark 데이블이 5.5기가 등등</li>\n<li>html 텍스트 데이터 압축 후 200 기가</li>\n<li>이정도가 중규모 ~ 대규모</li>\n<li>디비 규모가 기가바이트면 굉장히 많은 것이다.</li>\n<li>인덱스 사용 안했을 때 1건 검색시 200초 소요</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"강의5\" style=\"position:relative;\"><a href=\"#%EA%B0%95%EC%9D%985\" aria-label=\"강의5 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[강의5]</h2>\n<h2 id=\"대규모-데이터는-어떤-점이-어려운가\" style=\"position:relative;\"><a href=\"#%EB%8C%80%EA%B7%9C%EB%AA%A8-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%8A%94-%EC%96%B4%EB%96%A4-%EC%A0%90%EC%9D%B4-%EC%96%B4%EB%A0%A4%EC%9A%B4%EA%B0%80\" aria-label=\"대규모 데이터는 어떤 점이 어려운가 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>대규모 데이터는 어떤 점이 어려운가</h2>\n<ul>\n<li>한마디로 말하면 <strong>‘메모리 내에서 계산할 수 없다’</strong></li>\n<li>데이터가 너무 많으면 메모리 내에서 계산할 수 없으므로 디스크를 검색하면 읽어야하는데 디스크를 읽는 것은 계산량도 지나치게 많아지고 시간도 많이 소요된다. (I/O 시간)</li>\n<li>메모리와 디스크 속도 차이는 10만 ~ 100만배 정도</li>\n</ul>\n<h2 id=\"디스크는-왜-늦나\" style=\"position:relative;\"><a href=\"#%EB%94%94%EC%8A%A4%ED%81%AC%EB%8A%94-%EC%99%9C-%EB%8A%A6%EB%82%98\" aria-label=\"디스크는 왜 늦나 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>디스크는 왜 늦나</h2>\n<ul>\n<li>디스크의 경우 헤드의 이동과 원반의 회전이라는 두 가지 물리적인 이동이 수반되며 속도가 저하된다.</li>\n<li>\n<p>하지만 OS레벨에서 이것을 어느정도 커버하기 위해서 연속된 데이터를 같은 위치에 쌓고, 데이터를 여러 바이트씩 한꺼번에 읽도록 한다.</p>\n<ul>\n<li>이렇게 하면 한번의 디스크 회전으로 읽을 수 있는 데이터가 많으며 회전횟수를 최소화 할 수 있다.</li>\n</ul>\n</li>\n<li>\n<p>전송속도, 버스의 속도차도 있다.</p>\n<ul>\n<li>SSD는 물리적이 회전이 아니므로 탐색이 더 빠르긴 하다. 하지만 여전히 버스 속도로 인해 메모리 만큼 빠르지는 않다.</li>\n<li><strong>디스크와 메모리의 속도차를 생각하며 설계하는 것이 중요하다.</strong></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"linux-단일-호스트의-부하\" style=\"position:relative;\"><a href=\"#linux-%EB%8B%A8%EC%9D%BC-%ED%98%B8%EC%8A%A4%ED%8A%B8%EC%9D%98-%EB%B6%80%ED%95%98\" aria-label=\"linux 단일 호스트의 부하 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Linux 단일 호스트의 부하</h2>\n<ul>\n<li><strong>단일 서버의 성능을 충분히 끌어내는 것을 시작으로 복수 서버에서 부하분산이 의미를 갖는다</strong></li>\n<li><strong>추측하지 말고 계측</strong>!! 서버의 리소스를 정확히 파악하고 부하를 계측하는 것이 필요하다.</li>\n<li>\n<p>병목 규명작업 기본적인 흐름</p>\n<ul>\n<li>\n<p>Load Average 확인</p>\n<ul>\n<li>top, uptime 등의 명령어로 확인</li>\n<li>시스템 전체의 부하 상황을 나타내는 지표</li>\n<li>여기를 시초로 병목지점을 찾아나가야한다.</li>\n<li>Load Average가 낮은데 전송량이 오르지 않다면 소프트웨어 설정, 오류, 네트워크, 호스트 문제 쪽일 가능성이 높음</li>\n</ul>\n</li>\n<li>\n<p>CPU, I/O 중 병목 원인 조사</p>\n<ul>\n<li>Load Average가 높다면 둘 중 어디에 원인이 있는지 규명</li>\n<li>sar, vmstat으로 시간 경과에 CPU 사용률, I/O 대기율 추이 확인</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>CPU부하가 높을 경우 핸들링 루틴</p>\n<ul>\n<li>어플리케이션의 처리가 병목인지, 시스템 프로그램이 원인인지 top, sar로 확인</li>\n<li>ps로 프로세스 상태, CPU 사용시간 보며 원인 프로세스 찾기</li>\n<li>프로세스 찾은 후 strace로 해당 프로세스 추척, oprofile로 프로파일링</li>\n</ul>\n</li>\n<li>\n<p>주로 CPU 부하가 높은 경우</p>\n<ul>\n<li>\n<p>디스크나 메모리 용량에서 병목이 되지 않는 이상적인 상태</p>\n<ul>\n<li>서버 증설, 프로그램 로직, 알고리즘 개선 필요</li>\n</ul>\n</li>\n<li>\n<p>프로그램이 폭주해서 CPU에 필요이상의 부하가 걸리는 경우</p>\n<ul>\n<li>오류를 제거하여 프로그램 폭주를 방지</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>I/O 부하가 높은 경우</p>\n<ul>\n<li>프로그램 입출력이 많아서 부하가 높거나</li>\n<li>스왑이 발생해서 디스크 액세스가 발생</li>\n<li>sar , vmstat으로 스왑 발생상황 확인</li>\n<li>\n<p>스왑이 발생하고 있다면 다음과 같이 조사</p>\n<ul>\n<li>특정 프로세스가 극단적으로 메모리를 소비하고 있는지 ps로 확인</li>\n<li>프로그램의 오류로 메모리 소비시 프로그램 개선</li>\n<li>메모리 부족한 경우 메모리 증설, 또는 분산</li>\n</ul>\n</li>\n<li>\n<p>스왑이 아닌데 디스크로 입출력이 빈번하다면 캐시에 필요한 메모리 부족한 경우</p>\n<ul>\n<li>메모리 증설로 캐시 영역 확대</li>\n<li>또는 데이터 분산이나 캐시서버 도임</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>OS 튜닝이랑 부하의 원인을 알고 제거하는 것이다 !!!</p>\n<ul>\n<li>튜닝은 성능을 몇배씩 키워주는 것보다 ‘병목이 생기면 알아내고 제거하는 것’이다.</li>\n<li>본래 하드웨어가 가지고 있는 성능 이상을 내기는 어렵다. (그냥 하드웨어를 더 좋은걸 써야함)</li>\n</ul>\n</li>\n<li>\n<p>I/O 성능 개선을 위해서는 다음을 고려해야한다.</p>\n<ul>\n<li>메모리 증설해서 캐시영역 확보할 수 있는지</li>\n<li>데이터량이 너무 많지 않은지</li>\n<li>어플리케이션의 I/O 알고리즘을 변경해야하는지</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"강의6-규모조정의-요소\" style=\"position:relative;\"><a href=\"#%EA%B0%95%EC%9D%986-%EA%B7%9C%EB%AA%A8%EC%A1%B0%EC%A0%95%EC%9D%98-%EC%9A%94%EC%86%8C\" aria-label=\"강의6 규모조정의 요소 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[강의6] 규모조정의 요소</h2>\n<h2 id=\"규모조정-확장성\" style=\"position:relative;\"><a href=\"#%EA%B7%9C%EB%AA%A8%EC%A1%B0%EC%A0%95-%ED%99%95%EC%9E%A5%EC%84%B1\" aria-label=\"규모조정 확장성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>규모조정, 확장성</h2>\n<ul>\n<li>앞에서 이야기한 대규모 데이터가 시스템 전체의 확장성 전략에 어떠한 영향을 주나</li>\n<li>\n<p>웹 서비스에서는 스케일업 보다 스케일아웃 전략이 주류이다. </p>\n<ul>\n<li>웹 서비스에 적합하고 비용이 저렴, 시스템 구성에 유연함</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"규모조정의-요소---cpu-부하와-io-부하\" style=\"position:relative;\"><a href=\"#%EA%B7%9C%EB%AA%A8%EC%A1%B0%EC%A0%95%EC%9D%98-%EC%9A%94%EC%86%8C---cpu-%EB%B6%80%ED%95%98%EC%99%80-io-%EB%B6%80%ED%95%98\" aria-label=\"규모조정의 요소   cpu 부하와 io 부하 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>규모조정의 요소 - CPU 부하와 I/O 부하</h2>\n<ul>\n<li>스케일아웃으로 CPU 부하분산의 확장성 확보는 쉬움</li>\n<li>DB 서버에서는 I/O 부하가 걸린다.</li>\n</ul>\n<h2 id=\"웹-어플리케이션과-부하의-관계\" style=\"position:relative;\"><a href=\"#%EC%9B%B9-%EC%96%B4%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%EA%B3%BC-%EB%B6%80%ED%95%98%EC%9D%98-%EA%B4%80%EA%B3%84\" aria-label=\"웹 어플리케이션과 부하의 관계 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>웹 어플리케이션과 부하의 관계</h2>\n<ul>\n<li>\n<p>WAS는 CPU부하만 걸린다.</p>\n<ul>\n<li>서버를 늘리면 확장이 가능</li>\n<li>로드밸런서 장치 활용</li>\n</ul>\n</li>\n<li>\n<p>DB에서 I/O 부하 문제 발생</p>\n<ul>\n<li>여러 DB 서버를 두었을 때 동기화가 이슈가 됨</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"db-확장성-확보-어려움\" style=\"position:relative;\"><a href=\"#db-%ED%99%95%EC%9E%A5%EC%84%B1-%ED%99%95%EB%B3%B4-%EC%96%B4%EB%A0%A4%EC%9B%80\" aria-label=\"db 확장성 확보 어려움 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>DB 확장성 확보 어려움</h2>\n<ul>\n<li>디스크 속도 저하의 문제가 여기에 영향을 미침</li>\n<li>DB에서 디스크 많이 사용 → 데이터가 커지면 메모리에서 처리하지 못하고 디스크에서 처리할 수밖에 없음</li>\n<li>서버를 늘려서 해결할 수 없는 문제다.</li>\n</ul>\n<h2 id=\"-두-종류의-부하와-웹-어플리케이션\" style=\"position:relative;\"><a href=\"#-%EB%91%90-%EC%A2%85%EB%A5%98%EC%9D%98-%EB%B6%80%ED%95%98%EC%99%80-%EC%9B%B9-%EC%96%B4%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98\" aria-label=\" 두 종류의 부하와 웹 어플리케이션 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>+ 두 종류의 부하와 웹 어플리케이션</h2>\n<ul>\n<li>CPU 부하</li>\n<li>I/O 부하</li>\n</ul>\n<p>WAS는 CPU 바운드한 서버, DB는 I/O 바운드한 서버이다. </p>\n<h3 id=\"멀티태스킹-os와-부하\" style=\"position:relative;\"><a href=\"#%EB%A9%80%ED%8B%B0%ED%83%9C%EC%8A%A4%ED%82%B9-os%EC%99%80-%EB%B6%80%ED%95%98\" aria-label=\"멀티태스킹 os와 부하 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>멀티태스킹 OS와 부하</h3>\n<ul>\n<li>멀티태스킹으로 태스크를 처리하면서 태스크가 대기하게 된다.</li>\n<li>\n<p>top 명령어의 load average에 단위 시간당 대기된 태스크의 수, 즉, 평균 어느정도 태스크가 대기상태로 있었는지 보여준다.</p>\n<ul>\n<li>높은 숫자는 태스크 실행에 대기가 발생한다는 표시 → 부하가 높은 상황</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"위-부하의-정체\" style=\"position:relative;\"><a href=\"#%EC%9C%84-%EB%B6%80%ED%95%98%EC%9D%98-%EC%A0%95%EC%B2%B4\" aria-label=\"위 부하의 정체 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>위 부하의 정체</h3>\n<ul>\n<li>하드웨어는 CPU 인터럽트로 주기적 신호를 보내서 실행 중인 프로세스가 CPU를 얼마나 사용했는지 계산한다. 이 타이머 인터럽트마다 Load Average 값이 계산된다.</li>\n<li>\n<p>타이머 인터럽트 때 실행 가능 상태인 태스크(가용 가능한 CPU가 없어서 대기중인 프로세스)와 I/O 대기인 태스크의 개수를 세어서 단위시간으로 나눈 값으로 load avarage를 측정한다.</p>\n<ul>\n<li>처리를 실행하려고 해도 실행할 수 없어서 대기하는 프로세스의 수</li>\n</ul>\n</li>\n<li>이 값으로 부하 정도를 알 수 있고 CPU 부하인지 I/O 부하인지 판단하기는 어려워서 더 자세히 규명해야 한다.</li>\n</ul>\n<br>\n<h2 id=\"강의7\" style=\"position:relative;\"><a href=\"#%EA%B0%95%EC%9D%987\" aria-label=\"강의7 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[강의7]</h2>\n<p>대규모 데이터를 다루는 두가지 관점 </p>\n<ol>\n<li>프로그램을 작성할 때의 요령 </li>\n<li>프로그램 개발의 근간이 되는 기초라는 점에서 전제로 알아두면 좋은 것 </li>\n</ol>\n<h2 id=\"대규모-데이터-3가지-중요점---프로그램-작성시-중요\" style=\"position:relative;\"><a href=\"#%EB%8C%80%EA%B7%9C%EB%AA%A8-%EB%8D%B0%EC%9D%B4%ED%84%B0-3%EA%B0%80%EC%A7%80-%EC%A4%91%EC%9A%94%EC%A0%90---%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8-%EC%9E%91%EC%84%B1%EC%8B%9C-%EC%A4%91%EC%9A%94\" aria-label=\"대규모 데이터 3가지 중요점   프로그램 작성시 중요 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>대규모 데이터 3가지 중요점 - 프로그램 작성시 중요</h2>\n<ul>\n<li>어떻게 메모리에서 처리를 마칠 수 있을까</li>\n<li>데이터량 증가에 강한 알고리즘 (효율적인 탐색 알고리즘)</li>\n<li>\n<p>데이터 압축이나 검색기술과 같은 테크닉 활용</p>\n<ul>\n<li>압축하면 메모리에 캐싱하기 쉬움</li>\n<li>확장성 면에서 DB에 맡겨서 해결될 수 없을 때 검색엔진을 만들어서 속도를 확보할 수 있음</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"대규모-데이터-다루기-3대-전제지식---프로그램-개발-기초\" style=\"position:relative;\"><a href=\"#%EB%8C%80%EA%B7%9C%EB%AA%A8-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%8B%A4%EB%A3%A8%EA%B8%B0-3%EB%8C%80-%EC%A0%84%EC%A0%9C%EC%A7%80%EC%8B%9D---%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8-%EA%B0%9C%EB%B0%9C-%EA%B8%B0%EC%B4%88\" aria-label=\"대규모 데이터 다루기 3대 전제지식   프로그램 개발 기초 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>대규모 데이터 다루기 3대 전제지식 - 프로그램 개발 기초</h2>\n<ul>\n<li>OS 캐시</li>\n<li>분산 고려 RDBMS</li>\n<li>대규모 환경에서 알고리즘과 데이터구조 사용</li>\n</ul>\n<h2 id=\"-load-average-다음에-cpu-사용률과-io-대기율\" style=\"position:relative;\"><a href=\"#-load-average-%EB%8B%A4%EC%9D%8C%EC%97%90-cpu-%EC%82%AC%EC%9A%A9%EB%A5%A0%EA%B3%BC-io-%EB%8C%80%EA%B8%B0%EC%9C%A8\" aria-label=\" load average 다음에 cpu 사용률과 io 대기율 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>+ Load Average 다음에 CPU 사용률과 I/O 대기율</h2>\n<ul>\n<li>\n<p>sar(System Activity Reporter) 명령어로 CPU 대기율, I/O 대기율 확인</p>\n<ul>\n<li>Load average가 높고 <code class=\"language-text\">sar</code>의 <code class=\"language-text\">%user</code>, <code class=\"language-text\">%system</code> CPU 사용률 수치가 높으면 부하 원인이 CPU 리소스 부족</li>\n<li>Load average가 높고 <code class=\"language-text\">sar</code>의 <code class=\"language-text\">%iowait</code> CPU 사용률 수치가 높으면 부하 원인이 I/O</li>\n</ul>\n</li>\n<li>여기까지 알았다면 더 자세히 보기 위해 메모리 사용률, 스왑 발생 상황을 들여다본다.</li>\n<li>\n<p>멀티 CPU 인 경우 더 자세히 볼 필요가 있다.</p>\n<ul>\n<li>sar -p 옵션으로 여러 CPU 사용시 각 CPU의 지표를 볼 수 있다.</li>\n<li>I/O의 경우 전체 CPU의 <code class=\"language-text\">%iowait</code>의 지표는 높지 않을 수 있으나 각 CPU의 지표를 보았을 때 특정 CPU의 지표가 높을 수 있다.</li>\n<li>이는 멀티 CPU 이더라도 디스크는 하나밖에 없는 경우 I/O 부하가 분산되지 않기 때문이다.</li>\n</ul>\n</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#%EA%B0%95%EC%9D%984\">강의4</a></li>\n<li><a href=\"#%EC%96%B4%EB%8A%90%EC%A0%95%EB%8F%84%EA%B0%80-%EB%8C%80%EA%B7%9C%EB%AA%A8-%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%9D%B8%EA%B0%80-\">어느정도가 대규모 데이터인가 ?</a></li>\n<li><a href=\"#%EA%B0%95%EC%9D%985\">강의5</a></li>\n<li><a href=\"#%EB%8C%80%EA%B7%9C%EB%AA%A8-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%8A%94-%EC%96%B4%EB%96%A4-%EC%A0%90%EC%9D%B4-%EC%96%B4%EB%A0%A4%EC%9A%B4%EA%B0%80\">대규모 데이터는 어떤 점이 어려운가</a></li>\n<li><a href=\"#%EB%94%94%EC%8A%A4%ED%81%AC%EB%8A%94-%EC%99%9C-%EB%8A%A6%EB%82%98\">디스크는 왜 늦나</a></li>\n<li><a href=\"#linux-%EB%8B%A8%EC%9D%BC-%ED%98%B8%EC%8A%A4%ED%8A%B8%EC%9D%98-%EB%B6%80%ED%95%98\">Linux 단일 호스트의 부하</a></li>\n<li><a href=\"#%EA%B0%95%EC%9D%986-%EA%B7%9C%EB%AA%A8%EC%A1%B0%EC%A0%95%EC%9D%98-%EC%9A%94%EC%86%8C\">강의6 규모조정의 요소</a></li>\n<li><a href=\"#%EA%B7%9C%EB%AA%A8%EC%A1%B0%EC%A0%95-%ED%99%95%EC%9E%A5%EC%84%B1\">규모조정, 확장성</a></li>\n<li><a href=\"#%EA%B7%9C%EB%AA%A8%EC%A1%B0%EC%A0%95%EC%9D%98-%EC%9A%94%EC%86%8C---cpu-%EB%B6%80%ED%95%98%EC%99%80-io-%EB%B6%80%ED%95%98\">규모조정의 요소 - CPU 부하와 I/O 부하</a></li>\n<li><a href=\"#%EC%9B%B9-%EC%96%B4%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%EA%B3%BC-%EB%B6%80%ED%95%98%EC%9D%98-%EA%B4%80%EA%B3%84\">웹 어플리케이션과 부하의 관계</a></li>\n<li><a href=\"#db-%ED%99%95%EC%9E%A5%EC%84%B1-%ED%99%95%EB%B3%B4-%EC%96%B4%EB%A0%A4%EC%9B%80\">DB 확장성 확보 어려움</a></li>\n<li>\n<p><a href=\"#-%EB%91%90-%EC%A2%85%EB%A5%98%EC%9D%98-%EB%B6%80%ED%95%98%EC%99%80-%EC%9B%B9-%EC%96%B4%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98\">+ 두 종류의 부하와 웹 어플리케이션</a></p>\n<ul>\n<li><a href=\"#%EB%A9%80%ED%8B%B0%ED%83%9C%EC%8A%A4%ED%82%B9-os%EC%99%80-%EB%B6%80%ED%95%98\">멀티태스킹 OS와 부하</a></li>\n<li><a href=\"#%EC%9C%84-%EB%B6%80%ED%95%98%EC%9D%98-%EC%A0%95%EC%B2%B4\">위 부하의 정체</a></li>\n</ul>\n</li>\n<li><a href=\"#%EA%B0%95%EC%9D%987\">강의7</a></li>\n<li><a href=\"#%EB%8C%80%EA%B7%9C%EB%AA%A8-%EB%8D%B0%EC%9D%B4%ED%84%B0-3%EA%B0%80%EC%A7%80-%EC%A4%91%EC%9A%94%EC%A0%90---%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8-%EC%9E%91%EC%84%B1%EC%8B%9C-%EC%A4%91%EC%9A%94\">대규모 데이터 3가지 중요점 - 프로그램 작성시 중요</a></li>\n<li><a href=\"#%EB%8C%80%EA%B7%9C%EB%AA%A8-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%8B%A4%EB%A3%A8%EA%B8%B0-3%EB%8C%80-%EC%A0%84%EC%A0%9C%EC%A7%80%EC%8B%9D---%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8-%EA%B0%9C%EB%B0%9C-%EA%B8%B0%EC%B4%88\">대규모 데이터 다루기 3대 전제지식 - 프로그램 개발 기초</a></li>\n<li><a href=\"#-load-average-%EB%8B%A4%EC%9D%8C%EC%97%90-cpu-%EC%82%AC%EC%9A%A9%EB%A5%A0%EA%B3%BC-io-%EB%8C%80%EA%B8%B0%EC%9C%A8\">+ Load Average 다음에 CPU 사용률과 I/O 대기율</a></li>\n</ul>\n</div>","excerpt":"다음은 웹 개발자를 위한 대규모 서비스를 지탱하는 기술을 읽고 정리한 내용입니다 🙌 강의4 어느정도가 대규모 데이터인가 ? 이때 당시의 수치임을 감안하고 보자 !!  하테나의 경우 레코드 건수 1500만, 5000만 entry 테이블이 3기가, bookmark 데이블이 5.5기가 등등 html 텍스트 데이터 압축 후 200 기가 이정도가 중규모 ~ 대규모 디비 규모가 기가바이트면 굉장히 많은 것이다. 인덱스 사용 안했을 때 1건 검색시 200초 소요 강의5 대규모 데이터는 어떤 점이 어려운가 한마디로 말하면 ‘메모리 내에서 계산할 수 없다’ 데이터가 너무 많으면 메모리 내에서 계산할 수 없으므로 디스크를 검색하면 읽어야하는데 디스크를 읽는 것은 계산량도 지나치게 많아지고 시간도 많이 소요된다. (I/O 시간) 메모리와 디스크 속도 차이는 10만 ~ 100만배 정도 디스크는 왜 늦나 디스크의 경우 헤드의 이동과 원반의 회전이라는 두 가지 물리적인 이동이 수반되며 속도가 저하된다. 하…","frontmatter":{"date":"September 23, 2021","title":"대규모 서비스를 지탱하는 기술 - 대규모 데이터 처리","categories":"웹 인프라 책","author":"코다","emoji":"📚"},"fields":{"slug":"/high-traffic-service_2/"}},"next":{"id":"72eb0efc-2aca-58a7-8046-5b6afbb9b2fb","html":"<blockquote>\n<p>다음은 웹 개발자를 위한 대규모 서비스를 지탱하는 기술을 읽고 정리한 내용입니다 🙌</p>\n</blockquote>\n<br>\n<h3 id=\"어느-정도가-대규모-인가-\" style=\"position:relative;\"><a href=\"#%EC%96%B4%EB%8A%90-%EC%A0%95%EB%8F%84%EA%B0%80-%EB%8C%80%EA%B7%9C%EB%AA%A8-%EC%9D%B8%EA%B0%80-\" aria-label=\"어느 정도가 대규모 인가  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>어느 정도가 대규모 인가 ?</h3>\n<p>이것은 이 책이 쓰여졌을 당시의 상황이다. 전혀 감이 없으니 이때 당시의 대규모 정도를 숫자로 파악해보자. </p>\n<ul>\n<li>등록 사용자 100만 명 이상, 1500만 UU</li>\n<li>서버 500대 이상</li>\n<li>피크시 회선 트래픽 430Mbps</li>\n</ul>\n<h2 id=\"강의1\" style=\"position:relative;\"><a href=\"#%EA%B0%95%EC%9D%981\" aria-label=\"강의1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[강의1]</h2>\n<h2 id=\"소규모-서비스와-대규모-서비스의-차이\" style=\"position:relative;\"><a href=\"#%EC%86%8C%EA%B7%9C%EB%AA%A8-%EC%84%9C%EB%B9%84%EC%8A%A4%EC%99%80-%EB%8C%80%EA%B7%9C%EB%AA%A8-%EC%84%9C%EB%B9%84%EC%8A%A4%EC%9D%98-%EC%B0%A8%EC%9D%B4\" aria-label=\"소규모 서비스와 대규모 서비스의 차이 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>소규모 서비스와 대규모 서비스의 차이</h2>\n<h3 id=\"확장성-확보-부하분산-필요\" style=\"position:relative;\"><a href=\"#%ED%99%95%EC%9E%A5%EC%84%B1-%ED%99%95%EB%B3%B4-%EB%B6%80%ED%95%98%EB%B6%84%EC%82%B0-%ED%95%84%EC%9A%94\" aria-label=\"확장성 확보 부하분산 필요 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>확장성 확보, 부하분산 필요</h3>\n<p>1대의 서버로 처리 할 수 없는 부하를 어떻게 처리할 것인가 ? </p>\n<ul>\n<li>스케일 아웃 → 서버 대수를 늘림으로 스스템 처리능력을 높임</li>\n<li>스케일 업  → 하드웨어 성능을 높여 처리 능력을 끌어올림</li>\n</ul>\n<p>여러대의 서버를 사용했을 때 파생되는 문제 </p>\n<ul>\n<li>데이터 동기화, 네트워크 통신 지연시간,</li>\n</ul>\n<h3 id=\"다중성-확보\" style=\"position:relative;\"><a href=\"#%EB%8B%A4%EC%A4%91%EC%84%B1-%ED%99%95%EB%B3%B4\" aria-label=\"다중성 확보 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>다중성 확보</h3>\n<ul>\n<li>특정 서버가 고장이 나도 서비스를 계속 할 수 있어야 함</li>\n<li>스케일아웃은 서버의 고장율이 올라가고 하나가 고장났다고 전체가 정지해버릴 순 없다.</li>\n<li>시스템이 고장나면 다른 시스템이 자동으로 처리를 인계받는 시스템 설계가 필요</li>\n</ul>\n<h3 id=\"효율적-운용-필요\" style=\"position:relative;\"><a href=\"#%ED%9A%A8%EC%9C%A8%EC%A0%81-%EC%9A%B4%EC%9A%A9-%ED%95%84%EC%9A%94\" aria-label=\"효율적 운용 필요 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>효율적 운용 필요</h3>\n<ul>\n<li>서버의 상태를 확인하고, 부하, 헬스, 디스크 용량, 보안 등을 체크할 수 있어야한다.</li>\n<li>여러대의 서버일 경우 효율적으로 운용하기 어려움.</li>\n</ul>\n<h3 id=\"개발자-수-개발방법의-변화\" style=\"position:relative;\"><a href=\"#%EA%B0%9C%EB%B0%9C%EC%9E%90-%EC%88%98-%EA%B0%9C%EB%B0%9C%EB%B0%A9%EB%B2%95%EC%9D%98-%EB%B3%80%ED%99%94\" aria-label=\"개발자 수 개발방법의 변화 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>개발자 수, 개발방법의 변화</h3>\n<ul>\n<li>여러 사람이 개발을 하게 되면서 개발 표준화는 어떻게 해야하나, 컨벤션, 언어 통일, 라이브러리, 프레임워크 통일 등등의 표준화가 필요</li>\n</ul>\n<h2 id=\"대규모-데이터량에-대한-대처\" style=\"position:relative;\"><a href=\"#%EB%8C%80%EA%B7%9C%EB%AA%A8-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%9F%89%EC%97%90-%EB%8C%80%ED%95%9C-%EB%8C%80%EC%B2%98\" aria-label=\"대규모 데이터량에 대한 대처 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>대규모 데이터량에 대한 대처</h2>\n<ul>\n<li>\n<p>데이터 처리 과정</p>\n<ul>\n<li>디스크 → 메모리 → 캐시 메모리 → CPU</li>\n</ul>\n</li>\n<li>디스크와 CPU에서의 속도차이는 엄청나다</li>\n<li>미들웨어, 케싱등을 사용해서 데이터 처리 속도를 향상시키곤 한다.</li>\n<li>\n<p>하지만 대규모 서비스에서는 한계가 있다.</p>\n<ul>\n<li>데이터가 많아지면 캐시 미스가 많이 발생</li>\n<li>그러므로 디스크 I/O 가 많아져서 속도가 저하됨</li>\n</ul>\n</li>\n<li>소규모 서비스에서는 큰 문제가 아니지만 데이터량이 기하급수적으로 많으면 문제가 복잡해짐</li>\n</ul>\n<h2 id=\"강의2\" style=\"position:relative;\"><a href=\"#%EA%B0%95%EC%9D%982\" aria-label=\"강의2 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[강의2]</h2>\n<h2 id=\"웹-서비스의-어려움\" style=\"position:relative;\"><a href=\"#%EC%9B%B9-%EC%84%9C%EB%B9%84%EC%8A%A4%EC%9D%98-%EC%96%B4%EB%A0%A4%EC%9B%80\" aria-label=\"웹 서비스의 어려움 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>웹 서비스의 어려움</h2>\n<ul>\n<li>게속 점진적으로 성장해가기 때문에 운영 환경에 변화를 야기한다.</li>\n</ul>\n<h2 id=\"하테나의-예시\" style=\"position:relative;\"><a href=\"#%ED%95%98%ED%85%8C%EB%82%98%EC%9D%98-%EC%98%88%EC%8B%9C\" aria-label=\"하테나의 예시 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>하테나의 예시</h2>\n<ul>\n<li>트래픽이 많아지고 서버를 데이터 센터로 이전</li>\n<li>\n<p>이전하며 부하 상황정리</p>\n<ul>\n<li>병목지점 측정</li>\n<li>I/O 부하가 높은 서버는 메모리 중시</li>\n<li>CPU 부하가 높은 서버는 CPU를 중시 등으로 최적 구성으로 하드웨어 배치</li>\n<li>로드밸런서로 다중화</li>\n</ul>\n</li>\n<li>성급한 최적화가 좋은 건 아니다. 낮은 확률에 지나친 비용을 쏟아야 한다. 하지만 너무 불완전해서는 안된다.</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<ul>\n<li><a href=\"#%EC%96%B4%EB%8A%90-%EC%A0%95%EB%8F%84%EA%B0%80-%EB%8C%80%EA%B7%9C%EB%AA%A8-%EC%9D%B8%EA%B0%80-\">어느 정도가 대규모 인가 ?</a></li>\n</ul>\n</li>\n<li><a href=\"#%EA%B0%95%EC%9D%981\">강의1</a></li>\n<li>\n<p><a href=\"#%EC%86%8C%EA%B7%9C%EB%AA%A8-%EC%84%9C%EB%B9%84%EC%8A%A4%EC%99%80-%EB%8C%80%EA%B7%9C%EB%AA%A8-%EC%84%9C%EB%B9%84%EC%8A%A4%EC%9D%98-%EC%B0%A8%EC%9D%B4\">소규모 서비스와 대규모 서비스의 차이</a></p>\n<ul>\n<li><a href=\"#%ED%99%95%EC%9E%A5%EC%84%B1-%ED%99%95%EB%B3%B4-%EB%B6%80%ED%95%98%EB%B6%84%EC%82%B0-%ED%95%84%EC%9A%94\">확장성 확보, 부하분산 필요</a></li>\n<li><a href=\"#%EB%8B%A4%EC%A4%91%EC%84%B1-%ED%99%95%EB%B3%B4\">다중성 확보</a></li>\n<li><a href=\"#%ED%9A%A8%EC%9C%A8%EC%A0%81-%EC%9A%B4%EC%9A%A9-%ED%95%84%EC%9A%94\">효율적 운용 필요</a></li>\n<li><a href=\"#%EA%B0%9C%EB%B0%9C%EC%9E%90-%EC%88%98-%EA%B0%9C%EB%B0%9C%EB%B0%A9%EB%B2%95%EC%9D%98-%EB%B3%80%ED%99%94\">개발자 수, 개발방법의 변화</a></li>\n</ul>\n</li>\n<li><a href=\"#%EB%8C%80%EA%B7%9C%EB%AA%A8-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%9F%89%EC%97%90-%EB%8C%80%ED%95%9C-%EB%8C%80%EC%B2%98\">대규모 데이터량에 대한 대처</a></li>\n<li><a href=\"#%EA%B0%95%EC%9D%982\">강의2</a></li>\n<li><a href=\"#%EC%9B%B9-%EC%84%9C%EB%B9%84%EC%8A%A4%EC%9D%98-%EC%96%B4%EB%A0%A4%EC%9B%80\">웹 서비스의 어려움</a></li>\n<li><a href=\"#%ED%95%98%ED%85%8C%EB%82%98%EC%9D%98-%EC%98%88%EC%8B%9C\">하테나의 예시</a></li>\n</ul>\n</div>","frontmatter":{"date":"September 23, 2021","title":"대규모 서비스를 지탱하는 기술 - 오리엔테이션","categories":"웹 인프라 책","author":"코다","emoji":"📚"},"fields":{"slug":"/high-traffic-service_1/"}},"prev":{"id":"fe08b31d-d1b9-5132-8265-561e8d82be9a","html":"<blockquote>\n<p>다음은 웹 개발자를 위한 대규모 서비스를 지탱하는 기술을 읽고 정리한 내용입니다 🙌</p>\n</blockquote>\n<br>\n<h2 id=\"강의8-os-캐시-구조\" style=\"position:relative;\"><a href=\"#%EA%B0%95%EC%9D%988-os-%EC%BA%90%EC%8B%9C-%EA%B5%AC%EC%A1%B0\" aria-label=\"강의8 os 캐시 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[강의8] OS 캐시 구조</h2>\n<h2 id=\"os의-캐시-구조를-알고-애플리케이션-작성하기---페이지-캐시\" style=\"position:relative;\"><a href=\"#os%EC%9D%98-%EC%BA%90%EC%8B%9C-%EA%B5%AC%EC%A1%B0%EB%A5%BC-%EC%95%8C%EA%B3%A0-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EC%9E%91%EC%84%B1%ED%95%98%EA%B8%B0---%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C\" aria-label=\"os의 캐시 구조를 알고 애플리케이션 작성하기   페이지 캐시 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>OS의 캐시 구조를 알고 애플리케이션 작성하기 - 페이지 캐시</h2>\n<ul>\n<li>OS는 메모리를 이용해서 캐시 구조를 갖추고 디스크 액세스를 줄인다.</li>\n</ul>\n<h3 id=\"linuxx86-페이징-구조\" style=\"position:relative;\"><a href=\"#linuxx86-%ED%8E%98%EC%9D%B4%EC%A7%95-%EA%B5%AC%EC%A1%B0\" aria-label=\"linuxx86 페이징 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Linux(x86) 페이징 구조</h3>\n<p>OS는 가장 메모리 구조를 가지고 있는데 논리적인 선형 어드레스를 물리적인 어드레스로 변환한다. </p>\n<h2 id=\"가상-메모리-구조\" style=\"position:relative;\"><a href=\"#%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0\" aria-label=\"가상 메모리 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>가상 메모리 구조</h2>\n<p>기본적인 OS 구조를 보면 OS에서 관리하고 있는 메모리 구조 있고, OS가 있으며 OS에서 돌아가는 프로세스가 존재한다. 프로세스에서 메모리가 필요한 경우 메모리에 직접 접근해서 주소를 가져오는 것이 아니라, OS를 통해서 비어있는 주소와 다른 주소를 반환한다. </p>\n<h3 id=\"왜-가상-주소를-반환할까\" style=\"position:relative;\"><a href=\"#%EC%99%9C-%EA%B0%80%EC%83%81-%EC%A3%BC%EC%86%8C%EB%A5%BC-%EB%B0%98%ED%99%98%ED%95%A0%EA%B9%8C\" aria-label=\"왜 가상 주소를 반환할까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>왜 가상 주소를 반환할까?</h3>\n<p>개별 프로세스가 실제로 메모리의 어느 부분을 사용하는지 스스로 알고 있을 필요가 없고, 특정 번지에서 통일해서 시작하는 것으로 다루면 더 쉽기 때문이다. </p>\n<ul>\n<li>예) 유닉스에서 공유 라이브러리는 프로세스 내에서 지정된 주소로 할당이 되어 있는데 프로세스 내에서 이 특정 어드레스는 예약에 되어 있음. 따라서 시작주소가 다 다르면 메모리를 확보할 주소위치를 찾기가 어려움</li>\n</ul>\n<p>어쨌든 OS 커널에서 메모리를 추상화해서 넘기고 있다 !!! </p>\n<p>또한 OS에서 메모리를 확보할 때도 단일 바이트 만큼씩 액세스 하는 것이 아니라 4KB 정도의 블록을 확보해서 프로세스에 넘긴다. <strong>블록 = 페이지 (즉, OS가 메모리를 확보하는 단위)</strong> </p>\n<p>OS는 메모리 요청을 받을 때 필요한 만큼의 페이지를 확보해서 프로세스에 넘긴다.  </p>\n<h2 id=\"linux-페이지-캐시의-원리\" style=\"position:relative;\"><a href=\"#linux-%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C%EC%9D%98-%EC%9B%90%EB%A6%AC\" aria-label=\"linux 페이지 캐시의 원리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Linux 페이지 캐시의 원리</h2>\n<p>OS는 확보한 페이지를 메모리상에 캐싱해둔다. </p>\n<h3 id=\"프로세스가-디스크에서-데이터를-읽어내는-과정\" style=\"position:relative;\"><a href=\"#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EA%B0%80-%EB%94%94%EC%8A%A4%ED%81%AC%EC%97%90%EC%84%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A5%BC-%EC%9D%BD%EC%96%B4%EB%82%B4%EB%8A%94-%EA%B3%BC%EC%A0%95\" aria-label=\"프로세스가 디스크에서 데이터를 읽어내는 과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>프로세스가 디스크에서 데이터를 읽어내는 과정</h3>\n<p>첫번째, 우선 디스크로부터 4KB 정도의 블록을 읽어냄</p>\n<p>두번째, 우선 메모리에 해당 읽어낸 데이터를 위치시킴 </p>\n<ul>\n<li>프로세스는 디스크에서 데이터를 직접 읽을 수는 없다 ! 프로세스가 액세스 할 수 있는 것은 가상 메모리 주소이기 때문이다.</li>\n</ul>\n<p>세번째, OS는 메모리에 쓰인 블록의 해당 주소를 프로세스에 가상 주소로 변환해서 알려준다. </p>\n<p>네번째, 프로세스는 해당 가상 주소로 메모리에 액세스 하게 된다. </p>\n<p align=\"center\"><img width=\"85%\" src=\"https://user-images.githubusercontent.com/63405904/136983984-be05b727-15c4-485c-8cf8-9f349a1d3fff.png\"><br>이미지 출처: 대용량 서비스를 지탱하는 기술</p>\n<p><strong>페이지 캐시 등장 -</strong> 이후에 더이상 프로세스가 데이터가 필요하지 않더라도 메모리에 쓰인 블럭을 해제하지 않고 남겨둔다. 그럼 다음 프로세스가 같은 디스크에 액세스할 때 해당 페이지를 재사용한다. </p>\n<h3 id=\"페이지-캐시의-효과\" style=\"position:relative;\"><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C%EC%9D%98-%ED%9A%A8%EA%B3%BC\" aria-label=\"페이지 캐시의 효과 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>페이지 캐시의 효과</h3>\n<p>리눅스의 페이지 캐시는 모든 I/O에 작용(예외를 제외하고)하여 디스크를 최초 읽은 이후 두번째 액세스부터 빨라진다. (OS를 계속 가동시켜두면 빨라진다. 재부팅 시 메모리에 캐시된 데이터는 없어진다.) </p>\n<h2 id=\"vfs\" style=\"position:relative;\"><a href=\"#vfs\" aria-label=\"vfs permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>VFS</h2>\n<p>리눅스의 구조는 다음과 같다. </p>\n<ul>\n<li>최하위에 하드디스크를 조작하는 디바이스 드라이버 → 위에 여러 파일 시스템 (리눅스의 경우 ext3, ext2, ext4, 등등) → vfs (virtual file system)</li>\n<li>파일시스템은 다양한 함수를 갖추고 있는데 인터페이스를 통일하기 위해 있는 것이 vfs 이다.</li>\n</ul>\n<p>VFS가 페이지 캐시 구조를 가지고 있다. → 어떤 파일 시스템을 이용하여 어떤 디스크를 읽어도 vfs를 통해서 동일한 구조로 캐싱이 된다. </p>\n<p><strong>한마디로, VFS의 역할은 파일시스템 추상화와 성능에 관여하는 페이지 캐시 부분이다.</strong> </p>\n<h2 id=\"리눅스는-페이지-단위로-디스크를-캐싱\" style=\"position:relative;\"><a href=\"#%EB%A6%AC%EB%88%85%EC%8A%A4%EB%8A%94-%ED%8E%98%EC%9D%B4%EC%A7%80-%EB%8B%A8%EC%9C%84%EB%A1%9C-%EB%94%94%EC%8A%A4%ED%81%AC%EB%A5%BC-%EC%BA%90%EC%8B%B1\" aria-label=\"리눅스는 페이지 단위로 디스크를 캐싱 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>리눅스는 페이지 단위로 디스크를 캐싱</h2>\n<h3 id=\"왜-파일-캐시가-아니라-페이지-캐시일까-\" style=\"position:relative;\"><a href=\"#%EC%99%9C-%ED%8C%8C%EC%9D%BC-%EC%BA%90%EC%8B%9C%EA%B0%80-%EC%95%84%EB%8B%88%EB%9D%BC-%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C%EC%9D%BC%EA%B9%8C-\" aria-label=\"왜 파일 캐시가 아니라 페이지 캐시일까  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>왜 파일 캐시가 아니라 페이지 캐시일까 ?</h3>\n<p>만일 메모리에 남은 여유 메모리 공간이 1.5 GB이고 필요한 파일이 4GB 일 경우 문제가 발생한다. </p>\n<p>OS는 파일(현재 4GB 단위) 기준으로 캐싱하는 것이 아니라 블록 단위(4KB 단위)만으로 캐싱한다. 특정 파일의 읽어낸 일부분만 캐싱한다. </p>\n<ul>\n<li><strong>페이지 == 가상 메모리의 최소단위</strong></li>\n</ul>\n<h3 id=\"lru\" style=\"position:relative;\"><a href=\"#lru\" aria-label=\"lru permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>LRU</h3>\n<p>만일 적은 여유분의 메모리에 4GB 파일을 모두 읽게 된다면 LRU(Least Recently Used) 방식으로 캐싱이 최신화 된다. 따라서 DB 서버도 계속 구동시키면 캐시가 최적화되어 I/O 부하가 내려간다. </p>\n<h3 id=\"어떻게-캐싱이-될까\" style=\"position:relative;\"><a href=\"#%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%BA%90%EC%8B%B1%EC%9D%B4-%EB%90%A0%EA%B9%8C\" aria-label=\"어떻게 캐싱이 될까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>어떻게 캐싱이 될까</h3>\n<p>리눅스는 파일을 i노드 번호라는 번호로 식별하고 어느 위치에서 시작하는 오프셋을 제공하여 두가지 정보를 함께 캐싱한다. 따라서 파일 전체가 아닌 일부분을 캐싱할 수 있다.</p>\n<p>이 키가 너무 많으면 파일이 클 경우 데이터 찾는 것이 어렵다고 여겨질 수 있는 데이터 구조는 <strong>Radix Tree</strong>라는 구조로 탐색 속도가 떨어지지 않는다. </p>\n<h2 id=\"메모리가-비어있으면-캐싱\" style=\"position:relative;\"><a href=\"#%EB%A9%94%EB%AA%A8%EB%A6%AC%EA%B0%80-%EB%B9%84%EC%96%B4%EC%9E%88%EC%9C%BC%EB%A9%B4-%EC%BA%90%EC%8B%B1\" aria-label=\"메모리가 비어있으면 캐싱 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>메모리가 비어있으면 캐싱</h2>\n<p>리눅스는 메모리가 비어있으면 모두 캐싱 → 프로세스에 메모리가 필요하면 오래돈 캐시를 버리고 메모리 확보</p>\n<ul>\n<li>\n<p>메모리 상황 알아보기</p>\n<p><code class=\"language-text\">sar -r</code> 명령어를 통해서 <code class=\"language-text\">kbcached</code>(kilo byte cached) 부분과 <code class=\"language-text\">%memused</code> 부분으로 확인할 수 있다. 주로 꽉찬 메모리를 확인할 수 있는데 이것은 문제가 아니다. 본래 리눅스는 가용 가능한 메모리에 조금씩 디스크를 모두 캐싱하고 추가 메모리가 필요하면 오래된 캐시를 파기한다. </p>\n</li>\n</ul>\n<h2 id=\"메모리-늘려서-io-부하-줄이기\" style=\"position:relative;\"><a href=\"#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%8A%98%EB%A0%A4%EC%84%9C-io-%EB%B6%80%ED%95%98-%EC%A4%84%EC%9D%B4%EA%B8%B0\" aria-label=\"메모리 늘려서 io 부하 줄이기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>메모리 늘려서 I/O 부하 줄이기</h2>\n<p>메모리보다 디스크에 저장된 용량이 적으면 디스크의 모든 파일이 메모리에 캐싱되어 디스크 액세스가 일어나지 않게 된다. 따라서 메모리가 늘어날 수록 I/O 부하가 줄어든다. </p>\n<h2 id=\"페이지-캐시는-투과적으로-작용\" style=\"position:relative;\"><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C%EB%8A%94-%ED%88%AC%EA%B3%BC%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%9E%91%EC%9A%A9\" aria-label=\"페이지 캐시는 투과적으로 작용 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>페이지 캐시는 투과적으로 작용</h2>\n<p>부팅 직후 파일을 그렇게 많이 읽지 않았을 때 그 이후 갑자기 큰 파일을 읽으면 해당 파일이 캐싱이 되기 때문에 갑자기 메모리 사용 용량이 높아진다. </p>\n<h2 id=\"code-classlanguage-textsarcode-명령어로-os-지표-확인하기\" style=\"position:relative;\"><a href=\"#code-classlanguage-textsarcode-%EB%AA%85%EB%A0%B9%EC%96%B4%EB%A1%9C-os-%EC%A7%80%ED%91%9C-%ED%99%95%EC%9D%B8%ED%95%98%EA%B8%B0\" aria-label=\"code classlanguage textsarcode 명령어로 os 지표 확인하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"language-text\">sar</code> 명령어로 os 지표 확인하기</h2>\n<ol>\n<li>\n<p>과거 OS 데이터 확인하기  - <code class=\"language-text\">sar -f {/var/log/sa/sa04} | head</code> 명령어로 과거 데이터의 로그 파일을 확인하여 장애 발생 원인을 확인 할 수 있다.  </p>\n<ul>\n<li>프로그램 교체 후 전후 비교를 위해서 위 sar 데이터를 활용할 수 있음</li>\n</ul>\n</li>\n<li>\n<p>현재 데이터 확인하기 - <code class=\"language-text\">sar 1 3</code> </p>\n<ul>\n<li>1초 간격으로 3회 동안 OS 데이터를 확인</li>\n<li>지금 이 순간 시스템에서 일어나고 있는지 확인할 수 있음</li>\n</ul>\n</li>\n<li>멀티 코어일 경우 <code class=\"language-text\">sar -p</code> 옵션으로 CPU 별 데이터 확인 가능 </li>\n<li>\n<p>디폴트 <code class=\"language-text\">sar</code> (<code class=\"language-text\">sar -u</code>에 해당함) - </p>\n<p align=\"center\"><img width=\"85%\" src=\"https://user-images.githubusercontent.com/63405904/136984234-20945113-1236-42e4-b23b-3a9289e74d83.png\"><br>이미지 출처: 대용량 서비스를 지탱하는 기술</p>\n<ul>\n<li>user → 사용자 모드에서 CPU가 소비된 시간 비율</li>\n<li>nice → nice로 스캐줄링의 우선도 변경한 프로세스가 사용자모드에서 CPU를 소비한 비율</li>\n<li>system → 시스템 모드에서 CPU가 소비된 시간 비율</li>\n<li>iowait → CPU가 디스크 I/O대기 위해 Idle 상태로 소비한 시간 비율</li>\n<li>steal → OS 가상화 이용시 다른 가상 CPU 계산으로 대기된 시간 비율</li>\n<li>idle → CPU가 디스크 I/O 등으로 대기되지 않고 Idle 상대로 소비한 시간 비율 (프로세스가 실행하고 있지 않은 상태)</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">sar -q</code> - Load Average 확인   </p>\n<ul>\n<li>실행큐에 쌓여있는 프로세스 수, 시스템상의 프로세스 사이즈, load average 참조 가능</li>\n<li>시간 흐름에 따른 값의 추이를 추척 가능</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">sar -r</code> - 메모리 사용 현황 확인 </p>\n<ul>\n<li>시간 추이에 따른 메모리 정도, 용도 확인 가능</li>\n<li><code class=\"language-text\">sar -W</code>와 조합해 스왑 발생 시간대의 메모리 사용 상황 확인 가능</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">sar -W</code>- 스왑 발생상황 확인 </p>\n<ul>\n<li>pswpin/s → 1초 동안 스왑인 되고 있는 페이지 수</li>\n<li>pswpout/s → 1초 동안 스왑아웃 되고 있는 페이지 수</li>\n<li>스왑이 발생하면 서버 전송량이 떨어진다. 만일 메모리 부족으로 잦은 스왑이 발생하고 있는지 확인할 수 있다.</li>\n</ul>\n</li>\n</ol>\n<br>\n<h2 id=\"강의9-io-부하를-줄이는-방법\" style=\"position:relative;\"><a href=\"#%EA%B0%95%EC%9D%989-io-%EB%B6%80%ED%95%98%EB%A5%BC-%EC%A4%84%EC%9D%B4%EB%8A%94-%EB%B0%A9%EB%B2%95\" aria-label=\"강의9 io 부하를 줄이는 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[강의9] I/O 부하를 줄이는 방법</h2>\n<h2 id=\"캐시를-전제로-한-io-줄이는-방법\" style=\"position:relative;\"><a href=\"#%EC%BA%90%EC%8B%9C%EB%A5%BC-%EC%A0%84%EC%A0%9C%EB%A1%9C-%ED%95%9C-io-%EC%A4%84%EC%9D%B4%EB%8A%94-%EB%B0%A9%EB%B2%95\" aria-label=\"캐시를 전제로 한 io 줄이는 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>캐시를 전제로 한 I/O 줄이는 방법</h2>\n<p>I/O 대책의 기본은 캐시이다 !! </p>\n<ul>\n<li>첫번째 접근법 → 데이터 크기보다 물리 메모리 사이즈가 크다면 모두 캐싱할 수 있다.</li>\n</ul>\n<p>대규모 데이터에 데이터 압축이 중요하다. 압축해서 저장할 경우 디스크 전부를 메모리에 캐싱해둘 수도 있다. </p>\n<ul>\n<li>두번째 접근법 → 경제적 비용과 밸런스 고려</li>\n</ul>\n<p>점점 서버와 높은 용량의 메모리 가격이 내려가면서 압축 알고리즘에 지나친 에너지를 쏟을 필요가 없는 경우도 많다. 밸런스를 고려하는 것이 중요하다. </p>\n<h2 id=\"복수-서버로-확장---캐시로-해결-안되는-규모인-경우\" style=\"position:relative;\"><a href=\"#%EB%B3%B5%EC%88%98-%EC%84%9C%EB%B2%84%EB%A1%9C-%ED%99%95%EC%9E%A5---%EC%BA%90%EC%8B%9C%EB%A1%9C-%ED%95%B4%EA%B2%B0-%EC%95%88%EB%90%98%EB%8A%94-%EA%B7%9C%EB%AA%A8%EC%9D%B8-%EA%B2%BD%EC%9A%B0\" aria-label=\"복수 서버로 확장   캐시로 해결 안되는 규모인 경우 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>복수 서버로 확장 - 캐시로 해결 안되는 규모인 경우</h2>\n<p>현재 인프라의 구조가 프록시 ↔ WAS ↔ DB 인 경우에 다음과 같이 서버를 확장할 수 있다. </p>\n<ol>\n<li>\n<p>WAS 서버를 늘린다.</p>\n<ul>\n<li>CPU 부하를 낮추고 분산시키기 위해서이다.</li>\n<li>단순히 늘리면 된다.</li>\n</ul>\n</li>\n<li>\n<p>DB 서버를 늘린다.</p>\n<ul>\n<li>캐싱 용량을 늘리거나 효율을 높이고자 할 때 늘린다.</li>\n<li>하지만 I/O 분산에는 국소성을 고려해야하며 마냥 늘려서 좋은 것은 아니다.</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"대수만-늘려서-확정성-확보할-수-없다\" style=\"position:relative;\"><a href=\"#%EB%8C%80%EC%88%98%EB%A7%8C-%EB%8A%98%EB%A0%A4%EC%84%9C-%ED%99%95%EC%A0%95%EC%84%B1-%ED%99%95%EB%B3%B4%ED%95%A0-%EC%88%98-%EC%97%86%EB%8B%A4\" aria-label=\"대수만 늘려서 확정성 확보할 수 없다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>대수만 늘려서 확정성 확보할 수 없다.</h2>\n<ul>\n<li>\n<p>캐시 용량이 부족해서 DB 서버 대수를 확보했지만 부족한 캐싱 용량의 상황까지 그대로 복제될 수 있다.</p>\n<ul>\n<li>A 서버에서 조회하며 캐싱했는데 부족한 것이 B 서버에서도 동일하게 일어남</li>\n<li>어느정도 빨라질 수는 있겠지만 증설비용대비 성능향상은 좋지 않다.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"-io-부하-줄이기와-페이지-캐시\" style=\"position:relative;\"><a href=\"#-io-%EB%B6%80%ED%95%98-%EC%A4%84%EC%9D%B4%EA%B8%B0%EC%99%80-%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C\" aria-label=\" io 부하 줄이기와 페이지 캐시 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>+ I/O 부하 줄이기와 페이지 캐시</h2>\n<p>리눅스에서 sar 명령어로 메모리 상황을 확인했을 때 항상 메모리가 부족해보일수도 있다. 하지만 리눅스의 페이지 캐시 원리는 <code class=\"language-text\">리눅스는 가능한 남아있는 메모리를 페이지 캐시로 활용한다</code> 라는 것이다. 따라서 부팅 후 시간이 지날수록 sar의 <code class=\"language-text\">kbmemfree</code> 는 줄어들 수밖에 없다. </p>\n<h3 id=\"페이지-캐시에-의한-io-부하-경감-효과\" style=\"position:relative;\"><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C%EC%97%90-%EC%9D%98%ED%95%9C-io-%EB%B6%80%ED%95%98-%EA%B2%BD%EA%B0%90-%ED%9A%A8%EA%B3%BC\" aria-label=\"페이지 캐시에 의한 io 부하 경감 효과 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>페이지 캐시에 의한 I/O 부하 경감 효과</h3>\n<ul>\n<li>많은 데이터가 있는 상황에서 메모리를 증설하고 <code class=\"language-text\">sar -P</code> 로 확인해보면 <code class=\"language-text\">%iowait</code> 의 확연한 차이를 볼 수 있다.</li>\n<li>\n<p><code class=\"language-text\">sar -r</code> 를 사용하면 커널이 캐시를 확보하고 있는 정도를 확인할 수 있다. 커널이 확보하고 있는 캐시용량과 어플리케이션에서 다루는 데이터의 용량을 비교하여 데이터량이 더 많을 경우 메모리 증설을 검토하여 디스크 액세스를 줄인다.</p>\n<p><code class=\"language-text\">vmstat</code>을 사용하면 디스크 액세스 정도를 확인할 수 있다.   </p>\n</li>\n<li>메모리 증설이 어려운 경우 데이터 분할하여 각각 서버에 위치한다. → 캐시 올릴 데이터 비율이 올라가고 I/O 횟수가 줄어든다.</li>\n</ul>\n<h3 id=\"페이지-캐시는-한번의-read에서-시작된다\" style=\"position:relative;\"><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C%EB%8A%94-%ED%95%9C%EB%B2%88%EC%9D%98-read%EC%97%90%EC%84%9C-%EC%8B%9C%EC%9E%91%EB%90%9C%EB%8B%A4\" aria-label=\"페이지 캐시는 한번의 read에서 시작된다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>페이지 캐시는 한번의 read에서 시작된다.</h3>\n<ul>\n<li>캐싱하지 못한 데이터는 직접 디스크에서 읽는다. 서버를 재부팅한 경우 메모리의 캐시는 초기화 되므로 모든 액세스에 I/O를 발생시킨다.</li>\n<li>대규모 DB 서버인 경우 모든 DB 액세스마다 디스크 I/O가 발생해서 DB가 lock에 걸리는 경우도 많다.</li>\n<li>따라서 필요한 경우 필요데이터를 전체 한번 전체적으로 읽어 다시 캐싱하는 방법도 필요하다.</li>\n<li>I/O 바운드가 높은 서버인 경우 페이지 캐시가 최적화 되었는지 확인한다.</li>\n</ul>\n<br>\n<h2 id=\"강의10-국소성을-살리는-분산\" style=\"position:relative;\"><a href=\"#%EA%B0%95%EC%9D%9810-%EA%B5%AD%EC%86%8C%EC%84%B1%EC%9D%84-%EC%82%B4%EB%A6%AC%EB%8A%94-%EB%B6%84%EC%82%B0\" aria-label=\"강의10 국소성을 살리는 분산 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[강의10] 국소성을 살리는 분산</h2>\n<h2 id=\"국소성을-고려한-분산이란\" style=\"position:relative;\"><a href=\"#%EA%B5%AD%EC%86%8C%EC%84%B1%EC%9D%84-%EA%B3%A0%EB%A0%A4%ED%95%9C-%EB%B6%84%EC%82%B0%EC%9D%B4%EB%9E%80\" aria-label=\"국소성을 고려한 분산이란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>국소성을 고려한 분산이란</h2>\n<p>서버를 여러대 확장해서 캐시 용량을 늘리기 위해서는 국소성(locality)을 고려해서 분산시켜야한다. </p>\n<ul>\n<li>\n<p>DB의 경우 서비스 패턴과 처리방식에 따라 데이터 액세스 경향이 한쪽으로 치우친다.</p>\n<ul>\n<li>어떤 서비스 패턴이 엔트리 A에 많이 접근하고 다른 서비스는 테이블B에 많이 접근한다면 1, 2를 분산하여 한쪽에만 액세스 하도록 할 수 있다.</li>\n<li>이것을 고려하지 않으면 여전히 서버 1에서 두 패턴이 모두 일어나게 되므로 캐시를 위한 메모리 용량이 부족하게 된다.</li>\n<li>즉, 액세스 패턴을 고려하여 국소성을 적용한 분산을 하라!!</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"파티셔닝---국소성-분산1\" style=\"position:relative;\"><a href=\"#%ED%8C%8C%ED%8B%B0%EC%85%94%EB%8B%9D---%EA%B5%AD%EC%86%8C%EC%84%B1-%EB%B6%84%EC%82%B01\" aria-label=\"파티셔닝   국소성 분산1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>파티셔닝 - 국소성 분산1</h2>\n<p>한 대였던 DB를 여러대의 서버로 분할하는 방법이다. → 제일 간단한 분할 방법은 테이블 단위 분할</p>\n<ul>\n<li><strong>테이블 단위 분할</strong> - 같이 액세스 하는 경우가 많은 테이블을 같은 서버에 위치시키고 그 밖의 것들을 다른 서버에 위치</li>\n<li>\n<p><strong>테이블 데이터 분할 -</strong> 하나의 테이블을 여러 테이블로 분할</p>\n<ul>\n<li>예를 들어 책에 나온 예시로는 하나의 테이블을 앞 알파벳에 따라서 데이터를 분할함</li>\n<li>국소성이 올라가 캐싱이 잘됨</li>\n<li>단점: 분할이 너무 작게 된다면 데이터를 한번 병합해야 함</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"요청-패턴을-섬으로-분할---국소성-분산2\" style=\"position:relative;\"><a href=\"#%EC%9A%94%EC%B2%AD-%ED%8C%A8%ED%84%B4%EC%9D%84-%EC%84%AC%EC%9C%BC%EB%A1%9C-%EB%B6%84%ED%95%A0---%EA%B5%AD%EC%86%8C%EC%84%B1-%EB%B6%84%EC%82%B02\" aria-label=\"요청 패턴을 섬으로 분할   국소성 분산2 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>요청 패턴을 ‘섬’으로 분할 - 국소성 분산2</h2>\n<p>요청의 종류에 따라서 요청을 보내는 서버를 나누는 것이다. - 특이한 경우이기는 함</p>\n<p align=\"center\"><img width=\"85%\" src=\"https://user-images.githubusercontent.com/63405904/136984334-66cc4ba2-bb5a-4b92-aacd-1067c92f5765.png\"><br>이미지 출처: 대용량 서비스를 지탱하는 기술</p>\n<ul>\n<li>캐싱하기 쉬운 요청, 캐싱하기 어려운 요청을 처리하는 섬을 나눔 → 전자는 국소성으로 높은 캐시 적중률을 냄</li>\n</ul>\n<h2 id=\"페이지-캐시를-고려한-운용의-기본-원칙\" style=\"position:relative;\"><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C%EB%A5%BC-%EA%B3%A0%EB%A0%A4%ED%95%9C-%EC%9A%B4%EC%9A%A9%EC%9D%98-%EA%B8%B0%EB%B3%B8-%EC%9B%90%EC%B9%99\" aria-label=\"페이지 캐시를 고려한 운용의 기본 원칙 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>페이지 캐시를 고려한 운용의 기본 원칙</h2>\n<ol>\n<li>\n<p>OS를 가동한 직후에 서버를 투입하지 않는다 → 캐시가 쌓여있지 않기 때문이다. </p>\n<ul>\n<li>OS를 기동하고 자주 사용하는 DB의 파일을 한번 cat 하여 메모리에 올린다. 이후 로드밸런서에 편입한다.</li>\n</ul>\n</li>\n<li>성능 테스트를 할 경우 초기값은 버려야한다. → 최초 캐시가 최적화 되어 있지 않은 단계이므로 속도가 확연히 차이가 나게 된다. </li>\n</ol>\n<h2 id=\"-부하분산과-os의-동작원리\" style=\"position:relative;\"><a href=\"#-%EB%B6%80%ED%95%98%EB%B6%84%EC%82%B0%EA%B3%BC-os%EC%9D%98-%EB%8F%99%EC%9E%91%EC%9B%90%EB%A6%AC\" aria-label=\" 부하분산과 os의 동작원리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>+ 부하분산과 OS의 동작원리</h2>\n<ul>\n<li>OS 캐시, 멀티스레드나 멀티프로세스, 가상 메모리구조, 파일시스템 등과 같은 OS 지식이 있어야 부하분산을 잘 할 수 있음.</li>\n<li>요청 분배에는 LVS 사용법, MySQL 아파치와 같은 미들웨어 사용법 등이 있다.</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#%EA%B0%95%EC%9D%988-os-%EC%BA%90%EC%8B%9C-%EA%B5%AC%EC%A1%B0\">강의8 OS 캐시 구조</a></li>\n<li>\n<p><a href=\"#os%EC%9D%98-%EC%BA%90%EC%8B%9C-%EA%B5%AC%EC%A1%B0%EB%A5%BC-%EC%95%8C%EA%B3%A0-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EC%9E%91%EC%84%B1%ED%95%98%EA%B8%B0---%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C\">OS의 캐시 구조를 알고 애플리케이션 작성하기 - 페이지 캐시</a></p>\n<ul>\n<li><a href=\"#linuxx86-%ED%8E%98%EC%9D%B4%EC%A7%95-%EA%B5%AC%EC%A1%B0\">Linux(x86) 페이징 구조</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0\">가상 메모리 구조</a></p>\n<ul>\n<li><a href=\"#%EC%99%9C-%EA%B0%80%EC%83%81-%EC%A3%BC%EC%86%8C%EB%A5%BC-%EB%B0%98%ED%99%98%ED%95%A0%EA%B9%8C\">왜 가상 주소를 반환할까?</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#linux-%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C%EC%9D%98-%EC%9B%90%EB%A6%AC\">Linux 페이지 캐시의 원리</a></p>\n<ul>\n<li><a href=\"#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EA%B0%80-%EB%94%94%EC%8A%A4%ED%81%AC%EC%97%90%EC%84%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A5%BC-%EC%9D%BD%EC%96%B4%EB%82%B4%EB%8A%94-%EA%B3%BC%EC%A0%95\">프로세스가 디스크에서 데이터를 읽어내는 과정</a></li>\n<li><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C%EC%9D%98-%ED%9A%A8%EA%B3%BC\">페이지 캐시의 효과</a></li>\n</ul>\n</li>\n<li><a href=\"#vfs\">VFS</a></li>\n<li>\n<p><a href=\"#%EB%A6%AC%EB%88%85%EC%8A%A4%EB%8A%94-%ED%8E%98%EC%9D%B4%EC%A7%80-%EB%8B%A8%EC%9C%84%EB%A1%9C-%EB%94%94%EC%8A%A4%ED%81%AC%EB%A5%BC-%EC%BA%90%EC%8B%B1\">리눅스는 페이지 단위로 디스크를 캐싱</a></p>\n<ul>\n<li><a href=\"#%EC%99%9C-%ED%8C%8C%EC%9D%BC-%EC%BA%90%EC%8B%9C%EA%B0%80-%EC%95%84%EB%8B%88%EB%9D%BC-%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C%EC%9D%BC%EA%B9%8C-\">왜 파일 캐시가 아니라 페이지 캐시일까 ?</a></li>\n<li><a href=\"#lru\">LRU</a></li>\n<li><a href=\"#%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%BA%90%EC%8B%B1%EC%9D%B4-%EB%90%A0%EA%B9%8C\">어떻게 캐싱이 될까</a></li>\n</ul>\n</li>\n<li><a href=\"#%EB%A9%94%EB%AA%A8%EB%A6%AC%EA%B0%80-%EB%B9%84%EC%96%B4%EC%9E%88%EC%9C%BC%EB%A9%B4-%EC%BA%90%EC%8B%B1\">메모리가 비어있으면 캐싱</a></li>\n<li><a href=\"#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%8A%98%EB%A0%A4%EC%84%9C-io-%EB%B6%80%ED%95%98-%EC%A4%84%EC%9D%B4%EA%B8%B0\">메모리 늘려서 I/O 부하 줄이기</a></li>\n<li><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C%EB%8A%94-%ED%88%AC%EA%B3%BC%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%9E%91%EC%9A%A9\">페이지 캐시는 투과적으로 작용</a></li>\n<li><a href=\"#sar-%EB%AA%85%EB%A0%B9%EC%96%B4%EB%A1%9C-os-%EC%A7%80%ED%91%9C-%ED%99%95%EC%9D%B8%ED%95%98%EA%B8%B0\"><code class=\"language-text\">sar</code> 명령어로 os 지표 확인하기</a></li>\n<li><a href=\"#%EA%B0%95%EC%9D%989-io-%EB%B6%80%ED%95%98%EB%A5%BC-%EC%A4%84%EC%9D%B4%EB%8A%94-%EB%B0%A9%EB%B2%95\">강의9 I/O 부하를 줄이는 방법</a></li>\n<li><a href=\"#%EC%BA%90%EC%8B%9C%EB%A5%BC-%EC%A0%84%EC%A0%9C%EB%A1%9C-%ED%95%9C-io-%EC%A4%84%EC%9D%B4%EB%8A%94-%EB%B0%A9%EB%B2%95\">캐시를 전제로 한 I/O 줄이는 방법</a></li>\n<li><a href=\"#%EB%B3%B5%EC%88%98-%EC%84%9C%EB%B2%84%EB%A1%9C-%ED%99%95%EC%9E%A5---%EC%BA%90%EC%8B%9C%EB%A1%9C-%ED%95%B4%EA%B2%B0-%EC%95%88%EB%90%98%EB%8A%94-%EA%B7%9C%EB%AA%A8%EC%9D%B8-%EA%B2%BD%EC%9A%B0\">복수 서버로 확장 - 캐시로 해결 안되는 규모인 경우</a></li>\n<li><a href=\"#%EB%8C%80%EC%88%98%EB%A7%8C-%EB%8A%98%EB%A0%A4%EC%84%9C-%ED%99%95%EC%A0%95%EC%84%B1-%ED%99%95%EB%B3%B4%ED%95%A0-%EC%88%98-%EC%97%86%EB%8B%A4\">대수만 늘려서 확정성 확보할 수 없다.</a></li>\n<li>\n<p><a href=\"#-io-%EB%B6%80%ED%95%98-%EC%A4%84%EC%9D%B4%EA%B8%B0%EC%99%80-%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C\">+ I/O 부하 줄이기와 페이지 캐시</a></p>\n<ul>\n<li><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C%EC%97%90-%EC%9D%98%ED%95%9C-io-%EB%B6%80%ED%95%98-%EA%B2%BD%EA%B0%90-%ED%9A%A8%EA%B3%BC\">페이지 캐시에 의한 I/O 부하 경감 효과</a></li>\n<li><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C%EB%8A%94-%ED%95%9C%EB%B2%88%EC%9D%98-read%EC%97%90%EC%84%9C-%EC%8B%9C%EC%9E%91%EB%90%9C%EB%8B%A4\">페이지 캐시는 한번의 read에서 시작된다.</a></li>\n</ul>\n</li>\n<li><a href=\"#%EA%B0%95%EC%9D%9810-%EA%B5%AD%EC%86%8C%EC%84%B1%EC%9D%84-%EC%82%B4%EB%A6%AC%EB%8A%94-%EB%B6%84%EC%82%B0\">강의10 국소성을 살리는 분산</a></li>\n<li><a href=\"#%EA%B5%AD%EC%86%8C%EC%84%B1%EC%9D%84-%EA%B3%A0%EB%A0%A4%ED%95%9C-%EB%B6%84%EC%82%B0%EC%9D%B4%EB%9E%80\">국소성을 고려한 분산이란</a></li>\n<li><a href=\"#%ED%8C%8C%ED%8B%B0%EC%85%94%EB%8B%9D---%EA%B5%AD%EC%86%8C%EC%84%B1-%EB%B6%84%EC%82%B01\">파티셔닝 - 국소성 분산1</a></li>\n<li><a href=\"#%EC%9A%94%EC%B2%AD-%ED%8C%A8%ED%84%B4%EC%9D%84-%EC%84%AC%EC%9C%BC%EB%A1%9C-%EB%B6%84%ED%95%A0---%EA%B5%AD%EC%86%8C%EC%84%B1-%EB%B6%84%EC%82%B02\">요청 패턴을 ‘섬’으로 분할 - 국소성 분산2</a></li>\n<li><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C%EB%A5%BC-%EA%B3%A0%EB%A0%A4%ED%95%9C-%EC%9A%B4%EC%9A%A9%EC%9D%98-%EA%B8%B0%EB%B3%B8-%EC%9B%90%EC%B9%99\">페이지 캐시를 고려한 운용의 기본 원칙</a></li>\n<li><a href=\"#-%EB%B6%80%ED%95%98%EB%B6%84%EC%82%B0%EA%B3%BC-os%EC%9D%98-%EB%8F%99%EC%9E%91%EC%9B%90%EB%A6%AC\">+ 부하분산과 OS의 동작원리</a></li>\n</ul>\n</div>","frontmatter":{"date":"September 24, 2021","title":"대규모 서비스를 지탱하는 기술 - OS 캐시와 분산","categories":"웹 인프라 책","author":"코다","emoji":"📚"},"fields":{"slug":"/high-traffic-service_3/"}},"site":{"siteMetadata":{"siteUrl":"https://yjksw.github.io","comments":{"utterances":{"repo":"yjksw/yjksw.github.io"}}}}},"pageContext":{"slug":"/high-traffic-service_2/","nextSlug":"/high-traffic-service_1/","prevSlug":"/high-traffic-service_3/"}},"staticQueryHashes":["1073350324","2938748437"]}
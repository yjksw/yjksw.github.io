{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/operating-system-2/",
    "result": {"data":{"cur":{"id":"0515d110-b29d-5c41-a700-b62f2f2aee0f","html":"<blockquote>\n<p>다음은 반효경 교수님의 ‘운영체제와 정보기술의 원리’ <em>CH3. 컴퓨터 시스템의 동작원리</em>를 읽고 정리한 내용입니다 🙌</p>\n</blockquote>\n<br>\n<br>\n<h2 id=\"-1-컴퓨터-시스템의-구조\" style=\"position:relative;\"><a href=\"#-1-%EC%BB%B4%ED%93%A8%ED%84%B0-%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98-%EA%B5%AC%EC%A1%B0\" aria-label=\" 1 컴퓨터 시스템의 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 1. 컴퓨터 시스템의 구조</h2>\n<ul>\n<li>내부 장치 - CPU, 메모리</li>\n<li>외부 장치 - 디스크, 키보드, 마우스, 모니터, 네트워크 장치 등등\n<ul>\n<li>입출력장치라고 한다.</li>\n<li>각 하드웨어 장치를 각각의 컨트롤러가 제어한다.</li>\n</ul>\n</li>\n<li><strong>컴퓨터는 외부장치에서 내부장치로 데이터를 읽어 연산한 후 결과를 외부장치로 내보내는 방식으로 동작한다.</strong>\n<ul>\n<li>input - 내부로 들어오는 것</li>\n<li>output - 외부로 내보내는 것</li>\n</ul>\n</li>\n<li>여러 프로그램을 동시에 수행할 수 있도록 하는 것이 운영체제이기 때문에 항상 메모리에 상주한다.</li>\n<li>전체가 상주하기엔 너무 낭비이기 때문에 꼭 필요한 부분만 항상 메모리에 상주하고 그 부분을 **커널(kernel)**이라고 한다.</li>\n</ul>\n<br>\n<h2 id=\"-2-cpu-연산과-io-연산\" style=\"position:relative;\"><a href=\"#-2-cpu-%EC%97%B0%EC%82%B0%EA%B3%BC-io-%EC%97%B0%EC%82%B0\" aria-label=\" 2 cpu 연산과 io 연산 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 2. CPU 연산과 I/O 연산</h2>\n<ul>\n<li>I/O 연산들은 <strong>입출력 컨트롤러</strong>가 담당하고 컴퓨터 내부의 연산은 <strong>메인 CPU</strong>가 담당한다.\n<ul>\n<li>입출력 장치와 메인 CPU는 동시 수행이 가능하다.</li>\n</ul>\n</li>\n<li>각 장치마다 들어오고 나가는 데이터를 로컬버퍼(local buffer)라는 작은 메모리에 저장한다.</li>\n<li>컨트롤러가 로컬버퍼로 읽어오는 일을 담당한다. 버퍼에 데이터가 다 들어왔으면 컨트롤러가 CPU에게 인터럽트로 알린다.</li>\n<li>CPU는 매 시점 메모리에서 명령(instruction)을 하나씩 읽어서 수행하는데, 옆에 인터럽트 라인(interrupt line)이 있어서 인터럽트 신호가 중간에 들어오면 작업을 멈추고 인터럽트 작업을 먼저 처리한다.\n<ul>\n<li>즉, 매 명령 수행마다 인터럽트 발생 여부를 확인한다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-3-인터럽트의-일반적-기능\" style=\"position:relative;\"><a href=\"#-3-%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8%EC%9D%98-%EC%9D%BC%EB%B0%98%EC%A0%81-%EA%B8%B0%EB%8A%A5\" aria-label=\" 3 인터럽트의 일반적 기능 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 3. 인터럽트의 일반적 기능</h2>\n<ul>\n<li>운영체제에는 인터럽트가 들어왔을때 따라야하는 인터럽트 루틴이 저장되어 있다.\n<ul>\n<li>각각의 인터럽트에 따라서 다르며 운영체제 개발자가 미리 구현하여 커널에 포함해둔다.</li>\n</ul>\n</li>\n<li>디스크 컨트롤러의 인터럽트 루틴에서 수행하는 일\n<ul>\n<li>디스크의 로컬버퍼에 있는 내용을 사용자 프로그램 메모리로 전달하고 프로그램의 다음 명령을 수행할 수 있도록 표시</li>\n</ul>\n</li>\n<li><strong>하드웨어 인터럽트</strong> - 컨트롤러 등 하드웨어 장치가 CPU의 인터럽트 라인을 세팅 (통상적인 인터럽트)\n<ul>\n<li>CPU는 인터럽트가 발생하면 인터럽트 벡터(interrupt vector)에서 인터럽트 처리를 위한 루틴 코드를 커널에서 찾는다.\n<ul>\n<li>인터럽트 종류 번호에 따른 처리 코드가 위치한 부분을 가리키는 자료구조이다.</li>\n<li>실제 처리 코드는 인터럽트 처리 루틴(interrupt service routine) 또는 인터럽트 핸들러(interrupt handler)라고 불리는 곳에 정의된다.</li>\n</ul>\n</li>\n<li>CPU가 인터럽트 처리 후 돌아갈 위치를 알기 위해 수행중이던 작업을 저장하는 장소를 운영체제가 별도로 가지고 있다.</li>\n</ul>\n</li>\n<li><strong>소프트웨어 인터럽트</strong> - 소프트웨어가 세팅\n<ul>\n<li>트랩(trap)이라는 용어로 불리며 예외상황(exception)과 시스템 콜(system call)이 있다.\n<ul>\n<li>예외상황 - 0으로 나누거나, 메모리 영역 바깥에 접근하려는 시도 등</li>\n<li>시스템 콜 - 운영체제에 서비스를 요청하는 경우로 화면출력, 키보드 입력 등의 커널 코드를 호출하여 CPU 제어권을 넘겨야하는 경우</li>\n</ul>\n</li>\n<li>프로그램 코드가 인터럽트 라인을 세팅하는 명령을 실행하여 인터럽트를 발생시키고 CPU의 제어권을 운영체제에 넘기는 것이다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-4-인터럽트-핸들링\" style=\"position:relative;\"><a href=\"#-4-%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8-%ED%95%B8%EB%93%A4%EB%A7%81\" aria-label=\" 4 인터럽트 핸들링 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 4. 인터럽트 핸들링</h2>\n<p>인터럽트 발생한 후 처리해야할 절차를 의미한다.</p>\n<ul>\n<li>현재 진행중이던 프로그램의 상태를 저장한다.\n<ul>\n<li>실행 중이던 명령어 메모리 주소 및 부가정보 등등</li>\n<li>CPU에서 명령을 실행할 때 CPU 내부의 임시기억장치 레지스터의 데이터를 사용하는 데 이 값들을 미리 저장함</li>\n<li>프로그램을 관리하는 PCB에 현재 프로그램의 실행 상태를 저장하고 CPU의 제어권이 넘어간다.</li>\n<li>다시 실행될 경우 PCB에서 상태를 복원하고 실행을 이어한다.</li>\n</ul>\n</li>\n<li>오늘날은 운영체제(커널)이 인터럽트가 발생할 때만 실행된다. 인터럽트가 발생하지 않으면 사용자 프로그램이 CPU를 계속 점유한다.</li>\n</ul>\n<br>\n<h2 id=\"-5-입출력-구조\" style=\"position:relative;\"><a href=\"#-5-%EC%9E%85%EC%B6%9C%EB%A0%A5-%EA%B5%AC%EC%A1%B0\" aria-label=\" 5 입출력 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 5. 입출력 구조</h2>\n<p>컴퓨터 시스템이 외부 입출력 장치들과 데이터를 주고받는 것을 말한다.</p>\n<h3 id=\"동기식-입출력-vs-비동기식-입출력\" style=\"position:relative;\"><a href=\"#%EB%8F%99%EA%B8%B0%EC%8B%9D-%EC%9E%85%EC%B6%9C%EB%A0%A5-vs-%EB%B9%84%EB%8F%99%EA%B8%B0%EC%8B%9D-%EC%9E%85%EC%B6%9C%EB%A0%A5\" aria-label=\"동기식 입출력 vs 비동기식 입출력 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>동기식 입출력 vs. 비동기식 입출력</h3>\n<ul>\n<li>동기식 입출력 (Synchronous I/O) - 어떤 프로그램이 입출력을 요청했을 때 입출력 작업이 완료해야 해당 프로그램의 다음 작업을 할 수 있는 것.\n<ul>\n<li>입출력이 완료 되어야 인터럽트를 통해 CPU에게 알려 제어권이 다시 프로그램에게 넘어간다. 따라서 CPU는 입출력 연산이 끝날 때까지 인터럽트를 기다리며 자원을 낭비한다.\n<ul>\n<li>CPU 연산은 빠르지만 입출력 연산은 느리기 때문에 그동안 CPU를 사용하지 못하는 것은 자원의 낭비이다.</li>\n<li>또한 한번에 하나의 입출력만 수행될 수 있어 비효율적이다.</li>\n</ul>\n</li>\n<li>따라서 주로 그 동안 다른 프로그램에게 CPU를 할당하고 이전에 입출력 연산중인 프로그램에는 CPU를 할당하지 않는다.\n<ul>\n<li><strong>이것을 관리하기 위해 입출력 중인 프로그램을 blocked state로 전환시켜 CPU를 할당하지 않도록  관리한다.</strong></li>\n</ul>\n</li>\n<li>동기식으로 입출력이 연산되면 동기화가 자동으로 이루어진다. 하지만 그 사이 다른 프로그램이 CPU에 실행되면 동일한 데이터를 입출력할 때 결과가 틀어진다.\n<ul>\n<li>해결하기 위해 입출력 요청을 순서대로 실행하기 위한 큐(queue)가 장치별로 있어서 동기화한다.</li>\n<li>입출력 연산이 끝나면 인터럽트로 CPU에 알리면 인터럽트 처리루틴에 따라서 해당 프로그램이 CPU를 할당받을 수 있도록 blocked state에서 해제시킨다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>비동기식 입출력 (asynchronous I/O) - CPU 제어권을 입출력 연산을 호출한 프로그램에게 바로 다시 부여하는 것\n<ul>\n<li>입출력 데이터와 상관없이 다음 명령이 수행될 수 있는 경우는 입출력 연산과 상관없이 바로 수행하고 결과가 필요한 연산일 경우에만 기다렸다가 수행한다.</li>\n<li>쓰기 작업인 경우 다음 명령어 수행이 가능하므로 비동기식 입출력이 사용될 수 있다.</li>\n<li>입출력 연산이 완료되면 인터럽트로 알리고 그때부터 CPU는 읽어온 데이터를 필요로 하는 명령어를 수행한다.</li>\n</ul>\n</li>\n<li>입출력을 요청할 때, 완료했을 때 두번 인터럽트가 발생한다.\n<ul>\n<li>요청할 때 인터럽트 처리루틴 - 진행중이던 프로세스의 상태를 저장하고 해당 컨트롤러에 입출력 요청을 한다. 해당 프로세스를 blocked state로 바꾸고 CPU를 다른 프로세스에게 할당한다.</li>\n<li>완료했을 때 인터럽트 처리루틴 - 진행중이던 프로세스의 상태를 저장하고 (디스크 입출력인 경우) 로컬 버퍼의 데이터를 메모리 영역으로 읽어온다. 해당 프로세스의 blocked state를 해제하고 CPU에 할당될 수 있도록 한다.</li>\n</ul>\n</li>\n<li>일반적으로는 동기식 입출력을 사용하며 동기화를 통해 queue를 사용한다.</li>\n</ul>\n<br>\n<h2 id=\"-6-dma\" style=\"position:relative;\"><a href=\"#-6-dma\" aria-label=\" 6 dma permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 6. DMA</h2>\n<ul>\n<li>메모리는 본래 CPU에서만 접근할 수 있는데 이렇다면 메모리 접근 연산이 모두 CPU의 인터럽트를 통해서 이루어지면서 CPU 작업이 중단되어 효율성이 떨어지는 문제가 발생한다.</li>\n<li>DMA (Direct Memory Access) - 위 문제를 해결하기 위한 컨트롤러로 메모리에 접근할 수 있는 장치\n<ul>\n<li>로컬버퍼에서 데이터를 읽어오는 작업을 DMA가 CPU 대신 대행하여 CPU가 작업을 멈출 필요가 없다.</li>\n<li>DMA는 바이트 단위가 아니라 블록(block)이라는 큰 단위로 정보를 메모리로 읽어온다.</li>\n<li>작업을 완료하면 CPU에 인터럽트로 알려준다.</li>\n<li>CPU에 발생하는 인터럽트 빈도를 줄여 더 효율적으로 작업을 처리할 수 있도록 한다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-7-저장장치의-구조\" style=\"position:relative;\"><a href=\"#-7-%EC%A0%80%EC%9E%A5%EC%9E%A5%EC%B9%98%EC%9D%98-%EA%B5%AC%EC%A1%B0\" aria-label=\" 7 저장장치의 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 7. 저장장치의 구조</h2>\n<ul>\n<li>주기억장치\n<ul>\n<li>메모리라고 부르며 휘발성이다.</li>\n<li>RAM을 매체로 사용하는 경우가 대부분이다.</li>\n</ul>\n</li>\n<li>보조기억장치\n<ul>\n<li>비휘발성이며</li>\n<li>마크네틱 디스크를 주로 사용한다.</li>\n</ul>\n</li>\n<li>보조기억장치의 용도\n<ol>\n<li>전원이 나가도 유지해야할 파일 시스템용 (file system)</li>\n<li>메모리의 연장 공간인 스왑 영역 (swap area)\n<ul>\n<li>운영체제는 당장 필요한 부분을 메모리에 올려놓고, 그렇지 않은 부분을 디스크의 스왑 영역에 내려놓는다 ⇒ swap out</li>\n<li>스왑 영역에 있는 부분을 필요할 때 다시 메모리 영역으로 가져온다 ⇒ swap in</li>\n<li>스왑 영역은 프로그램이 실행될 때 내용을 저장했다가 프로그램 종료될 때 삭제하는 메모리의 연장 공간이다.</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<br>\n<h2 id=\"-8-저장장치의-계층-구조\" style=\"position:relative;\"><a href=\"#-8-%EC%A0%80%EC%9E%A5%EC%9E%A5%EC%B9%98%EC%9D%98-%EA%B3%84%EC%B8%B5-%EA%B5%AC%EC%A1%B0\" aria-label=\" 8 저장장치의 계층 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 8. 저장장치의 계층 구조</h2>\n<ul>\n<li>primary 저장장치는 작고 빠르지만 비싸다.\n<ul>\n<li>레지스터 → 캐시 메모리 → 메모리</li>\n<li>용량이 적지만 필요한 것만을 올리면서 용량이 큰 저장장치를 가지고 있는 것과 마찬가지로 성능효과를 낼 수 있다.</li>\n</ul>\n</li>\n<li>secondary 저장장치는 크고 느리지만 싸다.\n<ul>\n<li>마그네틱 디스크 → 광디스크 → 마그네틱 테이프</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-9-하드웨어의-보안\" style=\"position:relative;\"><a href=\"#-9-%ED%95%98%EB%93%9C%EC%9B%A8%EC%96%B4%EC%9D%98-%EB%B3%B4%EC%95%88\" aria-label=\" 9 하드웨어의 보안 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 9. 하드웨어의 보안</h2>\n<ul>\n<li>운영체제에서는 여러 프로그램이 동시에 실행되는 다중 프로그래밍 환경에서 동작하기 때문에 다른 프로그램을 방해하거나 충돌하지 않도록 하드웨어적인 보안유지가 필요하다.</li>\n<li>이것을 위해 운영체제는 <strong>1) 커널모드</strong>와 <strong>2) 사용자모드</strong> 두 가지를 지원한다.\n<ul>\n<li>커널모드는 운영체제가 CPU의 제어권을 가지고 운영체제 코드를 실행하는 것이다.</li>\n<li>중요정보에 접근해 위험한 상황을 초래할 수 있는 연산은 커널모드에서만 실행되도록 한다.</li>\n<li>일반 사용자 프로그램은 시스템에 위험한 연산을 하지 못하도록 통제한다.</li>\n</ul>\n</li>\n<li>일반 사용자가 운영체제 내부의 코드를 실행하지 못하도록 하드웨어적인 지원을 한다.\n<ul>\n<li>CPU 내부에 mode bit 를 두어 사용자 프로그램을  통제한다.</li>\n<li>mode bit = 0 ⇒ 커널모드이므로 모든 명령 수행 가능</li>\n<li>mode bit = 1 ⇒ 사용자모드 이므로 제한된 명령 수행 가능</li>\n<li>사용자 프로그램 시 모드 비트를 1로 세팅해 넘겨준다. 만일 사용자 프로그램에서 제한된 명령을 수행하고자 할 때는 시스템 콜을 통해서 운영체제에 위임하여 해당 명령을 하도록 요청한다.</li>\n<li>인터럽트 발생시에는 모드 비트가 자동으로 0으로 세팅되며 요청이 끝나면 다시 1로 세팅된다.</li>\n<li>모드 비트 0일때만 수행가능한 명령을 <strong>특권명령</strong>이라고 한다.</li>\n</ul>\n</li>\n<li>각종 장치에서 특권 명령\n<ul>\n<li>디스크에 저장된 파일에 자유롭게 접근하여 문제가 일어나지 않도록 모든 임출력 명령은 특권명령 규정을 사용한다.</li>\n<li>사용자 프로그램이 입출력을 하고 싶으면 system call로 운영체제에 요청을 한다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-10-메모리-보안\" style=\"position:relative;\"><a href=\"#-10-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%B3%B4%EC%95%88\" aria-label=\" 10 메모리 보안 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 10. 메모리 보안</h2>\n<ul>\n<li>여러 프로그램이 메모리에 한꺼번에 올라가서 실행되기 때문에 메모리도 보안이 필요하다.\n<ul>\n<li>사용자 프로그램에서 다른 프로그램의 메모리에 잘못 접근해서 변경할 수 있다.</li>\n<li>인터러트 벡터와 인터럽트 처리루틴이 있는 곳을 변경하여 보안성이 침해될 수 있다.</li>\n</ul>\n</li>\n<li>메모리 보호를 위해 2가지 레지스터를 사용한다.\n<ul>\n<li>기준 레지스터 (base register)\n<ul>\n<li>해당 프로그램이 접근할 수 있는 가장 작은 주소</li>\n</ul>\n</li>\n<li>한계 레지스터 (limit register)\n<ul>\n<li>기준 레지스터로부터 접근할 수 있는 메모리 범위</li>\n</ul>\n</li>\n<li>이 두 범위를 넘어가면 소프트웨어적인 인터럽트로 예외가 발생한다.</li>\n<li><strong>프로그램이 메모리의 한 영역에 연속적으로 위치하는 경우에만 가능한 메모리 관리 기법이다.</strong></li>\n<li>메모리를 페이징 할 경우 다른 메모리 보호 기법이 필요하다.</li>\n</ul>\n</li>\n<li>메모리 접근 연산은 특권명령이 아니지만 두 레지스터 값을 지정하는 것은 특권명령이다.</li>\n<li>입출력 연산은 모두 특권 명령이나 메모리 연산은 가능한 범위안에서는 사용자 모드에서 연산할 수 있다.</li>\n</ul>\n<br>\n<h2 id=\"-11-cpu-보호\" style=\"position:relative;\"><a href=\"#-11-cpu-%EB%B3%B4%ED%98%B8\" aria-label=\" 11 cpu 보호 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 11. CPU 보호</h2>\n<ul>\n<li>CPU가 하나의 프로그램에 독점되는 것을 막기 위해 타이머라는 하드웨어를 사용한다.</li>\n<li>CPU는 일정시간이 지나면 인터럽트를 발생시켜 운영체제가 CPU 제어하도록 하여 CPU를 다른 프로그램에게 이양한다.</li>\n<li>타이머는 일정 시간 단위로 세팅되어 매 클럭마다 1씩 감소하며 0이 되면 인터럽트가 발생한다.</li>\n<li>타이머 값 세팅은 load timer 명령이며 특권 명령이다.</li>\n<li>타이머를 통해서 시분할 시스템에서 현재 시간을 계산하기도 한다.</li>\n</ul>\n<br>\n<h2 id=\"-12-시스템-콜을-이용한-입출력-실행\" style=\"position:relative;\"><a href=\"#-12-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%BD%9C%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%9E%85%EC%B6%9C%EB%A0%A5-%EC%8B%A4%ED%96%89\" aria-label=\" 12 시스템 콜을 이용한 입출력 실행 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 12. 시스템 콜을 이용한 입출력 실행</h2>\n<ul>\n<li>디스크 파일 입출력, 키보드입출력 등은 모두 특권명령인 입출력 명령이다.</li>\n<li>운영체제의 system call이라는 서비스를 이용하여 입출력 명령을 대신 요쳥해야한다.</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#-1-%EC%BB%B4%ED%93%A8%ED%84%B0-%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98-%EA%B5%AC%EC%A1%B0\">🌩 1. 컴퓨터 시스템의 구조</a></p>\n</li>\n<li>\n<p><a href=\"#-2-cpu-%EC%97%B0%EC%82%B0%EA%B3%BC-io-%EC%97%B0%EC%82%B0\">🌩 2. CPU 연산과 I/O 연산</a></p>\n</li>\n<li>\n<p><a href=\"#-3-%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8%EC%9D%98-%EC%9D%BC%EB%B0%98%EC%A0%81-%EA%B8%B0%EB%8A%A5\">🌩 3. 인터럽트의 일반적 기능</a></p>\n</li>\n<li>\n<p><a href=\"#-4-%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8-%ED%95%B8%EB%93%A4%EB%A7%81\">🌩 4. 인터럽트 핸들링</a></p>\n</li>\n<li>\n<p><a href=\"#-5-%EC%9E%85%EC%B6%9C%EB%A0%A5-%EA%B5%AC%EC%A1%B0\">🌩 5. 입출력 구조</a></p>\n<ul>\n<li><a href=\"#%EB%8F%99%EA%B8%B0%EC%8B%9D-%EC%9E%85%EC%B6%9C%EB%A0%A5-vs-%EB%B9%84%EB%8F%99%EA%B8%B0%EC%8B%9D-%EC%9E%85%EC%B6%9C%EB%A0%A5\">동기식 입출력 vs. 비동기식 입출력</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-6-dma\">🌩 6. DMA</a></p>\n</li>\n<li>\n<p><a href=\"#-7-%EC%A0%80%EC%9E%A5%EC%9E%A5%EC%B9%98%EC%9D%98-%EA%B5%AC%EC%A1%B0\">🌩 7. 저장장치의 구조</a></p>\n</li>\n<li>\n<p><a href=\"#-8-%EC%A0%80%EC%9E%A5%EC%9E%A5%EC%B9%98%EC%9D%98-%EA%B3%84%EC%B8%B5-%EA%B5%AC%EC%A1%B0\">🌩 8. 저장장치의 계층 구조</a></p>\n</li>\n<li>\n<p><a href=\"#-9-%ED%95%98%EB%93%9C%EC%9B%A8%EC%96%B4%EC%9D%98-%EB%B3%B4%EC%95%88\">🌩 9. 하드웨어의 보안</a></p>\n</li>\n<li>\n<p><a href=\"#-10-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%B3%B4%EC%95%88\">🌩 10. 메모리 보안</a></p>\n</li>\n<li>\n<p><a href=\"#-11-cpu-%EB%B3%B4%ED%98%B8\">🌩 11. CPU 보호</a></p>\n</li>\n<li>\n<p><a href=\"#-12-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%BD%9C%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%9E%85%EC%B6%9C%EB%A0%A5-%EC%8B%A4%ED%96%89\">🌩 12. 시스템 콜을 이용한 입출력 실행</a></p>\n</li>\n</ul>\n</div>","excerpt":"다음은 반효경 교수님의 ‘운영체제와 정보기술의 원리’ CH3. 컴퓨터 시스템의 동작원리를 읽고 정리한 내용입니다 🙌 🌩 1. 컴퓨터 시스템의 구조 내부 장치 - CPU, 메모리 외부 장치 - 디스크, 키보드, 마우스, 모니터, 네트워크 장치 등등 입출력장치라고 한다. 각 하드웨어 장치를 각각의 컨트롤러가 제어한다. 컴퓨터는 외부장치에서 내부장치로 데이터를 읽어 연산한 후 결과를 외부장치로 내보내는 방식으로 동작한다. input - 내부로 들어오는 것 output - 외부로 내보내는 것 여러 프로그램을 동시에 수행할 수 있도록 하는 것이 운영체제이기 때문에 항상 메모리에 상주한다. 전체가 상주하기엔 너무 낭비이기 때문에 꼭 필요한 부분만 항상 메모리에 상주하고 그 부분을 **커널(kernel)**이라고 한다. 🌩 2. CPU 연산과 I/O 연산 I/O 연산들은 입출력 컨트롤러가 담당하고 컴퓨터 내부의 연산은 메인 CPU가 담당한다. 입출력 장치와 메인 CPU는 동시 수행이 가능하다.…","frontmatter":{"date":"October 11, 2021","title":"운영체제와 정보기술의 원리 - CH3. 컴퓨터 시스템의 동작원리","categories":"운영체제 책","author":"코다","emoji":"🧁"},"fields":{"slug":"/operating-system-2/"}},"next":{"id":"e5504118-763f-5c6d-b5da-4fd50eef8d78","html":"<blockquote>\n<p>다음은 반효경 교수님의 ‘운영체제와 정보기술의 원리’ <em>CH2. 운영체제 개요</em>를 읽고 정리한 내용입니다 🙌</p>\n</blockquote>\n<br>\n<br>\n<h2 id=\"-1-운영체제의-정의\" style=\"position:relative;\"><a href=\"#-1-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%9D%98-%EC%A0%95%EC%9D%98\" aria-label=\" 1 운영체제의 정의 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 1. 운영체제의 정의</h2>\n<ul>\n<li>운영체제란 컴퓨터 하드웨어 바로 위에 설치되는 소프트웨어이다.</li>\n<li>사용자가 직접 하드웨어를 다루는 것이 쉽지 않기 때문에 하드웨어를 기본적으로 운용하는 운영체제를 탑재해서 사용하도록 한다.</li>\n</ul>\n<h3 id=\"좁은-의미-운영체제-vs-넓은-의미-운영체제\" style=\"position:relative;\"><a href=\"#%EC%A2%81%EC%9D%80-%EC%9D%98%EB%AF%B8-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-vs-%EB%84%93%EC%9D%80-%EC%9D%98%EB%AF%B8-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C\" aria-label=\"좁은 의미 운영체제 vs 넓은 의미 운영체제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>좁은 의미 운영체제 vs. 넓은 의미 운영체제</h3>\n<ul>\n<li>운영체제도 소프트웨어이기 때문에 컴퓨터가 켜지면서 메모리에 올라가서 사용이 되어야 한다. 하지만 운영체제 전부를 메모리에 올려서 사용하기에는 리소스 낭비가 심하기 때문에 꼭 필요한 부분만을 전원이 켜짐과 동시에 메모리에 올린다.</li>\n<li>메모리에 전원이 켜짐과 동시에 상주하는 부분을 <strong>커널</strong>이라고 한다 ⇒ 좁은 의미의 운영체제</li>\n<li>이후 필요한 부분은 그때그때 사용자 유틸리티로 메모리에 올려서 사용한다 ⇒ 넓은 의미의 운영체제\n<ul>\n<li>파일 복사 등등</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"--2-운영체제의-기능\" style=\"position:relative;\"><a href=\"#--2-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%9D%98-%EA%B8%B0%EB%8A%A5\" aria-label=\"  2 운영체제의 기능 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩  2. 운영체제의 기능</h2>\n<ul>\n<li><strong>1) 하드웨어</strong>와 <strong>2) 사용자</strong>를 위한 역할 두가지를 중간에서 담당한다.\n<ul>\n<li>하드웨어를 관리하고 리소스를 효율적으로 운용한다.\n<ul>\n<li>자원 관리자 (resource manager)라고도 불린다.</li>\n<li>자원이란 CPU, 메모리, 하드디스크, 소프트웨어 자원들 등등</li>\n</ul>\n</li>\n<li>사용자에게 사용하기 편리한 인터페이스를 제공한다.</li>\n</ul>\n</li>\n<li>자원을 관리할 때 최대한의 성능을 내도록 한다. 동시에 모든 사용자 및 프로그램이 형평성있게 자원을 분배받을 수 있도록 관리한다.</li>\n<li>사용자와 운영체제의 보안을 담당한다.\n<ul>\n<li>다른 프로그램의 메모리 영역 참조를 막고 사적인 정보를 보호한다.</li>\n<li>메모리 영역의 보안을 담당한다.</li>\n</ul>\n  <br>\n</li>\n</ul>\n<h2 id=\"--3-운영체제의-분류\" style=\"position:relative;\"><a href=\"#--3-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%9D%98-%EB%B6%84%EB%A5%98\" aria-label=\"  3 운영체제의 분류 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩  3. 운영체제의 분류</h2>\n<h3 id=\"단일-작업용-vs-다중-작업용\" style=\"position:relative;\"><a href=\"#%EB%8B%A8%EC%9D%BC-%EC%9E%91%EC%97%85%EC%9A%A9-vs-%EB%8B%A4%EC%A4%91-%EC%9E%91%EC%97%85%EC%9A%A9\" aria-label=\"단일 작업용 vs 다중 작업용 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>단일 작업용 vs. 다중 작업용</h3>\n<ul>\n<li>단일 작업용 single tasking - 한번에 하나의 프로그램만 실행</li>\n<li>다중 작업용 multi tasking - 여러 프로그램을 동시에 실행\n<ul>\n<li>여러 프로그램이 CPU와 메모리를 공유한다.</li>\n<li><strong>시분할 시스템(time sharing system) -</strong> CPU의 작업시간을 나누어서 시분할 시스템(time sharing system) 방식으로 하나의 CPU에서 여러 프로그램을 실행시킨다.</li>\n<li><strong>다중 프로그래밍 시스템(multi-programming system)</strong> - 메모리 공간을 분할해 여러 프로그램들을 동시에 메모리에 올려놓고 처리하는 다중 프로그래밍 시스템(multi-programming system)으로 실행한다.</li>\n<li><strong>대화형 시스템(interactive system)</strong> - 여러 프로그램을 같이 실행시키지만 사용자 개개인의 관점에서 각 프로그램에 대한 키보드 입력 결과를 바로 화면에 보여준다.\n<ul>\n<li>ex. 여러 사람이 접속해서 사용하는 서버 (ec2)</li>\n</ul>\n</li>\n<li><strong>다중처리기 시스템 (multi-processor system)</strong> - 하나의 컴퓨터에 여러 CPU가 설치된 경우이다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"단일-사용자용-vs-다중-사용자용\" style=\"position:relative;\"><a href=\"#%EB%8B%A8%EC%9D%BC-%EC%82%AC%EC%9A%A9%EC%9E%90%EC%9A%A9-vs-%EB%8B%A4%EC%A4%91-%EC%82%AC%EC%9A%A9%EC%9E%90%EC%9A%A9\" aria-label=\"단일 사용자용 vs 다중 사용자용 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>단일 사용자용 vs. 다중 사용자용</h3>\n<ul>\n<li>단일 사용자용 - 한번에 한명의 사용자만 사용가능한 운영체제이다.\n<ul>\n<li>단일 사용자용은 단일 작업용, 다중 작업용으로 나뉜다.</li>\n<li>MS 윈도우 등등</li>\n</ul>\n</li>\n<li>다중 사용자용 - 여러 사용자가 동시에 접속해서 사용할 수 있는 운영체제이다.\n<ul>\n<li>서버, 웹서버 등등</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"처리방식\" style=\"position:relative;\"><a href=\"#%EC%B2%98%EB%A6%AC%EB%B0%A9%EC%8B%9D\" aria-label=\"처리방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>처리방식</h3>\n<ul>\n<li>일괄처리 (batch processing) 방식 - 요청된 작업을 모아서 한꺼번에 처리한다.\n<ul>\n<li>사용자 측면에서 응답시간이 길다.</li>\n</ul>\n</li>\n<li>시분할 방식 - 컴퓨터의 처리능력을 일정한 시간 단위로 분할해서 사용한다. (현대에 대부분 사용)\n<ul>\n<li>여러 사용자의 요청을 짧은 단위의 시간을 번갈아서 처리하여 응답한다.</li>\n<li>따라서 각 사용자가 혼자 사용하는 것처럼 느낀다. (대화형 시스템)</li>\n</ul>\n</li>\n<li>실시간 (real time) 운영체제 - 정해진 시간 안에 어떤 작업이 반드시 처리됨을 보장하는 시스템\n<ul>\n<li>원자로, 공장 제어 시스템, 미사일 제어 시스템 등등</li>\n<li>경성 실시간 시스템 (hard realtime system)\n<ul>\n<li>주어진 시간을 지키지 못하면 위험할 결과를 초래할 로켓, 원자로 제어 시스템 등등</li>\n</ul>\n</li>\n<li>연성 실시간 시스템 (soft realtime system)\n<ul>\n<li>멀티 미티어 스트리밍처럼 데이터가 정해진 시간 단위로 전달되어야 올바른 기능을 수행하는 시스템</li>\n</ul>\n</li>\n</ul>\n  <br>\n</li>\n</ul>\n<h2 id=\"-4-운영체제의-예\" style=\"position:relative;\"><a href=\"#-4-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%9D%98-%EC%98%88\" aria-label=\" 4 운영체제의 예 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 4. 운영체제의 예</h2>\n<ul>\n<li>윈도우는 시스템에 새로운 하드웨어를 장착하면 운영체제가 자동으로 감지하여 설정되는 plug and play 기능이 있다.</li>\n<li>유닉스는 안정성이 높고 깔끔한 모듈 단위로 구현된 운영체제로 확장성을 지원하는 대중적인 os이다.</li>\n</ul>\n<br>\n<h2 id=\"-5-운영체제의-자원-관리-기능\" style=\"position:relative;\"><a href=\"#-5-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%9D%98-%EC%9E%90%EC%9B%90-%EA%B4%80%EB%A6%AC-%EA%B8%B0%EB%8A%A5\" aria-label=\" 5 운영체제의 자원 관리 기능 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 5. 운영체제의 자원 관리 기능</h2>\n<h3 id=\"하드웨어\" style=\"position:relative;\"><a href=\"#%ED%95%98%EB%93%9C%EC%9B%A8%EC%96%B4\" aria-label=\"하드웨어 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>하드웨어</h3>\n<ul>\n<li>자원\n<ul>\n<li>CPU, 메모리, 입출력 장치 등의 주변기기</li>\n<li>여러 프로세스가 CPU와 메모리를 효율적으로 사용하도록 관리</li>\n<li>CPU와 메모리의 데이터가 전원이 꺼지면 없어지기 때문에 해당 데이터를 파일의 형태로 보조기억장치에 저장 (하드디스크)</li>\n<li>키보드, 모니터 등의 입출력 장치로 정보 교환</li>\n</ul>\n</li>\n<li>CPU 관리\n<ul>\n<li>CPU 스캐줄링 - 하나의 CPU를 어느 시점에 어떤 프로세스가 점유할 것인가</li>\n<li>CPU를 효율적으로 사용하면서 불이익을 받는 프로세스는 없도록 관리</li>\n<li><strong>FCFS</strong> - 먼저온 프로세스를 먼저 처리\n<ul>\n<li>시스템 전체적인 측면에서 비효율적일 수 있다. CPU를 먼저 점유한 프로세스가 작업을 완료할 때까지 다른 프로세스는 CPU를 사용할 수 없다. 이때 짧은 처리 시간을 가진 프로세스가 뒤늦게 도착했다면 매우 비효율적이다.</li>\n<li>문제 개선을 위해 RR이 등장했다.</li>\n</ul>\n</li>\n<li><strong>RR</strong> - CPU를 할당받아 사용할 수 있는 시간을 고정하여 번갈아 사용한다.\n<ul>\n<li>응답시간은 밀리초 단위로 지정하여 다수의 사용자가 동시접속해도 1초 이하의 응답시간을 보장받는다.</li>\n</ul>\n</li>\n<li><strong>Priority</strong> - 우선순위를 부여하여 그것에 따라 CPU를 먼저 할당한다.\n<ul>\n<li>지나치게 오래 기다리지 않도록 기다린 시간이 길면 우선순위를 높여준다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>메모리 관리\n<ul>\n<li>CPU가 직접 접근할 수 있는 컴퓨터 내부의 기억장치</li>\n<li>메모리의 어느 부분이 어떤 프로그램에 의해 사용되는지 파악하기 위해 주소(address)로 관리한다.\n<ul>\n<li>필요할 때 할당하고 끝나면 회수한다.</li>\n<li>불필요한 자원 낭비를 막는다.</li>\n</ul>\n</li>\n<li>메모리의 다른 프로세스가 서로 침범하지 않도록 보안을 유지한다.</li>\n<li><strong>고정분할(fixed partition)</strong> - 물리적 메모리를 몇개의 분할로 미리 나누어서 관리\n<ul>\n<li>각각의 분할에는 하나의 프로그램만 적재되므로 융통성이 없다.</li>\n<li>동시 적재 프로그램이 분할 개수로 한정되며, 분할된 크기보다 큰 프로그램은 적재할 수 없다.</li>\n<li>분할 크기보다 작은 프로그램은 남는 영역인 internal fragmentation이 생겨 비효율적이다.</li>\n</ul>\n</li>\n<li><strong>가변분할(variable partition)</strong> - 프로그램 크기에 맞게 메모리를 분할해서 사용한다.\n<ul>\n<li>프로그램의 크기에 따라서 제한이 되는 고정분할의 문제를 해결하지만 물리 메모리보다 큰 프로그램의 적재는 여전히 어렵다.</li>\n<li>분할 크기와 개수가 동적으로 변하기 때문에 기술적 관리 기법이 필요하다.</li>\n<li>내부조각 (internal fragmentation)은 발생하지 않지만 외부조각 (external fragmentation)은 발생한다.\n<ul>\n<li>프로그램에 할당되지는 않지만 남은 크기가 작아 할당되지 못하는 메모리 영역</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>가상 메모리 (virtual memory)</strong> - 가장 많이 이용되며 물리 메모리보다 큰 프로그램 실행이 가능하다.\n<ul>\n<li>모든 프로그램은 물리 메모리와 상관없이 독립적으로 0번에서 시작하는 가상 메모리 주소를 가진다.</li>\n<li>운영체제가 이 가상 메모리를 물리 메모리로 mapping 하여 변환 후 프로그램을 물리 메모리에 올린다.</li>\n<li>프로그램이 전체가 동시에 사용되는것이 아니기 때문에 물리 메모리보다 큰 프로그램을 사용할 수 있다. 나머지 부분을 하드디스크나 보조기억장치에 저장했다가 적재하는 방식을 택한다.\n<ul>\n<li>스왑 영역 swap area - 이때 사용되는 보조기억장치</li>\n</ul>\n</li>\n<li>가상 메모리 주소 공간은 페이지(page) 단위로 동일하게 나뉘어 물리적 메모리와 스왑 영역에 일부분씩 저장된다 ⇒ 페이징 기법</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>주변장치 및 입출력 장치\n<ul>\n<li>인터럽트 (interrupt) 매커니즘으로 관리한다.</li>\n<li>CPU가 필요할 때 신호를 발생시켜 서비스를 요청하는데, CPU는 스캐줄링 맞추어 작업을 처리하다가 인터럽트에 의한 요청 서비스를 수행한다.\n<ul>\n<li>ex. 키보드 입력</li>\n</ul>\n</li>\n<li>CPU는 인터럽트의 작업을 중간에 수행하기 위해서 이전에 처리중이던 작업의 상태를 저장해둔다.</li>\n<li>각 상황과 운영체제마다 인터럽트가 발생할때마다 따르는 인터럽트 루틴에 따라서 수행한다.\n<ul>\n<li>운영체제 커널의 일부분이다.</li>\n</ul>\n</li>\n<li>각 주변장치는 업무를 관리하기 위한 컨트롤러(CPU와 같은 것)가 있어 업무를 처리하고 CPU에 인터럽트를 발생시켜 보고하는 역할을 한다.</li>\n</ul>\n</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#-1-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%9D%98-%EC%A0%95%EC%9D%98\">🌩 1. 운영체제의 정의</a></p>\n<ul>\n<li><a href=\"#%EC%A2%81%EC%9D%80-%EC%9D%98%EB%AF%B8-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-vs-%EB%84%93%EC%9D%80-%EC%9D%98%EB%AF%B8-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C\">좁은 의미 운영체제 vs. 넓은 의미 운영체제</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#--2-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%9D%98-%EA%B8%B0%EB%8A%A5\">🌩  2. 운영체제의 기능</a></p>\n</li>\n<li>\n<p><a href=\"#--3-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%9D%98-%EB%B6%84%EB%A5%98\">🌩  3. 운영체제의 분류</a></p>\n<ul>\n<li><a href=\"#%EB%8B%A8%EC%9D%BC-%EC%9E%91%EC%97%85%EC%9A%A9-vs-%EB%8B%A4%EC%A4%91-%EC%9E%91%EC%97%85%EC%9A%A9\">단일 작업용 vs. 다중 작업용</a></li>\n<li><a href=\"#%EB%8B%A8%EC%9D%BC-%EC%82%AC%EC%9A%A9%EC%9E%90%EC%9A%A9-vs-%EB%8B%A4%EC%A4%91-%EC%82%AC%EC%9A%A9%EC%9E%90%EC%9A%A9\">단일 사용자용 vs. 다중 사용자용</a></li>\n<li><a href=\"#%EC%B2%98%EB%A6%AC%EB%B0%A9%EC%8B%9D\">처리방식</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-4-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%9D%98-%EC%98%88\">🌩 4. 운영체제의 예</a></p>\n</li>\n<li>\n<p><a href=\"#-5-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%9D%98-%EC%9E%90%EC%9B%90-%EA%B4%80%EB%A6%AC-%EA%B8%B0%EB%8A%A5\">🌩 5. 운영체제의 자원 관리 기능</a></p>\n<ul>\n<li><a href=\"#%ED%95%98%EB%93%9C%EC%9B%A8%EC%96%B4\">하드웨어</a></li>\n</ul>\n</li>\n</ul>\n</div>","frontmatter":{"date":"October 11, 2021","title":"운영체제와 정보기술의 원리 - CH2. 운영체제 개요","categories":"운영체제 책","author":"코다","emoji":"🧁"},"fields":{"slug":"/operating-system-1/"}},"prev":{"id":"c8678391-1095-5db1-99f3-e36da5f03ed2","html":"<blockquote>\n<p>다음은 반효경 교수님의 ‘운영체제와 정보기술의 원리’ <em>CH4. 프로그램의 구조와 실행</em>를 읽고 정리한 내용입니다 🙌</p>\n</blockquote>\n<br>\n<br>\n<h2 id=\"-1-프로그램의-구조와-인터럽트\" style=\"position:relative;\"><a href=\"#-1-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EC%9D%98-%EA%B5%AC%EC%A1%B0%EC%99%80-%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8\" aria-label=\" 1 프로그램의 구조와 인터럽트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 1. 프로그램의 구조와 인터럽트</h2>\n<ul>\n<li>CPU에서 프로그램 명령을 실행하기 위해서는 프로그램 명령을 담은 주소 영역이 메모리에 올라가야한다.\n<ul>\n<li>주소 영역은 code(프로그램 함수들이 기계어로 변환되어 저장), data(전역 변수 등 프로그램이 사용하는 데이터 저장), stack(함수 복귀 주소 및 데이터 임시 저장)으로 구분된다.</li>\n<li>함수를 호출하여 새로운 함수 위치로 점프할 때 다시 돌아올 주소를 스택 영역에 저장한다.</li>\n</ul>\n</li>\n<li>인터럽트 동작 원리도 함수의 호출과 비슷하다.\n<ul>\n<li>인터럽트 발생시 실행중이던 명령어의 위치를 저장한다. 처리루틴 후 해당 주소로 돌아와서 수행을 이어간다.</li>\n<li>이 주소는 운영체제가 관리하는 PCB에 저장된다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-2-컴퓨터-시스템의-작동-개요\" style=\"position:relative;\"><a href=\"#-2-%EC%BB%B4%ED%93%A8%ED%84%B0-%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98-%EC%9E%91%EB%8F%99-%EA%B0%9C%EC%9A%94\" aria-label=\" 2 컴퓨터 시스템의 작동 개요 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 2. 컴퓨터 시스템의 작동 개요</h2>\n<ul>\n<li>CPU는 매 시점 특정 주소에 존재하는 명령을 읽어서 그대로 실행한다.</li>\n<li>CPU가 실행해야할 명령의 메모리 위치는 Program Counter라는 레지스터에 저장된다. 주로 PC는 바로 다음 주소를 가리켜 코드가 순차적으로 실행되도록 한다.\n<ul>\n<li>반복문이나 함수호출 등의 주소이동이 있는 경우는 해당 주소를 가리키게 된다.</li>\n</ul>\n</li>\n<li>프로그램 실행 중 입출력 등의 다른 연산이 이루어지면 각 장치의 컨트롤러와 로컬버퍼가 함게 동작하여 연산을 처리한다.</li>\n<li>만일 PC가 메모리의 운영체제 부분을 가리키고 있다면 CPU는 커널 모드에서 수행중이라고 한다.</li>\n<li>CPU가 실행하는 명령은 일반명령과 특권명령을 나뉜다.\n<ul>\n<li>일반명령은 모든 프로그램에서 수행하는 명령이다. 메모리 자료를 읽어서 CPU 연산 후 결과를 메모리에 쓴다.</li>\n<li>특권명령은 보안이 필요한 명령으로 각종 장치에 접근한다. 운영체제만 수행하며 모드비트로 구분된다.</li>\n</ul>\n</li>\n<li>특권명령은 디스크파일접근, 화면출력 등을 수행할 수 있다. 사용자는 운영체제에 이 명령을 요청하여 대행하도록 system call을 한다.\n<ul>\n<li>system call이 호출되면 CPU는 해당 장치의 컨트롤러에 요청을 하고 데이터가 해당 장치의 로컬 버퍼에 담기면 컨트롤러가 CPU에 인터럽트를 발생시켜 작업 완료를 알린다.</li>\n</ul>\n</li>\n<li>CPU는 매 명령 수행 후 인터럽트 라인을 체크해 인터럽트가 일어났는지 확인한다.\n<ul>\n<li>인터럽트 라인은 종류마다 다르다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-3-프로그램의-실행\" style=\"position:relative;\"><a href=\"#-3-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EC%9D%98-%EC%8B%A4%ED%96%89\" aria-label=\" 3 프로그램의 실행 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 3. 프로그램의 실행</h2>\n<ul>\n<li>\n<p>프로그램이 실행된다는 것은</p>\n<ol>\n<li>실행파일이 메모리에 적재된다.</li>\n<li>프로그램이 CPU를 할당받고 명령을 수행하고 있다.</li>\n</ol>\n<p>라는 두가지 의미를 가진다.</p>\n</li>\n<li>\n<p>1번째 의미로 여러가지 프로그램이 메모리에 올라가 있을 수 있으니 <strong>여러 프로그램이 동시에 실행된다</strong>라고 할 수 있다.</p>\n</li>\n<li>\n<p>프로그램이 메모리에 적재될 때 일부분만 메모리에 나머지는 디스크에 내려가 있다.</p>\n</li>\n<li>\n<p><strong>프로그램마다 독자적</strong>으로 주소공간을 가져 코드, 데이터, 스택 영역등으로 나뉜다.</p>\n<ul>\n<li>해당 공간을 가상메모리 virtual memory, 논리적 메모리 logical memory 라고 부른다.</li>\n</ul>\n</li>\n<li>\n<p>운영체제의 경우도 하나의 프로그램이다.</p>\n<ul>\n<li>각각의 코드, 데이터 스택주소 공간을 가지고 있다.</li>\n<li>하드웨어와 사용자의 중간이기 때문에 1) CPU, 메모리 자원을 관리하는 부분과 2) 사용자에게 편리한 인터페이스 제공하기위한 부분이 나뉜다.</li>\n<li>시스템 콜, 인터럽트 처리 부분도 포함된다.</li>\n</ul>\n</li>\n<li>\n<p>커널의 데이터 영역 - 각종 자원을 관리하는 자료구조가 저장</p>\n<ul>\n<li>CPU, 메모리 하드웨어 자원 관리</li>\n<li>수행 중인 프로그램(소프트웨어) 관리 ⇒ 수행중인 프로그램을 프로세스라고 부른다.\n<ul>\n<li>각 프로세스의 상태, CPU 사용 정보, 메모리 사용 정보 등을 담은 PCB를 둔다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>커널의 스택 영역 - 함수호출 시 복귀 주소를 저장</p>\n<ul>\n<li>현재 수행 중인 프로세스마다 별도의 스택을 두어 관리\n<ul>\n<li>프로세스마다 특권명령을 수행하려고 system call을 하고 system call 안에서 다른 함수를 호출할 경우 복귀 주소가 커널 내 주소가 되기 때문</li>\n<li>커널은 공유 코드이므로 각 사용자 프로그램이 커널 함수에 접근할 수 있으므로 일관성 유지를 위해 각 프로세스마다 스택을 따로 둠.</li>\n</ul>\n</li>\n<li>요약\n<ul>\n<li>사용자 프로그램 내에서 함수호출 시 해당 프로그램의 스택에 복귀 주소를 저장</li>\n<li>시스템 콜이나 인터럽트 발생으로 운영체제가 제어하면 프로그램 복귀 정보를 PCB에 저장</li>\n<li>커널 내에서 이루어지는 함수호출은 각 프로세스의 커널스택에 복귀 정보를 저장\n<ul>\n<li>직전에 수행중이던 프로세스의 커널스택에 저장</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-4-사용자-프로그램이-사용하는-함수\" style=\"position:relative;\"><a href=\"#-4-%EC%82%AC%EC%9A%A9%EC%9E%90-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EC%9D%B4-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%ED%95%A8%EC%88%98\" aria-label=\" 4 사용자 프로그램이 사용하는 함수 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 4. 사용자 프로그램이 사용하는 함수</h2>\n<ol>\n<li>사용자정의 함수 - 프로그래머 본인이 작성\n<ol>\n<li>코드 영역에 기계어 형태</li>\n</ol>\n</li>\n<li>라이브러리 함수 - 다른 누군가 미리 작성\n<ol>\n<li>코드 영역에 기계어 형태</li>\n</ol>\n</li>\n<li>커널 함수 - 운영체제 커널의 코드에 정의된 함수\n<ul>\n<li>system call 함수, 인터럽트 처리 함수</li>\n<li>printf()와 같은 함수는 라이브러리 함수고 내부에서 system call을 한다.</li>\n<li>system call은 사용자가 운영체제 CPU를 넘겨서 실행하는 것이다.</li>\n<li>system call 또한 인터럽트 라인을 세팅하는 방법을 사용한다.</li>\n</ul>\n</li>\n</ol>\n<br>\n<h2 id=\"-5-인터럽트\" style=\"position:relative;\"><a href=\"#-5-%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8\" aria-label=\" 5 인터럽트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 5. 인터럽트</h2>\n<ul>\n<li>CPU는 대부분 명령을 순차적으로 진행한다. 매 명령마다 인터럽트 라인을 체크하고 발생했다면 제어권을 운영체제에게 넘겨 인터럽트 처리루틴에 따라 처리하고 다시 돌아온다.</li>\n<li>인터럽트 처리 중 다른 인터럽트가 발생 한 경우\n<ul>\n<li>원칙적으로 위 경우는 데이터 일관성을 위해 허용하지 않는다.</li>\n<li>예외적인 경우는 인터럽트 처리루틴 중 더 시급하거나 CPU가 당장 필요한 일이 발생한 경우이다.</li>\n</ul>\n</li>\n<li>인터럽트마다 중요도가 다르므로 중요도가 더 높은 인터럽트는 발생을 허용해 우선순위가 높은 인터럽트부터 처리하도록 한다.</li>\n</ul>\n<br>\n<h2 id=\"-6-시스템-콜\" style=\"position:relative;\"><a href=\"#-6-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%BD%9C\" aria-label=\" 6 시스템 콜 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 6. 시스템 콜</h2>\n<ul>\n<li>시스템 콜은 프로세스가 가지고 있는 자신의 주소 공간 내의 호출이 아닌 커널 (다른 프로그램 주소 공간) 함수를 호출하는 것이다.\n<ul>\n<li>이 경우 프로그램 자신이 스스로 인터럽트 라인을 세팅한다.</li>\n</ul>\n</li>\n<li>입출력 시스템 콜인 경우 CPU 명령 수행보다 많은 시간이 소요되므로 CPU가 그 시간동안 대기하고 있는 것은 자원의 낭비이다.</li>\n<li>또한 입출력을 요청한 프로그램에게 CPU를 다시 넘겨주는 것은 필요한 데이터가 없으므로 옳지 않다.</li>\n<li>따라서 한 프로그램이 입출력을 요청한다면 다른 프로그램에게 제어권을 넘겨주어 실행되도록 한다.</li>\n<li>입출력 작업이 완료되었을 경우 인터럽트 처리루틴\n<ul>\n<li>해당 인터럽트는 하드웨어 인터럽트이다.</li>\n<li>로컬버퍼의 내용을 메모리로 복사하고 해당 프로세스가 다시 CPU를 획득할 수 있는 권한을 준다.</li>\n<li>해당 프로세스가 작업 큐에 삽입되어 제어권이 돌아오게 한다.</li>\n</ul>\n</li>\n<li>정리 - 프로세스가 CPU를 빼앗기는 경우 2가지\n<ol>\n<li>타이머에 의한 인터럽트 발생 → 한 프로세스의 독점을 방지</li>\n<li>시스템 콜에 의한 인터럽트 발생 → 운영체제 함수 호출이 필요한 경우 실행</li>\n</ol>\n</li>\n</ul>\n<br>\n<h2 id=\"-7-프로세스의-두-가지-실행-상태\" style=\"position:relative;\"><a href=\"#-7-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%9D%98-%EB%91%90-%EA%B0%80%EC%A7%80-%EC%8B%A4%ED%96%89-%EC%83%81%ED%83%9C\" aria-label=\" 7 프로세스의 두 가지 실행 상태 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 7. 프로세스의 두 가지 실행 상태</h2>\n<ul>\n<li>사용자 모드에서 실행상태 (user mode running) - 자신의 주소 공간의 코드 실행</li>\n<li>커널 모드에서 실행상태 (kernel mode running) - 커널의 시스템 콜 함수 실행\n<ul>\n<li>이 경우에도 커널이 실행 상태에 있다고 하는 것이 아니라 해당 프로세스가 실행상태에 있다고 한다.</li>\n<li>해당 프로세스가 필요한 일을 처리하는 것이기 때문이다.</li>\n<li><em>프로세스 A가 커널모드에 실행 중</em> 이라고 표현한다.</li>\n</ul>\n</li>\n<li>프로그램 실행이 끝날 때는 커널 모드로 프로그램을 종료한다.</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#-1-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EC%9D%98-%EA%B5%AC%EC%A1%B0%EC%99%80-%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8\">🌩 1. 프로그램의 구조와 인터럽트</a></li>\n<li><a href=\"#-2-%EC%BB%B4%ED%93%A8%ED%84%B0-%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98-%EC%9E%91%EB%8F%99-%EA%B0%9C%EC%9A%94\">🌩 2. 컴퓨터 시스템의 작동 개요</a></li>\n<li><a href=\"#-3-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EC%9D%98-%EC%8B%A4%ED%96%89\">🌩 3. 프로그램의 실행</a></li>\n<li><a href=\"#-4-%EC%82%AC%EC%9A%A9%EC%9E%90-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EC%9D%B4-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%ED%95%A8%EC%88%98\">🌩 4. 사용자 프로그램이 사용하는 함수</a></li>\n<li><a href=\"#-5-%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8\">🌩 5. 인터럽트</a></li>\n<li><a href=\"#-6-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%BD%9C\">🌩 6. 시스템 콜</a></li>\n<li><a href=\"#-7-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%9D%98-%EB%91%90-%EA%B0%80%EC%A7%80-%EC%8B%A4%ED%96%89-%EC%83%81%ED%83%9C\">🌩 7. 프로세스의 두 가지 실행 상태</a></li>\n</ul>\n</div>","frontmatter":{"date":"October 12, 2021","title":"운영체제와 정보기술의 원리 - CH4. 프로그램의 구조와 실행","categories":"운영체제 책","author":"코다","emoji":"🧁"},"fields":{"slug":"/operating-system-3/"}},"site":{"siteMetadata":{"siteUrl":"https://yjksw.github.io","comments":{"utterances":{"repo":"yjksw/yjksw.github.io"}}}}},"pageContext":{"slug":"/operating-system-2/","nextSlug":"/operating-system-1/","prevSlug":"/operating-system-3/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}
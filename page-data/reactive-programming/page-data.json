{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/reactive-programming/",
    "result": {"data":{"cur":{"id":"3ba4fbef-2ac1-506c-baa4-ae874257f2a9","html":"<h2 id=\"-intro\" style=\"position:relative;\"><a href=\"#-intro\" aria-label=\" intro permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>💡 Intro</h2>\n<ul>\n<li>트래픽이 증가하고 사용자가 기대하는 요청시간은 더 빠른 응답을 원하게 되면서 리액티브 프로그래밍이라는 개념이 대두가 되기 시작했다.</li>\n<li>Java 진영에서는 물론이고 현재 공부하고 있는 스프링 어플리케이션에서도 리액티브 개념을 구현한 모듈이 추가되고 활용되고 있다.</li>\n<li>리액티브 프로그래밍을 키워드 중심으로 알아본다. (선언형, 리액티브 스트림, pub-sub 구조, 비동기, 옵저버 패턴 등등)</li>\n<li>리액티브 프로그래밍이 주요 개념이 된 이유에 대해서 고민해본다.</li>\n</ul>\n<br>\n<h2 id=\"리액티브-프로그래밍이란\" style=\"position:relative;\"><a href=\"#%EB%A6%AC%EC%95%A1%ED%8B%B0%EB%B8%8C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%B4%EB%9E%80\" aria-label=\"리액티브 프로그래밍이란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 리액티브 프로그래밍이란?</h2>\n<h3 id=\"reativex\" style=\"position:relative;\"><a href=\"#reativex\" aria-label=\"reativex permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ReativeX</h3>\n<p><a href=\"https://reactivex.io/\">ReativeX</a>는 옵저버 스트림을 활용한 비동기 프로그래밍을 위한 API이다. 그리고 이것을 구현한 여러 구현체들이 있다.</p>\n<p>나 같은 경우는 자바 언어를 주로 사용하는데 자바 진영에서도 리액티브 API를 구현한 RxJava가 있고, 자바9 부터 리액티브 프로그래밍을 구현할 수 있는 Flow 클래스를 제공한다.</p>\n<br>\n<h3 id=\"reactive---무엇에-반응한다는-것인가\" style=\"position:relative;\"><a href=\"#reactive---%EB%AC%B4%EC%97%87%EC%97%90-%EB%B0%98%EC%9D%91%ED%95%9C%EB%8B%A4%EB%8A%94-%EA%B2%83%EC%9D%B8%EA%B0%80\" aria-label=\"reactive   무엇에 반응한다는 것인가 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reactive - 무엇에 반응한다는 것인가?</h3>\n<p>Reactive는 반응하다 라는 뜻이다. 리액티브 프로그래밍은 Publisher가 발행한 데이터(요청)에 대해서 반응을 하기 때문에 리액티브 프로그래밍이라고 한다.</p>\n<ul>\n<li>\n<p>데이터가 즉각 반응을 한다는 것은 무슨 뜻일까 ?</p>\n<p>기존 명령형 프로그램과 비교해보자. 기존 명령형 프로그래밍은 어떠한 기능을 어떻게 할 것인지에 대한 코드가 있고 이것을 하드웨어가 차례로 실행한다.</p>\n<p>리액티브 프로그래밍은 “데이터의 흐름”을 정의하고 데이터 스트림을 그 흐름에서 선언한대로 데이터를 처리하고 구독한 subscriber가 처리된 데이터에 대한 마지막 행위를 한다. (예, 콘솔에 출력한다 등등)</p>\n</li>\n</ul>\n<p>조금 이해하기 어렵다면 다음 그림을 보자.</p>\n<p align=\"center\"><img width=\"80%\" src=\"https://user-images.githubusercontent.com/63405904/144062234-b2c15364-5290-4f49-b7c0-fe7af972d5da.png\"></p>\n<ul>\n<li>\n<p>위 그림에서 Publisher는 Click Stream이다.</p>\n<p>Click Stream에서 발생된 데이터의 흐름에 반응하여 마지막 subscriber가 filter된 데이터를 처리한다.</p>\n<p>(위 그림에서 Subscriber까지 표시되지는 않았다)</p>\n</li>\n<li>\n<p>데이터 스트림은  map → filter 파이프라인을 거치며 정제되며 마지막 데이터 스트림을 구독자가 처리하는 것이 반응형 프로그래밍이다.</p>\n</li>\n<li>\n<p>데이터의 흐름에 따라서 데이터가 변한다면 즉각적으로 반응하여 다른 결과를 출력하게 되기 때문에 반응형 프로그래밍이라고 한다.</p>\n</li>\n</ul>\n<br>\n<h3 id=\"어떻게-반응할까\" style=\"position:relative;\"><a href=\"#%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%B0%98%EC%9D%91%ED%95%A0%EA%B9%8C\" aria-label=\"어떻게 반응할까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>어떻게 반응할까?</h3>\n<p>반응형 프로그래밍에서 등장하는 키워드를 살펴보자. 가장 대표적인 반응형 비동기 프로그래밍 API인 ReactiveX 홈페이지를 참고했다.</p>\n<p align=\"center\"><img width=\"80%\" src=\"https://user-images.githubusercontent.com/63405904/144062576-d4d01ae9-71d6-4feb-bb53-8f675a1938e6.png\"></p>\n<ol>\n<li>\n<p><strong>옵저버 패턴</strong></p>\n<p>첫번째 키워드는 옵저버 패턴이다.</p>\n<p>옵저버 패턴이란 특정 객체의 상태를 관찰하는 관찰자(observer)들을 등록하고 해당 객체에 상태변화가 있을 때마다 메서드를 통해서 객체가 자신에게 등록된 관찰자들에게 통지하는 디자인 패턴이다.</p>\n<p>(Pub/sub 모델로도 알려져있지만 완전히 동일한 것은 아니다. 차이점은 다음 [링크](<a href=\"https://jistol.github.io/software\">https://jistol.github.io/software</a> engineering/2018/04/11/observer-pubsub-pattern/)를 참고해보자.</p>\n<p>내가 자주 사용하는 언어인 자바에서도 멀티 스레드 환경에서 안정적으로 옵저버 패턴을 활용할 수 있는 인터페이스와 클래스를 제공한다.</p>\n<p>관찰 당하는 객체는 Observable이라는 클래스를 상속하여 사용할 수 있고, 관찰하는 객체들은 Observer 인터페이스를 구현할 수 있다. synchronized 키워드를 통해서 필요시 동시성을 제어한다. (백터를 조작하는 과정 등등)</p>\n</li>\n<li>\n<p><strong>Iterator 패턴</strong></p>\n<p>두번째 키워드는 이터레이터 패턴이다.</p>\n<p>이터레이터 패턴이란 컬렉션의 생김새나 구현방법을 노출시키지 않으면서 컬렉션 내부에 접근할 수 있는 패턴이다. <code class=\"language-text\">next()</code> 와 같은 것을 호출하는 것만으로 컬렉션의 다음 element에 접근할 수 있다. 즉, 일종의 pull 방식이다.</p>\n<p>리액티브 프로그래밍에 대해서 설명할 때 이터레이터 패턴이 등장하는 이유는 BackPressure 때문이다. Publisher가 Subscriber가 감당하기 어려운 만큼의 양을 push 할 수 있으니, Subscriber가 오버플로우 되지 않도록 하는 것이 backpressure이다.</p>\n<p>여기서 이터레이터 패턴을 사용하여 감당 가능한 만큼의 데이터를 요청(pull)하여 처리한다.</p>\n<p align=\"center\"><img width=\"80%\" src=\"https://user-images.githubusercontent.com/63405904/144062711-c1892c27-6b65-43a3-ba9d-59ae7526c50c.png\"></p>\n</li>\n<li>\n<p><strong>함수형 프로그래밍</strong></p>\n<p>세번째 키워드는 함수형 프로그래밍이다.</p>\n<p>함수형 프로그래밍의 핵심은 선언형 프로그래밍이라는 것이다. 즉, 어떻게 할 것인지에 대한 구구절절한 구현이 있으면 발생 가능한 사이드 이펙트가 많으니 선언형으로 무엇을 할지를 선언하고 해당 함수를 조합하여 구현하는 것이다.</p>\n<p>마틴 파울러는 함수형 프로그래밍을 “Functional Programming is programming without assignment statements”라고 말했다. 변수를 선언하고 대입하여 구현하는 기존 프로그래밍과 다르게 함수형 프로그래밍은 작은 문제를 해결하기 위한 여러 함수들을 조합하여 결과를 낸다.</p>\n<p>리액티브 스트림에서는 함수형 프로그래밍을 활용하여 데이터를 가공한다. 상단의 사진에 COMBINE 부분을 보면 어떤 느낌으로 사용하는지 알 수 있을 것이다.</p>\n</li>\n</ol>\n<br>\n<h2 id=\"왜-이렇게-뜨는-개념일까\" style=\"position:relative;\"><a href=\"#%EC%99%9C-%EC%9D%B4%EB%A0%87%EA%B2%8C-%EB%9C%A8%EB%8A%94-%EA%B0%9C%EB%85%90%EC%9D%BC%EA%B9%8C\" aria-label=\"왜 이렇게 뜨는 개념일까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 왜 이렇게 뜨는 개념일까?</h2>\n<p>인터넷과 모바일이 보급되면서 사용자 관련 데이터와 트래픽은 점점 더 늘어나고 있다. 그렇기 때문에 기존에 전통적인 블록킹 동기 방식의 요청 처리는 사용자가 원하는 만큼이 속도를 내지도 못하고 처리량이 현저히 낮은 문제가 있다.</p>\n<ol>\n<li>\n<p><strong>기존의 요청 처리 방식</strong></p>\n<p>1개의 요청 당 1개의 스레드를 할당하여 처리한다.</p>\n<p>하지만 요청마다 스레드를 생성하는 것은 비용이 큰 작업이기 때문에 대부분 Thread pool을 사용하여 요청을 처리한다.</p>\n<p>특정 스레드가 할당된 요청이 블로킹 상태에 오래 머무르게 되고, thread pool에 있는 스레드를 모두 사용하면 결국 timeout이 발생하게 된다. 즉, 사용되지 않지만 점유되어 있는 스레드에 의한 비효율로 여러 요청을 빠르게 처리할 수 없다.(CPU는 일할 수 있음에도 불구하고 말이다!)</p>\n<ul>\n<li>\n<p>그렇다면 스레드 개수를 늘릴 수 없을까?</p>\n<p>스레드 개수를 늘리면 과도한 context switching이 발생하여 오히려 CPU utilization을 떨어뜨릴 수 있다.</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>리액티브 스트림의 요청 처리 방식</strong></p>\n<p>많은 요청을 처리하기 위해서 많은 스레드를 사용하지 않는다. (주로 CPU 코어 * 2 만큼만 만들어서 사용)</p>\n<p>이벤트 루프 기반의 비동기 논블로킹 방식을 사용하기 때문에 적은 수의 스레드로 많은 요청을 처리할 수 있으며 블로킹 상태에 스레드가 점유되어 낭비되는 일이 거의 없어진다.</p>\n<p>비동기/논블로킹이라면 호출되는 함수의 작업 완료 여부를 책임지지 않아도 되는 비동기와 호출된 함수로 넘어간 제어권이 바로 리턴되어 다른 일을 처리할 수 있도록 하는 논블로킹의 조합이다. 따라서 스트림을 블록하지 않고 비동기로 처리하면 CPU utilization을 극대화 할 수 있다.</p>\n</li>\n</ol>\n<br>\n<h2 id=\"헷갈리는-개념들-잡고가기\" style=\"position:relative;\"><a href=\"#%ED%97%B7%EA%B0%88%EB%A6%AC%EB%8A%94-%EA%B0%9C%EB%85%90%EB%93%A4-%EC%9E%A1%EA%B3%A0%EA%B0%80%EA%B8%B0\" aria-label=\"헷갈리는 개념들 잡고가기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 헷갈리는 개념들 잡고가기</h2>\n<h3 id=\"reactive-stream-vs-reactive-programming-vs-reactive-system\" style=\"position:relative;\"><a href=\"#reactive-stream-vs-reactive-programming-vs-reactive-system\" aria-label=\"reactive stream vs reactive programming vs reactive system permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reactive Stream vs. Reactive Programming vs. Reactive System</h3>\n<ul>\n<li>위에 말한 특징들 대부분이 Reactive Stream이다.</li>\n<li>이런 Reactive Stream을 사용한 프로그램이 Reactive Programming이다.</li>\n<li>Reactive Programming은 연관 키워드로 Event-driven, Reactive System은 Message-driven 이 많이 등장한다. 즉 전자는 한 어플리케이션 관점이고 후자는 전체 시스템 아키텍쳐의 관점으로 바라보아야한다.</li>\n<li>여러 Reactive Programming 컴포넌트들을 모아놓았다고 Reactive System인 것은 아니다. Reactive Manifesto에 나온 리액티브 특징을 살린 시스템 아키텍쳐여야 Reactive System이라고 할 수 있을 것이다.</li>\n</ul>\n<br>\n<h2 id=\"느낀-점\" style=\"position:relative;\"><a href=\"#%EB%8A%90%EB%82%80-%EC%A0%90\" aria-label=\"느낀 점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🛋 느낀 점</h2>\n<ul>\n<li>완전 새로운 개념이다 !! 마치 객체지향을 처음 공부했을 때처럼 실체가 있는 기술이 아니라 어떠한 형태의 프로그래밍 기법이니 더 개념 잡기가 어렵고 낯설었던 것 같다.</li>\n<li>면접을 보거나 프로젝트를 진행할 때 사용자를 고려하면 대량의 트래픽 처리와 동시성 문제는 빠지지 않는 주제인 것 같다.</li>\n<li>거의 모든 사람의 손에 모바일과 PC가 들려있으므로 리액티브 프로그래밍이 효율적인 요청처리와 동시성 측면에서도 좋은 해결책인 듯 싶다.</li>\n<li>이제 리액티브 프로그래밍의 기본 개념을 잡았으니 스프링 webflux에서 어떻게 이 개념을 활용하고 적용했는지 알아볼 수 있겠다!!</li>\n<li>모던 자바 인 액션과 자바의 정석에서도 자바의 리액티브 프로그래밍에 대해서 다루었다. 해당 부분을 읽고 정리해보는 것도 다음 목표이다. 관련 키워드는 Rx Java, Java Flow 등등이다. (모두 읽어보았으나 아직은 너무 어려웠다😭  추후 다시 도전)</li>\n</ul>\n<br>\n<br>\n<p><strong>[참고자료]</strong></p>\n<ul>\n<li><a href=\"https://sightstudio.tistory.com/14\">https://sightstudio.tistory.com/14</a></li>\n<li><a href=\"https://reactivex.io/\">https://reactivex.io/</a></li>\n<li>리액티브 매니페스토: <a href=\"https://reactivemanifesto.org/ko\">https://reactivemanifesto.org/ko</a></li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#-intro\">💡 Intro</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%A6%AC%EC%95%A1%ED%8B%B0%EB%B8%8C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%B4%EB%9E%80\">🌩 리액티브 프로그래밍이란?</a></p>\n<ul>\n<li><a href=\"#reativex\">ReativeX</a></li>\n<li><a href=\"#reactive---%EB%AC%B4%EC%97%87%EC%97%90-%EB%B0%98%EC%9D%91%ED%95%9C%EB%8B%A4%EB%8A%94-%EA%B2%83%EC%9D%B8%EA%B0%80\">Reactive - 무엇에 반응한다는 것인가?</a></li>\n<li><a href=\"#%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%B0%98%EC%9D%91%ED%95%A0%EA%B9%8C\">어떻게 반응할까?</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%99%9C-%EC%9D%B4%EB%A0%87%EA%B2%8C-%EB%9C%A8%EB%8A%94-%EA%B0%9C%EB%85%90%EC%9D%BC%EA%B9%8C\">🌩 왜 이렇게 뜨는 개념일까?</a></p>\n</li>\n<li>\n<p><a href=\"#%ED%97%B7%EA%B0%88%EB%A6%AC%EB%8A%94-%EA%B0%9C%EB%85%90%EB%93%A4-%EC%9E%A1%EA%B3%A0%EA%B0%80%EA%B8%B0\">🌩 헷갈리는 개념들 잡고가기</a></p>\n<ul>\n<li><a href=\"#reactive-stream-vs-reactive-programming-vs-reactive-system\">Reactive Stream vs. Reactive Programming vs. Reactive System</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EB%8A%90%EB%82%80-%EC%A0%90\">🛋 느낀 점</a></p>\n</li>\n</ul>\n</div>","excerpt":"💡 Intro 트래픽이 증가하고 사용자가 기대하는 요청시간은 더 빠른 응답을 원하게 되면서 리액티브 프로그래밍이라는 개념이 대두가 되기 시작했다. Java 진영에서는 물론이고 현재 공부하고 있는 스프링 어플리케이션에서도 리액티브 개념을 구현한 모듈이 추가되고 활용되고 있다. 리액티브 프로그래밍을 키워드 중심으로 알아본다. (선언형, 리액티브 스트림, pub-sub 구조, 비동기, 옵저버 패턴 등등) 리액티브 프로그래밍이 주요 개념이 된 이유에 대해서 고민해본다. 🌩 리액티브 프로그래밍이란? ReativeX ReativeX는 옵저버 스트림을 활용한 비동기 프로그래밍을 위한 API이다. 그리고 이것을 구현한 여러 구현체들이 있다. 나 같은 경우는 자바 언어를 주로 사용하는데 자바 진영에서도 리액티브 API를 구현한 RxJava가 있고, 자바9 부터 리액티브 프로그래밍을 구현할 수 있는 Flow 클래스를 제공한다. Reactive - 무엇에 반응한다는 것인가? Reactive는 반응하다…","frontmatter":{"date":"November 30, 2021","title":"리액티브 시리즈 - 1. 리액티브 프로그래밍 기본","categories":"스프링 웹","author":"코다","emoji":"🍀"},"fields":{"slug":"/reactive-programming/"}},"next":{"id":"00e80243-2a3a-528a-8625-03c3c7bfbedb","html":"<h2 id=\"-intro\" style=\"position:relative;\"><a href=\"#-intro\" aria-label=\" intro permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>💡 Intro</h2>\n<ul>\n<li>JVM은 자바의 큰 장점 중 하나로 이 가상머신이 깔려있는 운영체제에서는 모두 동일하게 자바 클래스 파일이 실행될 수 있다.</li>\n<li>JVM의 기본 구조를 알아보자 🙌</li>\n</ul>\n<br>\n<h2 id=\"-jvm-메모리-구조\" style=\"position:relative;\"><a href=\"#-jvm-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0\" aria-label=\" jvm 메모리 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 JVM 메모리 구조</h2>\n<p><strong>1) Class Loader 2) Execution Engine 3) Garbage Collector 4) Runtime Data Area</strong> 4가지로 나뉘어져 있다.</p>\n<h3 id=\"class-loader\" style=\"position:relative;\"><a href=\"#class-loader\" aria-label=\"class loader permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Class Loader</h3>\n<ul>\n<li>JVM 내로 클래스 파일을 로드하고 링크를 통해 배치하는 작업을 수행한다.</li>\n<li>런타임 시에 동적으로 클래스를 로드한다.</li>\n</ul>\n<h3 id=\"execution-engine\" style=\"position:relative;\"><a href=\"#execution-engine\" aria-label=\"execution engine permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Execution Engine</h3>\n<ul>\n<li>클래스 로더가 Runtime Data Area에 배치한 바이트 코드들을 명령어 단위로 읽어서 실행하는 작업을 수행한다.</li>\n<li>최초 JVM에서는 인터프리터 방식이어서 느렸지만 JIT 컴파일러로 변경되면서 실행이 빠르다는 장점이 있다.</li>\n<li>모든 코드 JIT으로 하지 않고 인터프리터로 하다가 일정한 기준이 넘어가면 JIT 컴파일러 방식으로 실행한다.\n<ul>\n<li>한번 읽어서 기계어로 변경한 소스코드는 변역하지 않는다.</li>\n<li>저장소에 저장하여 반복되는 코드는 한꺼번에 컴파일하여서 사용한다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"garbage-collector\" style=\"position:relative;\"><a href=\"#garbage-collector\" aria-label=\"garbage collector permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Garbage Collector</h3>\n<ul>\n<li>힙 메모리 영역에 객체 중 더이상 참조되지 않는 객체들을 제거하는 역할을 한다.\n<ul>\n<li>Reference Counting 혹은 Mark-and-sweep 방식을 사용</li>\n<li>Minor GC(eden, survivor1, survivor2)와 Major GC(old)</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"runtime-data-area\" style=\"position:relative;\"><a href=\"#runtime-data-area\" aria-label=\"runtime data area permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Runtime Data Area</h3>\n<ul>\n<li>애플리케이션이 실행할 때 사용되는 데이터를 적재하는 영역\n<ul>\n<li><strong>Method Area</strong> → 모든 스레드가 공유하는 메모리 영역으로 클래스, 인터페이스, 메소드, 필드, static 변수 등의 바이트 코드를 보관</li>\n<li><strong>Heap Area</strong> → 모든 스레드가 공유하며 new 키워드로 생성된 객체와 배열이 생성되는 영역</li>\n<li><strong>Stack Area</strong> → 메서드 호출시마다 스택 프레임을 생성하여 매개변수, 지역변수, 리턴 값, 연산 시 값들을 임시로 저장하며 메서드 수행이 끝나면 프레임을 삭제</li>\n<li><strong>PC Register</strong> → 쓰레드 시작 시 생성되며 스레드마다 하나씩 존재하고 무슨 명령어를 실행할지 명령의 주소 보관</li>\n<li><strong>Native Method Stack</strong> → 자바 외 언어로 작성된 네이티브 코드를 저장하는 메모리</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-느낀-점\" style=\"position:relative;\"><a href=\"#-%EB%8A%90%EB%82%80-%EC%A0%90\" aria-label=\" 느낀 점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🛋 느낀 점</h2>\n<ul>\n<li>JVM의 구조를 알고 있어야지 자바 코드가 실행되는 부분이 일종의 ‘매직’처럼 남아있지 않고 구체화 되어서 그려질 것 같다.</li>\n<li>공부를 할수록 그냥 되는줄 알았던 부분들이 차츰차츰 명료해지는 것 같다.</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#-intro\">💡 Intro</a></p>\n</li>\n<li>\n<p><a href=\"#-jvm-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0\">🌩 JVM 메모리 구조</a></p>\n<ul>\n<li><a href=\"#class-loader\">Class Loader</a></li>\n<li><a href=\"#execution-engine\">Execution Engine</a></li>\n<li><a href=\"#garbage-collector\">Garbage Collector</a></li>\n<li><a href=\"#runtime-data-area\">Runtime Data Area</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-%EB%8A%90%EB%82%80-%EC%A0%90\">🛋 느낀 점</a></p>\n</li>\n</ul>\n</div>","frontmatter":{"date":"November 17, 2021","title":"JVM 구조 알아보기","categories":"자바","author":"코다","emoji":"✊"},"fields":{"slug":"/java-jvm/"}},"prev":{"id":"39669800-a8a1-59fe-b30a-a447fd689c46","html":"<h2 id=\"intro\" style=\"position:relative;\"><a href=\"#intro\" aria-label=\"intro permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>💡 Intro</h2>\n<ul>\n<li><strong>데이터의 그룹을 저장하는 클래스들을 표준화한 프로그래밍 방식</strong></li>\n<li>컬렉션 프레임워크는 다수의 데이터를 다루는 여러 클래스를 제공하여 개발자의 부담을 덜어준다.</li>\n<li>인터페이스와 다형성을 이용해서 객체지향적으로 설계가 되어 있기 때문에 추상적이고 재사용성이 높은 좋은 프레임워크이다.</li>\n</ul>\n<br>\n<h2 id=\"핵심-인터페이스\" style=\"position:relative;\"><a href=\"#%ED%95%B5%EC%8B%AC-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4\" aria-label=\"핵심 인터페이스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 핵심 인터페이스</h2>\n<p>컬렉션에 담기는 데이터를 크게 3가지로 나누어 각각을 인터페이스로 정의해두었다. 그리고 3가지 중 List, Set의 공통점을 뽑아 따로 인터페이스로 추상화 되어 있다.</p>\n<p align=\"center\"><img width=\"80%\" src=\"https://user-images.githubusercontent.com/63405904/144552104-6d0d4ba5-92c9-464a-8e14-3580a0972f6c.png\"></p>\n<p>각 인터페이스와 특징은 다음과 같다.</p>\n<ol>\n<li>List: 순서가 있으며 중복이 허용된 데이터의 집합\n<ul>\n<li>ArrayList, LinkedList, Stack, Vector, etc.</li>\n</ul>\n</li>\n<li>Set: 순서가 없으며 중복을 허용하지 않는 데이터의 집합\n<ul>\n<li>HashSet, TreeSet, etc.</li>\n</ul>\n</li>\n<li>Map: 키와 값의 쌍으로 이루어진 데이터의 집합이며 순서를 유지하지 않으며 키는 중복을 허용하지 않음\n<ul>\n<li>HashMap, TreeMap, Hashtable, etc.</li>\n</ul>\n</li>\n</ol>\n<p>모든 컬렉션 클래스는 위 3개의 인터페이스 중 하나를 구현하고 있으며 해당 인터페이스의 이름이 클래스명에 포함되어 있다. (예외로 Vector, Hashtable, Stack 같이 이전에 이미 존재하던 것들은 이름에 인터페이스명을 포함하고 있지 않기도 하다. 기존 호환을 위해 남겨져 있기는 하나 되도록 새로 정의된 컬렉션 클래스를 쓰는 것을 추천한다.)</p>\n<h3 id=\"collection-인터페이스\" style=\"position:relative;\"><a href=\"#collection-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4\" aria-label=\"collection 인터페이스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Collection 인터페이스</h3>\n<p>컬렉션 클래스에 저장된 데이터를 읽고, 추가하고 삭제하는 등 컬렉션을 다루는 기본적인 메서드들을 정의</p>\n<p>예시)</p>\n<ul>\n<li>add, addAll, clear, contains, equals, isEmpty, remove, etc.</li>\n</ul>\n<h3 id=\"list-인터페이스\" style=\"position:relative;\"><a href=\"#list-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4\" aria-label=\"list 인터페이스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>List 인터페이스</h3>\n<ul>\n<li>상속계층도</li>\n</ul>\n<p align=\"center\"><img width=\"70%\" src=\"https://user-images.githubusercontent.com/63405904/144552206-76fe42b0-368c-4c8c-a4b3-2907d8c1ac14.png\"></p>\n<h3 id=\"set-인터페이스\" style=\"position:relative;\"><a href=\"#set-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4\" aria-label=\"set 인터페이스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Set 인터페이스</h3>\n<ul>\n<li>상속계층도</li>\n</ul>\n<p align=\"center\"><img width=\"70%\" src=\"https://user-images.githubusercontent.com/63405904/144552215-20cedfd3-3a44-4d56-ab5a-0f69b24fa62d.png\"></p>\n<h3 id=\"map-인터페이스\" style=\"position:relative;\"><a href=\"#map-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4\" aria-label=\"map 인터페이스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Map 인터페이스</h3>\n<ul>\n<li>상속계층도</li>\n</ul>\n<p align=\"center\"><img width=\"70%\" src=\"https://user-images.githubusercontent.com/63405904/144552224-6c84a3c4-28cf-4608-8d19-aad933cfa988.png\"></p>\n<ul>\n<li>값을 반환하는 <code class=\"language-text\">values()</code> 의 반환 타입은 Collection이고, <code class=\"language-text\">keySet()</code>의 반환 타입은 Set이다. 전자는 중복을 허용하고 후자는 중복을 허용하지 않는다.</li>\n</ul>\n<h3 id=\"mapentry-인터페이스\" style=\"position:relative;\"><a href=\"#mapentry-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4\" aria-label=\"mapentry 인터페이스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Map.Entry 인터페이스</h3>\n<ul>\n<li>Map 인터페이스 내부에는 Map.Entry 라는 인터페이스가 하나 더 있다.</li>\n<li>Map에 저장되는 <strong>key-value 쌍을 다루기 위해 내부적으로 정의한 인터페이스</strong>이다.</li>\n<li>객체지향적으로 설계하도록 유도한 인터페이스이며, Map 인터페이스를 구현하면 Map.Entry 인터페이스도 함께 구현해야한다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">Map</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">K</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">V</span><span class=\"token punctuation\">></span></span> <span class=\"token punctuation\">{</span>\n\t\n\t<span class=\"token keyword\">int</span> <span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">boolean</span> <span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">interface</span> <span class=\"token class-name\">Entry</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">K</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">V</span><span class=\"token punctuation\">></span></span> <span class=\"token punctuation\">{</span>\n\t\t\n\t\t<span class=\"token class-name\">K</span> <span class=\"token function\">getKey</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\t\t<span class=\"token class-name\">V</span> <span class=\"token function\">getValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\t\t<span class=\"token class-name\">V</span> <span class=\"token function\">setValue</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">V</span> value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\t\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<br>\n<h2 id=\"arraylist\" style=\"position:relative;\"><a href=\"#arraylist\" aria-label=\"arraylist permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 ArrayList</h2>\n<ul>\n<li>\n<p>Object 배열을 이용하여 순차적으로 데이터를 저장한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ArrayList</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">AbstractList</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">List</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">RandomAccess</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Cloneable</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>io<span class=\"token punctuation\">.</span></span>Serializable</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t<span class=\"token keyword\">transient</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> elementData<span class=\"token punctuation\">;</span> \n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n</ul>\n<h3 id=\"왜-code-classlanguage-textelementdatacode-는-code-classlanguage-texttrasientcode-설정이-되어-있을까-\" style=\"position:relative;\"><a href=\"#%EC%99%9C-code-classlanguage-textelementdatacode-%EB%8A%94-code-classlanguage-texttrasientcode-%EC%84%A4%EC%A0%95%EC%9D%B4-%EB%90%98%EC%96%B4-%EC%9E%88%EC%9D%84%EA%B9%8C-\" aria-label=\"왜 code classlanguage textelementdatacode 는 code classlanguage texttrasientcode 설정이 되어 있을까  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>왜 <code class=\"language-text\">elementData</code> 는 <code class=\"language-text\">trasient</code> 설정이 되어 있을까? 🤔</h3>\n<p>우선 <code class=\"language-text\">transient</code>는 해당 클래스를 직렬화 할 때 직렬화 대상이 되지 않도록 하는 키워드이다. 그럼 핵심 데이터를 담는 <code class=\"language-text\">elementData</code>가 <code class=\"language-text\">transient</code> 설정이 되어 있다면 직렬화 대상에서 제외가 될 텐데 왜 이런 설정이 되어 있을까?</p>\n<p>우선 짚고 넘어가고 싶은 것은 직렬화는 좋은 기술이지만 고려해야할 부분들이 매우 많은 까다로운 기술이라는 것이다. 자세한 것은 다음 <a href=\"https://www.youtube.com/watch?v=3iypR-1Glm0\">링크</a>를 참고해보자.</p>\n<p>따라서 ArrayList 클래스를 보면 <code class=\"language-text\">serialize</code>, <code class=\"language-text\">deserialize</code> 하는 메소드인 <code class=\"language-text\">writeObject()</code>, <code class=\"language-text\">readObject()</code>를 직접 구현하고 있다.</p>\n<h3 id=\"배열의-초기-크기는-어떻게-산정이-될까-\" style=\"position:relative;\"><a href=\"#%EB%B0%B0%EC%97%B4%EC%9D%98-%EC%B4%88%EA%B8%B0-%ED%81%AC%EA%B8%B0%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%82%B0%EC%A0%95%EC%9D%B4-%EB%90%A0%EA%B9%8C-\" aria-label=\"배열의 초기 크기는 어떻게 산정이 될까  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>배열의 초기 크기는 어떻게 산정이 될까? 🤔</h3>\n<p><strong>초기 크기를 지정한 경우의 내부 구현을 살펴보자.</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token class-name\">ArrayList</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> initialCapacity<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>initialCapacity <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>elementData <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">[</span>initialCapacity<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>initialCapacity <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>elementData <span class=\"token operator\">=</span> EMPTY_ELEMENTDATA<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IllegalArgumentException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Illegal Capacity: \"</span><span class=\"token operator\">+</span> initialCapacity<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>초기 값이 0 이라면 <code class=\"language-text\">EMTPY_ELEMENTDATA</code> 라는 것을 지정하고 아니라면 입력 값 크기 만큼의 배열을 선언한다.</li>\n</ul>\n<p><strong>초기 크기를 지정하지 않은 경우의 내부 구현을 살펴보자.</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token class-name\">ArrayList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>elementData <span class=\"token operator\">=</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>빈 Object 배열을 선언하여 할당한다.</li>\n<li>하지만 주로 ArrayList를 활용할 때 초기 크기 뿐 아니라 이후에도 크기를 정해주지 않았으며 그냥 element를 추가만 하는 경우가 많았다.</li>\n<li>그러면 언제 배열의 크기를 재할당 하는 것일까? 다음 코드를 살펴보자.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">E</span> e<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> elementData<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> s<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>s <span class=\"token operator\">==</span> elementData<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span>\n        elementData <span class=\"token operator\">=</span> <span class=\"token function\">grow</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    elementData<span class=\"token punctuation\">[</span>s<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> e<span class=\"token punctuation\">;</span>\n    size <span class=\"token operator\">=</span> s <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">E</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">// element를 add 하는 로직</span>\n    modCount<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">add</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">,</span> elementData<span class=\"token punctuation\">,</span> size<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">private</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token function\">grow</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> minCapacity<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> elementData <span class=\"token operator\">=</span> <span class=\"token class-name\">Arrays</span><span class=\"token punctuation\">.</span><span class=\"token function\">copyOf</span><span class=\"token punctuation\">(</span>elementData<span class=\"token punctuation\">,</span> <span class=\"token function\">newCapacity</span><span class=\"token punctuation\">(</span>minCapacity<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">private</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token function\">grow</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">//추가 공간이 필요한 경우 capacity를 늘리는 로직 </span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">grow</span><span class=\"token punctuation\">(</span>size <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>ArrayList는 내부적으로 size라는 인스턴스 변수를 두고 몇개의 요소들이 있는지 트랙킹한다. 새로운 요소를 추가할 때 이 추가 공간이 있는지 확인하고 없다면 <code class=\"language-text\">grow()</code> 메소드를 호출한다.</li>\n<li><code class=\"language-text\">grow()</code>는 <code class=\"language-text\">Arrays.copyOf()</code>를 사용하여 새로운 크기 만큼의 배열을 생성하고 기존 데이터를 옮긴다.</li>\n<li>시스템 적으로 오버헤드가 많고 처리시간이 많이 소요되는 작업이므로 ArrayList를 사용할때는 저장할 개수보다 조금 더 여유있기 기본 사이즈를 할당하는 것이 좋다.</li>\n</ul>\n<br>\n<h2 id=\"느낀-점\" style=\"position:relative;\"><a href=\"#%EB%8A%90%EB%82%80-%EC%A0%90\" aria-label=\"느낀 점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🛋 느낀 점</h2>\n<ul>\n<li>내용 추가 예정 ‼️ 안 끝남 주의 ‼️</li>\n</ul>\n<br>\n<br>\n<p><strong>[참고자료]</strong></p>\n<ul>\n<li>자바의 정석</li>\n<li>Java 내부구현 코드</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#intro\">💡 Intro</a></p>\n</li>\n<li>\n<p><a href=\"#%ED%95%B5%EC%8B%AC-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4\">🌩 핵심 인터페이스</a></p>\n<ul>\n<li><a href=\"#collection-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4\">Collection 인터페이스</a></li>\n<li><a href=\"#list-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4\">List 인터페이스</a></li>\n<li><a href=\"#set-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4\">Set 인터페이스</a></li>\n<li><a href=\"#map-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4\">Map 인터페이스</a></li>\n<li><a href=\"#mapentry-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4\">Map.Entry 인터페이스</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#arraylist\">🌩 ArrayList</a></p>\n<ul>\n<li><a href=\"#%EC%99%9C-elementdata-%EB%8A%94-trasient-%EC%84%A4%EC%A0%95%EC%9D%B4-%EB%90%98%EC%96%B4-%EC%9E%88%EC%9D%84%EA%B9%8C-\">왜 <code class=\"language-text\">elementData</code> 는 <code class=\"language-text\">trasient</code> 설정이 되어 있을까? 🤔</a></li>\n<li><a href=\"#%EB%B0%B0%EC%97%B4%EC%9D%98-%EC%B4%88%EA%B8%B0-%ED%81%AC%EA%B8%B0%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%82%B0%EC%A0%95%EC%9D%B4-%EB%90%A0%EA%B9%8C-\">배열의 초기 크기는 어떻게 산정이 될까? 🤔</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EB%8A%90%EB%82%80-%EC%A0%90\">🛋 느낀 점</a></p>\n</li>\n</ul>\n</div>","frontmatter":{"date":"December 03, 2021","title":"자바 컬렉션 프레임워크 파헤치기 1 - 기본 & ArrayList","categories":"자바","author":"코다","emoji":"✊"},"fields":{"slug":"/java-collection-framework-1/"}},"site":{"siteMetadata":{"siteUrl":"https://yjksw.github.io","comments":{"utterances":{"repo":"yjksw/yjksw.github.io"}}}}},"pageContext":{"slug":"/reactive-programming/","nextSlug":"/java-jvm/","prevSlug":"/java-collection-framework-1/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}
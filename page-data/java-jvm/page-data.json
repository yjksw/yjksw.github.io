{"componentChunkName":"component---src-templates-blog-template-js","path":"/java-jvm/","result":{"data":{"cur":{"id":"00e80243-2a3a-528a-8625-03c3c7bfbedb","html":"<h2 id=\"-intro\" style=\"position:relative;\"><a href=\"#-intro\" aria-label=\" intro permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>💡 Intro</h2>\n<ul>\n<li>JVM은 자바의 큰 장점 중 하나로 이 가상머신이 깔려있는 운영체제에서는 모두 동일하게 자바 클래스 파일이 실행될 수 있다.</li>\n<li>JVM의 기본 구조를 알아보자 🙌</li>\n</ul>\n<br>\n<h2 id=\"-jvm-메모리-구조\" style=\"position:relative;\"><a href=\"#-jvm-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0\" aria-label=\" jvm 메모리 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 JVM 메모리 구조</h2>\n<p><strong>1) Class Loader 2) Execution Engine 3) Garbage Collector 4) Runtime Data Area</strong> 4가지로 나뉘어져 있다. </p>\n<h3 id=\"class-loader\" style=\"position:relative;\"><a href=\"#class-loader\" aria-label=\"class loader permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Class Loader</h3>\n<ul>\n<li>JVM 내로 클래스 파일을 로드하고 링크를 통해 배치하는 작업을 수행한다.</li>\n<li>런타임 시에 동적으로 클래스를 로드한다.</li>\n</ul>\n<h3 id=\"execution-engine\" style=\"position:relative;\"><a href=\"#execution-engine\" aria-label=\"execution engine permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Execution Engine</h3>\n<ul>\n<li>클래스 로더가 Runtime Data Area에 배치한 바이트 코드들을 명령어 단위로 읽어서 실행하는 작업을 수행한다.</li>\n<li>최초 JVM에서는 인터프리터 방식이어서 느렸지만 JIT 컴파일러로 변경되면서 실행이 빠르다는 장점이 있다.</li>\n<li>\n<p>모든 코드 JIT으로 하지 않고 인터프리터로 하다가 일정한 기준이 넘어가면 JIT 컴파일러 방식으로 실행한다.</p>\n<ul>\n<li>한번 읽어서 기계어로 변경한 소스코드는 변역하지 않는다.</li>\n<li>저장소에 저장하여 반복되는 코드는 한꺼번에 컴파일하여서 사용한다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"garbage-collector\" style=\"position:relative;\"><a href=\"#garbage-collector\" aria-label=\"garbage collector permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Garbage Collector</h3>\n<ul>\n<li>\n<p>힙 메모리 영역에 객체 중 더이상 참조되지 않는 객체들을 제거하는 역할을 한다.</p>\n<ul>\n<li>Reference Counting 혹은 Mark-and-sweep 방식을 사용</li>\n<li>Minor GC(eden, survivor1, survivor2)와 Major GC(old)</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"runtime-data-area\" style=\"position:relative;\"><a href=\"#runtime-data-area\" aria-label=\"runtime data area permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Runtime Data Area</h3>\n<ul>\n<li>\n<p>애플리케이션이 실행할 때 사용되는 데이터를 적재하는 영역</p>\n<ul>\n<li><strong>Method Area</strong> → 모든 스레드가 공유하는 메모리 영역으로 클래스, 인터페이스, 메소드, 필드, static 변수 등의 바이트 코드를 보관</li>\n<li><strong>Heap Area</strong> → 모든 스레드가 공유하며 new 키워드로 생성된 객체와 배열이 생성되는 영역</li>\n<li><strong>Stack Area</strong> → 메서드 호출시마다 스택 프레임을 생성하여 매개변수, 지역변수, 리턴 값, 연산 시 값들을 임시로 저장하며 메서드 수행이 끝나면 프레임을 삭제</li>\n<li><strong>PC Register</strong> → 쓰레드 시작 시 생성되며 스레드마다 하나씩 존재하고 무슨 명령어를 실행할지 명령의 주소 보관</li>\n<li><strong>Native Method Stack</strong> → 자바 외 언어로 작성된 네이티브 코드를 저장하는 메모리</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-느낀-점\" style=\"position:relative;\"><a href=\"#-%EB%8A%90%EB%82%80-%EC%A0%90\" aria-label=\" 느낀 점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🛋 느낀 점</h2>\n<ul>\n<li>JVM의 구조를 알고 있어야지 자바 코드가 실행되는 부분이 일종의 ‘매직’처럼 남아있지 않고 구체화 되어서 그려질 것 같다.</li>\n<li>공부를 할수록 그냥 되는줄 알았던 부분들이 차츰차츰 명료해지는 것 같다.</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#-intro\">💡 Intro</a></li>\n<li>\n<p><a href=\"#-jvm-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0\">🌩 JVM 메모리 구조</a></p>\n<ul>\n<li><a href=\"#class-loader\">Class Loader</a></li>\n<li><a href=\"#execution-engine\">Execution Engine</a></li>\n<li><a href=\"#garbage-collector\">Garbage Collector</a></li>\n<li><a href=\"#runtime-data-area\">Runtime Data Area</a></li>\n</ul>\n</li>\n<li><a href=\"#-%EB%8A%90%EB%82%80-%EC%A0%90\">🛋 느낀 점</a></li>\n</ul>\n</div>","excerpt":"💡 Intro JVM은 자바의 큰 장점 중 하나로 이 가상머신이 깔려있는 운영체제에서는 모두 동일하게 자바 클래스 파일이 실행될 수 있다. JVM의 기본 구조를 알아보자 🙌 🌩 JVM 메모리 구조 1) Class Loader 2) Execution Engine 3) Garbage Collector 4) Runtime Data Area 4가지로 나뉘어져 있다.  Class Loader JVM 내로 클래스 파일을 로드하고 링크를 통해 배치하는 작업을 수행한다. 런타임 시에 동적으로 클래스를 로드한다. Execution Engine 클래스 로더가 Runtime Data Area에 배치한 바이트 코드들을 명령어 단위로 읽어서 실행하는 작업을 수행한다. 최초 JVM에서는 인터프리터 방식이어서 느렸지만 JIT 컴파일러로 변경되면서 실행이 빠르다는 장점이 있다. 모든 코드 JIT으로 하지 않고 인터프리터로 하다가 일정한 기준이 넘어가면 JIT 컴파일러 방식으로 실행한다. 한번 읽어서 기계어로 …","frontmatter":{"date":"November 17, 2021","title":"JVM 구조 알아보기","categories":"자바","author":"코다","emoji":"✊"},"fields":{"slug":"/java-jvm/"}},"next":{"id":"b07a3ebb-de77-55b2-820a-0f1162a587a2","html":"<h2 id=\"-intro\" style=\"position:relative;\"><a href=\"#-intro\" aria-label=\" intro permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>💡 Intro</h2>\n<ul>\n<li>스프링에서 어느날 등장한 개념은 아니고 어떠한 이름으로든 사용이 되고 있던 기술인데 스프링에서 더 잘 사용되도록 특정 형태를 부여했다.</li>\n<li>이 3가지 기술들이 그 자체로 스프링이기보다 POJO 기반 엔터프라이즈 개발을 편하게 해줄 수 있는 일종의 도구이다. 즉, 객체지향적인 구현에 충실하면서 자연스럽게 등장하게 된 결과라고 할 수 있다.</li>\n<li>스프링에서 제공하는 PSA, AOP만 사용하는 것이 아니라 그 개념을 차출하여 객체지향적 구현을 하는 것이 중요하다.</li>\n</ul>\n<br>\n<h2 id=\"-iocdi\" style=\"position:relative;\"><a href=\"#-iocdi\" aria-label=\" iocdi permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 IoC/DI</h2>\n<ul>\n<li>AOP, PSA도 IoC/DI에 바탕을 두고 있는 기술이다.</li>\n<li>느슨한 결합을 위해 인터페이스를 두고 실제 구현체를 DI를 통해 외부에서 주입하는 것이다.</li>\n</ul>\n<h3 id=\"왜-강한-결합보다-느슨한-결합이-나은가\" style=\"position:relative;\"><a href=\"#%EC%99%9C-%EA%B0%95%ED%95%9C-%EA%B2%B0%ED%95%A9%EB%B3%B4%EB%8B%A4-%EB%8A%90%EC%8A%A8%ED%95%9C-%EA%B2%B0%ED%95%A9%EC%9D%B4-%EB%82%98%EC%9D%80%EA%B0%80\" aria-label=\"왜 강한 결합보다 느슨한 결합이 나은가 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>왜 강한 결합보다 느슨한 결합이 나은가?</h3>\n<ul>\n<li>유연한 확장이 가능하게 하기 위해서 → OCP</li>\n<li>\n<p>변경에 닫혀있다는 것은 <strong>재사용이 가능하다</strong> 라는 뜻이다.</p>\n<ul>\n<li>A → B 의존관계일 때 B가 변경이 되어도 A가 아무 영향을 받지 않으면 A 입장에서는 폐쇄이며 B 관점에서는 유연한 확장이다.</li>\n<li>B가 B1, B2, B3로 바뀔수도 있고, A는 그대로 재사용이 가능하기 때문이다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"di의-활용-방법-및-장점\" style=\"position:relative;\"><a href=\"#di%EC%9D%98-%ED%99%9C%EC%9A%A9-%EB%B0%A9%EB%B2%95-%EB%B0%8F-%EC%9E%A5%EC%A0%90\" aria-label=\"di의 활용 방법 및 장점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>DI의 활용 방법 및 장점</h3>\n<ol>\n<li>\n<p>핵심기능의 변경</p>\n<ul>\n<li>구현체를 바꿀 수 있다.</li>\n<li>예를 들어 DAO를 사용하고 그 구현을 JDBC, JPA 하이버네이트, JDO 등으로 바꿀 수 있다.</li>\n</ul>\n</li>\n<li>\n<p>핵심기능의 동적인 변겅</p>\n<ul>\n<li>애플리케이션 동작 중간에 의존 대상을 다이나믹하게 변경할 수 있다.</li>\n<li>예를들어 사용자의 입력에 따라서 다른 DataSource를 사용하게 만들 수 있다.</li>\n<li>기술적으로 프록시를 활용한 것인데 이것은 DI 없이는 불가능한 기술이다.</li>\n</ul>\n</li>\n<li>\n<p>부가기능의 추가</p>\n<ul>\n<li>핵심 기능은 그대로 둔 채 부가기능을 추가하는 데코레이터 패턴과 같은 것이다.</li>\n<li>DI를 사용해서 데코레이터 패턴을 쉽게 적용할 수 있다.</li>\n<li>클라이언트 코드에는 영향을 주지 않으면서 부가기능 추가가 가능하다.</li>\n<li>부가 작업을 특정 오브젝트를 대상으로 하는 것이 아니라 많은 대상으로 일반화 한다면 AOP가 되는 것이다.</li>\n</ul>\n</li>\n<li>\n<p>인터페이스의 변경</p>\n<ul>\n<li>클라이언트에서 사용하는 인터페이스와 오브젝트의 인터페이스가 일치하지 않을 때 DI를 활용하여 어댑터 패턴을 응용할 수 있다.</li>\n<li>예를 들어 A가 B인터페이스에 의존하지만 C 오브젝트를 사용하고자 할 때, B 인터페이스를 상속하고 C기능을 제공하는 어댑터를 구현하여 해결할 수 있다.</li>\n<li>\n<p>일반화하여 인터페이스가 다양한 구현을 같은 방식으로 사용하도록 할 수도 있다. → PSA</p>\n<ul>\n<li>구현체는 다양하지만 클라이언트 입장에서는 같은 방식으로 늘 사용하는 것이다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>프록시</p>\n<ul>\n<li>필요한 시점에서 실제로 사용할 오브젝트를 초기화해고 지연된 로딩을 적용할 때 사용할 수 있다.</li>\n</ul>\n</li>\n<li>\n<p>템플릿과 콜백 </p>\n<ul>\n<li>작업의 흐름 사이에 자주 바뀌는 부분을 템플릿과 콜백으로 만들고 DI 원리를 사용하면 코드를 간결하게 구현할 수 있다.</li>\n</ul>\n</li>\n<li>\n<p>싱글톤과 오브젝트 스코프</p>\n<ul>\n<li>DI하는 오브젝트의 생명주기를 제어할 수 있다. DI를 컨테이너가 한다면 오브젝트의 생명주기를 마음대로 관리하고 제어할 수 있다.</li>\n<li>기본 스코프는 싱글톤이다. 웹 엔터프라이즈는 수많은 클라이언트를 대상으로 서비스를 제공해야하기 때문에 여러 스레드의 요청을 동시에 처리할 수 있도록 하기 위해서다.</li>\n<li>전통적인 싱글톤은 오브젝트에 많은 제약을 가했지만 IoC 방식의 싱글톤은 자유로운 설계가 가능하다.</li>\n</ul>\n</li>\n<li>\n<p>테스트</p>\n<ul>\n<li>오브젝트를 효과적으로 테스트하기 위해서는 오브젝트가 고립되어야 한다.</li>\n<li>다른 오브젝트와 협력하는 부분을 테스트하기 위해서는 환경 전체를 테스트해야한다는 부담감이 있다.</li>\n<li>\n<p>DI를 한다면 의존 오브젝트를 대신하여 스텁 혹은 목 오브젝트 같이 테스트 대역을 할 수 있다.</p>\n<ul>\n<li>\n<p>번외) stub과 mock의 차이</p>\n<p>stub은 더미 객체를 사용하여 실제로 동작하는 것 처럼 보이도록 하는 것이다. 상태검증을 한다. </p>\n<p>mock은 기대값을 명세하고 특정 결과를 반환하도록 하는 것이다. 행위검증을 한다. </p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<br>\n<h2 id=\"-aop\" style=\"position:relative;\"><a href=\"#-aop\" aria-label=\" aop permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 AOP</h2>\n<ul>\n<li>관점 지향 프로그래밍이라고도 많이 알려져 있다.</li>\n<li>관심사가 같은 코드를 분리해 객체지향의 원칙에 따라서 분리하고 응집된 것들을 한 곳에 모으는 것이 좋다.</li>\n<li>\n<p>트랜잭션의 경우</p>\n<ul>\n<li>트랜잭션은 한 곳에 모을 수 없고 여기저기에 흩어져있다. 따라서 모듈화가 힘들다.</li>\n<li>부가기능이기 때문에 스스로 독립적인 방식으로 존재하는 것이 어렵다.</li>\n<li>흩어져있는 부가로직을 분리하여 중복되지 않고, 변경이 필요한 경우 한 곳만 변경할 수 있도록 하는 것이 AOP의 역할이다.</li>\n</ul>\n</li>\n<li>Aspect는 부가 기능을 정의한 advice와 해당 advice를 적용할 포인트컷을 가지고 있다.</li>\n<li>부가기능이 핵심기능 모듈에 침투하면서 핵심기능을 파악하고 수정하고 테스트하기 어렵다.</li>\n<li>\n<p>AOP와 OOP</p>\n<ul>\n<li>AOP와 OOP가 대체관계라고 생각할 수 있지만 사실 보조하는 기술이다.</li>\n<li>부가기능이 핵심기능 안으로 침투하면 핵심기능에 객체지향 기술을 부여하기 힘들고 테스트하기 어려움으로 AOP로 해당 로직을 분리하여 객체지향적인 가치를 지킬 수 있도록 해주는 것이다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-psa\" style=\"position:relative;\"><a href=\"#-psa\" aria-label=\" psa permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 PSA</h2>\n<ul>\n<li>환경과 세부 기술의 변화와 관계없이 일관된 방식으로 기술에 접근할 수 있다.</li>\n<li>\n<p>POJO 코드가 JavaEE에 직접 노출되지 않도록 해준다.</p>\n<ul>\n<li>예를 들어서 트랜잭션이라는 엔터프라이즈 기술을 직접 POJO에 노출하는 것이 아니라 일관적인 서비스 추상화 기술의 형태로 제공해준다.</li>\n</ul>\n</li>\n<li>대신 설정을 통해 추상화 된 부분에 어떤 기술을 할 것인지 지정해주어야한다.</li>\n</ul>\n<br>\n<h2 id=\"-느낀-점\" style=\"position:relative;\"><a href=\"#-%EB%8A%90%EB%82%80-%EC%A0%90\" aria-label=\" 느낀 점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🛋 느낀 점</h2>\n<ul>\n<li>스프링 프레임워크의 목적은 “엔터프라이즈 기술을 사용하되 비즈니스 로직을 객체지향적으로 구현하고자 하는 것”이다.</li>\n<li>이해하기 어려운 스프링 프레임워크의 기술도 이 관점으로 보면 나름 이해할 수 있다.</li>\n<li>그리고 그 모든 기술의 기반은 바로 DI 다 !! 추상적으로 구현하여 확장성을 보장하고 변경에 자유로운 객체지향적 코드를 구현할 수 있도록 해준다.</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#-intro\">💡 Intro</a></li>\n<li>\n<p><a href=\"#-iocdi\">🌩 IoC/DI</a></p>\n<ul>\n<li><a href=\"#%EC%99%9C-%EA%B0%95%ED%95%9C-%EA%B2%B0%ED%95%A9%EB%B3%B4%EB%8B%A4-%EB%8A%90%EC%8A%A8%ED%95%9C-%EA%B2%B0%ED%95%A9%EC%9D%B4-%EB%82%98%EC%9D%80%EA%B0%80\">왜 강한 결합보다 느슨한 결합이 나은가?</a></li>\n<li><a href=\"#di%EC%9D%98-%ED%99%9C%EC%9A%A9-%EB%B0%A9%EB%B2%95-%EB%B0%8F-%EC%9E%A5%EC%A0%90\">DI의 활용 방법 및 장점</a></li>\n</ul>\n</li>\n<li><a href=\"#-aop\">🌩 AOP</a></li>\n<li><a href=\"#-psa\">🌩 PSA</a></li>\n<li><a href=\"#-%EB%8A%90%EB%82%80-%EC%A0%90\">🛋 느낀 점</a></li>\n</ul>\n</div>","frontmatter":{"date":"November 16, 2021","title":"스프링 3대 개념 - IoC/DI, AOP, PSA","categories":"스프링 웹","author":"코다","emoji":"🍀"},"fields":{"slug":"/spring-ioc-aop-psa/"}},"prev":null,"site":{"siteMetadata":{"siteUrl":"https://yjksw.github.io","comments":{"utterances":{"repo":"yjksw/yjksw.github.io"}}}}},"pageContext":{"slug":"/java-jvm/","nextSlug":"/spring-ioc-aop-psa/","prevSlug":""}},"staticQueryHashes":["1073350324","2938748437"]}
{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/realmysql-1/",
    "result": {"data":{"cur":{"id":"6fab7afb-3293-568e-b9f6-c7fa8095d568","html":"<blockquote>\n<p>다음 글은 Real MySQL 스터디를 진행하면서 정리한 4.1장 내용입니다. 🙌</p>\n</blockquote>\n<h2 id=\"-intro\" style=\"position:relative;\"><a href=\"#-intro\" aria-label=\" intro permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>💡 Intro</h2>\n<ul>\n<li>프로젝트를 진행해보니 서비스의 대부분의 병목은 데이터베이스에서 발생한다는 것을 알 수 있었다.</li>\n<li>DBA가 아니더라도 기본적으로 파생된 쿼리가 어느 과정을 거쳐서 처리되는지, 성능을 좌우하는 시스템 변수들은 어떠한 것들이 있는지 아는 것이 매우 중요하다고 생각한다.</li>\n<li>MySQL 엔진은 데이터베이스의 뇌의 역할을 한다. 기본적은 서버 구조와 MySQL 엔진과 스토리지 엔진의 차이점 및 담당 부분을 이해해보자.</li>\n</ul>\n<br>\n<h2 id=\"-mysql-서버의-구조\" style=\"position:relative;\"><a href=\"#-mysql-%EC%84%9C%EB%B2%84%EC%9D%98-%EA%B5%AC%EC%A1%B0\" aria-label=\" mysql 서버의 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 MySQL 서버의 구조</h2>\n<p>머리 역할을 하는 MySQL 엔진과 손발 역할을 하는 스토리지 엔진(InnoDB, MyISAM)이 있다.</p>\n<p>스토리지 엔진은 핸들러 API를 만족하면 직접 구현하여 추가해서 사용할 수 있다.</p>\n<br>\n<h2 id=\"-mysql-엔진-아키텍쳐\" style=\"position:relative;\"><a href=\"#-mysql-%EC%97%94%EC%A7%84-%EC%95%84%ED%82%A4%ED%85%8D%EC%B3%90\" aria-label=\" mysql 엔진 아키텍쳐 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 MySQL 엔진 아키텍쳐</h2>\n<h3 id=\"mysql-전체구조\" style=\"position:relative;\"><a href=\"#mysql-%EC%A0%84%EC%B2%B4%EA%B5%AC%EC%A1%B0\" aria-label=\"mysql 전체구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>MySQL 전체구조</h3>\n<ol>\n<li><strong>MySQL 엔진</strong></li>\n</ol>\n<p>먼저 MySQL 서버는 대부분의 상용 언어에서 지원할 수 있으며 MySQL 서버의 커넥션 핸들러에서 커넥션을 관리한다. 이렇게 클라이언트로부터의 접속과 쿼리 요청을 처리하는 커넥션 핸들러와 SQL 파서 및 전 처리기, 옵티마이저가 여기에 속한다.</p>\n<p>표준 SQL 문법을 지원하기 때문에 표준 문법에 따라서 작성된 쿼리는 다른 DBMS에서 실행될 수 있다.</p>\n<ol>\n<li><strong>스토리지 엔진</strong></li>\n</ol>\n<p>실제 데이터를 디스크에 저장하고 데이터를 디스크로부터 읽어오는 부분을 담당한다. 테이블마다 다른 스토리지 엔진을 정의하여 처리할 수 있다. 각 스토리지 엔진은 성능을 향상하기 위해서 키 캐시(MyISAM)나 버퍼 풀(InnoDB)와 같은 기능을 내장한다.</p>\n<ol>\n<li><strong>핸들러 API</strong></li>\n</ol>\n<p>각 스토리지 엔진에 읽기 또는 쓰기를 요청하는 것을 핸들러(handler) 요청이라고 하며 그 API를 핸들러API 라고 한다. <code class=\"language-text\">SHOW GLOBAL STATUS LIKE 'Handler%';</code> 등을 통해서 핸들러 API의 요청 작업을 확인할 수 있다.</p>\n<br>\n<h3 id=\"mysql-스레딩-구조\" style=\"position:relative;\"><a href=\"#mysql-%EC%8A%A4%EB%A0%88%EB%94%A9-%EA%B5%AC%EC%A1%B0\" aria-label=\"mysql 스레딩 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>MySQL 스레딩 구조</h3>\n<p>MySQL 서버는 프로세스가 아닌 스레드 기반으로 작동한다. 포그라운드(Foreground) 스레드와 백그라운드(Background) 스레드로 구분하여 실행되며 MySQL의 <code class=\"language-text\">performance_schema</code> 데이터베이스의 <code class=\"language-text\">threads</code> 테이블로 스레드 현황을 확인할 수 있다.</p>\n<p>대부분 포그라운드 스레드가 더 적고 백그라운드 스레드가 많으며 하나의 작업에 대해 여러 스레드가 할당되어 병렬 처리를 할 수 있다. 커뮤니티 에디션이 아닌 MySQL 서버에서는 스레드 풀(thread pool) 모델을 사용할 수도 있다.</p>\n<p><strong>포그라운드 스레드(클라이언트 스레드)</strong></p>\n<p>MySQL 서버에 접속된 클라이언트의 수만큼 존재하며 각 클라이언트 사용자가 요청하는 쿼리 문장을 처리한다. 커넥션이 종료되었을 때 해당 스레드가 스레드 캐시(thread cache)로 돌아간다. 이때 스레드 캐시에 있는 스레드의 개수가 설정된 <code class=\"language-text\">thread_cache_size</code> 보다 크다면 해당 스레드는 캐시로 넣지않고 바로 종료한다.</p>\n<p>포그라운드 스레드가 하는 일은 데이터를 MySQL의 데이터 버퍼나 캐시로부터 가져오며 버퍼나 캐시에 없는 경우에는 직접 디스크나 인덱스 파일로부터 데이터를 읽고 작업을 처리한다. InnoDB 테이블 같은 경우에는 데이터 버퍼나 캐시만 포그라운드 스레드가 처리하고 나머지는 백그라운드 스레드가 처리한다. (MyISAM은 디스크 쓰기까지 포그라운드 스레드가 처리한다)</p>\n<p><strong>백그라운드 스레드</strong></p>\n<p>InnoDB에서는 다음 작업들이 백그라운드 스레드로 처리된다.</p>\n<ul>\n<li>인서트 버퍼를 병합하는 스레드</li>\n<li>로그를 디스크로 기록하는 스레드</li>\n<li>InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드</li>\n<li>데이터를 버퍼로 읽어 오는 스레드</li>\n<li>잠금이나 데드락을 모니터링하는 스레드</li>\n</ul>\n<p>이 중에서 로그를 기록하는 로그 스레드(Log thread)와 데이터를 디스크에 기록하는 쓰기 스레드(Write Thread)가 가장 중요하다.</p>\n<p>MySQL 5.5 부터 읽기 및 쓰기 스레드를 여러개 설정할 수 있으며 <code class=\"language-text\">innodb_write_io_thread</code>, <code class=\"language-text\">innodb_read_io_thread</code> 로 설정할 수 있다. 읽기는 주로 클라이언트 스레드에서 처리되지만 쓰기는 백그라운드로 많이 처리하므로 일반적으로 2~4 정도를 설정하는 것이 좋다.</p>\n<p>데이터 쓰기 작업은 버퍼링되어 처리될 수 있으므로 일반 DBMS나 InnoDB는 쓰기 데이터가 디스크에 완전히 저장될 때까지 기다리지 않아도 된다. 이후에 일괄 처리할 수 있다. 하지만 MyISAM 같은 경우에는 사용자 스레드가 쓰기작업까지 함께 처리하게 되어 있어 쓰기 버퍼링 기능을 사용할 수 없다.</p>\n<br>\n<h3 id=\"메모리-할당-및-사용-구조\" style=\"position:relative;\"><a href=\"#%EB%A9%94%EB%AA%A8%EB%A6%AC-%ED%95%A0%EB%8B%B9-%EB%B0%8F-%EC%82%AC%EC%9A%A9-%EA%B5%AC%EC%A1%B0\" aria-label=\"메모리 할당 및 사용 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>메모리 할당 및 사용 구조</h3>\n<p>MySQL의 메모리 구조는 글로벌 메모리 영역과 로컬 메모리 영역으로 나뉘어지는데 운영체제에 따라서 글로벌 메모리 영역은 요청 메모리 공간을 100% 할당 받거나 일부 예약하고 필요할 때 할당받거나 한다. 메모리 영역의 크기를 측정하는 것은 어렵고 최대 MySQL 시스템 변수 만큼 운영체제로부터 메모리를 할당받는다.</p>\n<p><strong>글로벌 메모리 영역과 로컬 메모리 영역의 차이는 MySQL 서버 내의 스레드가 공유하는지 아닌지에 따라서 구분이 된다.</strong></p>\n<p><strong>글로벌 메모리 영역</strong></p>\n<p>클라이언트 스레드의 수와 상관없이 주로 1개만 존재한다. 여러개가 존재할 수도 있지만 그래도 모든 스레드가 공유한다.</p>\n<ul>\n<li>테이블 캐시</li>\n<li>InnoDB 버퍼 풀</li>\n<li>InnoDB 어댑티브 해시 인덱스</li>\n<li>InnoDB 리두 로그 버퍼</li>\n</ul>\n<p><strong>로컬 메모리 영역</strong></p>\n<p>세션 메모리 영역이며 클라이언트 스레드가 쿼리를 처리할 때 사용하는 메모리 영역이다. 대표적으로 커넥션 버퍼와 정렬 버퍼등이 있다. 커넥션 마다 할당되는 클라이언트 스레드가 할당받는 메모리 영역이기 때문에 <strong>클라이언트 메모리 영역</strong>이라고도 하며 커넥션을 일반적으로 세션이라고도 부르기 때문에 <strong>세션 메모리 영역</strong>이라고도 한다.</p>\n<p>로컬 메모리는 스레드 별로 독립적으로 할당되어 절대 공유되지 않는다. 또한 필요할 때만 공간을 할당하고 필요하지 않으면 MySQL은 공간을 전혀 할당하지 않을 수도 있다.</p>\n<p>로컬 메모리 영역 중 커넥션 버퍼나 결과 버퍼는 커넥션의 생명주기에 따라서 계속 할당되어 있고 소트 버퍼나 조인 버퍼는 쿼리를 실행하는 순간에만 할당하고 바로 해제한다.</p>\n<ul>\n<li>정렬 버퍼</li>\n<li>조인 버퍼</li>\n<li>바이너리 로그 캐시</li>\n<li>네트워크 버퍼</li>\n</ul>\n<br>\n<h3 id=\"플러그인-스토리지-엔진-모델\" style=\"position:relative;\"><a href=\"#%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80-%EC%97%94%EC%A7%84-%EB%AA%A8%EB%8D%B8\" aria-label=\"플러그인 스토리지 엔진 모델 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>플러그인 스토리지 엔진 모델</h3>\n<p>플러그인 모델은 MySQL의 독특한 특징이다. 스토리지 엔진은 플러그인 해서 사용할 수 있다. (이외에도 검색어 파서, 사용자 인증 기능, 비밀번호 검증, 쿼리 재작성 등을 플러그인으로 구현되어 제공된다) 기본적으로 제공되는 스토리지 엔진에 부가기능을 추가로 제공하여 직접 스토리지 엔진을 개발할 수도 있다.</p>\n<p>대부분의 작업은 MySQL 엔진에서 처리되고 스토리지 엔진은 데이터 읽기/쓰기 작업만 처리한다. 스토리지 엔진의 데이터 읽기/쓰기 작업은 1건의 레코드 단위로 처리된다. 스토리지 엔진을 조정하기 위해서 핸들러라는 것이 사용되며 자주 등장하는 개념이다.</p>\n<p>MySQL에서 핸들러는 개념적인 내용이다. MySQL엔진이 스토리지 엔진에서 데이터를 읽어오거나 저장하도록 명령하려면 핸들러를 통해서 할 수 있다. 시스템 변수 중 <code class=\"language-text\">'Handler_'</code> 로 시작하는 것들은 MySQL엔진이 스토리지 엔진에게 보낸 명령의 횟수와 같은 정보들이다. 스토리지 엔진에서는 철처히 데이터 읽기/쓰기만 실행되고 <code class=\"language-text\">GROUP BY</code>, <code class=\"language-text\">ORDER BY</code>  와 같은 복잡한 처리는 쿼리 실행기에서 처리된다.</p>\n<p>데이터 읽기/쓰기 처리는 스토리지 엔진에 따라서 그 방식이 매우 달라질 수 있다. 또한 하나의 쿼리 작업은 여러 하위 작업으로 나뉠 수 있으며 어떤 작업이 MySQL 엔진에서 실행되는지 스토리지 엔진에서 실행되는지 구분할 필요가 있다.</p>\n<br>\n<h3 id=\"컴포넌트\" style=\"position:relative;\"><a href=\"#%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8\" aria-label=\"컴포넌트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>컴포넌트</h3>\n<p>MySQL 5.5까지는 플러그인 아키텍처 였는데 이것을 대체하기 위해서 컴포넌트 아키텍처를 지원할 수 있다. 이것은 플러그인 아키텍쳐의 단점들을 보완한다.</p>\n<ul>\n<li>플러그인은 MySQL 서버와만 인터페이스 할 수 있고 플러그인끼리는 통신할 수 없다.</li>\n<li>플러그인은 MySQL 서버의 변수나 함수를 직접 호출하여 안전하지 않다. (캡슐화가 안된다)</li>\n<li>플러그인은 상호 의존관계를 설정할 수 없어서 초기화가 어렵다.</li>\n</ul>\n<p>컴포넌트를 사용하려면 <code class=\"language-text\">INSTALL COMPONENT</code> 를 통해서 컴포넌트를 설치하고 관련 새로운 시스템 변수를 설치하면 된다.</p>\n<br>\n<h3 id=\"쿼리-실행-구조\" style=\"position:relative;\"><a href=\"#%EC%BF%BC%EB%A6%AC-%EC%8B%A4%ED%96%89-%EA%B5%AC%EC%A1%B0\" aria-label=\"쿼리 실행 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>쿼리 실행 구조</h3>\n<p>다음 순서에 따라서 쿼리를 실행하고 결과를 가져와 요청자에게 응답한다.</p>\n<p><code class=\"language-text\">쿼리 파서 → 전처리기 → 옵티마이저(쿼리 변환, 비용 최적화, 실행 계획 수립) → 쿼리 실행기</code></p>\n<ol>\n<li><strong>쿼리 파서</strong></li>\n</ol>\n<p>사용자로부터 들어온 쿼리 문장을 토큰(MYSQL이 인식하는 최 단위의 어휘)으로 분리하여 트리 형태의 구조로 만든다. 문법 오류가 발견되는 지점이다.</p>\n<ol>\n<li><strong>전처리기</strong></li>\n</ol>\n<p>파서 트리를 기반으로 쿼리 문장 구조적 문제를 확인한다. 테이블 이름, 칼럼 이름, 내장 함수 등등을 매핑하여 존재 여부와 접근 권한 등을 확인한다.</p>\n<ol>\n<li><strong>옵티마이저</strong></li>\n</ol>\n<p>사용자 요청으로 들어온 쿼리 문장을 가장 저렴하게 처리할 수 있는 방법을 찾는 두뇌 역할을 한다. 옵티마이저가 어떻게 하면 더 나은 선택을 할 수 있도록 할지 유도하는 것이 매우 중요하며 전체적인 성능에 영향을 끼치는 부분이다.</p>\n<ol>\n<li><strong>실행 엔진</strong></li>\n</ol>\n<p>실행 엔진은 손과 발에 비유한다. 다음 순서를 다라서 실행 엔진의 일을 이해해보자.</p>\n<ol>\n<li>실행 엔진이 핸들러에게 임시 테이블을 만들라고 요청</li>\n<li>실행 엔진이 WHERE 절에 일치하는 레코드를 읽어오라고 핸들러에게 요청</li>\n<li>읽어온 레코드들을 임시 테이블에 저장하도록 핸들러에게 요청</li>\n<li>임시 테이블에서 필요한 방식으로 데이터를 읽어오라고 핸들러에게 요청</li>\n<li>실행엔진은 최종 결과를 사용자나 다른 모듈에게 넘김</li>\n</ol>\n<p>옵티마이저에 의해 만들어진 계획대로 핸들러에게 요청해서 받은 결과를 다른 핸들러에게 요청하여 연결하는 역할을 한다.</p>\n<ol>\n<li><strong>핸들러(스토리지 엔진)</strong></li>\n</ol>\n<p>실행 엔진의 요청에 따라서 데이터를 디스크로 저장하고 디스크로 읽어온다. 핸들러는 스토리지 엔진을 의미한다.</p>\n<br>\n<h3 id=\"쿼리-캐시\" style=\"position:relative;\"><a href=\"#%EC%BF%BC%EB%A6%AC-%EC%BA%90%EC%8B%9C\" aria-label=\"쿼리 캐시 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>쿼리 캐시</h3>\n<p>빠른 응답을 필요로 하는 웹 기반 프로그램에서 중요하다. SQL 실행 결과를 메모리에 캐시하고 동일한 SQL쿼리가 실행되면 테이블을 읽지 않고 동일한 결과를 즉시 반환한다.</p>\n<p>하지만 테이블의 데이터가 변경되면 그 결과가 바뀌므로 관련 캐시는 모두 삭제해야 하는데 이것이 동시 처리 성능 저하를 유발한다. 또한 많은 버그의 원인이 되기도 하였다.</p>\n<p>따라서 MySQL8.0부터는 쿼리 캐시가 완전히 제거되었다.</p>\n<br>\n<h3 id=\"스레드-풀\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%EB%A0%88%EB%93%9C-%ED%92%80\" aria-label=\"스레드 풀 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스레드 풀</h3>\n<p>커뮤니티 에디션에서는 지원하지 않지만 엔터프라이즈 에디션에서는 스레드 풀(Thread pool) 기능을 제공한다. 이 책에서는 Percona Server 스레드 풀을 기반으로 설명한다.</p>\n<p>스레드 풀의 목적은 사용자의 요청마다 생성되는 스레드 개수를 줄여 동시 요청수가 많아도 제한된 개수의 스레드 처리만 집중할 수 있도록 하는 것이다. 매우 성능이 향상될 것 같지만 실제로 눈에 띄는 성능 향상을 보여주는 경우는 많이 없다. 제한된 수의 스레드를 CPU가 잘 처리할 수 있도록 하는 기능인데 스케줄링 과정에서 CPU 자원이 잘 확보되지 못하면 쿼리 처리가 더 느려진다. 이것이 잘 처리되도록 유도한다면 CPU 프로세서 친화도도 높이고 운영체제 입장에서 컨텍스트 스위치도 줄여서 오버헤드를 줄일 수 있다.</p>\n<p>Percona Server와 같은 경우 기본적으로 CPU 코어 개수만큼 스레드를 생성하여 사용한다. (그래야 CPU 프로세서 친화도를 높일 수 있다) 요청이 들어왔을 때 스레드 풀이 처리중인 작업이 있다면 <code class=\"language-text\">thread_pool_oversubscribe</code> 변수 만큼 추가로 스레드를 받아드려서 처리한다. 만약에 이 값이 너무 크면 스레드가 많아지고 스케줄링을 해야해서 스레드 풀이 비효율적으로 작동할 수 있다.</p>\n<p>만약에 모든 스레드가 일을 처리하고 있다면 새로운 worker thread를 추가할지 기다릴지 결정할 수 있다. 이때는 <code class=\"language-text\">thread_pool_stall_limit</code> 만큼 기다렸다가 그래도 작업이 끝나지 않으면 새로운 스레드를 추가하여 작업을 처리한다. 하지만 여전히 <code class=\"language-text\">thread_pool_max_threads</code> 를 넘을수는 없다.</p>\n<p>Perconam Server는 선순위 큐와 후순위 큐를 사용하여 먼저 처리할 수 있는 트랜잭션이나 쿼리를 우선적으로 처리하여 잠금 경합을 낮추고 전체적인 성능을 향상시키도록 하는 기능을 제공한다.</p>\n<br>\n<h3 id=\"트랜잭션-지원-메타데이터\" style=\"position:relative;\"><a href=\"#%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EC%A7%80%EC%9B%90-%EB%A9%94%ED%83%80%EB%8D%B0%EC%9D%B4%ED%84%B0\" aria-label=\"트랜잭션 지원 메타데이터 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>트랜잭션 지원 메타데이터</h3>\n<p>우선 데이터베이스 서버에서 테이블 구조 정보나 스토어드 프로그램 등의 정보를 데이터 딕셔너리 혹은 메타데이터라고 한다. 이전에는 이것을 파일 기반의 메타데이터로 저장했다. 이 데이터 생성 및 변경 작업을 트랜잭션을 지원하지 않기 때문에 중간에 에러가 나거나 종료가 되면일관되지 않은 상태로 남아있어 문제가 생기게 된다.</p>\n<p>따라서 MySQL8.0 부터는 테이블의 구조 정보나 스토어드 프로그램의 코드는 모두 InnoDB의 테이블에 저장하도록 했다. MySQL 서버가 실행하는데 기본적으로 필요한 테이블들을 시스템 테이블이라고 하며 사용자 인증 및 권한 등과 관련된 테이블이 있다. 이런 시스템 테이블과 데이터 딕셔너리 정보를 mysql DB에 저장하고 그것을 mysql.ibd 라는 테이블스페이스에 저장하므로 이것은 각별히 주의하여 관리해야 한다.</p>\n<p>이제 트랜잭션 기반의 InnoDB에 저장이 되므로 중간에 실패를 하면 트랜잭션의 원자성 특성에 따라서 완전히 성공하거나 실패한 것은 완전히 정리된다.</p>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#-intro\">💡 Intro</a></p>\n</li>\n<li>\n<p><a href=\"#-mysql-%EC%84%9C%EB%B2%84%EC%9D%98-%EA%B5%AC%EC%A1%B0\">🌩 MySQL 서버의 구조</a></p>\n</li>\n<li>\n<p><a href=\"#-mysql-%EC%97%94%EC%A7%84-%EC%95%84%ED%82%A4%ED%85%8D%EC%B3%90\">🌩 MySQL 엔진 아키텍쳐</a></p>\n<ul>\n<li><a href=\"#mysql-%EC%A0%84%EC%B2%B4%EA%B5%AC%EC%A1%B0\">MySQL 전체구조</a></li>\n<li><a href=\"#mysql-%EC%8A%A4%EB%A0%88%EB%94%A9-%EA%B5%AC%EC%A1%B0\">MySQL 스레딩 구조</a></li>\n<li><a href=\"#%EB%A9%94%EB%AA%A8%EB%A6%AC-%ED%95%A0%EB%8B%B9-%EB%B0%8F-%EC%82%AC%EC%9A%A9-%EA%B5%AC%EC%A1%B0\">메모리 할당 및 사용 구조</a></li>\n<li><a href=\"#%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80-%EC%97%94%EC%A7%84-%EB%AA%A8%EB%8D%B8\">플러그인 스토리지 엔진 모델</a></li>\n<li><a href=\"#%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8\">컴포넌트</a></li>\n<li><a href=\"#%EC%BF%BC%EB%A6%AC-%EC%8B%A4%ED%96%89-%EA%B5%AC%EC%A1%B0\">쿼리 실행 구조</a></li>\n<li><a href=\"#%EC%BF%BC%EB%A6%AC-%EC%BA%90%EC%8B%9C\">쿼리 캐시</a></li>\n<li><a href=\"#%EC%8A%A4%EB%A0%88%EB%93%9C-%ED%92%80\">스레드 풀</a></li>\n<li><a href=\"#%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EC%A7%80%EC%9B%90-%EB%A9%94%ED%83%80%EB%8D%B0%EC%9D%B4%ED%84%B0\">트랜잭션 지원 메타데이터</a></li>\n</ul>\n</li>\n</ul>\n</div>","excerpt":"다음 글은 Real MySQL 스터디를 진행하면서 정리한 4.1장 내용입니다. 🙌 💡 Intro 프로젝트를 진행해보니 서비스의 대부분의 병목은 데이터베이스에서 발생한다는 것을 알 수 있었다. DBA가 아니더라도 기본적으로 파생된 쿼리가 어느 과정을 거쳐서 처리되는지, 성능을 좌우하는 시스템 변수들은 어떠한 것들이 있는지 아는 것이 매우 중요하다고 생각한다. MySQL 엔진은 데이터베이스의 뇌의 역할을 한다. 기본적은 서버 구조와 MySQL 엔진과 스토리지 엔진의 차이점 및 담당 부분을 이해해보자. 🌩 MySQL 서버의 구조 머리 역할을 하는 MySQL 엔진과 손발 역할을 하는 스토리지 엔진(InnoDB, MyISAM)이 있다. 스토리지 엔진은 핸들러 API를 만족하면 직접 구현하여 추가해서 사용할 수 있다. 🌩 MySQL 엔진 아키텍쳐 MySQL 전체구조 MySQL 엔진 먼저 MySQL 서버는 대부분의 상용 언어에서 지원할 수 있으며 MySQL 서버의 커넥션 핸들러에서 커넥션을 관…","frontmatter":{"date":"December 21, 2021","title":"[Real MySQL] MySQL 엔진 아키텍쳐","categories":"책 데이터베이스","author":"코다","emoji":"🗃"},"fields":{"slug":"/realmysql-1/"}},"next":{"id":"73dec607-9cfc-5427-8d94-f52427f33c4f","html":"<blockquote>\n<p>이 글은 몇몇 크루들과 이펙티브 자바 스터디를 하며 정리한 내용입니다. 🙌</p>\n</blockquote>\n<h2 id=\"-아이템-11-equals를-재정의하려거든-hashcode도-재정의하라\" style=\"position:relative;\"><a href=\"#-%EC%95%84%EC%9D%B4%ED%85%9C-11-equals%EB%A5%BC-%EC%9E%AC%EC%A0%95%EC%9D%98%ED%95%98%EB%A0%A4%EA%B1%B0%EB%93%A0-hashcode%EB%8F%84-%EC%9E%AC%EC%A0%95%EC%9D%98%ED%95%98%EB%9D%BC\" aria-label=\" 아이템 11 equals를 재정의하려거든 hashcode도 재정의하라 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 [아이템 11] equals를 재정의하려거든 hashCode도 재정의하라</h2>\n<p><code class=\"language-text\">equals</code>와 함께 <code class=\"language-text\">hashCode</code>도 재정의하지 않으면 <code class=\"language-text\">HashMap</code>이나 <code class=\"language-text\">HashSet</code>의 원소로 사용할 때 일관성이 무너진다.</p>\n<p>Object 명세에 따르면 다음 규약이 있다.</p>\n<blockquote>\n<p>eqauls(Object)가 두 객체를 같다고 판단하면, 두 객체의 hashCode는 똑같은 값을 반환해야 한다.</p>\n</blockquote>\n<p>다시 말해서 논리적으로 같은 객체는 같은 해시코드를 반환해야 한다는 것이다. 해시코드가 같지 않으면 다음 코드에서 일관성이 깨진다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">Map</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">PhoneNumber</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> m <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashMap</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nm<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">PhoneNumber</span><span class=\"token punctuation\">(</span><span class=\"token number\">707</span><span class=\"token punctuation\">,</span> <span class=\"token number\">867</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5309</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"사용자\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token class-name\">String</span> result <span class=\"token operator\">=</span> m<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">PhoneNumber</span><span class=\"token punctuation\">(</span><span class=\"token number\">707</span><span class=\"token punctuation\">,</span> <span class=\"token number\">867</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5309</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// result.equals(\"사용자\") != false 이다.</span>\n</code></pre></div>\n<br>\n<h3 id=\"좋은-hashcode를-작성하기\" style=\"position:relative;\"><a href=\"#%EC%A2%8B%EC%9D%80-hashcode%EB%A5%BC-%EC%9E%91%EC%84%B1%ED%95%98%EA%B8%B0\" aria-label=\"좋은 hashcode를 작성하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>좋은 hashCode를 작성하기</h3>\n<ol>\n<li>\n<p>hashCode의 로컬 int 변수 result를 첫번째 핵심 필드의 해시코드로 초기화 한다. (여기서 해시코드는 다음 2.a 단계대로 계산한다.)</p>\n</li>\n<li>\n<p>다음 핵심 필드 들에 대해서 다음과 같이 해시코드를 계산하고 result 필드를 갱신한다.</p>\n<ol>\n<li>\n<p>기본 타입 필드라면 Type.hashCode(f)를 수행한다. Type은 해당 기본 타입의 박싱 클래스다.</p>\n<p>만일 참조 클래스라면 hashCode를 재귀적으로 호출할 수 있으니 이 필드의 표준형을 만들어서 해당 표준형(canonical representation)의 hashCode를 호출하고 null 이라면 0을 사용한다.</p>\n<p>필드가 배열이면 각각의 원소를 별도의 필드로 다루어 해시코드를 계산한다. Arrays.hashCode를 사용할 수 있다.</p>\n</li>\n<li>\n<p>a에서 계산된 해시코드로 result를 갱신한다.</p>\n<p><code class=\"language-text\">result = 31 * result + c;</code> 이다.</p>\n</li>\n</ol>\n</li>\n<li>\n<p>result를 반환한다.</p>\n</li>\n</ol>\n<ul>\n<li>참고로 파생 필드는 제외해도 된다.</li>\n<li>equals에서 사용되지 않는 필드는 반드시 제외한다.</li>\n<li>단계 b에서 31 * result를 하는 순서에 따라서 result 값이 달라지므로 해시 효과를 높여준다. 그렇지 않으면 anagram인 경우 해시코드가 같아지면서 성능이 저하된다. (O(n)이 된다) 31은 홀수이면서 소수이기 때문에 적합하다. (그 이유는 책에 더 자세히 나와있다)</li>\n</ul>\n<p>이렇게 완성된 hashCode의 예시를 보면 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Override</span> <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">hashCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">int</span> result <span class=\"token operator\">=</span> <span class=\"token class-name\">Short</span><span class=\"token punctuation\">.</span><span class=\"token function\">hashCode</span><span class=\"token punctuation\">(</span>areaCode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\tresult <span class=\"token operator\">=</span> <span class=\"token number\">31</span> <span class=\"token operator\">*</span> result <span class=\"token operator\">+</span> <span class=\"token class-name\">Short</span><span class=\"token punctuation\">.</span><span class=\"token function\">hashCode</span><span class=\"token punctuation\">(</span>prefix<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\tresult <span class=\"token operator\">=</span> <span class=\"token number\">31</span> <span class=\"token operator\">*</span> result <span class=\"token operator\">+</span> <span class=\"token class-name\">Short</span><span class=\"token punctuation\">.</span><span class=\"token function\">hashCode</span><span class=\"token punctuation\">(</span>lineNum<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><strong>Objects 클래스의 정적 메서드 활용하기</strong></p>\n<ul>\n<li>임의 개수의 객체를 받아서 해시코드를 계산해주는 정적 메서드 hash를 제공한다.</li>\n<li>하지만 속도는 다수 느리다. 입력 인수를 위한 배열이 만들어지고 박싱/언박싱이 일어나기 때문에 성능이 민감한 요소라면 사용하지 않는 것이 좋다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Override</span> \n<span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">hashCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token class-name\">Objects</span><span class=\"token punctuation\">.</span><span class=\"token function\">hash</span><span class=\"token punctuation\">(</span>lineNum<span class=\"token punctuation\">,</span> prefix<span class=\"token punctuation\">,</span> areaCode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>클래스가 불변이고 해시코드 계산 비용이 크다면 캐싱 방식을 고려하는 것이 좋다.</li>\n<li>hashCode를 지연초기화 하는 것도 하나의 방법인데 이때는 스레드 안전성을 고려하여 구현해야 한다.</li>\n<li>성능을 높이기 위해 핵심 필드를 생략해서 해시코드를 계산하면 안된다.</li>\n<li>hashCode의 생성 규칙을 API 사용자가 자세히 알 필요가 없다. 클라이언트가 이 값에 의지하지 않게 되고 이후에 계산 방식을 바꿀 수도 있다.</li>\n</ul>\n<br>\n<h2 id=\"-아이템-12-tostring을-항상-재정의하라\" style=\"position:relative;\"><a href=\"#-%EC%95%84%EC%9D%B4%ED%85%9C-12-tostring%EC%9D%84-%ED%95%AD%EC%83%81-%EC%9E%AC%EC%A0%95%EC%9D%98%ED%95%98%EB%9D%BC\" aria-label=\" 아이템 12 tostring을 항상 재정의하라 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 [아이템 12] toString을 항상 재정의하라</h2>\n<p>Object에서 기본적으로 제공하는 <code class=\"language-text\">toString</code>은 <code class=\"language-text\">클래스명@16진수_해시코드</code> 를 주로 반환하여 사용자가 필요한 형태로 반환하는 경우가 거의 없다. <code class=\"language-text\">toString</code> 은 <strong>간결하며 사용자가 읽기 쉬운 형태의 유익한 정보</strong>를 반환해야 한다. 따라서 이 메서드를 항상 재정의 하는 것이 필요하다.</p>\n<p><code class=\"language-text\">toString</code>을 잘 구현한다면 <code class=\"language-text\">println</code>, <code class=\"language-text\">printf</code>, <code class=\"language-text\">+ 연산자</code>, <code class=\"language-text\">assert</code> 등에서 유용하게 사용되며 시스템 디버깅이 훨씬 용의해진다. 또한 직접 호출하지 않아도 오류 메세지 로깅 시 매우 읽기 좋은 유용한 정보를 표시한다.</p>\n<p><code class=\"language-text\">toString</code>은 해당 객체가 가진 주요 정보를 모두 반환하는 것이 좋다. 하지만 객체가 너무 크다면 표현하기 무리가 있다. 이럴 경우에는 요약 정보를 담는 것이 좋다. <strong>어쨋든 자기 스스로를 굉장히 잘 표현한 문자열이어야 한다.</strong></p>\n<p>toString을 구현할 때 반환값의 형식을 문서화 할지 정하는데, 값 클래스라면 문서화 하는 것이 좋다. 그대로 입출력에서 사용하고 CSV 파일처럼 사람이 읽을 수 있는 데이터 객체로 저장될 수 있다. 이 경우 문자열과 객체를 상호 전환할 수 있는 생성자나 정적 팩토리 메서드를 제공해주는 것이 좋다.</p>\n<p>포맷을 명시하는 것의 단점으로는 그 포맷이 평생 쓰이게 된다. 따라서 다른 포맷을 적용하고 싶다면 해당 포맷에 맞추어서 파싱하고 새로운 객체를 만들어서 데이터를 저장하는 코드를 작성해야 한다. 그 다음에 포맷이 바뀌게 된다면 굉장히 번거로워진다.</p>\n<p>또한 toString에서 반환하는 정보에 대한 접근자를 각각 제공하는 것이 좋다. 그렇지 않다면 사용자는 toString을 파싱해서 사용할 수밖에 없어진다.</p>\n<p>정적 유틸리티 클래스는 toString을 제공할 필요가 없으며 열거 타입도 마찬가지이다.</p>\n<p>추상 클래스같은 경우 하위 클래스에서 공통적으로 사용해야할 문자열 표현이 있다면 추상 클래스에서 toString을 재정의해야한다.</p>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#-%EC%95%84%EC%9D%B4%ED%85%9C-11-equals%EB%A5%BC-%EC%9E%AC%EC%A0%95%EC%9D%98%ED%95%98%EB%A0%A4%EA%B1%B0%EB%93%A0-hashcode%EB%8F%84-%EC%9E%AC%EC%A0%95%EC%9D%98%ED%95%98%EB%9D%BC\">🌩 [아이템 11] equals를 재정의하려거든 hashCode도 재정의하라</a></p>\n<ul>\n<li><a href=\"#%EC%A2%8B%EC%9D%80-hashcode%EB%A5%BC-%EC%9E%91%EC%84%B1%ED%95%98%EA%B8%B0\">좋은 hashCode를 작성하기</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-%EC%95%84%EC%9D%B4%ED%85%9C-12-tostring%EC%9D%84-%ED%95%AD%EC%83%81-%EC%9E%AC%EC%A0%95%EC%9D%98%ED%95%98%EB%9D%BC\">🌩 [아이템 12] toString을 항상 재정의하라</a></p>\n</li>\n</ul>\n</div>","frontmatter":{"date":"December 19, 2021","title":"이펙티브 자바 - 아이템 11 & 12","categories":"책 자바","author":"코다","emoji":"🐡"},"fields":{"slug":"/effective-java-11-12/"}},"prev":null,"site":{"siteMetadata":{"siteUrl":"https://yjksw.github.io","comments":{"utterances":{"repo":"yjksw/yjksw.github.io"}}}}},"pageContext":{"slug":"/realmysql-1/","nextSlug":"/effective-java-11-12/","prevSlug":""}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}
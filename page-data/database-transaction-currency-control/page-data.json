{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/database-transaction-currency-control/",
    "result": {"data":{"cur":{"id":"0574f453-d5ef-573e-bcb2-ee85bc19c34e","html":"<h2 id=\"동시성-문제-발생-가능-상황\" style=\"position:relative;\"><a href=\"#%EB%8F%99%EC%8B%9C%EC%84%B1-%EB%AC%B8%EC%A0%9C-%EB%B0%9C%EC%83%9D-%EA%B0%80%EB%8A%A5-%EC%83%81%ED%99%A9\" aria-label=\"동시성 문제 발생 가능 상황 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>동시성 문제 발생 가능 상황</h2>\n<p>두개의 트랜잭션이 모두 읽는 연산을 하는 경우 문제가 되지 않는다.</p>\n<ul>\n<li>하나의 트랜잭션은 read, 하나는 write인 경우 (<strong>Isolation</strong>으로 해결)\n<ul>\n<li>\n<p><strong>Dirty Read</strong></p>\n<p><strong>상황</strong>: 트랜잭션1이 write 할 때 트랜잭션2가 update된 데이터를 읽었지만 트랜잭션1이 rollback 되었을 때 발생 <br></p>\n<p><strong>문제</strong>: 트랜잭션2가 무효된 데이터를 읽었음 <br></p>\n</li>\n<li>\n<p><strong>Non-repeatable Read</strong></p>\n<p><strong>상황</strong>: 트랜잭션1이 데이터를 read하고, 트랜잭션2가 데이터를 write 한 후, 트랜잭션1이 다시 동일한 데이터를 read 할 경우에 발생 <br></p>\n<p><strong>문제</strong>: 트랜잭션이 1이 동일한 read를 했음에도 불구하고 바뀐 데이터를 읽음 <br></p>\n</li>\n<li>\n<p><strong>Phantom Read</strong></p>\n<p><strong>상황</strong>: 트랜잭션1이 데이터(범위)를 read하고, 트랜잭션 2가 데이터를 추가(insert) 했는데, 트랜잭션1이 다시 데이터를 read한 경우 <br></p>\n<p><strong>문제</strong>: 동일한 read를 실행하였는데, 이전에 없었던 값이 추가됨 <br></p>\n</li>\n</ul>\n</li>\n<li>두개의 트랜잭션이 모두 wrtie인 경우 (<strong>Currency Control</strong>로 해결)\n<ul>\n<li>\n<p><strong>Lost Update</strong></p>\n<p><strong>상황</strong>: 두개의 트랜잭션이 한 개의 데이터를 동시에 update 할 때 발생 <br></p>\n<p><strong>문제</strong>: 하나의 트랜잭션의 내용을 다른 트랜잭션이 덮어씀으로 이전에 update 한 내용이 손실됨 <br></p>\n</li>\n<li>\n<p><strong>Inconsistency(or Unrecoverability)</strong></p>\n<p><strong>상황</strong>: 한 트랜잭션(T1)이 두개의 일관된 값을 읽어야하는데 다른 트랜잭션(T2)이 그 사이에 실행될 때 발생 <br></p>\n<p><strong>문제</strong>: <code class=\"language-text\">T1</code>이 두개의 값 <code class=\"language-text\">X</code>, <code class=\"language-text\">Y</code>를 읽어 수정할 때, <code class=\"language-text\">T1</code>이 <code class=\"language-text\">X</code>만 읽어서 수정한 상태에서 <code class=\"language-text\">T2</code>가 <code class=\"language-text\">X</code>와 <code class=\"language-text\">Y</code>를 수정하고 이후에 <code class=\"language-text\">T1</code>이 <code class=\"language-text\">Y</code>를 읽어 수정함. 이때 <code class=\"language-text\">T1</code>의 입장에서 하나는 갱신 이전의 값, 또 하나는 갱신 이후의 값을 읽어서 데이터가 불일치한 모순이 일어남. <br></p>\n</li>\n<li>\n<p><strong>Cascading Rollback</strong></p>\n<p><strong>상황</strong>: 한 트랜잭션(T1)이 두개의 값을 읽고 수정하는 사이에 다른 트랜잭션(T2)이 완료되었지만 T1이 rollback 되어야 할 때 발생<br></p>\n<p><strong>문제</strong>: <code class=\"language-text\">T1</code>이 두개의 값 <code class=\"language-text\">X</code>, <code class=\"language-text\">Y</code>를 읽어서 수정할 때, <code class=\"language-text\">T1</code>이 <code class=\"language-text\">X</code>를 수정한 상태에서 <code class=\"language-text\">T2</code>가 <code class=\"language-text\">X</code>를 수정하고 해당 트랜잭션을 완료함. 이후 <code class=\"language-text\">T1</code>에서 오류가 발생해 rollback이 되어야하는 상황에서 <code class=\"language-text\">T2</code>는 이미 완료되었으므로 <code class=\"language-text\">X</code> 값에 대한 rollback이 되지 못하여 문제가 발생함. <br></p>\n</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"트랜잭션-스케줄\" style=\"position:relative;\"><a href=\"#%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EC%8A%A4%EC%BC%80%EC%A4%84\" aria-label=\"트랜잭션 스케줄 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>트랜잭션 스케줄</h2>\n<p>위 문제를 해결하기 위해서 트랜잭션 스케줄을 통해 연산들의 실행 순서를 제어하여 데이터에 오류가 없도록 해야한다.</p>\n<ol>\n<li>\n<p>Serial Schedule 직렬 스케줄</p>\n<p>모든 트랜잭션이 순차적으로 실행</p>\n</li>\n<li>\n<p>Nonsercial Schedule 비직렬 스케줄</p>\n<p>트랜잭션이 상관없이 병행하여 실행</p>\n</li>\n<li>\n<p>Serializable Schedule 직렬 가능 스케줄</p>\n<p>서로 영향을 주지 않는 스케줄의 경우 병행 실행하고, 나머지는 실행 순서를 제어하여 실행</p>\n</li>\n</ol>\n<p>직렬 스케줄의 경우 오류가 생기지 않도록 보장할 수는 있지만, 효율이 떨어진다는 단점이 있다. 따라서 트랜잭션을 최대한 직렬 가능한 스케줄로 만드는 것이 중요하고 <strong>Locking</strong> 기법을 통해서 트랜잭션 실행 순서를 제어해 직렬 가능한 스케줄로 만들어 데이터에 생길 수 있는 오류를 제어한다. <br></p>\n<p>예를 들어, 두개의 트랜잭션이 모두 READ 연산을 한다면 연산 순서가 중요하지 않으므로 병행 실행한다. <br></p>\n<p>또 두개의 트랜잭션이 다른 데이터에 접근한다면 연산 순서가 중요하지 않으므로 병행 실행한다. <br></p>\n<p>만일 한 데이터에 대해서 읽고 쓰는 작업이 한꺼번에 발생한다면 실행순서가 중요하므로 Lock을 통해서 그 순서를 제어한다. <br></p>\n<br>\n<h2 id=\"locking-기법\" style=\"position:relative;\"><a href=\"#locking-%EA%B8%B0%EB%B2%95\" aria-label=\"locking 기법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Locking 기법</h2>\n<p>여러 트랜잭션이 동일한 데이터에 대해서 병행 접근을 하지 못하도록 제어해서 데이터간 문제가 발생하지 않도록 하는 기법</p>\n<ul>\n<li>\n<p>Shared-lock 공유락</p>\n<p>읽기를 할 때 거는 lock <br></p>\n<p>read 트랜잭션은 서로 영향을 주지 않으므로 shared-lock이 걸린 상태에서 추가 shared-lock을 걸 수 있음 <br></p>\n<p>read 트랜잭션 중 쓰기가 발생할 경우 데이터가 손상되어 문제가 발생하므로 추가 exclusive-lock은 걸 수 없음 <br></p>\n</li>\n<li>\n<p>Exclusive-lock 베타락</p>\n<p>읽고 쓰기를 할 때 거는 lock <br></p>\n<p>write 트랜잭션은 읽거나 쓰는 트랜잭션 모두에게 영향을 주기 때문에 exclusive-lock이 걸린 상태에서는 다른 lock을 걸 수 없음 <br></p>\n</li>\n</ul>\n<h3 id=\"2단계-로킹-규약-2plp\" style=\"position:relative;\"><a href=\"#2%EB%8B%A8%EA%B3%84-%EB%A1%9C%ED%82%B9-%EA%B7%9C%EC%95%BD-2plp\" aria-label=\"2단계 로킹 규약 2plp permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2단계 로킹 규약 2PLP</h3>\n<p>lock을 걸고 해제할 때 제한을 두어서 두 트랜잭션이 동시 실행되면서 생기는 데이터 일관성이 깨지는 현상을 방지하는 것이다. 로킹 단계를 2가지로 구분 지어서, 각 단계에 다른 제한을 두어 트랜잭션 동시 실행으로 발생할만한 데이터 오류를 방지한다.</p>\n<ul>\n<li>\n<p>Growing Phase 확장 단계</p>\n<p>해당 트랜잭션이 새로운 Lock 연산은 가능하나 unlock 연산을 가능하지 않은 상태</p>\n</li>\n<li>\n<p>Shrinking Phase 축소 단계</p>\n<p>해당 트랜잭션이 unlock 연산만 가능하고 lock 연산은 가능하지 않은 상태</p>\n</li>\n</ul>\n<p>하지만 2PLP을 준수하므로 <strong>deadlock</strong>이 발생할 여지가 있다. <br></p>\n<p>→ 2단계 로킹 규약을 적용하지 않아서 데이터의 일관성이 깨진 경우 <br></p>\n<p align=\"center\"><img width=\"85%\" src=\"https://user-images.githubusercontent.com/63405904/135496848-c9c42362-63c5-493f-a2e9-fcd05f5cf6c6.png\"></p>\n<p>→ 2단계 로킹 기법을 사용하여 일관성 문제 해결한 경우 <br></p>\n<p align=\"center\"><img width=\"85%\" src=\"https://user-images.githubusercontent.com/63405904/135496984-e425dd70-3f11-4718-a42e-28513c3452bb.png\"></p>\n<h3 id=\"deadlock-데드락-교착상태\" style=\"position:relative;\"><a href=\"#deadlock-%EB%8D%B0%EB%93%9C%EB%9D%BD-%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9C\" aria-label=\"deadlock 데드락 교착상태 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Deadlock 데드락 (교착상태)</h3>\n<p>두개의 트랜잭션이 각자의 데이터에 lock을 걸어놓고 상대의 데이터에 요청을 하므로 무한 대기 상태에 빠지게 되는 문제</p>\n<br>\n<h2 id=\"트랜잭션-isolation-level\" style=\"position:relative;\"><a href=\"#%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-isolation-level\" aria-label=\"트랜잭션 isolation level permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>트랜잭션 Isolation Level</h2>\n<ul>\n<li>\n<p><strong>READ UNCOMMITTED (LEVEL 0)</strong></p>\n<p>데이터를 읽을 때 shared-lock을 걸지 않고, write 작업 시 exclusive-lock만 거는 것(갱신손실문제 방지) <br></p>\n<p>다른 트랜잭션에 shared-lock/exclusive-lock이 걸렸더라도 데이터를 대기하지 않고 읽는 것<br></p>\n<p>따라서 Dirty read, non-repeatable read, phantom read 모두 방지할 수 없다.<br></p>\n</li>\n<li>\n<p><strong>READ COMMITED (LEVEL 1)</strong></p>\n<p>데이터를 읽을 때 shared-lock을 걸지만, 트랜잭션이 끝나기 전에도 unlock 가능<br></p>\n<p>다른 트랜잭션에 shared-lock이 걸렸다면 데이터를 읽지만, exclusive-lock이 걸린 경우에는 읽지 못함<br></p>\n<p>Dirty read 방지 가능, non-repeatable read, phantom read 방지 불가능<br></p>\n</li>\n<li>\n<p><strong>REPEATABLE READ (LEVEL 2)</strong></p>\n<p>본 데이터에 설정된 shared-lock과 exclusive-lock을 트랜잭션 종료시까지 유지<br></p>\n<p>트랜잭션이 완료될 때까지 SELECT문이 사용하는 모든 데이터에 대해서 shared-lock이 걸린다. 따라서 update가 불가능하지만, insert에 대해서는 다른 제약이 없다.<br></p>\n<p>다른 트랜잭션이 공유한 공유락은 읽고, 배타락은 읽지 않음<br></p>\n<p>다른 isolation level에 비해서 동시성이 낮아 잘 사용하지 않는 것을 추천<br></p>\n<p>Dirty read, non-repeatable read 방지, phantom read 방지 불가능<br></p>\n</li>\n<li>\n<p><strong>SERIALIZABLE (LEVEL 3)</strong></p>\n<p>데이터의 집합 범위에 잠금을 설정함<br></p>\n<p>다른 사용자가 데이터를 update 혹은 insert 할 때 모두 트랜잭션을 격리함<br></p>\n<p>트랜잭션이 완료될 때까지 SELECT문이 사용하는 모든 데이터에 대해서 shared-lock이 걸린다.<br></p>\n<p><strong>인덱스에 공유락을 설정</strong>한다. 따라서 다른 트랜잭션의 insert가 불가능<br></p>\n<p>Dirty read, non-repeatable read, phantom read 방지 <br></p>\n</li>\n</ul>\n<br>\n<br>\n<p><strong>[참고링크]</strong></p>\n<ul>\n<li><a href=\"https://mangkyu.tistory.com/30\">https://mangkyu.tistory.com/30</a></li>\n<li><a href=\"https://medium.com/pocs/%EB%8F%99%EC%8B%9C%EC%84%B1-%EC%A0%9C%EC%96%B4-%EA%B8%B0%EB%B2%95-%EC%9E%A0%EA%B8%88-locking-%EA%B8%B0%EB%B2%95-319bd0e6a68a\">https://medium.com/pocs/동시성-제어-기법-잠금-locking-기법-319bd0e6a68a</a></li>\n<li><a href=\"https://goodmilktea.tistory.com/62\">https://goodmilktea.tistory.com/62</a>## 동시성 문제 발생 가능 상황</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#%EB%8F%99%EC%8B%9C%EC%84%B1-%EB%AC%B8%EC%A0%9C-%EB%B0%9C%EC%83%9D-%EA%B0%80%EB%8A%A5-%EC%83%81%ED%99%A9\">동시성 문제 발생 가능 상황</a></p>\n</li>\n<li>\n<p><a href=\"#%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EC%8A%A4%EC%BC%80%EC%A4%84\">트랜잭션 스케줄</a></p>\n</li>\n<li>\n<p><a href=\"#locking-%EA%B8%B0%EB%B2%95\">Locking 기법</a></p>\n<ul>\n<li><a href=\"#2%EB%8B%A8%EA%B3%84-%EB%A1%9C%ED%82%B9-%EA%B7%9C%EC%95%BD-2plp\">2단계 로킹 규약 2PLP</a></li>\n<li><a href=\"#deadlock-%EB%8D%B0%EB%93%9C%EB%9D%BD-%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9C\">Deadlock 데드락 (교착상태)</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-isolation-level\">트랜잭션 Isolation Level</a></p>\n</li>\n</ul>\n</div>","excerpt":"동시성 문제 발생 가능 상황 두개의 트랜잭션이 모두 읽는 연산을 하는 경우 문제가 되지 않는다. 하나의 트랜잭션은 read, 하나는 write인 경우 (Isolation으로 해결) Dirty Read 상황: 트랜잭션1이 write 할 때 트랜잭션2가 update된 데이터를 읽었지만 트랜잭션1이 rollback 되었을 때 발생  문제: 트랜잭션2가 무효된 데이터를 읽었음  Non-repeatable Read 상황: 트랜잭션1이 데이터를 read하고, 트랜잭션2가 데이터를 write 한 후, 트랜잭션1이 다시 동일한 데이터를 read 할 경우에 발생  문제: 트랜잭션이 1이 동일한 read를 했음에도 불구하고 바뀐 데이터를 읽음  Phantom Read 상황: 트랜잭션1이 데이터(범위)를 read하고, 트랜잭션 2가 데이터를 추가(insert) 했는데, 트랜잭션1이 다시 데이터를 read한 경우  문제: 동일한 read를 실행하였는데, 이전에 없었던 값이 추가됨  두개의 트랜잭션이 모…","frontmatter":{"date":"July 01, 2021","title":"Transaction의 동시성 제어(Currency Control)","categories":"데이터베이스","author":"코다","emoji":"💾"},"fields":{"slug":"/database-transaction-currency-control/"}},"next":{"id":"156033a5-3d3b-51d5-abc6-61b8996690bf","html":"<p>다음 글은 [링크](Understanding Spring Web Application Architecture: The Classic Way)에 기술되어 있는 스프링 웹 어플리케이션 구조에 대한 글을 번역 한 내용이다.</p>\n<h2 id=\"좋은-architecture를-위한-두-기둥\" style=\"position:relative;\"><a href=\"#%EC%A2%8B%EC%9D%80-architecture%EB%A5%BC-%EC%9C%84%ED%95%9C-%EB%91%90-%EA%B8%B0%EB%91%A5\" aria-label=\"좋은 architecture를 위한 두 기둥 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>좋은 architecture를 위한 두 기둥</h2>\n<h3 id=\"the-socseparation-of-concerns-원칙\" style=\"position:relative;\"><a href=\"#the-socseparation-of-concerns-%EC%9B%90%EC%B9%99\" aria-label=\"the socseparation of concerns 원칙 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>The SoC(Separation of Concerns) 원칙</h3>\n<blockquote>\n<p>A design principle for separating a computer program into distinct sections, which each section addresses a separate concern. <br> <a href=\"%5Bhttps://en.wikipedia.org/wiki/Separation_of_concerns%5D(https://en.wikipedia.org/wiki/Separation_of_concerns)\">출처</a></p>\n</blockquote>\n<p>SoC에서 신경써야 할 부분은 두가지이다.</p>\n<ol>\n<li>고려해야 할 <strong>concerns</strong>가 무엇인지</li>\n<li>어디서 해당 <strong>concern</strong>을 다루고 싶은지</li>\n</ol>\n<p>SoC를 준수하게 된다면 각각의 layer와 해당 layer의 책임에 대해서 자연스럽게 정의할 수 있도록 도와준다.</p>\n<h3 id=\"the-kisskeep-it-simple-stupid-원칙\" style=\"position:relative;\"><a href=\"#the-kisskeep-it-simple-stupid-%EC%9B%90%EC%B9%99\" aria-label=\"the kisskeep it simple stupid 원칙 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>The KISS(Keep It Simple Stupid) 원칙</h3>\n<blockquote>\n<p>Most systems work best if they are kept simple rather than made complicated; therefore simplicity should be a key goal in design and unnecessary complexity should be avoided. <br> <a href=\"%5Bhttp://en.wikipedia.org/wiki/KISS_principle%5D(http://en.wikipedia.org/wiki/KISS_principle)\">출처</a></p>\n</blockquote>\n<p>이 원칙은 각 레이어는 그만큼의 비용이 들고 복잡한 구조를 가진 어플리케이션은 그만큼의 높은 비용을 감수해야 한다는 것을 상기시켜준다.</p>\n<ul>\n<li>새로운 feature를 추가하는 경우 해당 정보를 여러 layer에 모두 전달해야 하기 때문에 과정이 오래 걸림</li>\n<li>지나치게 복잡한 구조를 가지고 있기 때문에 아무도 제대로 이해하고 있지 않아서 해당 어플리케이션의 유지보수가 어려움</li>\n</ul>\n<br>\n<h2 id=\"3-layers가-가장-적당하다\" style=\"position:relative;\"><a href=\"#3-layers%EA%B0%80-%EA%B0%80%EC%9E%A5-%EC%A0%81%EB%8B%B9%ED%95%98%EB%8B%A4\" aria-label=\"3 layers가 가장 적당하다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3 Layers가 가장 적당하다</h2>\n<p>웹 어플리케이션의 책임을 고려했을때 웹 어플리케이션 전체적으로 다음과 같은 concerns가 있다.</p>\n<ul>\n<li>사용자의 입력을 받아서 적당한 응답을 반환</li>\n<li>예외 처리를 하여 예외 상황시 적절한 에외 메세지를 반환</li>\n<li>트랜잭션 관리 전략을 가짐</li>\n<li>인가와 인증을 처리함</li>\n<li>어플리케이션의 비지니스 로직을 작성</li>\n<li>사용되는 데이터 저장소와 외부 리소스와의 커뮤니케이션 담당</li>\n</ul>\n<p>위 역할을 감당하기 위해서 다음 3가지 layer로 충분하다.</p>\n<ol>\n<li>\n<p><strong>The Web Layer</strong></p>\n<p>웹 어플리케이션의 최상단에 있는 layer이다. 사용자의 입력을 받아서 적정한 응답을 반환하는 역할을 맡는다. 이 레이어에서는 다른 레이어에서 발생한 예외들에 대한 핸들링을 처리해야한다. <br></p>\n<p>현재 레이어는 해당 어플리케이션의 입구이기 때문에 인증 및 인가를 담당하여 허가되지 않은 사용자에 대한 1차 방어를 해야한다.</p>\n</li>\n<li>\n<p><strong>The Service Layer</strong></p>\n<p>웹 레이어 다음에 위치한 레이어이다. 이 레이어는 트랜잭션 단위를 구분하고, application과 infrastructure 서비스를 모두 포함한다. <br></p>\n<p>여기서 <strong>application services</strong>는 서비스 레이어의 <strong>public API</strong>를 제공한다. 이 뜻은, 어플리케이션 서비스에서 처리하고하고자 하는 일들이 서비스 레이어의 <code class=\"language-text\">public</code> 메소드에서 처리된다는 것이다. 이 메소드 별로 트랜잭션 단위가 나뉘어지고 인증 및 인가 작업도 여기서 담당한다. <br></p>\n<p>서비스 레이어에서 <strong>infrastructure services</strong>는 파일 시스템, 데이터베이스, 이메일 서버 등등의 외부 리소스와 커뮤니케이션하기 때문에 “plumbing code” (배관 코드)라고 불리기도 한다. 이 메소드들은 하나 이상의 어플리케이션 서비스 코드에서 주로 활용된다.</p>\n</li>\n<li>\n<p><strong>The Repository Layer</strong></p>\n<p>웹 어플리케이션의 최하위에 위치해있는 레이어이다. 데이터 저장소와의 연결을 담당한다.</p>\n</li>\n</ol>\n<br>\n<p>특정 레이어에 속한 컴포넌트는 동일 레이어, 혹은 더 하위 레이어의 컴포넌트를 활용할 수 있다.</p>\n<p align=\"center\"><img width=\"85%\" src=\"https://user-images.githubusercontent.com/63405904/135494819-559541d9-1b75-4f2b-a5fe-f03519508483.png\"></p>\n<br>\n<h2 id=\"layer-나누어-설계하기\" style=\"position:relative;\"><a href=\"#layer-%EB%82%98%EB%88%84%EC%96%B4-%EC%84%A4%EA%B3%84%ED%95%98%EA%B8%B0\" aria-label=\"layer 나누어 설계하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Layer 나누어 설계하기</h2>\n<p>이제는 각 레이어에 대한 인터페이스를 설계해야하는데, 여기서 DTO(Domain Transfer Object)와 domain model이라는 키워드가 등장한다.</p>\n<ul>\n<li>\n<p><strong>DTO</strong></p>\n<p>단순한 데이터를 담는 객체로 각기 다른 프로세스와 어플리케이션의 레이어간 데이터 전달 때 사용되는 객체이다.</p>\n</li>\n<li>\n<p><strong>Domain Model</strong></p>\n<p>도메인 모델에는 3가지 다른 역할의 객체들이 있다.</p>\n<ol>\n<li>\n<p><strong>Domain Service</strong></p>\n<p>도메인과 관련된 operation 이지만 enity나 VO의 일부는 아닌 상태가 없는(stateless) 클래스</p>\n</li>\n<li>\n<p><strong>Entity</strong></p>\n<p>전체 라이프 사이클 동안 바뀌지 않고 그 indentity 자체로 정의되는 객체 <strong>(?????)</strong></p>\n</li>\n<li>\n<p><strong>Value Object</strong></p>\n<p>어떤 것의 속성을 나타내고, 그 자체로의 identity나 lifecycle이 없는 객체이다. 주로 VO의 life cycle은 entity의 lifecycle에 종속되어 있다.</p>\n</li>\n</ol>\n</li>\n</ul>\n<p>각 레이어의 인터페이스에는 다음 것들이 포함되어 있어야 한다.</p>\n<ul>\n<li>web layer는 DTO만을 다루어야 한다.</li>\n<li>service layer는 DTO를 메소드 인자로 받고 도메인 모델을 핸들링 할 수는 있지만 DTO만을 web layer에 다시 반환해야 한다.</li>\n<li>repository layer는 entity를 메소드 인자로 받고 entity를 반환해야 한다.</li>\n</ul>\n<p>그렇다면 왜 VO가 아닌 DTO로 레이어간 소통을 해야하는지 궁금할 수 있다. 다음 두가지 이유로 VO를 직접 사용하는 것은 좋지 않다.</p>\n<ol>\n<li>도메인 모델은 어플리케이션 내부 모델이다. 따라서 도메인 모델을 외부로 노출한다면 클라이언트는 해당 도메인 모델을 어떻게 다루어야하는지 인지해야한다. 하지만, 클라이언트는 해당 로직에 대해서 알 필요가 없다. 만일 DTO를 사용한다면 도메인 모델을 클라이언트에게 숨기고, 깔끔하고 쉬운 API를 제공할 수 있다.</li>\n<li>도메인 모델을 외부에 노출한다면 도메인 모델을 수정할 때 해당 도메인 모델이 의존하는 것들을 함께 수정해야한다. 하지만 만일 DTO를 사용한다면도메인 모델을 수정하더라도 다른 것(other stuff)들이 DTO와 연결되어 있기 때문에 다른 것들을 수정하지 않아도 된다.</li>\n</ol>\n<p align=\"center\"><img width=\"85%\" src=\"https://user-images.githubusercontent.com/63405904/135494900-92d34444-4d4a-4312-af6a-a0d45bf62f75.png\"></p>\n<br>\n<br>\n<p><strong>[참고링크]</strong></p>\n<ul>\n<li><a href=\"https://www.petrikainulainen.net/software-development/design/understanding-spring-web-application-architecture-the-classic-way/\">https://www.petrikainulainen.net/software-development/design/understanding-spring-web-application-architecture-the-classic-way/</a></li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#%EC%A2%8B%EC%9D%80-architecture%EB%A5%BC-%EC%9C%84%ED%95%9C-%EB%91%90-%EA%B8%B0%EB%91%A5\">좋은 architecture를 위한 두 기둥</a></p>\n<ul>\n<li><a href=\"#the-socseparation-of-concerns-%EC%9B%90%EC%B9%99\">The SoC(Separation of Concerns) 원칙</a></li>\n<li><a href=\"#the-kisskeep-it-simple-stupid-%EC%9B%90%EC%B9%99\">The KISS(Keep It Simple Stupid) 원칙</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#3-layers%EA%B0%80-%EA%B0%80%EC%9E%A5-%EC%A0%81%EB%8B%B9%ED%95%98%EB%8B%A4\">3 Layers가 가장 적당하다</a></p>\n</li>\n<li>\n<p><a href=\"#layer-%EB%82%98%EB%88%84%EC%96%B4-%EC%84%A4%EA%B3%84%ED%95%98%EA%B8%B0\">Layer 나누어 설계하기</a></p>\n</li>\n</ul>\n</div>","frontmatter":{"date":"June 26, 2021","title":"클래식한 스프링 웹 어플리케이션 구조","categories":"스프링 웹","author":"코다","emoji":"🍀"},"fields":{"slug":"/spring-spring-web-application-architecture/"}},"prev":{"id":"8316d4d6-553f-5d70-b995-11dc98735d16","html":"<h2 id=\"intro\" style=\"position:relative;\"><a href=\"#intro\" aria-label=\"intro permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Intro</h2>\n<p>함수는 <strong>시스템의 상태를 바꾸는지</strong>에 따라서 크게 두 가지로 나뉜다. 1) Command 2) Query. 이 두 가지 분류법에 대해서 하나의 함수가 두 가지 경우를 모두 담당하는 것은 좋지 않다.</p>\n<br>\n<h2 id=\"command-vs-query\" style=\"position:relative;\"><a href=\"#command-vs-query\" aria-label=\"command vs query permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Command vs. Query</h2>\n<ul>\n<li>\n<p><strong>Query</strong></p>\n<p>주어진 쿼리에 대한 결과값을 반환하고 시스템의 상태를 변화시키지는 않는다.</p>\n<p>다른 값을 바꾸지 않고 오직 질문에만 대답한다.</p>\n<p>부작용에서 자유롭다. (read-only)</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\">list <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">print</span><span class=\"token punctuation\">(</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token number\">5</span></code></pre></div>\n</li>\n<li>\n<p><strong>Command</strong></p>\n<p>값을 반환하지 않아도 시스템의 상태를 변화시킨다. (영구적)</p>\n<p>부작용이 생길 여기자 있다. (mutator, modifier)</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\">list <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\nlist<span class=\"token punctuation\">.</span><span class=\"token function\">reverse</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">print</span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">)</span>\n\n<span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span></code></pre></div>\n</li>\n</ul>\n<p>이렇게 함수를 두 가지로 나누는 것은 유용하다. 현재 사용하는 함수가 상태를 바꾸지 않는 query 라면 신뢰를 가지고 사용할 수 있다. 하지만 상태를 바꾸는 command라면 함수간 순서에 주의를 기울이고 부작용이 생길 여지를 인지하고 있어야 한다.</p>\n<br>\n<h2 id=\"cqs---command-query-separation\" style=\"position:relative;\"><a href=\"#cqs---command-query-separation\" aria-label=\"cqs   command query separation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CQS - Command Query Separation</h2>\n<p><em><strong>Betrand Meyer</strong></em>라는 프랑스 학자는 하나의 함수가 command 이거나 query 이어야 한다고 주장한다. 이러한 프로그램 원칙을 CQS라고 하며 한 함수에서는 둘은 분명히 구분해야 한다고 말했다. <br></p>\n<p>하지만 스택의 pop() 연산 같은 경우는 위 두가지를 모두 담당하기도 한다. 이러한 예외 상황은 융통성 있게 허용하는 것이 전반적으로 더 효율적일 수 있다. <br></p>\n<p>위 개념은 현재 진행중인 프로젝트에서 다음과 같은 코드에 대한 크루의 코드리뷰로 접하게 되었다. <br></p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">Post</span> newPost <span class=\"token operator\">=</span> post<span class=\"token punctuation\">.</span><span class=\"token function\">update</span><span class=\"token punctuation\">(</span>updatedContent<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>위와 같은 경우 CQS를 준수하지 않은 것이므로 둘 중 하나를 담당하도록 구현로직을 바꾸고 필요하면 재조회하는 방향으로 리팩토링 했다. <br></p>\n<br>\n<br>\n<p><strong>[참고자료]</strong></p>\n<ul>\n<li><a href=\"https://shoark7.github.io/programming/knowledge/command-and-query-method\">https://shoark7.github.io/programming/knowledge/command-and-query-method</a></li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#intro\">Intro</a></li>\n<li><a href=\"#command-vs-query\">Command vs. Query</a></li>\n<li><a href=\"#cqs---command-query-separation\">CQS - Command Query Separation</a></li>\n</ul>\n</div>","frontmatter":{"date":"July 17, 2021","title":"CQS(Command Query Separation) 간단히 알아보기","categories":"자바","author":"코다","emoji":"✊"},"fields":{"slug":"/java-cqs/"}},"site":{"siteMetadata":{"siteUrl":"https://yjksw.github.io","comments":{"utterances":{"repo":"yjksw/yjksw.github.io"}}}}},"pageContext":{"slug":"/database-transaction-currency-control/","nextSlug":"/spring-spring-web-application-architecture/","prevSlug":"/java-cqs/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}
{"componentChunkName":"component---src-templates-blog-template-js","path":"/movie-dlrm-2/","result":{"data":{"cur":{"id":"0da8868f-8e99-5b04-8738-0846bdb6f9b8","html":"<p>이어서 딥러닝 영화 개인화 추천 모델을 구현하면서 구축한 딥러닝 협업 필터링 모델 부분에 대한 코드를 살펴보면서 딥러닝 전체적인 흐름에 대해서 짚어보자. 앞에서 언급했듯이 코드는 다음 <a href=\"https://jyoondev.tistory.com/65?category=823946\">링크</a>에서 참고하여 모델과 전체적인 데이터 처리를 진행했고, 이후에 학습된 output에 대한 데이터 및 결과 후처리는 추가 구현했다. 해당 부분은 다음 파트에 다루도록 하겠다. <br></p>\n<h2 id=\"모델-전체-코드\" style=\"position:relative;\"><a href=\"#%EB%AA%A8%EB%8D%B8-%EC%A0%84%EC%B2%B4-%EC%BD%94%EB%93%9C\" aria-label=\"모델 전체 코드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>모델 전체 코드</h2>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">NNCollabFiltering</span><span class=\"token punctuation\">(</span>nn<span class=\"token punctuation\">.</span>Module<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n  <span class=\"token keyword\">def</span> <span class=\"token function\">__init__</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> num_users<span class=\"token punctuation\">,</span> num_items<span class=\"token punctuation\">,</span> emb_size<span class=\"token operator\">=</span><span class=\"token number\">100</span><span class=\"token punctuation\">,</span> n_hidden<span class=\"token operator\">=</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token builtin\">super</span><span class=\"token punctuation\">(</span>NNCollabFiltering<span class=\"token punctuation\">,</span> self<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>__init__<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    self<span class=\"token punctuation\">.</span>user_emb <span class=\"token operator\">=</span> nn<span class=\"token punctuation\">.</span>Embedding<span class=\"token punctuation\">(</span>num_users<span class=\"token punctuation\">,</span> emb_size<span class=\"token punctuation\">)</span>\n    self<span class=\"token punctuation\">.</span>item_emb <span class=\"token operator\">=</span> nn<span class=\"token punctuation\">.</span>Embedding<span class=\"token punctuation\">(</span>num_items<span class=\"token punctuation\">,</span> emb_size<span class=\"token punctuation\">)</span>\n    self<span class=\"token punctuation\">.</span>lin1 <span class=\"token operator\">=</span> nn<span class=\"token punctuation\">.</span>Linear<span class=\"token punctuation\">(</span>emb_size<span class=\"token operator\">*</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> n_hidden<span class=\"token punctuation\">)</span>\n    self<span class=\"token punctuation\">.</span>lin2 <span class=\"token operator\">=</span> nn<span class=\"token punctuation\">.</span>Linear<span class=\"token punctuation\">(</span>n_hidden<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    self<span class=\"token punctuation\">.</span>drop1 <span class=\"token operator\">=</span> nn<span class=\"token punctuation\">.</span>Dropout<span class=\"token punctuation\">(</span><span class=\"token number\">0.1</span><span class=\"token punctuation\">)</span>\n    \n  <span class=\"token keyword\">def</span> <span class=\"token function\">forward</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> u<span class=\"token punctuation\">,</span> v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    U <span class=\"token operator\">=</span> self<span class=\"token punctuation\">.</span>user_emb<span class=\"token punctuation\">(</span>u<span class=\"token punctuation\">)</span>\n    V <span class=\"token operator\">=</span> self<span class=\"token punctuation\">.</span>item_emb<span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span>\n    x <span class=\"token operator\">=</span> F<span class=\"token punctuation\">.</span>relu<span class=\"token punctuation\">(</span>torch<span class=\"token punctuation\">.</span>cat<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>U<span class=\"token punctuation\">,</span> V<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> dim<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    x <span class=\"token operator\">=</span> self<span class=\"token punctuation\">.</span>drop1<span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span>\n    x <span class=\"token operator\">=</span> F<span class=\"token punctuation\">.</span>relu<span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">.</span>lin1<span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    x <span class=\"token operator\">=</span> self<span class=\"token punctuation\">.</span>lin2<span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> x</code></pre></div>\n<br>\n<h2 id=\"step1-임베딩---nnembedding\" style=\"position:relative;\"><a href=\"#step1-%EC%9E%84%EB%B2%A0%EB%94%A9---nnembedding\" aria-label=\"step1 임베딩   nnembedding permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Step1. 임베딩 - nn.Embedding()</h2>\n<p>위 코드를 보면 먼저 User와 Item에 관한 임베딩으로 시작한다. 파이토치에서 임베딩 벡터를 사용하는 방법은 크게 두가지가 있는데 그 중 위의 <code class=\"language-text\">nn.Embedding()</code> 은 embedding layer를 만들어서 훈련 데이터로부터 처음부터 임베딩 벡터를 학습하는 방법이다. <br></p>\n<p>먼저 임베딩 층의 입력으로 사용하기 위해서는 정수 인코딩이 되어 있어야 한다. 즉 다음과 같은 단계를 따른다. <br></p>\n<blockquote>\n<p>어떤 단어 -> 고유한 정수로 인코딩 -> 임베딩 층을 통과 -> 밀집 벡터 </p>\n</blockquote>\n<p>즉, 고유한 정수 인코딩 값에 대해서 밀집 벡터(dense vector)를 맵핑해주는 것이다. 이 밀집 베터가 흔히 알고 있는 임베딩 벡터이다. 임베딩을 시킨다는 것은 어떠한 단어에 대한 고유 인코딩 정수값을 인덱스로 가지고 있는 룩업 테이블에서 해당 임베딩 벡터 값을 가져오는 것이다. 또한 <mark>이 테이블은 단어 집합만큼의 행을 가지고 있으므로 모든 단어들은 고유한 임베딩 벡터를 보유하게 된다.</mark> 이러한 벡터 값을 담고 있는 룩업 테이블을 생성하는 것이 <code class=\"language-text\">nn.Embedding()</code>의 역할이다. <br></p>\n<p><img src=\"https://user-images.githubusercontent.com/63405904/110482824-6bad5d80-812c-11eb-9da2-750e1946c80b.png\" alt=\"image\"></p>\n<p>위의 그림을 참고해보면 단어 ‘great’에 대한 임베딩 벡터가 4차원인 것을 확인할 수 있다. 해당 차원값은 parameter로 넘겨줄 수 있는 부분이다. 이렇게 생성된 임베딩 벡터는 모델의 입력이 되고, 역전파 과정을 거치면서 바로 이 임베딩 벡터값이 학습 되는 것이다. <br></p>\n<h3 id=\"-코드에서-임베딩\" style=\"position:relative;\"><a href=\"#-%EC%BD%94%EB%93%9C%EC%97%90%EC%84%9C-%EC%9E%84%EB%B2%A0%EB%94%A9\" aria-label=\" 코드에서 임베딩 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>> 코드에서 임베딩</h3>\n<p>위 코드에서 임베딩이 어떻게 이루어지고 있는지 살펴보자. 코드를 살펴보면 임베딩 관련한 부분에 다음과 같이 있다. <br></p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\">#def __init__ 메소드 내: </span>\n  self<span class=\"token punctuation\">.</span>user_emb <span class=\"token operator\">=</span> nn<span class=\"token punctuation\">.</span>Embedding<span class=\"token punctuation\">(</span>num_users<span class=\"token punctuation\">,</span> emb_size<span class=\"token punctuation\">)</span>\n  self<span class=\"token punctuation\">.</span>item_emb <span class=\"token operator\">=</span> nn<span class=\"token punctuation\">.</span>Embedding<span class=\"token punctuation\">(</span>num_items<span class=\"token punctuation\">,</span> emb_size<span class=\"token punctuation\">)</span></code></pre></div>\n<p><code class=\"language-text\">nn.Embedding()</code> 에 넘겨지는 parameter는 크게 <strong>2가지</strong>가 있다. 1) 테이블 사이즈 (단어 및 데이터 갯수) 2) 임베딩 사이즈 (embedding vector  차원). <br></p>\n<p>영화에서 모델에 넣어서 학습할 데이터는 사용자 user와 영화 item이다. 이 두개에 대한 임베딩 테이블을 생성하기 위해서 인코딩 하며 중복없이 뽑아낸 user 와 item 리스트의 크기와 임베딩 사이즈를 결정해서 <code class=\"language-text\">nn.Embbeding()</code>을 호출한다. 그럼 임베딩 테이블이 생성되어 각각 user<em>emb 와 item</em>emb에 저장된다. <br></p>\n<h2 id=\"step2-linear-layer-생성---nnlinear\" style=\"position:relative;\"><a href=\"#step2-linear-layer-%EC%83%9D%EC%84%B1---nnlinear\" aria-label=\"step2 linear layer 생성   nnlinear permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Step2. Linear Layer 생성 - nn.Linear()</h2>\n<p>다음 코드에서는 Linear layer를 생성한다. 딥러닝의 핵심인 신경망(neural network) 층을 쌓아올려서 학습을 진행한다. 그때 필요한 신경망 층을 생성하는 역할을 한다. 딥러닝을 위한 신경망은 기본적으로 선형회귀분석을 기본으로 하기 때문에 선형변형 함수로 층을 쌓는다. <br></p>\n<p><img src=\"https://user-images.githubusercontent.com/63405904/110482886-7d8f0080-812c-11eb-9b12-6c65a734be69.png\" alt=\"image\"></p>\n<p>파이토치에서 제공하는 <a href=\"https://pytorch.org/docs/stable/nn.html#linear-layers\">document</a>를 살펴보면 위와 같은 선형변형 함수를 사용하는 것을 확인할 수 있다. 선형결합은 보존하는 선형변형 함수를 생성하고 원하는 <strong>in_feature</strong>와 <strong>out_feature</strong>의 사이즈를 parameter로 넘긴다. <br></p>\n<h3 id=\"-코드에서-layer-생성\" style=\"position:relative;\"><a href=\"#-%EC%BD%94%EB%93%9C%EC%97%90%EC%84%9C-layer-%EC%83%9D%EC%84%B1\" aria-label=\" 코드에서 layer 생성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>> 코드에서 layer 생성</h3>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\">#def __init__ 메소드 내:</span>\n\tself<span class=\"token punctuation\">.</span>lin1 <span class=\"token operator\">=</span> nn<span class=\"token punctuation\">.</span>Linear<span class=\"token punctuation\">(</span>emb_size<span class=\"token operator\">*</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> n_hidden<span class=\"token punctuation\">)</span>\n  self<span class=\"token punctuation\">.</span>lin2 <span class=\"token operator\">=</span> nn<span class=\"token punctuation\">.</span>Linear<span class=\"token punctuation\">(</span>n_hidden<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>위 코드는 입력 차원이 emb<em>size의 두배인 input sample에 대해서 n</em>hidden 사이즈 만큼의 차원으로 선형변형을 하는 linear layer 하나와, n_hidden 사이즈의 input sample에 대해서 1로 선형변형을 하는 linear layer 두개를 생성한다. <br></p>\n<h2 id=\"step3-모델-일반화---nndropout\" style=\"position:relative;\"><a href=\"#step3-%EB%AA%A8%EB%8D%B8-%EC%9D%BC%EB%B0%98%ED%99%94---nndropout\" aria-label=\"step3 모델 일반화   nndropout permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Step3. 모델 일반화 - nn.Dropout()</h2>\n<p>Dropout은 모델을 일반화 기법으로 일부 파라미터를 학습에 반영하지 않는 것이다. Validation과 test 시에는 적용하지 않고 train 시에 dropout을 적용하는데, 일종의 정규화 기법이라고 볼 수 있다. 모델을 학습할 때 과적합(overfitting)의 위험을 줄이고, 학습속도를 개선하는 문제를 해결하기 위한 방법이다. 모델을 학습할 때 지나치게 학습 데이터에 대한 높은 정확도를 보이기 보다, 범용적으로 사용될 수 있도록 overfitting 문제를 피하기 위해서 고안된 해결책 중 하나이다. 일반적으로 신경망의 층이 깊어지고, 학습률이 작을수록 overfitting이 될 가능성이 높다. <br></p>\n<p>이중 본 코드에서 사용하고 있는 모델 일반화의 방법은 드롭아웃 Dropout이다. 신경망 모델이 지나치게 복잡해질 때, 뉴런의 연결을 임의로 삭제하여 전달하지 않도록 떨어뜨리는 역할을 한다. 다만, 테스트를 할 때에는 모든 뉴런을 사용하기 때문에 반드시 학습시에만 드롭아웃을 적용해야 한다. <br></p>\n<p><img src=\"https://user-images.githubusercontent.com/63405904/110482706-47ea1780-812c-11eb-9908-5686512aae8c.png\" alt=\"image\"></p>\n<p>파이토치 <a href=\"https://pytorch.org/docs/stable/generated/torch.nn.Dropout.html#torch.nn.Dropout\">document</a>를 보면 <code class=\"language-text\">nn.torch</code> 모듈에서 드롭아웃 또한 지원을 한다. <br></p>\n<p><img src=\"https://user-images.githubusercontent.com/63405904/110482789-5fc19b80-812c-11eb-960c-8f7da3b2597f.png\" alt=\"image\"></p>\n<p>파이토치에 제공하는 도큐멘트를 살펴보면 학습시 무작위로 몇개의 뉴런들에 대해서 <em>p</em> 확률만큼  ‘zeros’ 시킨다고 나와있다. 이때 <em>p</em>는 parameter로 주어지는 확률 변수이고, default는 0.5이다. <code class=\"language-text\">forward</code>함수가 호출될 때마다 적용되도록 되어 있다. <br></p>\n<h3 id=\"-코드에서-dropout\" style=\"position:relative;\"><a href=\"#-%EC%BD%94%EB%93%9C%EC%97%90%EC%84%9C-dropout\" aria-label=\" 코드에서 dropout permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>> 코드에서 Dropout</h3>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\">#def __init__ 메소드 내:</span>\n\tself<span class=\"token punctuation\">.</span>drop1 <span class=\"token operator\">=</span> nn<span class=\"token punctuation\">.</span>Dropout<span class=\"token punctuation\">(</span><span class=\"token number\">0.1</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>본 코드를 살펴보면 nn.torch 모둘에서 Dropout 함수를 호출하고 확률 변수를 0.1로 주었다. <br></p>\n<h2 id=\"step4-활성화함수---torchnnfunctionalrelu\" style=\"position:relative;\"><a href=\"#step4-%ED%99%9C%EC%84%B1%ED%99%94%ED%95%A8%EC%88%98---torchnnfunctionalrelu\" aria-label=\"step4 활성화함수   torchnnfunctionalrelu permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Step4. 활성화함수 - torch.nn.functional.relu()</h2>\n<p>다음 딥러닝 신경망 모델 구축에서 중요한 부분은 활성화 함수(Activation Function)이다. 활성화 함수는 최종출력 신호 후, 다음 뉴런으로 보낼지 말지를 결정하는 함수이다. 즉, 특정 뉴런이 다음 뉴런으로 신호를 보낼 때 입력신호의 어떠한 기준에 따라서 보내고 보내지 않는지를 결정하도록 하는 것이다. 딥러닝에서는 뉴런들을 다음 레이어로 전달할 때 비선형 함수를 통화시킨 후 전달하도록 하는데 이때 사용되는 함수가 활성화 함수이다. <br></p>\n<p>딥러닝 학습의 핵심은 이름에서 볼 수 있듯이 깊게 층을 쌓아서 그 층을 통과하면서 학습되는 것인데, 선형함수를 사용하게 되면 층을 깊게 하는 의미가 줄어들게 된다. 해당 설명은 [밑바닥부터 시작하는 딥러닝] 책의 한 부분을 인용하도록 하겠다. <br></p>\n<blockquote>\n<p>선형합수인 h(x)=cx를 활성화함수로 사용한 3층 네트워크를 떠올려 보세요. 이를 식으로 나타내면 y(x) = h(h(h(x)))가 됩니다. 이는 실은 y(x)=ax와 똑같은 식 입니다. a=c3이라고 하면 끝이죠. 즉, 은닉층이 없는 네트워크로 표현할 수 있습니다. 뉴럴네트워크에서 층을 쌓는 혜택을 얻고 싶다면 활성화 함수로는 반드시 비선형 함수를 사용해야 한다. </p>\n<p>-밑바닥부터 시작하는 딥러닝-</p>\n</blockquote>\n<p>이러한 역할을 하는 활성화 함수는 많은 종류가 있다. <strong>1) 시그모이드 함수 2) tanh 함수 3) ReLU 함수.</strong>  본 코드에서는 가장 많이 사용되는 활성화 함수인 ReLU 함수를 사용했다. <br></p>\n<p><img src=\"https://user-images.githubusercontent.com/63405904/110482937-8b448600-812c-11eb-9672-04dc7c7e5928.png\" alt=\"image\"></p>\n<p>ReLU 함수를 살펴보면 <span class=\"mjx-chtml\"><span class=\"mjx-math\" aria-label=\"x > 0\"><span class=\"mjx-mrow\" aria-hidden=\"true\"><span class=\"mjx-mi\"><span class=\"mjx-char MJXc-TeX-math-I\" style=\"padding-top: 0.225em; padding-bottom: 0.298em;\">x</span></span><span class=\"mjx-mo MJXc-space3\"><span class=\"mjx-char MJXc-TeX-main-R\" style=\"padding-top: 0.225em; padding-bottom: 0.372em;\">&gt;</span></span><span class=\"mjx-mn MJXc-space3\"><span class=\"mjx-char MJXc-TeX-main-R\" style=\"padding-top: 0.372em; padding-bottom: 0.372em;\">0</span></span></span></span></span> 이면 기울기가 1인 직선이고 <span class=\"mjx-chtml\"><span class=\"mjx-math\" aria-label=\"x < 0\"><span class=\"mjx-mrow\" aria-hidden=\"true\"><span class=\"mjx-mi\"><span class=\"mjx-char MJXc-TeX-math-I\" style=\"padding-top: 0.225em; padding-bottom: 0.298em;\">x</span></span><span class=\"mjx-mo MJXc-space3\"><span class=\"mjx-char MJXc-TeX-main-R\" style=\"padding-top: 0.225em; padding-bottom: 0.372em;\">&lt;</span></span><span class=\"mjx-mn MJXc-space3\"><span class=\"mjx-char MJXc-TeX-main-R\" style=\"padding-top: 0.372em; padding-bottom: 0.372em;\">0</span></span></span></span></span>이면 함수값이 0이 된다. 따라서 다른 활성화함수에 비해서 굉장히 간단하고 빠르다. 해당 함수는 양수에서는 Linear function 과 같은 모습을 보이지만 음수의 경우 0으로 버려지므로 non-linear 한 함수로 작동하여 layer를 깊게 쌓을 수 있는 장점을 가진다. <br></p>\n<h3 id=\"-코드에서-활성화함수\" style=\"position:relative;\"><a href=\"#-%EC%BD%94%EB%93%9C%EC%97%90%EC%84%9C-%ED%99%9C%EC%84%B1%ED%99%94%ED%95%A8%EC%88%98\" aria-label=\" 코드에서 활성화함수 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>> 코드에서 활성화함수</h3>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\">#def forward 내</span>\n\tx <span class=\"token operator\">=</span> F<span class=\"token punctuation\">.</span>relu<span class=\"token punctuation\">(</span>torch<span class=\"token punctuation\">.</span>cat<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>U<span class=\"token punctuation\">,</span> V<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> dim<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>선형함수가 linear layer에 들어가기 전에 비선형 함수를 거친다. 위의 코드에서 F는 <code class=\"language-text\">torch.nn.funtional</code>모듈이며 모듈 내에 있는 <code class=\"language-text\">relu()</code>를 사용하고 있다. <br></p>\n<br>\n<br>\n<p><strong><small> [참고 자료]: <a href=\"https://wikidocs.net/64779\">https://wikidocs.net/64779</a>, <a href=\"https://tutorials.pytorch.kr/beginner/blitz/neural_networks_tutorial.html\">https://tutorials.pytorch.kr/beginner/blitz/neural_networks_tutorial.html</a>, <a href=\"https://pytorch.org/docs/\">https://pytorch.org/docs/</a>, <a href=\"https://yeomko.tistory.com/39\">https://yeomko.tistory.com/39</a>, <a href=\"https://reniew.github.io/12/\">https://reniew.github.io/12/</a>, <a href=\"https://eda-ai-lab.tistory.com/405\">https://eda-ai-lab.tistory.com/405</a>, <a href=\"https://jyoondev.tistory.com/65?category=823946\">https://jyoondev.tistory.com/65?category=823946</a>, <a href=\"https://sacko.tistory.com/45\">https://sacko.tistory.com/45</a></small></strong></p>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#%EB%AA%A8%EB%8D%B8-%EC%A0%84%EC%B2%B4-%EC%BD%94%EB%93%9C\">모델 전체 코드</a></li>\n<li>\n<p><a href=\"#step1-%EC%9E%84%EB%B2%A0%EB%94%A9---nnembedding\">Step1. 임베딩 - nn.Embedding()</a></p>\n<ul>\n<li><a href=\"#-%EC%BD%94%EB%93%9C%EC%97%90%EC%84%9C-%EC%9E%84%EB%B2%A0%EB%94%A9\">> 코드에서 임베딩</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#step2-linear-layer-%EC%83%9D%EC%84%B1---nnlinear\">Step2. Linear Layer 생성 - nn.Linear()</a></p>\n<ul>\n<li><a href=\"#-%EC%BD%94%EB%93%9C%EC%97%90%EC%84%9C-layer-%EC%83%9D%EC%84%B1\">> 코드에서 layer 생성</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#step3-%EB%AA%A8%EB%8D%B8-%EC%9D%BC%EB%B0%98%ED%99%94---nndropout\">Step3. 모델 일반화 - nn.Dropout()</a></p>\n<ul>\n<li><a href=\"#-%EC%BD%94%EB%93%9C%EC%97%90%EC%84%9C-dropout\">> 코드에서 Dropout</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#step4-%ED%99%9C%EC%84%B1%ED%99%94%ED%95%A8%EC%88%98---torchnnfunctionalrelu\">Step4. 활성화함수 - torch.nn.functional.relu()</a></p>\n<ul>\n<li><a href=\"#-%EC%BD%94%EB%93%9C%EC%97%90%EC%84%9C-%ED%99%9C%EC%84%B1%ED%99%94%ED%95%A8%EC%88%98\">> 코드에서 활성화함수</a></li>\n</ul>\n</li>\n</ul>\n</div>","excerpt":"이어서 딥러닝 영화 개인화 추천 모델을 구현하면서 구축한 딥러닝 협업 필터링 모델 부분에 대한 코드를 살펴보면서 딥러닝 전체적인 흐름에 대해서 짚어보자. 앞에서 언급했듯이 코드는 다음 링크에서 참고하여 모델과 전체적인 데이터 처리를 진행했고, 이후에 학습된 output에 대한 데이터 및 결과 후처리는 추가 구현했다. 해당 부분은 다음 파트에 다루도록 하겠다.  모델 전체 코드 Step1. 임베딩 - nn.Embedding() 위 코드를 보면 먼저 User와 Item에 관한 임베딩으로 시작한다. 파이토치에서 임베딩 벡터를 사용하는 방법은 크게 두가지가 있는데 그 중 위의  은 embedding layer를 만들어서 훈련 데이터로부터 처음부터 임베딩 벡터를 학습하는 방법이다.  먼저 임베딩 층의 입력으로 사용하기 위해서는 정수 인코딩이 되어 있어야 한다. 즉 다음과 같은 단계를 따른다.  어떤 단어 -> 고유한 정수로 인코딩 -> 임베딩 층을 통과 -> 밀집 벡터  즉, 고유한 정수 …","frontmatter":{"date":"August 22, 2020","title":"[머신러닝] 딥러닝 영화 개인화 추천 - Part.2","categories":"머신러닝","author":"코다","emoji":"🪄"},"fields":{"slug":"/movie-dlrm-2/"}},"next":{"id":"00f6784d-9c1b-544a-bbc9-c05f7ea73ba6","html":"<p>인턴을 하는 중에 요즘에 중요한 머신러닝의 한 분야가 되고 있는 개인화 추천에 대한 개발을 맡게 되었다. 요즘 넷플릭스, 왓챠와 같은 OTT 서비스는 물론이고, SNS에 표기되는 광고, 당근마켓 등등과 같은 중고거래 및 쇼핑 어플리케이션에서도 중요한 것이 사용자의 취향을 분석하여서 알맞은 아이템을 추천하는 기술이 핵심이다. 어쩌면 사용자가 의식적으로 파악하고 있는 이상의 취향을 파악해서 추천해야 할 때도 있다. 이전 포스트에서 다루었듯이 개인화 추천에는 여러 통계기반 머신러닝 기법들이 있다. 그리고 인공 신경망이라는 딥러닝 기법이 등장하게 되면서 더욱 세밀하고 정확한 개인화 추천이 가능해졌다. <br></p>\n<p>처음 접했기 때문에 매우 생소하고 낯선 분야였지만 많은 자료들을 찾아보면서 현재 내 삶(<small>유튜브나 넷플릭스의 노예…</small>)과 아주 밀접하게 연관이 되어 있는 많은 어플리케이션과 서비스등에 실제로 사용되고 있는 인공지능 기법이라는 것이 금방 흥미를 불러 일으켰다. 조금 어렵긴 하지만 facebook에서 공개한 DLRM(Deep Learning Recommendation Model) <a href=\"https://ai.facebook.com/blog/dlrm-an-advanced-open-source-deep-learning-recommendation-model/\">자료</a>나 구글에서 공개한 유튜브 개인화 추천 <a href=\"https://research.google/pubs/pub45530/\">논문</a>, 국내의 당근마켓에서 쓴 개인화 추천 관련 블로그 <a href=\"%5Bhttps://medium.com/daangn/%EB%94%A5%EB%9F%AC%EB%8B%9D-%EA%B0%9C%EC%9D%B8%ED%99%94-%EC%B6%94%EC%B2%9C-1eda682c2e8c%5D(https://medium.com/daangn/%EB%94%A5%EB%9F%AC%EB%8B%9D-%EA%B0%9C%EC%9D%B8%ED%99%94-%EC%B6%94%EC%B2%9C-1eda682c2e8c)\">포스트</a> 등을 참고하면서 개인화 추천에 대한 대략적인 아이디어나 개념을 잡았다. <small>물론 매우 매우 어렵기 때문에 모든 것을 이해하는 것은 (나는) 힘들다. 가볍지만 꼼꼼하게 읽으면서 대략적인 맥락을 파악하는 것을 추천한다!</small> <br></p>\n<p>이후에 구현되어 있었던 pytorch를 활용한 딥러닝 모델 예시를 보게 되었고 참고하여 응용하면서 아주 간단한 딥러닝 영화 개인화 추천 모델을 구현하였다. 이번 포스트는 해당 개발의 초반, 데이터 전처리에 관한 내용을 다룰 예정이다. 전체 코드를 보고 싶다면 다음 <a href=\"https://github.com/yjksw/DeepLearning_Movie_Recommendation_System\">github repo</a>를 참고하시길. <br></p>\n<h2 id=\"데이터-모양새\" style=\"position:relative;\"><a href=\"#%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%AA%A8%EC%96%91%EC%83%88\" aria-label=\"데이터 모양새 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>데이터 모양새</h2>\n<p>딥러닝 개인화 추천 모델 구현을 시작하면서 가장 먼저 한 일은 입력 데이터의 형식에 대해서 파악한 것이다. 본 모델을 사용자와 영화 아이템, 그리고 해당  영화에 대한 각 사용자의 ratings 데이터를 담고 있는 MovieLens 데이터를 사용하였다. 해당 사이트에 가서 원하는 파일을 다운받아서 열면 다음과 같은 형식으로 데이터가 담겨져 있다. <br></p>\n<p><img src=\"https://user-images.githubusercontent.com/63405904/110306953-c027de80-8041-11eb-838e-1ca3bf9957f2.png\" alt=\"image\"> <br></p>\n<p>해당 csv. 파일을 읽어서 validation 과 test 데이터를 나누어야 한다. 다음 명령어를 써서 읽은 csv 파일 data frame에 대한 마스크를 씌울 수 있다. <br></p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">msk <span class=\"token operator\">=</span> np<span class=\"token punctuation\">.</span>random<span class=\"token punctuation\">.</span>rand<span class=\"token punctuation\">(</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">0.8</span></code></pre></div>\n<p>나는 구현할 때 80% 정도의 데이터를 학습 데이터로, 나머지 20%의 데이터를 검증 데이터로 사용했다. <br></p>\n<h2 id=\"데이터-전처리\" style=\"position:relative;\"><a href=\"#%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%A0%84%EC%B2%98%EB%A6%AC\" aria-label=\"데이터 전처리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>데이터 전처리</h2>\n<p>데이터 전처리에서 해야할 일들은 매우 간단하다. 기본적으로 학습 데이터와 검증 데이터는 모두 비슷한 과정의 데이터 전처리 과정을 거치지만 개인화 추천을 위한 영화 데이터에 대해서 구현할 때는 검증 데이터 전처리에 관해 조금 다른 부분이 필요하기도 하다. <br></p>\n<p>학습에서 사용되는 데이터는 ratings.csv 파일에서도 특히 <em>userId</em>와 <em>movieId</em> 부분이다. 따라서 해당 column를 하나씩 끌어다가 전처리를 해주어야 한다. 여기서 필요한 전처리 과정은 다음과 같다. <br></p>\n<ol>\n<li>중복을 제거하여 순수한 유저와 아이템 리스트 갯수 및 리스트 생성</li>\n<li>학습 데이터가 아닌 검증 또는 테스트 데이터일 경우, 학습 데이터에 존재하지 않는 유저와 아이템에 대하여 -1 처리하여 제외</li>\n</ol>\n<p><strong>1번</strong> 과정이 필요한 이유는 이후에 신경망 layers를 쌓고 임베딩 할 때에 pytorch의 모듈을 사용하여서 임베딩 테이블을 생성해야하기 때문이다. <strong>2번</strong> 과정이 필요한 이유는 검증 또는 테스트 데이터에 학습 데이터로 학습되지 않은 전혀 새로운 유저나 영화가 나왔을 경우, 제대로 예측할 수 없기 때문에 미리 제거해 주는 것이다. <br></p>\n<h2 id=\"코드\" style=\"position:relative;\"><a href=\"#%EC%BD%94%EB%93%9C\" aria-label=\"코드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>코드</h2>\n<p>위의 데이터 전처리를 하기 위해서 유용한 몇가지 파이썬 코드를 소개한다. <br></p>\n<ol>\n<li>데이터 columns의 중복제거</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">uni <span class=\"token operator\">=</span> train_col<span class=\"token punctuation\">.</span>unique<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>위 메소드는 입력으로 들어온 column에 대해서 중복을 제거한 리스트를 uni 변수에 저장해준다. </p>\n<ol start=\"2\">\n<li>존재하지 않는 아이템에 대하여 -1 처리하기</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">np<span class=\"token punctuation\">.</span>array<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>name2idx<span class=\"token punctuation\">.</span>get<span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">for</span> x <span class=\"token keyword\">in</span> col<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>여기서 name2idx는 중복이 없는 순수한 유저 또는 아이템 리스트와 해당 index이다. 위와 같은 코드를 실행하면 name2idx에서 해당 col에 있는 x 값이 있다면 해당 값을 가져오고, 그렇지 않다면 -1을 입력하도록 하는 간편한 파이썬 문법이다. <br></p>\n<p>이후에 학습 데이터에 존재하지 않는 유저 또는 아이템이 음수로 들어와 있으니 해당 처리를 다음과 같이하면 제외하고 검증 및 테스트 할 수 있다. <br></p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">df <span class=\"token operator\">=</span> df<span class=\"token punctuation\">[</span>df<span class=\"token punctuation\">[</span>col_name<span class=\"token punctuation\">]</span> <span class=\"token operator\">>=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">]</span></code></pre></div>\n<h2 id=\"결과-화면\" style=\"position:relative;\"><a href=\"#%EA%B2%B0%EA%B3%BC-%ED%99%94%EB%A9%B4\" aria-label=\"결과 화면 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>결과 화면</h2>\n<p>위와 같은 데이터 전처리를 끝내면 다음과 같은 전처리된 데이터가 생성된다. 물론 임베딩하는 전처리가 추가로 필요하지만 다음 포스트에서 학습과 함께 다루도록 하겠다. 결과 화면의 데이터는 csv의 데이터와 크게 차이가 없이 지저분한 데이터들을 제외하고 처리해 놓은 데이터라고 생각하면 된다. <br></p>\n<p><img src=\"https://user-images.githubusercontent.com/63405904/110306884-b00fff00-8041-11eb-91f0-51660920fbcf.png\" alt=\"image\"></p>\n<p><strong><small> [참고 자료]: <a href=\"https://jyoondev.tistory.com/65\">https://jyoondev.tistory.com/65</a> </small></strong></p>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%AA%A8%EC%96%91%EC%83%88\">데이터 모양새</a></li>\n<li><a href=\"#%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%A0%84%EC%B2%98%EB%A6%AC\">데이터 전처리</a></li>\n<li><a href=\"#%EC%BD%94%EB%93%9C\">코드</a></li>\n<li><a href=\"#%EA%B2%B0%EA%B3%BC-%ED%99%94%EB%A9%B4\">결과 화면</a></li>\n</ul>\n</div>","frontmatter":{"date":"August 21, 2020","title":"[머신러닝] 딥러닝 영화 개인화 추천 - Part.1","categories":"머신러닝","author":"코다","emoji":"🪄"},"fields":{"slug":"/movie-dlrm-1/"}},"prev":{"id":"54bfcba0-c3f2-59e2-ad81-8f56a2e38c26","html":"<p>이진탐색의 응용 버전으로 상/하한선을 찾는 알고리즘이다. 이를 응용한 <a href=\"https://www.acmicpc.net/problem/10816\">문제</a>를 풀면서 배운 개념을 정리해둔다. <br></p>\n<p>이진탐색을 사용하면 모든 요소들을 다 방문하면서 탐색하는 것보다 훨씬 더 효율적으로 원하는 요소를 탐색할 수 있다. 하지만 이진탐색의 경우, <u>중복되지 않은 값이 주어진 경우</u>이거나, <u>해당 요소의 존재 여부</u>만을 가리기 위해서 일 경우에만 사용이 가능하다. 위의 문제의 경우, 중복되는 값들이 존재하며 그 값들이 총 몇개가 있는지도 확인할 수 있어야 하기 때문에 일반적인 이진탐색을 통해서는 답을 도출할 수 없다. 그래서 찾은 알고리즘 <mark>Upper Bound</mark> 와 <mark>Lower Bound</mark> 알고리즘 이다. <strong>이진탐색에서 살짝 변형되어서 중복된 자료가 있을 때 유용하게 탐색할 수 있는 알고리즘</strong>이다. <br></p>\n<p>아래 그림을 보면 lower bound와 upper bound에 대해서 더 잘 이해할 수 있다. <br></p>\n<p><img src=\"https://user-images.githubusercontent.com/63405904/111030306-c4d70300-8444-11eb-8b82-7ad2c3cc0ec1.png\" alt=\"image\"></p>\n<h2 id=\"upper-bound-algorithm\" style=\"position:relative;\"><a href=\"#upper-bound-algorithm\" aria-label=\"upper bound algorithm permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Upper Bound Algorithm</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">> Upper Bound Theory:\n\tK 값보다 큰 값(>)이 처음 나오는 위치를 리턴해주는 알고리즘. </code></pre></div>\n<p>구현은 이진 탐색과 매우 유사하지만 약간의 변형이 있다. <br></p>\n<ol>\n<li><strong>탐색의 범위를 크기가 n일 때:</strong> index만큼인 n-1까지 탐색하는 것이 아니라, n까지 탐색해야 함.</li>\n<li><strong>탐색하는 숫자 k를 찾았거나, mid 값보다 k가 작을 경우:</strong>  해당 값이나 위치를 return하는 것이 아니라, 중간 값 이후부터 분할한 오른쪽 부분을 재 탐색함. </li>\n<li><strong>탐색하는 숫자 k보다 mid에 있는 값이 클 경우:</strong> 본래 mid를 제외한 start~mid-1까지를 탐색했으나, 여기서는 start~mid 탐색해 mid값을 재포함 함. </li>\n</ol>\n<p>여기서 1번을 시행하는 이유는 만약 배열에 있는 모든 요소, 혹은 마지막 요소보다 큰 값에 대해서 return 해야할 경우, 배열의 크기 만큼을 리턴해야 하므로 end 요소에 이진 탐색처럼 <code class=\"language-text\">array.length-1</code>이 아닌 <code class=\"language-text\">array.length</code>가 들어가야 한다. <br></p>\n<p>2번의 경우에는 해당 값 k를 찾았을 때도, <em><u>k보다 큰 값이 처음 등장하는 위치</u></em> 를 찾아야 하기 때문에, 해당 다음 위치부터 end index에 대해서 마지막 하나 남을 때까지 재탐색 해야 한다. <br></p>\n<p>3번의 경우 mid 인덱스를 재포함하는 이유는 해당 mid에 있는 값이 upper bound 일 수 있으나, 탐색 숫자 k보다 <u>큰 첫번째 숫자임을 보장할 수 없기 때문에</u> 탐색을 이어서 진행하는 것이다. <br></p>\n<p><strong>코드:</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">searchUpper</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> start<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> end<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>start<span class=\"token operator\">>=</span>end<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> start<span class=\"token punctuation\">;</span>\n  \n  <span class=\"token keyword\">int</span> mid <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>start<span class=\"token operator\">+</span>end<span class=\"token punctuation\">)</span><span class=\"token operator\">/</span><span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n  \n  <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>num_list<span class=\"token punctuation\">[</span>mid<span class=\"token punctuation\">]</span><span class=\"token operator\">&lt;=</span>num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">searchUpper</span><span class=\"token punctuation\">(</span>mid<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> end<span class=\"token punctuation\">,</span> num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">searchUpper</span><span class=\"token punctuation\">(</span>start<span class=\"token punctuation\">,</span> mid<span class=\"token punctuation\">,</span> num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<br>\n<h2 id=\"lower-bound-algorithm\" style=\"position:relative;\"><a href=\"#lower-bound-algorithm\" aria-label=\"lower bound algorithm permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Lower Bound Algorithm</h2>\n<p>Lower bound 또한 Upper bound와 매우 유사하게 진행되므로 위의 설명을 참고하면 된다. 다만 upper bound와 다르게 작용하는 부분은, 딱 한 부분이다. <br></p>\n<ul>\n<li>탐색하고 있는 k가 등장했을 때, upper bound 알고리즘에서는 mid+1 값부터 오른쪽 반을 탐색하였는데, lower bound 알고리즘에서는 mid를 포함시켜 왼쪽 반을 탐색하도록 한다. <br></li>\n</ul>\n<p>이 부분은 lower bound이 경우 숫자 k 가 처음 등장한 위치를 찾아야 하기 때문에 k 가 등장하더라도 그 이전에 k가 존재하지는 않는지 확인해야 하기 때문이다. <br></p>\n<br>\n<p><strong>코드:</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">searchLower</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> start<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> end<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>start<span class=\"token operator\">>=</span>end<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> start<span class=\"token punctuation\">;</span>\n  \n  <span class=\"token keyword\">int</span> mid <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>start<span class=\"token operator\">+</span>end<span class=\"token punctuation\">)</span><span class=\"token operator\">/</span><span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n  \n  <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>num_list<span class=\"token punctuation\">[</span>mid<span class=\"token punctuation\">]</span><span class=\"token operator\">>=</span>num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">searchLower</span><span class=\"token punctuation\">(</span>start<span class=\"token punctuation\">,</span> mid<span class=\"token punctuation\">,</span> num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">searchLower</span><span class=\"token punctuation\">(</span>mid<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> end<span class=\"token punctuation\">,</span> num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<br>\n<br>\n<p><strong><small>[참고 자료]: <a href=\"http://bajamircea.github.io/coding/cpp/2018/08/09/lower-bound.html\">http://bajamircea.github.io/coding/cpp/2018/08/09/lower-bound.html</a>, <a href=\"https://jackpot53.tistory.com/33#:~:text=lower%20bound%EB%8A%94%20%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%82%B4,%EB%A5%BC%20%EB%A6%AC%ED%84%B4%ED%95%B4%EC%A3%BC%EB%8A%94%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%B4%EB%8B%A4.\">https://jackpot53.tistory.com/33#:~:text=lower%20bound%EB%8A%94%20%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%82%B4,%EB%A5%BC%20%EB%A6%AC%ED%84%B4%ED%95%B4%EC%A3%BC%EB%8A%94%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%B4%EB%8B%A4.</a> </small></strong></p>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#upper-bound-algorithm\">Upper Bound Algorithm</a></li>\n<li><a href=\"#lower-bound-algorithm\">Lower Bound Algorithm</a></li>\n</ul>\n</div>","frontmatter":{"date":"September 04, 2020","title":"[알고리즘] 이진탐색 응용: UpperBound와 LowerBound","categories":"알고리즘","author":"코다","emoji":"🤹‍♀️"},"fields":{"slug":"/bin-search-bound/"}},"site":{"siteMetadata":{"siteUrl":"https://yjksw.github.io","comments":{"utterances":{"repo":"yjksw/yjksw.github.io"}}}}},"pageContext":{"slug":"/movie-dlrm-2/","nextSlug":"/movie-dlrm-1/","prevSlug":"/bin-search-bound/"}},"staticQueryHashes":["1073350324","2938748437"]}
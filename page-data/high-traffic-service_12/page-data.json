{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/high-traffic-service_12/",
    "result": {"data":{"cur":{"id":"67377600-a29e-5099-ba3e-69e517ee7ca0","html":"<blockquote>\n<p>다음은 웹 개발자를 위한 대규모 서비스를 지탱하는 기술을 읽고 정리한 내용입니다 🙌</p>\n</blockquote>\n<br>\n<ul>\n<li>규모가 커지면서 트래픽이 커지면 문제가 발생한다. → 라우터의 성능 관점에서는 bps보다 패킷 단위인 pps가 더 중요하다. 사용하고 있는 라우터에서 감당하는 이상의 패킷이 송수신되면 문제가 발생한다.</li>\n<li>또한 호스트 수가 500을 넘어가면서 하나의 서브넷을 구성하면 여러 패킷 손실등이 발생하기도 한다.</li>\n<li>글로벌 서비스로 확장하면 데이터 센트럴 한군데 두었을 때 latency도 한계에 다다를 수 있다.</li>\n</ul>\n<h2 id=\"강의38-네트워크-분기점\" style=\"position:relative;\"><a href=\"#%EA%B0%95%EC%9D%9838-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EB%B6%84%EA%B8%B0%EC%A0%90\" aria-label=\"강의38 네트워크 분기점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[강의38] 네트워크 분기점</h2>\n<h2 id=\"1gbps의-한계---pc-라우터의-한계\" style=\"position:relative;\"><a href=\"#1gbps%EC%9D%98-%ED%95%9C%EA%B3%84---pc-%EB%9D%BC%EC%9A%B0%ED%84%B0%EC%9D%98-%ED%95%9C%EA%B3%84\" aria-label=\"1gbps의 한계   pc 라우터의 한계 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1Gbps의 한계 - PC 라우터의 한계</h2>\n<ul>\n<li>1Gbps 는 30만pps → 한계치이다.</li>\n<li>이것을 해결하기 위해서는 PC 라우터를 여러 대 병렬화 하던지, 고가의 라우터를 사용해야 한다.</li>\n</ul>\n<h2 id=\"500호스트의-한계---1서브넷-arp-테이블에서의-한계\" style=\"position:relative;\"><a href=\"#500%ED%98%B8%EC%8A%A4%ED%8A%B8%EC%9D%98-%ED%95%9C%EA%B3%84---1%EC%84%9C%EB%B8%8C%EB%84%B7-arp-%ED%85%8C%EC%9D%B4%EB%B8%94%EC%97%90%EC%84%9C%EC%9D%98-%ED%95%9C%EA%B3%84\" aria-label=\"500호스트의 한계   1서브넷 arp 테이블에서의 한계 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>500호스트의 한계 - 1서브넷 ARP 테이블에서의 한계</h2>\n<ul>\n<li>스위치의 ARP(Address Resolution Protocol table)에서 한계가 있다.\n<ul>\n<li>ARP는 IP주소와 MAC 주소간의 관계를 나타내는 테이블이다.</li>\n</ul>\n</li>\n<li>이 테이블의 크기에 제한이 있다. 그것을 넘어가게 되면 특정 호스트로 ping이 가지 않게 된다.</li>\n<li>서브넷 내에 호스트가 많으면 브로드캐스팅 패킷이 증가하여 트래픽이 부하를 생성한다.</li>\n</ul>\n<h2 id=\"네트워크-구조-계층화\" style=\"position:relative;\"><a href=\"#%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EA%B5%AC%EC%A1%B0-%EA%B3%84%EC%B8%B5%ED%99%94\" aria-label=\"네트워크 구조 계층화 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>네트워크 구조 계층화</h2>\n<ul>\n<li>지금까지 언급한 문제에 대한 대책\n<ul>\n<li>3단 구조로 네트워크를 계층화 하자는 것이다.</li>\n</ul>\n</li>\n<li><strong>3단 구조</strong>\n<ol>\n<li>가장 작은 것은 Access 계층</li>\n<li>그 다음이 Distribution 계층</li>\n<li>가장 위가 Core 계층 또는 OSPF 영역</li>\n</ol>\n<ul>\n<li>이렇게 가장 작은 서브넷에서 100대, 200대를 억제, 디스트리뷰션에서 1000대, 코어 전체에서 100000 단위로 다룬다.</li>\n</ul>\n</li>\n<li>Distribution 영역간 트래픽을 제어해서 너무 증가하지 않도록 하고 서브넷 내에서의 통신량을 제어한다.</li>\n</ul>\n<h2 id=\"글로벌화\" style=\"position:relative;\"><a href=\"#%EA%B8%80%EB%A1%9C%EB%B2%8C%ED%99%94\" aria-label=\"글로벌화 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>글로벌화</h2>\n<ul>\n<li>CDN을 사용해서 여러 곳에 배치된 데이터센터를 활용해 latency를 줄인다.</li>\n</ul>\n<br>\n<h2 id=\"강의39-한층-높은-단계로\" style=\"position:relative;\"><a href=\"#%EA%B0%95%EC%9D%9839-%ED%95%9C%EC%B8%B5-%EB%86%92%EC%9D%80-%EB%8B%A8%EA%B3%84%EB%A1%9C\" aria-label=\"강의39 한층 높은 단계로 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[강의39] 한층 높은 단계로</h2>\n<h2 id=\"웹-서비스-인프라의-핵심\" style=\"position:relative;\"><a href=\"#%EC%9B%B9-%EC%84%9C%EB%B9%84%EC%8A%A4-%EC%9D%B8%ED%94%84%EB%9D%BC%EC%9D%98-%ED%95%B5%EC%8B%AC\" aria-label=\"웹 서비스 인프라의 핵심 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>웹 서비스 인프라의 핵심</h2>\n<ul>\n<li>저비용, 높은 확장성</li>\n<li>적당하면서 충분히 높은 신뢰성</li>\n<li>기술 4가지\n<ul>\n<li>확장성</li>\n<li>다중화</li>\n<li>효율향상</li>\n<li>네트워크</li>\n</ul>\n</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#%EA%B0%95%EC%9D%9838-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EB%B6%84%EA%B8%B0%EC%A0%90\">[강의38] 네트워크 분기점</a></li>\n<li><a href=\"#1gbps%EC%9D%98-%ED%95%9C%EA%B3%84---pc-%EB%9D%BC%EC%9A%B0%ED%84%B0%EC%9D%98-%ED%95%9C%EA%B3%84\">1Gbps의 한계 - PC 라우터의 한계</a></li>\n<li><a href=\"#500%ED%98%B8%EC%8A%A4%ED%8A%B8%EC%9D%98-%ED%95%9C%EA%B3%84---1%EC%84%9C%EB%B8%8C%EB%84%B7-arp-%ED%85%8C%EC%9D%B4%EB%B8%94%EC%97%90%EC%84%9C%EC%9D%98-%ED%95%9C%EA%B3%84\">500호스트의 한계 - 1서브넷 ARP 테이블에서의 한계</a></li>\n<li><a href=\"#%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EA%B5%AC%EC%A1%B0-%EA%B3%84%EC%B8%B5%ED%99%94\">네트워크 구조 계층화</a></li>\n<li><a href=\"#%EA%B8%80%EB%A1%9C%EB%B2%8C%ED%99%94\">글로벌화</a></li>\n<li><a href=\"#%EA%B0%95%EC%9D%9839-%ED%95%9C%EC%B8%B5-%EB%86%92%EC%9D%80-%EB%8B%A8%EA%B3%84%EB%A1%9C\">[강의39] 한층 높은 단계로</a></li>\n<li><a href=\"#%EC%9B%B9-%EC%84%9C%EB%B9%84%EC%8A%A4-%EC%9D%B8%ED%94%84%EB%9D%BC%EC%9D%98-%ED%95%B5%EC%8B%AC\">웹 서비스 인프라의 핵심</a></li>\n</ul>\n</div>","excerpt":"다음은 웹 개발자를 위한 대규모 서비스를 지탱하는 기술을 읽고 정리한 내용입니다 🙌 규모가 커지면서 트래픽이 커지면 문제가 발생한다. → 라우터의 성능 관점에서는 bps보다 패킷 단위인 pps가 더 중요하다. 사용하고 있는 라우터에서 감당하는 이상의 패킷이 송수신되면 문제가 발생한다. 또한 호스트 수가 500을 넘어가면서 하나의 서브넷을 구성하면 여러 패킷 손실등이 발생하기도 한다. 글로벌 서비스로 확장하면 데이터 센트럴 한군데 두었을 때 latency도 한계에 다다를 수 있다. [강의38] 네트워크 분기점 1Gbps의 한계 - PC 라우터의 한계 1Gbps 는 30만pps → 한계치이다. 이것을 해결하기 위해서는 PC 라우터를 여러 대 병렬화 하던지, 고가의 라우터를 사용해야 한다. 500호스트의 한계 - 1서브넷 ARP 테이블에서의 한계 스위치의 ARP(Address Resolution Protocol table)에서 한계가 있다. ARP는 IP주소와 MAC 주소간의 관계를 나…","frontmatter":{"date":"September 29, 2021","title":"대규모 서비스를 지탱하는 기술 - 웹 서비스와 네트워크","categories":"웹 인프라 책 성능테스트","author":"코다","emoji":"📚"},"fields":{"slug":"/high-traffic-service_12/"}},"next":{"id":"3e136db1-f284-581a-99b2-6583b2742509","html":"<blockquote>\n<p>다음은 웹 개발자를 위한 대규모 서비스를 지탱하는 기술을 읽고 정리한 내용입니다 🙌</p>\n</blockquote>\n<br>\n<ul>\n<li>다중화로 어느정도 문제를 해결할 수 있지만 규모가 작으면 다중화를 했을 경우 전체적인 리소스 사용률이 떨어지면서 효율이 떨어진다.</li>\n<li>가상화로 전체적인 리소스 사용률을 높일 수 있다.</li>\n</ul>\n<br>\n<h2 id=\"강의36-가상화-기술\" style=\"position:relative;\"><a href=\"#%EA%B0%95%EC%9D%9836-%EA%B0%80%EC%83%81%ED%99%94-%EA%B8%B0%EC%88%A0\" aria-label=\"강의36 가상화 기술 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[강의36] 가상화 기술</h2>\n<h2 id=\"가상화-기술의-도입\" style=\"position:relative;\"><a href=\"#%EA%B0%80%EC%83%81%ED%99%94-%EA%B8%B0%EC%88%A0%EC%9D%98-%EB%8F%84%EC%9E%85\" aria-label=\"가상화 기술의 도입 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>가상화 기술의 도입</h2>\n<h3 id=\"왜-가상화-기술을-사용하나\" style=\"position:relative;\"><a href=\"#%EC%99%9C-%EA%B0%80%EC%83%81%ED%99%94-%EA%B8%B0%EC%88%A0%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%82%98\" aria-label=\"왜 가상화 기술을 사용하나 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>왜 가상화 기술을 사용하나</h3>\n<ul>\n<li>확장성 → 오버헤드 최소화</li>\n<li>비용대비 성능 → 리소스 사용률 향상, 운용의 유연함</li>\n<li>고가용성 → 환경 격리</li>\n</ul>\n<h2 id=\"가상화-기술의-효용\" style=\"position:relative;\"><a href=\"#%EA%B0%80%EC%83%81%ED%99%94-%EA%B8%B0%EC%88%A0%EC%9D%98-%ED%9A%A8%EC%9A%A9\" aria-label=\"가상화 기술의 효용 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>가상화 기술의 효용</h2>\n<ul>\n<li>IPMI를 대체하는 하이퍼바이저\n<ul>\n<li>호스트 OS : 서버에서 최초에 기동하는 OS</li>\n</ul>\n</li>\n<li>하드웨어 간 차이 흡수 → 환경 추상화</li>\n<li>준 가상화 사용</li>\n<li>리소스 소비 제어\n<ul>\n<li>과부하 경고</li>\n<li>부하 조정</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"가상화-서버-구축정책\" style=\"position:relative;\"><a href=\"#%EA%B0%80%EC%83%81%ED%99%94-%EC%84%9C%EB%B2%84-%EA%B5%AC%EC%B6%95%EC%A0%95%EC%B1%85\" aria-label=\"가상화 서버 구축정책 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>가상화 서버 구축정책</h2>\n<ul>\n<li>하드웨어의 이용효율을 높이기 위해 남아있는 리소스를 사용하는 게스트 OS를 투입하는 것이다.\n<ul>\n<li>예를 들어 CPU 리소스가 남이있으면 웹 서버, I/O 리소스가 남아있으면 DB 서버, 메모리 용량이 남아있으면 캐시 서버를 투입한다.</li>\n<li>리소스 소비경향이 비슷한 게스트 OS는 서로 점유하려고 하므로 같이 두지 않는다.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"가상화로-얻은-장점-정리\" style=\"position:relative;\"><a href=\"#%EA%B0%80%EC%83%81%ED%99%94%EB%A1%9C-%EC%96%BB%EC%9D%80-%EC%9E%A5%EC%A0%90-%EC%A0%95%EB%A6%AC\" aria-label=\"가상화로 얻은 장점 정리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>가상화로 얻은 장점 정리</h2>\n<ul>\n<li>물리적인 리소스 제약에서 해방 → 동적으로 변경 가능</li>\n<li>게스트 OS의 마이그레이션 및 복제가 용이 → 서버 증설이 용이 + 확장성 확보</li>\n<li>소프트웨어 레벨에서 호스트 리소스 제어가능</li>\n<li>비정상 동작 시 문제를 국소화, 호스트를 쉽게 제어</li>\n<li>효율이 향상, 시스템 안정화 가능</li>\n<li>비용대비 성능 향상, 고가용성으로 발전</li>\n</ul>\n<h2 id=\"가상화-도입-시-주의할-점\" style=\"position:relative;\"><a href=\"#%EA%B0%80%EC%83%81%ED%99%94-%EB%8F%84%EC%9E%85-%EC%8B%9C-%EC%A3%BC%EC%9D%98%ED%95%A0-%EC%A0%90\" aria-label=\"가상화 도입 시 주의할 점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>가상화 도입 시 주의할 점</h2>\n<ul>\n<li>성능상 오버헤드가 있다.\n<ul>\n<li>CPU에서 2% - 3%</li>\n<li>메모리 성능에서 1할정도</li>\n<li>네트워크 성능 절반</li>\n<li>I/O 성능 5% 정도</li>\n</ul>\n</li>\n<li>상황에 따라서 가상화를 하는 것이 좋을수도 있고, 아닐수도 있다.</li>\n<li>지금은 가상화 기술이 더 안정되었을 것이다 → docker</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#%EA%B0%95%EC%9D%9836-%EA%B0%80%EC%83%81%ED%99%94-%EA%B8%B0%EC%88%A0\">[강의36] 가상화 기술</a></p>\n</li>\n<li>\n<p><a href=\"#%EA%B0%80%EC%83%81%ED%99%94-%EA%B8%B0%EC%88%A0%EC%9D%98-%EB%8F%84%EC%9E%85\">가상화 기술의 도입</a></p>\n<ul>\n<li><a href=\"#%EC%99%9C-%EA%B0%80%EC%83%81%ED%99%94-%EA%B8%B0%EC%88%A0%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%82%98\">왜 가상화 기술을 사용하나</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EA%B0%80%EC%83%81%ED%99%94-%EA%B8%B0%EC%88%A0%EC%9D%98-%ED%9A%A8%EC%9A%A9\">가상화 기술의 효용</a></p>\n</li>\n<li>\n<p><a href=\"#%EA%B0%80%EC%83%81%ED%99%94-%EC%84%9C%EB%B2%84-%EA%B5%AC%EC%B6%95%EC%A0%95%EC%B1%85\">가상화 서버 구축정책</a></p>\n</li>\n<li>\n<p><a href=\"#%EA%B0%80%EC%83%81%ED%99%94%EB%A1%9C-%EC%96%BB%EC%9D%80-%EC%9E%A5%EC%A0%90-%EC%A0%95%EB%A6%AC\">가상화로 얻은 장점 정리</a></p>\n</li>\n<li>\n<p><a href=\"#%EA%B0%80%EC%83%81%ED%99%94-%EB%8F%84%EC%9E%85-%EC%8B%9C-%EC%A3%BC%EC%9D%98%ED%95%A0-%EC%A0%90\">가상화 도입 시 주의할 점</a></p>\n</li>\n</ul>\n</div>","frontmatter":{"date":"September 28, 2021","title":"대규모 서비스를 지탱하는 기술 - 효율 향상 전략","categories":"웹 인프라 책 성능테스트","author":"코다","emoji":"📚"},"fields":{"slug":"/high-traffic-service_11/"}},"prev":{"id":"d93ef879-079d-56a0-858e-48a2ddb90717","html":"<blockquote>\n<p>다음은 <em>성공과 실패를 결정하는 1%의 네트워크 원리</em> 를 읽고 정리한 내용입니다. 본 글은 CH2. TCP/IP의 데이터를 전기 신호로 만들어 보낸다_프로토콜 스택과 LAN 어댑터의 탐험입니다 🙌</p>\n</blockquote>\n<br>\n<h2 id=\"-story1-소켓을-작성한다\" style=\"position:relative;\"><a href=\"#-story1-%EC%86%8C%EC%BC%93%EC%9D%84-%EC%9E%91%EC%84%B1%ED%95%9C%EB%8B%A4\" aria-label=\" story1 소켓을 작성한다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🛺 [Story1] 소켓을 작성한다.</h2>\n<h3 id=\"1-프로토콜-스택의-내부-구성\" style=\"position:relative;\"><a href=\"#1-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-%EC%8A%A4%ED%83%9D%EC%9D%98-%EB%82%B4%EB%B6%80-%EA%B5%AC%EC%84%B1\" aria-label=\"1 프로토콜 스택의 내부 구성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 프로토콜 스택의 내부 구성</h3>\n<ul>\n<li>네트워크를 제어하는 다음 두 가지가 필요하다.\n<ol>\n<li>소프트웨어 - (OS 내장) 프로토콜 스택</li>\n<li>하드웨어 - LAN 어댑터</li>\n</ol>\n</li>\n<li>아래가 네트워크 계층 구조이다.\n<ul>\n<li>\n<p>어플리케이션에서 데이터 송신을 시작한다. 이때 소켓 라이브러리를 사용하여 리졸버로 DNS 서버를 조회하는 등의 동작을 실행한다.</p>\n</li>\n<li>\n<p>OS 내부에 있는 프로토콜 스택이 그 다음 작업을 의뢰받는다.</p>\n<ul>\n<li>TCP 혹은 UDP로 데이터를 송수신한다.</li>\n<li><strong>IP 프로토콜로 패킷 송수신 동작을 제어한다. ICMP(패킷운반시 오류 통지, 제어용 메세지) 혹은 ARP(IP에 대응하는 MAC주소 조사)로 동작한다.</strong></li>\n</ul>\n</li>\n<li>\n<p>LAN 드라이버는 LAN 어댑터라는 하드웨어를 제어한다. LAN 어댑터라는 <strong>하드웨어가</strong> 실제 송수신 동작, 케이블 신호 송수신 동작을 제어한다.</p>\n<p align=\"center\"><img width=\"70%\" src=\"https://user-images.githubusercontent.com/63405904/138543586-0252b0b7-f015-466a-b5b5-1cc404b75d0b.png\"><br>출처: 상위 1% 네트워크</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-소켓은-통신-제어용-제어-정보이다\" style=\"position:relative;\"><a href=\"#2-%EC%86%8C%EC%BC%93%EC%9D%80-%ED%86%B5%EC%8B%A0-%EC%A0%9C%EC%96%B4%EC%9A%A9-%EC%A0%9C%EC%96%B4-%EC%A0%95%EB%B3%B4%EC%9D%B4%EB%8B%A4\" aria-label=\"2 소켓은 통신 제어용 제어 정보이다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 소켓은 통신 제어용 제어 정보이다</h3>\n<ul>\n<li>소켓 내부에 제어 정보를 기록하는 메모리 영역이 존재 → 통신 동작 제어용 정보를 기록한다.\n<ul>\n<li>ex. 통신 상대의 IP 주소, 포트 번호, 통신 동작 진행 상태 등등</li>\n<li>이것에 소켓의 실체이다 → 제어 정보의 집합</li>\n</ul>\n</li>\n<li>프로토콜 스택은 위 제어정보를 참조하여 동작한다.\n<ul>\n<li>제어 정보를 참조하여 송신 대상으로 데이터를 송신하고 응답을 기다린다.</li>\n<li>일정 시간 경과 후 응답이 오지 않으면 데이터를 재송신 한다. (즉, 경과 시간등을 기록한다)</li>\n<li>이외의 많은 역할들을 한다. (이후에 추가적으로 다룸)</li>\n</ul>\n</li>\n<li>소켓을 만든다는 것\n<ul>\n<li><code class=\"language-text\">netstat</code>(윈도우 경우) 명령어에 의해서 나오는 소켓 통신 정보에 해당 소켓에 대한 제어정보를 추가하는 것\n<ul>\n<li><code class=\"language-text\">netstat</code> 명령어 입력시 Local Address에 여러 IP 주소가 나온다면 여러 LAN 어댑터를 보유하고 있다는 뜻이다.</li>\n<li>IP가 <code class=\"language-text\">0.0.0.0</code> 으로 기재되는 것은 양측이 모두 통신을 시작하지 않아서 IP가 정해지지 않았기 때문이다.</li>\n</ul>\n</li>\n<li>통신을 시작하는 부분의 상태를 기록하고 송수신 데이터를 일시적으로 저장하는 버퍼 메모리를 준비하는 것 등등</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-소켓을-호출했을-때-동작\" style=\"position:relative;\"><a href=\"#3-%EC%86%8C%EC%BC%93%EC%9D%84-%ED%98%B8%EC%B6%9C%ED%96%88%EC%9D%84-%EB%95%8C-%EB%8F%99%EC%9E%91\" aria-label=\"3 소켓을 호출했을 때 동작 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 소켓을 호출했을 때 동작</h3>\n<p>먼저 Socket 라이브러리의 <code class=\"language-text\">socket</code> 메서드를 호출하여 프로토콜 스택에 의뢰해 소켓을 하나 생성한다.</p>\n<ul>\n<li>프로토콜 스택은 소켓 한 개가 사용하는 메모리 영역을 확보한다.</li>\n<li>아직 통신 이전이면 초기 상태의 정보를 메모리에 기록한다.</li>\n<li>포로토콜 스택은 소켓에 대한 디스크립터를 어플리케이션에 알려준다.</li>\n<li>이 디스크립터를 통해 어플리케이션은 이후 데이터 송수신을 프로토콜 스택에 의뢰한다.</li>\n<li>디스크립터만 있으면 프로토콜 스택이 소켓의 통신 상태, 상대 소켓 등등의 기타 정보를 모두 알 수 있다. (어플리케이션은 해당 정보에 대해서 알 필요가 없다)</li>\n</ul>\n<br>\n<h2 id=\"-story2-서버에-접속한다\" style=\"position:relative;\"><a href=\"#-story2-%EC%84%9C%EB%B2%84%EC%97%90-%EC%A0%91%EC%86%8D%ED%95%9C%EB%8B%A4\" aria-label=\" story2 서버에 접속한다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🛺 [Story2] 서버에 접속한다.</h2>\n<h3 id=\"1-접속의-의미\" style=\"position:relative;\"><a href=\"#1-%EC%A0%91%EC%86%8D%EC%9D%98-%EC%9D%98%EB%AF%B8\" aria-label=\"1 접속의 의미 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 접속의 의미</h3>\n<p>어플리케이션은 소켓 생성 후 <code class=\"language-text\">connect</code> 메서드를 호출하여 접속 동작을 시작한다. 여기서 말하는 접속 동작은 케이블 등을 연결하는 접속 동작이 아니다. 주로 필요한 회선 및 케이블은 이미 연결이 되어 있다.</p>\n<p>접속동작이라고 하는 것은 <strong>데이터를 주고받고자 하는 대상과 필요한 정보를 주고받아서 기록하고 데이터 송수신이 가능한 상태로 만드는 것</strong>이다.</p>\n<ul>\n<li>초기상태\n<ul>\n<li>아무것도 기록되어 있지 않으므로 상대 소켓에 대한 IP 주소와 포트번호에 대한 정보가 필요하다.</li>\n<li>connect 메소드는 어플리케이션이 알고 있는 상대 소켓의 IP 주소(DNS 리졸버를 통해서 획득한 정보) 및 포트 번호(사용자가 이미 알고 있는 정보)를 프로토콜 스택에 알려 소켓에 기록하는 로직을 수행한다.</li>\n</ul>\n</li>\n<li>대상 소켓B도 소켓을 생성한 후에 자신과 접속하고자 하는 소켓A를 알지 못하므로 소켓을 생성하고 소켓A가 접속을 원한다는 요청을 받기 이전까지 대기한다. 요청을 받으면 소켓B도 소켓A의 정보를 기록하여 통신할 수 있도록 한다.</li>\n<li>소켓에 접속하는 <code class=\"language-text\">connect</code> 수행 시 데이터 송수신 메모리 버퍼도 확보한다.</li>\n</ul>\n<h3 id=\"2-소켓-앞에-제어-정보를-기록한-헤더-배치\" style=\"position:relative;\"><a href=\"#2-%EC%86%8C%EC%BC%93-%EC%95%9E%EC%97%90-%EC%A0%9C%EC%96%B4-%EC%A0%95%EB%B3%B4%EB%A5%BC-%EA%B8%B0%EB%A1%9D%ED%95%9C-%ED%97%A4%EB%8D%94-%EB%B0%B0%EC%B9%98\" aria-label=\"2 소켓 앞에 제어 정보를 기록한 헤더 배치 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 소켓 앞에 제어 정보를 기록한 헤더 배치</h3>\n<ul>\n<li>소켓에 기록되는 제어정보는 무엇이 있을까 - 이 정보는 소켓의 헤더에 포함되서 보내진다.\n<ul>\n<li><strong>이더넷 혹은 IP 헤더</strong> + <strong>TCP 헤더</strong> - 클라이언트와 서버가 통신하기 위해서 필요한 정보이다. 이 정보는 소켓의 헤더에 포함되서 보내진다.\n<ul>\n<li>헤더 사양이 정해져있다. 점점 통신을 하면서 덧붙여간다.</li>\n</ul>\n</li>\n<li>소켓(프로토콜 스택 메모리 영역)에 기록되는 정보\n<ul>\n<li>송수신 동작은 진행상황</li>\n<li>어플리케이션에서 받은 정보, 통신 상대로부터 받은 정보</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>소켓의 제어 정보에 따라서 프로토콜 스택의 동작 대부분이 결정지어 지기 때문에 결합도가 매우 높다.</li>\n</ul>\n<h3 id=\"3-접속-동작의-실체\" style=\"position:relative;\"><a href=\"#3-%EC%A0%91%EC%86%8D-%EB%8F%99%EC%9E%91%EC%9D%98-%EC%8B%A4%EC%B2%B4\" aria-label=\"3 접속 동작의 실체 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 접속 동작의 실체</h3>\n<ul>\n<li><code class=\"language-text\">connect</code>를 호출하며 상대 IP와 포트 번호를 함께 쓴다.</li>\n<li>프로토콜 스택의 <strong>TCP 담당</strong>이 상대와 정보를 주고받아 헤더에 주고받은 정보를 기록하는 다음 과정을 거친다(송신처와 수신처 포트 번호 등등의 중요한 정보)\n<ul>\n<li>상대소켓 지정(IP주소와 포트번호)과 헤더설정 끝나면 SYN 비트(컨트롤비트)를 1로 설정한다.</li>\n</ul>\n</li>\n<li>TCP 헤더 생성 이후 프로토콜 스택 내부의 <strong>IP 담당</strong>에게 넘겨주어 패킷 송신 동작을 실행하도록 한다. (여기서 송신한 패킷은 상대서버의 IP 담당이 받아 TCP 담당에게 넘겨준다)</li>\n<li><strong>상대 소켓의 TCP 담당은 받은 패킷의 수신처 포트번호에 적힌 소켓을 찾는다.</strong> 소켓을 지정하여 필요한 정보를 기록하고 응답을 보낸다.</li>\n<li>응답을 보낼때, 마찬가지로 SYN을 1(시퀀스 초기번호)로 설정하고 TCP 헤더에 필요 정보를 설정한다. 추가로 패킷을 성공적으로 받았다고 알리는 ACK 비트를 1로 설정한다.</li>\n<li>생성된 헤더 정보를 IP 담당에게 넘겨 다시 응답한다.</li>\n<li>응답을 받은 소켓은 SYN 비트를 확인하여 접속이 성공했는지 보고 성공이라면 접속 완료를 기록한다. 그리고 상대 소켓에 패킷을 잘 받았다는 ACK 비트를 1로 만든 패킷으로 응답한다.</li>\n</ul>\n<p align=\"center\"><img width=\"70%\" src=\"https://user-images.githubusercontent.com/63405904/138543684-50c4a737-99d8-48cc-9c11-c47cb793dfb9.png\"><br>출처: 상위 1% 네트워크</p>\n<br>\n<h2 id=\"-story3-데이터를-송수신-한다\" style=\"position:relative;\"><a href=\"#-story3-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A5%BC-%EC%86%A1%EC%88%98%EC%8B%A0-%ED%95%9C%EB%8B%A4\" aria-label=\" story3 데이터를 송수신 한다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🛺 [Story3] 데이터를 송수신 한다.</h2>\n<h3 id=\"1-프로토콜-스택에-http-리퀘스트-메세지를-넘긴다\" style=\"position:relative;\"><a href=\"#1-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-%EC%8A%A4%ED%83%9D%EC%97%90-http-%EB%A6%AC%ED%80%98%EC%8A%A4%ED%8A%B8-%EB%A9%94%EC%84%B8%EC%A7%80%EB%A5%BC-%EB%84%98%EA%B8%B4%EB%8B%A4\" aria-label=\"1 프로토콜 스택에 http 리퀘스트 메세지를 넘긴다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 프로토콜 스택에 HTTP 리퀘스트 메세지를 넘긴다</h3>\n<p><code class=\"language-text\">write</code> 메서드를 호출하여 송신하고자 하는 데이터를 프로토콜 스택에 넘긴다.</p>\n<ul>\n<li>어플리케이션에서 받은 데이터를 프로토콜 스택 내부의 버퍼 메모리 영역에 우선 저장한다.\n<ul>\n<li>이유는, 어플리케이션에 건네주는 데이터의 크기는 프로토콜 스택이 제어할 수 없기 때문에 받은 데이터를 곧바로 보내면 데이터 송수신 동작이 지나치게 많이 일어나서 네트워크 효율이 떨어진다.</li>\n<li>패킷의 최대크기인 MTU에서 헤더를 제외한 MSS 만큼의 최대 데이터를 보낼 수 있다. (이것보다 작은 데이터를 보내는 경우 패킷이 예상치 못하게 나누어지지 않는다)</li>\n<li>하지만 항상 버퍼를 꽉 채워서 데이터를 보내는 경우 대기 시간이 길어지므로 송신 동작이 지연된다.</li>\n<li>네트워크 이용 효율을 중시하는지, 송신 동작 시간을 중시하는지 잘 절충해야한다. (프로토콜 스택을 구현한 OS에서 담당하며 어플리케이션 레벨에서 어느 정도 설정을 할 수도 있다)</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-데이터가-클-때는-분할하여-보낸다\" style=\"position:relative;\"><a href=\"#2-%EB%8D%B0%EC%9D%B4%ED%84%B0%EA%B0%80-%ED%81%B4-%EB%95%8C%EB%8A%94-%EB%B6%84%ED%95%A0%ED%95%98%EC%97%AC-%EB%B3%B4%EB%82%B8%EB%8B%A4\" aria-label=\"2 데이터가 클 때는 분할하여 보낸다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 데이터가 클 때는 분할하여 보낸다</h3>\n<ul>\n<li>데이터가 지나치게 크면 MSS 크기만큼 분할하여 패킷(헤더 + 데이터)을 만들어 보낸다.</li>\n</ul>\n<h3 id=\"3-ack-번호를-사용하여-패킷이-도착했는지-확인한다\" style=\"position:relative;\"><a href=\"#3-ack-%EB%B2%88%ED%98%B8%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EC%97%AC-%ED%8C%A8%ED%82%B7%EC%9D%B4-%EB%8F%84%EC%B0%A9%ED%96%88%EB%8A%94%EC%A7%80-%ED%99%95%EC%9D%B8%ED%95%9C%EB%8B%A4\" aria-label=\"3 ack 번호를 사용하여 패킷이 도착했는지 확인한다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. ACK 번호를 사용하여 패킷이 도착했는지 확인한다</h3>\n<ul>\n<li>\n<p><strong>ACK 번호 = 수신을 완료한 바이트 + 1</strong></p>\n</li>\n<li>\n<p>최초 3way handshake를 할 때 초기 시퀀스 번호를 함께 주고받는다.</p>\n<ul>\n<li>초기 시퀀스 번호를 악용할 수 있기 때문에 난수로 설정하여 미리 주고받는다.</li>\n</ul>\n</li>\n<li>\n<p>이후 <code class=\"language-text\">최초 시퀀스 번호 + 데이터의 크기</code> 만큼의 데이터를 수신했다면 그것에 대한 확인으로 <code class=\"language-text\">지금까지 수신한 바이트 + 1</code> 숫자를 ACK로 지정하여 응답한다.</p>\n<ul>\n<li>데이터의 크기는 어떻게 알 수 있을까? 보낸 패킷에 헤더길이를 빼면 수신한 데이터의 크기를 유추할 수 있기 때문에 따로 기재하지 않는다.</li>\n</ul>\n</li>\n<li>\n<p>이후 송신할 데이터를 시퀀스 번호로 지정하고 송신하고, 동일하게 수신한 마지막 바이트 + 1을 ACK로 응답한다.</p>\n<p align=\"center\"><img width=\"70%\" src=\"https://user-images.githubusercontent.com/63405904/138543698-a54e59f0-b7a5-48c8-896d-419eccce982f.png\"><br>출처: 상위 1% 네트워크</p>\n</li>\n<li>\n<p>시퀀스번호와 ACK 번호로 누락된 패킷 여부를 알 수 있다. 만일 누락되었으면 송신 버퍼 메모리에 저장되어 있는 데이터를 재송신한다.</p>\n<ul>\n<li><strong>이렇게 TCP는 누락을 검출하고 회복 처리를 한다.</strong></li>\n<li>LAN 어댑터, 버퍼, 라우터는 회복조치를 취하지 않는다. 오류가 검출되면 패킷을 버린다.</li>\n<li>TCP 여러번 패킷을 재송신해도 오류가 난다면 동작을 중지하고 어플리케이션에 오류를 통지한다.</li>\n</ul>\n</li>\n<li>\n<p>양방향 통신이 이루어지는 경우 역으로 동일하게 수행하면 된다.</p>\n<p align=\"center\"><img width=\"70%\" src=\"https://user-images.githubusercontent.com/63405904/138543707-85dcb8c9-5725-4039-828f-f588255ec919.png\"><br>출처: 상위 1% 네트워크</p>\n</li>\n</ul>\n<h3 id=\"4-패킷-평균-왕복-시간으로-ack-번호의-대기-시간을-조정한다\" style=\"position:relative;\"><a href=\"#4-%ED%8C%A8%ED%82%B7-%ED%8F%89%EA%B7%A0-%EC%99%95%EB%B3%B5-%EC%8B%9C%EA%B0%84%EC%9C%BC%EB%A1%9C-ack-%EB%B2%88%ED%98%B8%EC%9D%98-%EB%8C%80%EA%B8%B0-%EC%8B%9C%EA%B0%84%EC%9D%84-%EC%A1%B0%EC%A0%95%ED%95%9C%EB%8B%A4\" aria-label=\"4 패킷 평균 왕복 시간으로 ack 번호의 대기 시간을 조정한다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. 패킷 평균 왕복 시간으로 ACK 번호의 대기 시간을 조정한다</h3>\n<ul>\n<li>ACK가 오지 않는 것으로 패킷 유실을 판단하는데 ACK를 평생 기다릴 수 없으니 타임아웃 값 만큼 기다린다.\n<ul>\n<li>제대로 수신하였는데 네트워크가 혼잡하여 ACK가 오지 못하는 상황일수도 있으니 타임아웃 값을 적절하게 잘 설정해야한다.</li>\n<li>네트워크 혼잡으로 ACK를 받지 못했을때 패킷을 재송신 하면 네트워크에 부하를 얹는 것이다. 하지만 너무 오래 기다리면 속도가 지연의 원인이 된다.</li>\n<li>상황에 따라서 항상 다르기 때문에 대기 시간을 동적으로 변경한다.\n<ul>\n<li>항상 ACK가 돌아오는 시간을 기록하고 그 시간이 길어지면 대기 시간도 늘리며 짧으면 대기 시간도 줄인다.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"5-윈도우sliding-window-제어-방식으로-ack-번호를-관리한다\" style=\"position:relative;\"><a href=\"#5-%EC%9C%88%EB%8F%84%EC%9A%B0sliding-window-%EC%A0%9C%EC%96%B4-%EB%B0%A9%EC%8B%9D%EC%9C%BC%EB%A1%9C-ack-%EB%B2%88%ED%98%B8%EB%A5%BC-%EA%B4%80%EB%A6%AC%ED%95%9C%EB%8B%A4\" aria-label=\"5 윈도우sliding window 제어 방식으로 ack 번호를 관리한다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5. 윈도우(Sliding Window) 제어 방식으로 ACK 번호를 관리한다</h3>\n<ul>\n<li><a href=\"http://blog.skby.net/%EC%8A%AC%EB%9D%BC%EC%9D%B4%EB%94%A9-%EC%9C%88%EB%8F%84%EC%9A%B0sliding-window/\">http://blog.skby.net/슬라이딩-윈도우sliding-window/</a></li>\n<li>패킷을 하나 보내고 ACK를 기다리고 또 패킷을 보내고 ACK를 기다리는 핑퐁 방식은 시간을 소요한다. 복수개의 패킷을 보내는 슬라이딩 윈도우 기법으로 효율적으로 관리하도록 한다.\n<ul>\n<li>핑퐁의 경우 ack가 와야만 다음 패킷을 보내기 때문에 수신하는 측의 능력만큼 패킷을 보낸다.</li>\n<li>슬라이딩 윈도우는 여러개의 패킷을 우선 보내기 때문에 수신측의 능력을 초과하여 패킷을 보낼수도 있다. 이것을 방지하기 위해서 <strong>수신측의 수신버퍼만큼만 패킷을 보내도록 슬라이딩 윈도우 기법으로 송신</strong>하는 패킷 사이즈를 조절한다.</li>\n</ul>\n</li>\n<li>수신측이 ACK 값 산출 등의 후처리를 하는 동안 수신한 데이터를 일시적으로 수신 버퍼 메모리에 저장한다. 이때 송신측에서 수신 버퍼 메모리가 넘치도록 패킷을 보내면 수신측의 능력을 초과한 것이다.</li>\n<li>이것을 해결하기 위해 슬라이딩 윈도우 방식에서 <strong>수신 측에 빈 버퍼  최대 사이즈(윈도우 사이즈)를 TCP 헤더의 윈도우 필드에 기록</strong>하여 송신측에 알려준다.\n<ul>\n<li>\n<p>송신측에 알려주는 타이밍은 수신 버퍼에서 메모리를 추출하여 빈 공간이 추가로 생긴 타이밍이다. 점점 줄어드는 사이즈는 패킷의 데이터 사이즈를 통해서 유추할 수 있다.</p>\n<p align=\"center\"><img width=\"70%\" src=\"https://user-images.githubusercontent.com/63405904/138543713-a05c8851-30df-4e28-bd9e-9a1fc91b166d.png\"><br>출처: 상위 1% 네트워크</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"6-윈도우-사이즈--ack-합승\" style=\"position:relative;\"><a href=\"#6-%EC%9C%88%EB%8F%84%EC%9A%B0-%EC%82%AC%EC%9D%B4%EC%A6%88--ack-%ED%95%A9%EC%8A%B9\" aria-label=\"6 윈도우 사이즈  ack 합승 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>6. 윈도우 사이즈 + ACK 합승</h3>\n<ul>\n<li>ACK번호와 윈도우 사이즈를 각각 다른 패킷에 송신하면 주고받는 패킷이 너무 많기 때문에 효율적이지 않다.</li>\n<li>둘 중 하나만 생성되었을 때 기다리다가 두 개가 모두 일어나면 함께 하나의 패킷으로 송신한다.</li>\n<li>복수개의 ACK가 생겼을 때도 최후의 것만 송신한다.</li>\n<li>복수 윈도우 통지가 발생해도 최후 윈도우 사이즈만 보낸다.</li>\n</ul>\n<h3 id=\"7-http-응답-메세지를-수신한다\" style=\"position:relative;\"><a href=\"#7-http-%EC%9D%91%EB%8B%B5-%EB%A9%94%EC%84%B8%EC%A7%80%EB%A5%BC-%EC%88%98%EC%8B%A0%ED%95%9C%EB%8B%A4\" aria-label=\"7 http 응답 메세지를 수신한다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>7. HTTP 응답 메세지를 수신한다</h3>\n<ul>\n<li>프로토콜 스택이 HTTP 요청 메세지를 모두 보면 응답 메세지를 수신해야한다.</li>\n<li><code class=\"language-text\">read</code> 메서드를 호출해 프로토콜 수택이 수신 버퍼에 응답 메세지를 수신한다.</li>\n<li>응답 메세지가 일정 시간 후 도착해 수신 버퍼에 담기면 프로토콜 스택은 그것을 추출해 어플리케이션에 넘겨준다.</li>\n<li>수신 데이터에 TCP 헤더 정보를 통해 누락된 데이터가 없는지 확인하고 ACK를 응답한다. 데이터 조각을 버퍼에 보관하고 원래 데이터로 복원하여 어플리케이션에 보낸다.</li>\n<li>어플리케이션에 데이터를 추출한 타이밍에 윈도우 사이즈를 상대에 통지한다.</li>\n</ul>\n<br>\n<br>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[용어]\n\n패킷 - 네트워크에 운반되는 분할된 데이터의 덩어리 단위 \n\nMAC 주소 - LAN 방식의 기기가 가지고 있는 형식의 주소 \n\nPID - Process ID의 약자. OS가 각 프로세스에 할당하는 번호 \n\n소켓 - 통신 파이프 양 끝에 있는 출입구와 같은 것 \n\nMTU - Maximum Transmission Unit 패킷 하나에 운받하는 디지털 데이터의 최대길이 (이더넷 1500바이트)\n\nMSS - Maximum Segment Size 헤더를 제외한 TCP 데이터의 최대길이</code></pre></div>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#-story1-%EC%86%8C%EC%BC%93%EC%9D%84-%EC%9E%91%EC%84%B1%ED%95%9C%EB%8B%A4\">🛺 [Story1] 소켓을 작성한다.</a></p>\n<ul>\n<li><a href=\"#1-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-%EC%8A%A4%ED%83%9D%EC%9D%98-%EB%82%B4%EB%B6%80-%EA%B5%AC%EC%84%B1\">1. 프로토콜 스택의 내부 구성</a></li>\n<li><a href=\"#2-%EC%86%8C%EC%BC%93%EC%9D%80-%ED%86%B5%EC%8B%A0-%EC%A0%9C%EC%96%B4%EC%9A%A9-%EC%A0%9C%EC%96%B4-%EC%A0%95%EB%B3%B4%EC%9D%B4%EB%8B%A4\">2. 소켓은 통신 제어용 제어 정보이다</a></li>\n<li><a href=\"#3-%EC%86%8C%EC%BC%93%EC%9D%84-%ED%98%B8%EC%B6%9C%ED%96%88%EC%9D%84-%EB%95%8C-%EB%8F%99%EC%9E%91\">3. 소켓을 호출했을 때 동작</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-story2-%EC%84%9C%EB%B2%84%EC%97%90-%EC%A0%91%EC%86%8D%ED%95%9C%EB%8B%A4\">🛺 [Story2] 서버에 접속한다.</a></p>\n<ul>\n<li><a href=\"#1-%EC%A0%91%EC%86%8D%EC%9D%98-%EC%9D%98%EB%AF%B8\">1. 접속의 의미</a></li>\n<li><a href=\"#2-%EC%86%8C%EC%BC%93-%EC%95%9E%EC%97%90-%EC%A0%9C%EC%96%B4-%EC%A0%95%EB%B3%B4%EB%A5%BC-%EA%B8%B0%EB%A1%9D%ED%95%9C-%ED%97%A4%EB%8D%94-%EB%B0%B0%EC%B9%98\">2. 소켓 앞에 제어 정보를 기록한 헤더 배치</a></li>\n<li><a href=\"#3-%EC%A0%91%EC%86%8D-%EB%8F%99%EC%9E%91%EC%9D%98-%EC%8B%A4%EC%B2%B4\">3. 접속 동작의 실체</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-story3-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A5%BC-%EC%86%A1%EC%88%98%EC%8B%A0-%ED%95%9C%EB%8B%A4\">🛺 [Story3] 데이터를 송수신 한다.</a></p>\n<ul>\n<li><a href=\"#1-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-%EC%8A%A4%ED%83%9D%EC%97%90-http-%EB%A6%AC%ED%80%98%EC%8A%A4%ED%8A%B8-%EB%A9%94%EC%84%B8%EC%A7%80%EB%A5%BC-%EB%84%98%EA%B8%B4%EB%8B%A4\">1. 프로토콜 스택에 HTTP 리퀘스트 메세지를 넘긴다</a></li>\n<li><a href=\"#2-%EB%8D%B0%EC%9D%B4%ED%84%B0%EA%B0%80-%ED%81%B4-%EB%95%8C%EB%8A%94-%EB%B6%84%ED%95%A0%ED%95%98%EC%97%AC-%EB%B3%B4%EB%82%B8%EB%8B%A4\">2. 데이터가 클 때는 분할하여 보낸다</a></li>\n<li><a href=\"#3-ack-%EB%B2%88%ED%98%B8%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EC%97%AC-%ED%8C%A8%ED%82%B7%EC%9D%B4-%EB%8F%84%EC%B0%A9%ED%96%88%EB%8A%94%EC%A7%80-%ED%99%95%EC%9D%B8%ED%95%9C%EB%8B%A4\">3. ACK 번호를 사용하여 패킷이 도착했는지 확인한다</a></li>\n<li><a href=\"#4-%ED%8C%A8%ED%82%B7-%ED%8F%89%EA%B7%A0-%EC%99%95%EB%B3%B5-%EC%8B%9C%EA%B0%84%EC%9C%BC%EB%A1%9C-ack-%EB%B2%88%ED%98%B8%EC%9D%98-%EB%8C%80%EA%B8%B0-%EC%8B%9C%EA%B0%84%EC%9D%84-%EC%A1%B0%EC%A0%95%ED%95%9C%EB%8B%A4\">4. 패킷 평균 왕복 시간으로 ACK 번호의 대기 시간을 조정한다</a></li>\n<li><a href=\"#5-%EC%9C%88%EB%8F%84%EC%9A%B0sliding-window-%EC%A0%9C%EC%96%B4-%EB%B0%A9%EC%8B%9D%EC%9C%BC%EB%A1%9C-ack-%EB%B2%88%ED%98%B8%EB%A5%BC-%EA%B4%80%EB%A6%AC%ED%95%9C%EB%8B%A4\">5. 윈도우(Sliding Window) 제어 방식으로 ACK 번호를 관리한다</a></li>\n<li><a href=\"#6-%EC%9C%88%EB%8F%84%EC%9A%B0-%EC%82%AC%EC%9D%B4%EC%A6%88--ack-%ED%95%A9%EC%8A%B9\">6. 윈도우 사이즈 + ACK 합승</a></li>\n<li><a href=\"#7-http-%EC%9D%91%EB%8B%B5-%EB%A9%94%EC%84%B8%EC%A7%80%EB%A5%BC-%EC%88%98%EC%8B%A0%ED%95%9C%EB%8B%A4\">7. HTTP 응답 메세지를 수신한다</a></li>\n</ul>\n</li>\n</ul>\n</div>","frontmatter":{"date":"September 29, 2021","title":"성공과 실패를 결정하는 1%의 네트워크 원리_3","categories":"네트워크 책","author":"코다","emoji":"⚡️"},"fields":{"slug":"/one-percent-network-3/"}},"site":{"siteMetadata":{"siteUrl":"https://yjksw.github.io","comments":{"utterances":{"repo":"yjksw/yjksw.github.io"}}}}},"pageContext":{"slug":"/high-traffic-service_12/","nextSlug":"/high-traffic-service_11/","prevSlug":"/one-percent-network-3/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}
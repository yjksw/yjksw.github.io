{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/handler-method-argument-resolver/",
    "result": {"data":{"cur":{"id":"1f652c1c-da4d-5aba-86ee-d66e7a606fcb","html":"<h2 id=\"intro\" style=\"position:relative;\"><a href=\"#intro\" aria-label=\"intro permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>INTRO</h2>\n<ul>\n<li><code class=\"language-text\">HandlerMethodArgumentResolver</code>는 Spring framework에서 제공하는 인터페이스로 request에서 메소드의 parameters를 해당하는 인자값으로 변환 혹은 바인딩 하는 resolver이다.</li>\n</ul>\n<br>\n<h2 id=\"인터페이스-내용\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-%EB%82%B4%EC%9A%A9\" aria-label=\"인터페이스 내용 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>인터페이스 내용</h2>\n<p><code class=\"language-text\">HandelrMethodArgumentResolver</code>에는 두가지 메소드가 있다.</p>\n<ol>\n<li><code class=\"language-text\">supportsParameter()</code></li>\n<li><code class=\"language-text\">resolveArgument()</code></li>\n</ol>\n<br>\n<h2 id=\"첫번째-parameter가-해당-resolver를-지원하는-여부-확인\" style=\"position:relative;\"><a href=\"#%EC%B2%AB%EB%B2%88%EC%A7%B8-parameter%EA%B0%80-%ED%95%B4%EB%8B%B9-resolver%EB%A5%BC-%EC%A7%80%EC%9B%90%ED%95%98%EB%8A%94-%EC%97%AC%EB%B6%80-%ED%99%95%EC%9D%B8\" aria-label=\"첫번째 parameter가 해당 resolver를 지원하는 여부 확인 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>첫번째, Parameter가 해당 resolver를 지원하는 여부 확인</h2>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token function\">supportsParameter</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">MethodParameter</span> parameter<span class=\"token punctuation\">)</span></code></pre></div>\n<p><strong>[참고]</strong> 아래 설명은 <code class=\"language-text\">@RequestBody</code>가 붙은 인자의 경우를 보는 것이므로 그 구현체가 <code class=\"language-text\">RequestResponseBodyMethodProcess.java</code>의 예시로 설명한 것이다. <br></p>\n<ul>\n<li>Parameter가 있는 수만큼 <code class=\"language-text\">InvocableHanderMethod#InvokeForRequest()</code> → <code class=\"language-text\">getMethodArgumentValues()</code> 안에서 for문을 돌면서 해당 parameter에 대한 argument resolve를 한다. 이때 resolve를 하기 위해서 현재 클래스가 가지고 있는 <code class=\"language-text\">resolvers</code> 가 해당 parameter 지원 하는지 여부를 확인한다.</li>\n<li>→ 확인하는 로직은 <code class=\"language-text\">HandlerMethodArgumentResolverComposite</code> 안에 있는 resolver들의 배열을 돌면서(한번 찾으면 캐싱함) 해당 parameter를 지원하는 resolver를 찾아서 반환하고, null인지 여부를 체크해 boolean을 반환한다. 이때 <code class=\"language-text\">supportsParameter()</code> 메소드가 수행된다.</li>\n<li>→ 다시 <code class=\"language-text\">InvocableHanderMethod#InvokeForRequest()</code> → <code class=\"language-text\">getMethodArgumentValues()</code> 의 반복문 안에서  <code class=\"language-text\">HandlerMethodArgumentResolver#resolveArgument()</code> 가 실행이 되면서(어노테이션에 따라서 구현체가 각기 따로 있음 ex. <code class=\"language-text\">RequestResponseBodyMethodProcess</code> 등등) controller 메서드에서 사용되는 인자를 배열에 저장한다.</li>\n</ul>\n<br>\n<h2 id=\"두번째-해당-parameter를-argument-value로-변환-및-바인딩\" style=\"position:relative;\"><a href=\"#%EB%91%90%EB%B2%88%EC%A7%B8-%ED%95%B4%EB%8B%B9-parameter%EB%A5%BC-argument-value%EB%A1%9C-%EB%B3%80%ED%99%98-%EB%B0%8F-%EB%B0%94%EC%9D%B8%EB%94%A9\" aria-label=\"두번째 해당 parameter를 argument value로 변환 및 바인딩 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>두번째, 해당 parameter를 argument value로 변환 및 바인딩</h2>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token function\">resolveArgument</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">MethodParameter</span> parameter<span class=\"token punctuation\">,</span> <span class=\"token class-name\">ModelAndViewContainer</span> mavContainer<span class=\"token punctuation\">,</span> <span class=\"token class-name\">NativeWebRequest</span> webRequest<span class=\"token punctuation\">,</span> <span class=\"token class-name\">WebDataBinderFactory</span> binderFactory<span class=\"token punctuation\">)</span></code></pre></div>\n<p>Method parameter를 argument value로 변환 및 바인딩 하는 역할을 한다.</p>\n<ul>\n<li><code class=\"language-text\">ModelAndViewContainer</code> 는 request의 model에 접근할 수 있도록 한다.</li>\n<li><code class=\"language-text\">WebDataBinderFactory</code>는 <code class=\"language-text\">WebDataBinder</code> 인스턴스를 추출해 데이터 바인딩이나 타입 변환을 지원한다.</li>\n</ul>\n<p>성공 시 argument value를 리턴하고, 없다면 <code class=\"language-text\">null</code>을 리턴한다.</p>\n<p>만일 <code class=\"language-text\">@Valid</code> 어노테이션이 해당 인자에 붙어있다면 해당하는 validation도 이 메소드에서 처리한다.</p>\n<br>\n<h2 id=\"custom-resolver-구현\" style=\"position:relative;\"><a href=\"#custom-resolver-%EA%B5%AC%ED%98%84\" aria-label=\"custom resolver 구현 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Custom Resolver 구현</h2>\n<ol>\n<li><code class=\"language-text\">HandlerMethodArgumentResolver</code> 인터페이스를 구현하는 custom resovler 클래스를 구현</li>\n<li><code class=\"language-text\">@Override</code> 한 <code class=\"language-text\">supportParameter()</code> 메소드에서 원하는 타입의 인자인 경우 <code class=\"language-text\">true</code>를 반환하도록 구현</li>\n<li><code class=\"language-text\">@Override</code>한 <code class=\"language-text\">resolveArgument()</code>에서 controller의 메서드 인자로 보면 값을 반환하도록 구현</li>\n<li><code class=\"language-text\">WebMvcConfiguration</code> 를 구현하는 클래스의 <code class=\"language-text\">addArgumentResolver()</code>라는 메소드를 override하여 위 구현한 custom resolver를 추가해준다.</li>\n</ol>\n<br>\n<br>\n<p><strong>[참고링크]</strong></p>\n<ul>\n<li><a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/method/support/HandlerMethodArgumentResolver.html\">https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/method/support/HandlerMethodArgumentResolver.html</a></li>\n<li><a href=\"https://enai.tistory.com/31\">https://enai.tistory.com/31</a></li>\n</ul>\n<br>\n<p><strong>[유용링크]</strong></p>\n<ul>\n<li>스프링에서 요청을 처리하는 과정\n<a href=\"https://m.blog.naver.com/PostView.nhn?blogId=duco777&#x26;logNo=220605479481&#x26;proxyReferer=https:%2F%2Fwww.google.com%2F\">https://m.blog.naver.com/PostView.nhn?blogId=duco777&#x26;logNo=220605479481&#x26;proxyReferer=https:%2F%2Fwww.google.com%2F</a></li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#intro\">INTRO</a></li>\n<li><a href=\"#%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-%EB%82%B4%EC%9A%A9\">인터페이스 내용</a></li>\n<li><a href=\"#%EC%B2%AB%EB%B2%88%EC%A7%B8-parameter%EA%B0%80-%ED%95%B4%EB%8B%B9-resolver%EB%A5%BC-%EC%A7%80%EC%9B%90%ED%95%98%EB%8A%94-%EC%97%AC%EB%B6%80-%ED%99%95%EC%9D%B8\">첫번째, Parameter가 해당 resolver를 지원하는 여부 확인</a></li>\n<li><a href=\"#%EB%91%90%EB%B2%88%EC%A7%B8-%ED%95%B4%EB%8B%B9-parameter%EB%A5%BC-argument-value%EB%A1%9C-%EB%B3%80%ED%99%98-%EB%B0%8F-%EB%B0%94%EC%9D%B8%EB%94%A9\">두번째, 해당 parameter를 argument value로 변환 및 바인딩</a></li>\n<li><a href=\"#custom-resolver-%EA%B5%AC%ED%98%84\">Custom Resolver 구현</a></li>\n</ul>\n</div>","excerpt":"INTRO 는 Spring framework에서 제공하는 인터페이스로 request에서 메소드의 parameters를 해당하는 인자값으로 변환 혹은 바인딩 하는 resolver이다. 인터페이스 내용 에는 두가지 메소드가 있다.   첫번째, Parameter가 해당 resolver를 지원하는 여부 확인 [참고] 아래 설명은 가 붙은 인자의 경우를 보는 것이므로 그 구현체가 의 예시로 설명한 것이다.  Parameter가 있는 수만큼  →  안에서 for문을 돌면서 해당 parameter에 대한 argument resolve를 한다. 이때 resolve를 하기 위해서 현재 클래스가 가지고 있는  가 해당 parameter 지원 하는지 여부를 확인한다. → 확인하는 로직은  안에 있는 resolver들의 배열을 돌면서(한번 찾으면 캐싱함) 해당 parameter를 지원하는 resolver를 찾아서 반환하고, null인지 여부를 체크해 boolean을 반환한다. 이때  메소드가 수행된다.…","frontmatter":{"date":"June 25, 2021","title":"HandlerMethodArgumentResolver 내부동작 원리 알아보기","categories":"스프링 웹","author":"코다","emoji":"🍀"},"fields":{"slug":"/handler-method-argument-resolver/"}},"next":{"id":"90dcdd48-5814-5261-9fed-a768d1269d4a","html":"<h2 id=\"개요\" style=\"position:relative;\"><a href=\"#%EA%B0%9C%EC%9A%94\" aria-label=\"개요 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>개요</h2>\n<p>Handler interceptors는 어떤 요청들에 대한 특정 기능을 적용하고 싶을 때 사용이 되는데, 특히 어떤 조건 및 원칙들을 검증하는데 많이 사용된다.</p>\n<br>\n<h2 id=\"interceptor-구성\" style=\"position:relative;\"><a href=\"#interceptor-%EA%B5%AC%EC%84%B1\" aria-label=\"interceptor 구성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Interceptor 구성</h2>\n<p>Interceptor를 구현하기 위해서는 HandlerInterceptor를 구현해야 한다. 해당 인터페이스에는 interceptor가 실행되는 3가지 경우에 대한 메소드가 정의되어 있다.</p>\n<ol>\n<li>handler가 실행되기 이전</li>\n<li>handler가 실행된 이후</li>\n<li>전체 요청 처리가 모두 수행된 이후</li>\n</ol>\n<p>이것들 중 handler 실행 이전에 수행되는 메소드인 <code class=\"language-text\">preHandle()</code> 은 boolean 값을 반환한다. <code class=\"language-text\">postHandle()</code>과 <code class=\"language-text\">afterCompletion()</code>은 void를 반환한다.</p>\n<p>위 세가지 메소드 모두 공통된 인자로 Servlet에 의해서 생성된 <code class=\"language-text\">HttpServletRequest</code>, <code class=\"language-text\">HttpServletResponse</code>, <code class=\"language-text\">handler</code>(Object 타입)을 받는다. 따라서 void 반환타입인 경우 HttpServletResponse에 후처리를 할 수 있다. (<code class=\"language-text\">postHandle()</code>의 경우에는 <code class=\"language-text\">ModelAndView</code>를 <code class=\"language-text\">afterCompletion()</code>은 <code class=\"language-text\">Exception</code>을 <code class=\"language-text\">@Nullable</code> 속성으로 받는다)</p>\n<h3 id=\"prehandle-동작원리\" style=\"position:relative;\"><a href=\"#prehandle-%EB%8F%99%EC%9E%91%EC%9B%90%EB%A6%AC\" aria-label=\"prehandle 동작원리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>preHandle() 동작원리</h3>\n<p><code class=\"language-text\">DispatcherServlet</code>은 <code class=\"language-text\">interceptors</code>와 <code class=\"language-text\">handler</code>를 execution chain으로 실행한다. (마지막에 handler가 실행이 되는 형태)</p>\n<p>이 <code class=\"language-text\">preHandle()</code> 메소드를 통해서 이 execution chain 중단 여부를 결정할 수 있다. 만일 체이닝 되어 있는 interceptor가 true를 반환한다면 그 다음 interceptor 혹은 handler를 실행한다. 만일 false를 반환한다면 체이닝 된 interceptor 혹은 handler 실행을 멈추고 <strong>DispatcherServlet은 해당 interceptor가 알아서 response에 필요한 처리를 했다고 간주한다.</strong></p>\n<br>\n<br>\n<p><strong>[참고링크]</strong></p>\n<ul>\n<li><a href=\"https://docs.spring.io/spring-framework/docs/3.0.x/reference/mvc.html#mvc-handlermapping-interceptor\">https://docs.spring.io/spring-framework/docs/3.0.x/reference/mvc.html#mvc-handlermapping-interceptor</a></li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#%EA%B0%9C%EC%9A%94\">개요</a></p>\n</li>\n<li>\n<p><a href=\"#interceptor-%EA%B5%AC%EC%84%B1\">Interceptor 구성</a></p>\n<ul>\n<li><a href=\"#prehandle-%EB%8F%99%EC%9E%91%EC%9B%90%EB%A6%AC\">preHandle() 동작원리</a></li>\n</ul>\n</li>\n</ul>\n</div>","frontmatter":{"date":"June 23, 2021","title":"초간단 Interceptor 알아보기","categories":"스프링 웹","author":"코다","emoji":"🍀"},"fields":{"slug":"/spring-interceptor/"}},"prev":{"id":"156033a5-3d3b-51d5-abc6-61b8996690bf","html":"<p>다음 글은 [링크](Understanding Spring Web Application Architecture: The Classic Way)에 기술되어 있는 스프링 웹 어플리케이션 구조에 대한 글을 번역 한 내용이다.</p>\n<h2 id=\"좋은-architecture를-위한-두-기둥\" style=\"position:relative;\"><a href=\"#%EC%A2%8B%EC%9D%80-architecture%EB%A5%BC-%EC%9C%84%ED%95%9C-%EB%91%90-%EA%B8%B0%EB%91%A5\" aria-label=\"좋은 architecture를 위한 두 기둥 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>좋은 architecture를 위한 두 기둥</h2>\n<h3 id=\"the-socseparation-of-concerns-원칙\" style=\"position:relative;\"><a href=\"#the-socseparation-of-concerns-%EC%9B%90%EC%B9%99\" aria-label=\"the socseparation of concerns 원칙 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>The SoC(Separation of Concerns) 원칙</h3>\n<blockquote>\n<p>A design principle for separating a computer program into distinct sections, which each section addresses a separate concern. <br> <a href=\"%5Bhttps://en.wikipedia.org/wiki/Separation_of_concerns%5D(https://en.wikipedia.org/wiki/Separation_of_concerns)\">출처</a></p>\n</blockquote>\n<p>SoC에서 신경써야 할 부분은 두가지이다.</p>\n<ol>\n<li>고려해야 할 <strong>concerns</strong>가 무엇인지</li>\n<li>어디서 해당 <strong>concern</strong>을 다루고 싶은지</li>\n</ol>\n<p>SoC를 준수하게 된다면 각각의 layer와 해당 layer의 책임에 대해서 자연스럽게 정의할 수 있도록 도와준다.</p>\n<h3 id=\"the-kisskeep-it-simple-stupid-원칙\" style=\"position:relative;\"><a href=\"#the-kisskeep-it-simple-stupid-%EC%9B%90%EC%B9%99\" aria-label=\"the kisskeep it simple stupid 원칙 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>The KISS(Keep It Simple Stupid) 원칙</h3>\n<blockquote>\n<p>Most systems work best if they are kept simple rather than made complicated; therefore simplicity should be a key goal in design and unnecessary complexity should be avoided. <br> <a href=\"%5Bhttp://en.wikipedia.org/wiki/KISS_principle%5D(http://en.wikipedia.org/wiki/KISS_principle)\">출처</a></p>\n</blockquote>\n<p>이 원칙은 각 레이어는 그만큼의 비용이 들고 복잡한 구조를 가진 어플리케이션은 그만큼의 높은 비용을 감수해야 한다는 것을 상기시켜준다.</p>\n<ul>\n<li>새로운 feature를 추가하는 경우 해당 정보를 여러 layer에 모두 전달해야 하기 때문에 과정이 오래 걸림</li>\n<li>지나치게 복잡한 구조를 가지고 있기 때문에 아무도 제대로 이해하고 있지 않아서 해당 어플리케이션의 유지보수가 어려움</li>\n</ul>\n<br>\n<h2 id=\"3-layers가-가장-적당하다\" style=\"position:relative;\"><a href=\"#3-layers%EA%B0%80-%EA%B0%80%EC%9E%A5-%EC%A0%81%EB%8B%B9%ED%95%98%EB%8B%A4\" aria-label=\"3 layers가 가장 적당하다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3 Layers가 가장 적당하다</h2>\n<p>웹 어플리케이션의 책임을 고려했을때 웹 어플리케이션 전체적으로 다음과 같은 concerns가 있다.</p>\n<ul>\n<li>사용자의 입력을 받아서 적당한 응답을 반환</li>\n<li>예외 처리를 하여 예외 상황시 적절한 에외 메세지를 반환</li>\n<li>트랜잭션 관리 전략을 가짐</li>\n<li>인가와 인증을 처리함</li>\n<li>어플리케이션의 비지니스 로직을 작성</li>\n<li>사용되는 데이터 저장소와 외부 리소스와의 커뮤니케이션 담당</li>\n</ul>\n<p>위 역할을 감당하기 위해서 다음 3가지 layer로 충분하다.</p>\n<ol>\n<li>\n<p><strong>The Web Layer</strong></p>\n<p>웹 어플리케이션의 최상단에 있는 layer이다. 사용자의 입력을 받아서 적정한 응답을 반환하는 역할을 맡는다. 이 레이어에서는 다른 레이어에서 발생한 예외들에 대한 핸들링을 처리해야한다. <br></p>\n<p>현재 레이어는 해당 어플리케이션의 입구이기 때문에 인증 및 인가를 담당하여 허가되지 않은 사용자에 대한 1차 방어를 해야한다.</p>\n</li>\n<li>\n<p><strong>The Service Layer</strong></p>\n<p>웹 레이어 다음에 위치한 레이어이다. 이 레이어는 트랜잭션 단위를 구분하고, application과 infrastructure 서비스를 모두 포함한다. <br></p>\n<p>여기서 <strong>application services</strong>는 서비스 레이어의 <strong>public API</strong>를 제공한다. 이 뜻은, 어플리케이션 서비스에서 처리하고하고자 하는 일들이 서비스 레이어의 <code class=\"language-text\">public</code> 메소드에서 처리된다는 것이다. 이 메소드 별로 트랜잭션 단위가 나뉘어지고 인증 및 인가 작업도 여기서 담당한다. <br></p>\n<p>서비스 레이어에서 <strong>infrastructure services</strong>는 파일 시스템, 데이터베이스, 이메일 서버 등등의 외부 리소스와 커뮤니케이션하기 때문에 “plumbing code” (배관 코드)라고 불리기도 한다. 이 메소드들은 하나 이상의 어플리케이션 서비스 코드에서 주로 활용된다.</p>\n</li>\n<li>\n<p><strong>The Repository Layer</strong></p>\n<p>웹 어플리케이션의 최하위에 위치해있는 레이어이다. 데이터 저장소와의 연결을 담당한다.</p>\n</li>\n</ol>\n<br>\n<p>특정 레이어에 속한 컴포넌트는 동일 레이어, 혹은 더 하위 레이어의 컴포넌트를 활용할 수 있다.</p>\n<p align=\"center\"><img width=\"85%\" src=\"https://user-images.githubusercontent.com/63405904/135494819-559541d9-1b75-4f2b-a5fe-f03519508483.png\"></p>\n<br>\n<h2 id=\"layer-나누어-설계하기\" style=\"position:relative;\"><a href=\"#layer-%EB%82%98%EB%88%84%EC%96%B4-%EC%84%A4%EA%B3%84%ED%95%98%EA%B8%B0\" aria-label=\"layer 나누어 설계하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Layer 나누어 설계하기</h2>\n<p>이제는 각 레이어에 대한 인터페이스를 설계해야하는데, 여기서 DTO(Domain Transfer Object)와 domain model이라는 키워드가 등장한다.</p>\n<ul>\n<li>\n<p><strong>DTO</strong></p>\n<p>단순한 데이터를 담는 객체로 각기 다른 프로세스와 어플리케이션의 레이어간 데이터 전달 때 사용되는 객체이다.</p>\n</li>\n<li>\n<p><strong>Domain Model</strong></p>\n<p>도메인 모델에는 3가지 다른 역할의 객체들이 있다.</p>\n<ol>\n<li>\n<p><strong>Domain Service</strong></p>\n<p>도메인과 관련된 operation 이지만 enity나 VO의 일부는 아닌 상태가 없는(stateless) 클래스</p>\n</li>\n<li>\n<p><strong>Entity</strong></p>\n<p>전체 라이프 사이클 동안 바뀌지 않고 그 indentity 자체로 정의되는 객체 <strong>(?????)</strong></p>\n</li>\n<li>\n<p><strong>Value Object</strong></p>\n<p>어떤 것의 속성을 나타내고, 그 자체로의 identity나 lifecycle이 없는 객체이다. 주로 VO의 life cycle은 entity의 lifecycle에 종속되어 있다.</p>\n</li>\n</ol>\n</li>\n</ul>\n<p>각 레이어의 인터페이스에는 다음 것들이 포함되어 있어야 한다.</p>\n<ul>\n<li>web layer는 DTO만을 다루어야 한다.</li>\n<li>service layer는 DTO를 메소드 인자로 받고 도메인 모델을 핸들링 할 수는 있지만 DTO만을 web layer에 다시 반환해야 한다.</li>\n<li>repository layer는 entity를 메소드 인자로 받고 entity를 반환해야 한다.</li>\n</ul>\n<p>그렇다면 왜 VO가 아닌 DTO로 레이어간 소통을 해야하는지 궁금할 수 있다. 다음 두가지 이유로 VO를 직접 사용하는 것은 좋지 않다.</p>\n<ol>\n<li>도메인 모델은 어플리케이션 내부 모델이다. 따라서 도메인 모델을 외부로 노출한다면 클라이언트는 해당 도메인 모델을 어떻게 다루어야하는지 인지해야한다. 하지만, 클라이언트는 해당 로직에 대해서 알 필요가 없다. 만일 DTO를 사용한다면 도메인 모델을 클라이언트에게 숨기고, 깔끔하고 쉬운 API를 제공할 수 있다.</li>\n<li>도메인 모델을 외부에 노출한다면 도메인 모델을 수정할 때 해당 도메인 모델이 의존하는 것들을 함께 수정해야한다. 하지만 만일 DTO를 사용한다면도메인 모델을 수정하더라도 다른 것(other stuff)들이 DTO와 연결되어 있기 때문에 다른 것들을 수정하지 않아도 된다.</li>\n</ol>\n<p align=\"center\"><img width=\"85%\" src=\"https://user-images.githubusercontent.com/63405904/135494900-92d34444-4d4a-4312-af6a-a0d45bf62f75.png\"></p>\n<br>\n<br>\n<p><strong>[참고링크]</strong></p>\n<ul>\n<li><a href=\"https://www.petrikainulainen.net/software-development/design/understanding-spring-web-application-architecture-the-classic-way/\">https://www.petrikainulainen.net/software-development/design/understanding-spring-web-application-architecture-the-classic-way/</a></li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#%EC%A2%8B%EC%9D%80-architecture%EB%A5%BC-%EC%9C%84%ED%95%9C-%EB%91%90-%EA%B8%B0%EB%91%A5\">좋은 architecture를 위한 두 기둥</a></p>\n<ul>\n<li><a href=\"#the-socseparation-of-concerns-%EC%9B%90%EC%B9%99\">The SoC(Separation of Concerns) 원칙</a></li>\n<li><a href=\"#the-kisskeep-it-simple-stupid-%EC%9B%90%EC%B9%99\">The KISS(Keep It Simple Stupid) 원칙</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#3-layers%EA%B0%80-%EA%B0%80%EC%9E%A5-%EC%A0%81%EB%8B%B9%ED%95%98%EB%8B%A4\">3 Layers가 가장 적당하다</a></p>\n</li>\n<li>\n<p><a href=\"#layer-%EB%82%98%EB%88%84%EC%96%B4-%EC%84%A4%EA%B3%84%ED%95%98%EA%B8%B0\">Layer 나누어 설계하기</a></p>\n</li>\n</ul>\n</div>","frontmatter":{"date":"June 26, 2021","title":"클래식한 스프링 웹 어플리케이션 구조","categories":"스프링 웹","author":"코다","emoji":"🍀"},"fields":{"slug":"/spring-spring-web-application-architecture/"}},"site":{"siteMetadata":{"siteUrl":"https://yjksw.github.io","comments":{"utterances":{"repo":"yjksw/yjksw.github.io"}}}}},"pageContext":{"slug":"/handler-method-argument-resolver/","nextSlug":"/spring-interceptor/","prevSlug":"/spring-spring-web-application-architecture/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}
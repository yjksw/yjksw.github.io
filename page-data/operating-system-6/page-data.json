{"componentChunkName":"component---src-templates-blog-template-js","path":"/operating-system-6/","result":{"data":{"cur":{"id":"15c686a2-e380-5751-aa10-a46cbef8c812","html":"<blockquote>\n<p>다음은 반효경 교수님의 ‘운영체제와 정보기술의 원리’ <em>CH7. 메모리 관리</em>를 읽고 정리한 내용입니다 🙌</p>\n</blockquote>\n<br>\n<br>\n<h2 id=\"-들어가기-전\" style=\"position:relative;\"><a href=\"#-%EB%93%A4%EC%96%B4%EA%B0%80%EA%B8%B0-%EC%A0%84\" aria-label=\" 들어가기 전 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 들어가기 전</h2>\n<ul>\n<li>\n<p>우리가 흔히 사용하는 컴퓨터 주소 체계는 32비트 혹은 64비트로 나뉘어져 있다.</p>\n<ul>\n<li>32비트면 32개의 비트로 주소를 표현할 수 있는 것이다.</li>\n<li>2^32가지 다른 메모리 위치를 구분할 수 있다.</li>\n<li>컴퓨터는 바이트 단위(8비트)로 주소를 부여한다. 따라서 2^32 바이트 만큼의 메모리 공간에 서로 다른 주소를 할당할 수 있다.</li>\n</ul>\n</li>\n<li>32 비트를 계층적으로 묶어서 관리한다.</li>\n<li>\n<p>보통 4KB (2^12 바이트) 단위로 묶어서 페이지(page)를 구성한다.</p>\n<ul>\n<li>페이지 내에서 주소를 구분하기 위해서는 12비트가 필요하다. 따라서 32비트 중 하위 12비트는 페이지 내에서 주소를 나타낸다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-1-주소-바인딩\" style=\"position:relative;\"><a href=\"#-1-%EC%A3%BC%EC%86%8C-%EB%B0%94%EC%9D%B8%EB%94%A9\" aria-label=\" 1 주소 바인딩 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 1. 주소 바인딩</h2>\n<ul>\n<li>\n<p>프로세스의 주소 공간 (address space)는 프로그램이 실행되기 위해 메모리에 적재되면 프로세스를 위한 독자적인 주소 공간이 생성된다.</p>\n<ul>\n<li>논리적 주소 (logical address) 혹은 가상 주소 (virtual address)라고 부른다.</li>\n<li>CPU는 논리적 주소에 근거해 명령을 실행한다.</li>\n</ul>\n</li>\n<li>논리적 주소는 프로세스 마다 <strong>독립적</strong>으로 할당되고 모두 0번지부터 시작한다.</li>\n<li>\n<p>물리적 주소 (physical address)는 물리적 메모리에 실제로 올라가는 위치이다.</p>\n<ul>\n<li>물리적 메모리의 낮은 주소에는 운영체제가 올라가고 높은 주소에는 사용자 프로세스들이 올라간다.</li>\n</ul>\n</li>\n<li>메모리 참조를 할 때 프로세스의 논리적 주소가 물리적 주소의 어느 위치인지 확인해야하는 주소 바인딩 (address binding)이라는 작업이 필요하다.</li>\n</ul>\n<h3 id=\"주소-바인딩-방식\" style=\"position:relative;\"><a href=\"#%EC%A3%BC%EC%86%8C-%EB%B0%94%EC%9D%B8%EB%94%A9-%EB%B0%A9%EC%8B%9D\" aria-label=\"주소 바인딩 방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>주소 바인딩 방식</h3>\n<ul>\n<li>물리 메모리 주소가 결정되는 시기에 따라서 분류된다.</li>\n<li>\n<p>컴파일 타임 바인딩 (compile time binding) </p>\n<ul>\n<li>프로그램을 컴파일할 때 물리적 메모리 주소가 결정</li>\n<li>컴파일 시점에 해당 프로그램이 물리적 메모리 몇 번지에 위치할 것인지 결정</li>\n<li>프로그램이 절대주소로 적재된다는 뜻으로 절대코드를 생성하는 바인딩 (absolute code)</li>\n<li>프로그램의 물리적 주소를 변경하고 싶다면 프로그램을 다시 컴파일해야한다.</li>\n<li>비현실적이며 현대 시분할 컴퓨팅 환경에서는 잘 사용하지 않는다.</li>\n</ul>\n</li>\n<li>\n<p>로드 타임 바인딩 (load time binding)</p>\n<ul>\n<li>프로그램이 시작될 때 물리적 메모리 주소가 결정</li>\n<li>\n<p>loader의 책임하에 물리적 메모리 주소가 부여되고 프로그램 종료까지 물리적 메모리상의 위치가 고정</p>\n<ul>\n<li>로더는 사용자 프로그램을 메모리에 적재시키는 프로그램</li>\n</ul>\n</li>\n<li>컴파일러가 재배치 가능 코드(relocatable code)를 생성한 경우에 가능한 주소 바인딩 방식</li>\n</ul>\n</li>\n<li>\n<p>실행시간 바인딩 (execution time binding or run time binding)</p>\n<ul>\n<li>프로그램 시작 후에도 물리적 메모리 주소가 변경될 수 있음</li>\n<li>CPU가 메모리 주소를 참조할 때마다 데이터가 물리적 메모리의 어느 위치에 있는지 주소 매핑 테이블 (address mapping table)을 참조해 바인딩을 점검</li>\n<li>\n<p>기준 레지스터 (base register)와 한계 레지스터 (limit register) 를 포함하여 MMU (Memeory Management Unit)이라는 하드웨어적 자원 뒷받침이 필요</p>\n<ul>\n<li>MMU는 논리적 주소를 물리적 주소로 매핑해주는 하드웨어 장치</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"mmu-기법\" style=\"position:relative;\"><a href=\"#mmu-%EA%B8%B0%EB%B2%95\" aria-label=\"mmu 기법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>MMU 기법</h3>\n<ul>\n<li>MMU를 사용하여 주소 변환하는 기본적인 방식</li>\n<li>\n<p>MMU 기법은 논리적 주소값에 기준 레지스터 값을 더해 물리적 주소값을 얻어낸다.</p>\n<ul>\n<li>기준 레지스터는 재배치 레지스터 (reload register)라고도 하며 프로세스의 물리적 메모리 시작 주소를 가지고 있다.</li>\n<li>offset 개념</li>\n</ul>\n</li>\n<li>MMU 기법은 프로그램의 주소가 물리적 메모리에 연속적으로 적재된 것을 가정한다.</li>\n<li>따라서 물리적 메모리의 시작 주소만 알면 변환을 쉽게 할 수 있으며 사용자 프로그램이나 CPU는 물리적 메모리를 알 필요 없이 논리적 메모리 주소만 다룬다.</li>\n<li>\n<p>프로세스마다 고유의 메모리 주소를 가지고 있기 때문에 같은 주소 (논리적 메모리 주소 100번지)도 각기 다른 물리적 메모리 위치를 가리켜야한다.</p>\n<ul>\n<li>이것을 기준 레지스터를 해당 프로세스에 맞는 값으로 설정하므로 여러 프로세스에 대한 주소 매핑을 한다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"메모리-보안-memory-protection\" style=\"position:relative;\"><a href=\"#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%B3%B4%EC%95%88-memory-protection\" aria-label=\"메모리 보안 memory protection permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>메모리 보안 Memory protection</h3>\n<ul>\n<li>메모리에 여러 프로세스가 올라가 있기 때문에 한 프로세스가 다른 프로세스의 물리적 주소를 참조하여 문제가 발생할수도 있다.</li>\n<li>한계 레지스터 (limit register)를 이용하여 해당 프로세스가 자신의 주소 공간을 넘어 메모리를 참조하면 (base register + limit register) 트랩을 발생시켜 해당 프로세스를 종료시킨다.</li>\n</ul>\n<br>\n<h2 id=\"-2-메모리-관리와-관련된-용어\" style=\"position:relative;\"><a href=\"#-2-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC%EC%99%80-%EA%B4%80%EB%A0%A8%EB%90%9C-%EC%9A%A9%EC%96%B4\" aria-label=\" 2 메모리 관리와 관련된 용어 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 2. 메모리 관리와 관련된 용어</h2>\n<h3 id=\"1-동적로딩-dynamic-loading\" style=\"position:relative;\"><a href=\"#1-%EB%8F%99%EC%A0%81%EB%A1%9C%EB%94%A9-dynamic-loading\" aria-label=\"1 동적로딩 dynamic loading permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1) 동적로딩 dynamic loading</h3>\n<ul>\n<li>여러 프로그램이 동시에 메모리에 올라가서 수행되는 다중 프로그래밍(multi-programming) 환경에서 메모리 효율을 높이는 기법이다.</li>\n<li>\n<p>프로세스가 시작될 때 그 프로세스의 주소 공간 전체를 물리적 메모리에 올리는 것이 아니라 해당 부분이 호출될 때 메모리에 적재되는 방식이다.</p>\n<ul>\n<li>프로그램의 오류 처리루틴 등등은 가끔씩만 사용되는 방어용 코드이므로 항상 적재될 필요는 없다.</li>\n</ul>\n</li>\n<li>\n<p>필요하지 않은 코드가 한꺼번에 적재되어 메모리가 낭비되는 것을 막아 메모리를 효율적으로 사용할 수 있도록 한다.</p>\n<ul>\n<li>프로그램 자체에서 구현 가능하고 운영체제가 라이브러리로 지원하기도 한다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-동적연결-dynamic-linking\" style=\"position:relative;\"><a href=\"#2-%EB%8F%99%EC%A0%81%EC%97%B0%EA%B2%B0-dynamic-linking\" aria-label=\"2 동적연결 dynamic linking permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2) 동적연결 dynamic linking</h3>\n<ul>\n<li>연결은 개발자가 작성한 소스코드를 컴파일하여 생성된 object file과 이미 컴파일된 라이브러리 파일 library file을 묶어 하나의 실행파일을 생성하는 과정이다.</li>\n<li>\n<p>동적연결은 이 연결을 프로그램 실행 시점까지 지연시키는 기법이다.</p>\n<ul>\n<li>정적 연결 static linking은 미리 작성된 코드와 라이브러리 코드가 합쳐져서 실행파일이 생성된다.</li>\n<li>따라서 실행파일의 크기가 크고 동일한 라이브러리를 각 프로세스가 개별적으로 메모리에 적재하여 물리적 메모리가 낭비된다.</li>\n</ul>\n</li>\n<li>동적연결은 라이브러리가 실행시점에 연결되어 실행파일에 라이브러리 코드가 포함되어 있지 않고 라이브러리 함수 호출 시 라이브러리에 연결된다.</li>\n<li>\n<p>동적연결을 위해 코드의 라이브러리 호출 부분에 스텁 stub이라는 작은 코드를 둔다.</p>\n<ul>\n<li>stub으로 해당 라이브러리가 메모리에 존재하는지 보고 있다면 그 주소에서 직접 참조하고 없다면 디스크에서 라이브러리를 메모리로 적재한다.</li>\n</ul>\n</li>\n<li>공동으로 사용하는 라이브러리는 한번 적재하여 메모리 효율을 높인다.</li>\n<li>운영체제의 지원이 필요하다.</li>\n</ul>\n<h3 id=\"3-중첩-overlays\" style=\"position:relative;\"><a href=\"#3-%EC%A4%91%EC%B2%A9-overlays\" aria-label=\"3 중첩 overlays permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3) 중첩 overlays</h3>\n<ul>\n<li>프로세스의 주소 공간을 분할해 실제 필요한 부분만 메모리에 적재하는 기법이다.</li>\n<li>\n<p>동적로딩과 비슷하나 중첩의 배경은 초창기에 물리적 메모리의 공간이 부족하여 프로세스의 주소 공간을 분할해 당장 필요한 부분을 올리고 해당 부분의 실행이 끝나면 나머지 부분을 올려서 실행한 기법이다. (단일 프로세스를 올릴 때 메모리가 부족한 경우..)</p>\n<ul>\n<li>동적로딩은 다중 프로그래밍 환경에서 메모리 이용률을 높이기 위한 기법이다.</li>\n</ul>\n</li>\n<li>중첩은 운영체제의 지원이 없고 프로그래머가 직접 구현되어야 했으며 따라서 수작업 중첩(manual overlays)라고도 부른다.</li>\n</ul>\n<h3 id=\"4-스와핑-swapping\" style=\"position:relative;\"><a href=\"#4-%EC%8A%A4%EC%99%80%ED%95%91-swapping\" aria-label=\"4 스와핑 swapping permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4) 스와핑 swapping</h3>\n<ul>\n<li>메모리에 올라온 프로세스의 주소공간 전체를 스왑 영역에 일시적으로 내려놓는 것이다.</li>\n<li>\n<p>스왑 영역을 백킹스토어 backing store 라고도 부른다.</p>\n<ul>\n<li>디스크 내에서 파일 시스템과는 별도로 존재한다.</li>\n<li>스왑 영역은 디스크에 일시적으로 저장하여 저장기간이 짧은 저장공간이다.</li>\n</ul>\n</li>\n<li>스왑 영역은 다수의 프로세스를 담을 수 있는 충분한 저장공간이면서 접근 속도가 보장되어야 한다.</li>\n<li>\n<p>스와핑은 프로세스 종료 후 디스크에 프로세스를 내려놓는 것이 아니라, 특정 이유로 <strong>수행 중인 프로세스</strong>를 메모리에서 디스크로 내려놓는 것이다.</p>\n<ul>\n<li>디스크 → 메모리 : 스왑인</li>\n<li>메모리 → 디스크: 스왑아웃</li>\n</ul>\n</li>\n<li>\n<p>스와핑 과정</p>\n<ul>\n<li>스와퍼 swapper라고 불리는 중기 스캐줄러(medium-term scheduler)로 스왑시킬 프로세스를 선정</li>\n<li>해당 프로세스는 메모리에 올라가있는 전체 내용이 스왑 영역으로 스왑 아웃</li>\n</ul>\n</li>\n<li>\n<p>스와핑의 중요 역할은 메모리의 프로세스 수를 조절하는 것이다.</p>\n<ul>\n<li>degree of multiprogramming 다중 프로그래밍의 정도를 조절한다.</li>\n<li>메모리에 너무 많은 양의 프로세스가 올라와있으면 시스템 전체 성능이 떨어지기 때문이다.</li>\n</ul>\n</li>\n<li><strong>컴파일 타임 바인딩</strong>과 <strong>로드 타임 바인딩</strong>은 스왑 아웃된 프로세스가 스왑인 될 때 동일한 메모리 위치로 올라가야한다.</li>\n<li>\n<p>스와핑에서 스왑 영역에 프로세스의 주소 공간이 순차적으로 저장된다.</p>\n<ul>\n<li>스와핑 소요시간은 디스크 탐색시간이나 회전지연시간(rotational latency)보다 디스크 섹터에서 실제 데이터를 읽고 쓰는 전송시간 transfer time이 대부분을 차지한다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-3-물리적-메모리의-할당방식\" style=\"position:relative;\"><a href=\"#-3-%EB%AC%BC%EB%A6%AC%EC%A0%81-%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%9D%98-%ED%95%A0%EB%8B%B9%EB%B0%A9%EC%8B%9D\" aria-label=\" 3 물리적 메모리의 할당방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 3. 물리적 메모리의 할당방식</h2>\n<ul>\n<li>\n<p>운영체제 상주 영역과 사용자 프로세스영역으로 나뉜다.</p>\n<ul>\n<li>운영체제 상주 영역은 인터럽트 벡터와 함께 낮은 주소 영역을 사용한다.</li>\n<li>운영체제 커널이 위치한다.</li>\n</ul>\n</li>\n<li>\n<p>사용자 프로세스 영역은 연속할당(contiguous allocation)과 불연속할당(noncontiguous alloation) 방식으로 나뉜다.</p>\n<ul>\n<li>\n<p>연속할당 - 각각의 프로세스를 물리적 메모리 연속적인 공간에 올림</p>\n<ul>\n<li>물리적 메모리를 다수의 분할로 나누어 하나의 분할에 하나의 프로세스가 적재</li>\n<li>분할은 고정분할(fixed partition allocation)과 가변분할(variable partition allocation) 방식으로 나뉜다. 고정분할은 미리 메모리를 나누어 놓는다.</li>\n</ul>\n</li>\n<li>\n<p>불연속 할당 - 하나의 프로세스를 물리적 메모리 여러 영역에 분산하여 적재하는 방식</p>\n<ul>\n<li>동일한 페이지로 잘라서 메모리에 페이지 단위로 적재시키는 페이징(paging) 기법</li>\n<li>프로그램 주소 공간을 코드, 데이터, 스택 등 의미있는 단위인 세그먼트로 나누는 세그멘테이션(segmentation) 기법이 있다.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"1-연속할당-방식\" style=\"position:relative;\"><a href=\"#1-%EC%97%B0%EC%86%8D%ED%95%A0%EB%8B%B9-%EB%B0%A9%EC%8B%9D\" aria-label=\"1 연속할당 방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1) 연속할당 방식</h3>\n<ul>\n<li>고정분할이나 가변분할로 나뉘어진 크기에 프로세스를 연속적으로 적재한다.</li>\n<li>\n<p>고정분할 방식</p>\n<ul>\n<li>물리적 메모리를 주어진 개수만큼 영구적인 분할(partition)으로 나누고 각 분할에 하나의 프로세스를 적재한다.</li>\n<li>분할의 크기가 모두 같을수도 다를수도 있다.</li>\n<li>메모리에 올릴 수 있는 프로세스의 수가 분할개수 만큼으로 고정되어 있고 수행 가능한 프로그램의 최대 크기가 정해져있다. (분할의 최대크기)</li>\n<li>\n<p>외부조각(external fragmentation)과 내부조각(internal fragmentation)이 발생할 수 있다.</p>\n<ul>\n<li>외부조각은 분할이 비었는데 프로그램의 크기보다 작아서 적재하는 못하는 경우 발생</li>\n<li>내부조각은 프로그램에게 배정되었는데 조각의 크기가 상대적으로 커서 내부에 사용하지 않는 메모리 공간이 생기는 경우 발생</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>가변분할 방식</p>\n<ul>\n<li>\n<p>적재되는 프로그램의 크기에 따라 분할의 크기와 개수가 동적으로 변하는 방식이다.</p>\n<ul>\n<li>관리를 위한 프로그래밍 기법이 필요하다.</li>\n</ul>\n</li>\n<li>프로그램의 크기만큼 분할하므로 내부조각은 발생하지 않는다. 하지만 외부조각은 여전히 발생한다.</li>\n<li>\n<p>중요한 점은 주소 공간의 크기가 n인 프로세스를 메모리에 올릴 때 메모리 가용공간 중 어느 위치에 올릴지 이다.</p>\n<ul>\n<li>동적 메모리 할당 문제 dynamic storage-allocation problem 이라고 한다.</li>\n<li>가용공간은 사용되지 않은 메모리 공간이고 산발적으로 존재한다.</li>\n<li>연속할당 기법에서는 프로세스 전체를 담을 수 있는 가용공간을 찾아야한다.</li>\n<li>운영체제는 이미 사용중인 메모리와 가용 공간에 대한 정보를 유지하여 가용 공간을 효율적으로 관리해야한다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>동적 메모리 할당 문제 해결 방법 3가지</p>\n<ol>\n<li>\n<p>크기가 n 이상인 가용 공간 중 가장 먼저 찾아지는 공간에 프로세스를 할당하는 최초적합 (first-fit) 방법</p>\n<ul>\n<li>가용공간을 모두 탐색하지 않으므로 시간적인 면에서 효율적이다.</li>\n</ul>\n</li>\n<li>\n<p>크기가 n 이상인 가장 작은 가용 공간을 찾아가곳에 프로세스를 할당하는 최적적합(best-fit) 방법</p>\n<ul>\n<li>가용공간 리스트가 크기순으로 정렬되어 있지 않는다면 모든 가용공간 리스트를 탐색하여 시간적 오버헤드가 발생</li>\n<li>다수의 매우 작은 가용 공간들이 생성될 수 있다는 단점</li>\n<li>공간적인 면에서 효율적인 장점이 존재한다.</li>\n</ul>\n</li>\n<li>\n<p>가용 공간 중 가장 크기가 큰 곳에 새로운 프로그램을 할당하는 최악적합(worst-fit) 방법</p>\n<ul>\n<li>가용 공간 리스트를 탐색하는 시간적 오버헤드 발생</li>\n<li>상대적으로 더 큰 프로그램을 담을 수 있는 가용 공간을 빨리 소진한다는 문제</li>\n</ul>\n</li>\n<li>최초척합과 최적적합 방식이 최악적합 방식에 비해 속도와 공간 이용률 측면에서 효과적이다.</li>\n</ol>\n</li>\n<li>\n<p>컴팩션 compaction - 가변분할 방식에서 외부조각 문제를 해결하는 방법</p>\n<ul>\n<li>물리적 메모리 중 프로세스에 의해 사용중인 메모리 영역을 한쪽으로 몰고 가용 공간들을 다른 한쪽으로 모아 하나의 큰 가용 공간을 만드는 방법</li>\n<li>수행 중인 프로세스의 메모리상의 위치를 상당 부분 이동시키므로 비용이 많이 든다.</li>\n<li>중간에 일부 가용 공간이 발생하더라도 적은 수의 메모리 이동으로 효율적인 컴팩션을 수행해야하는데 이론적으로 복잡하다.</li>\n<li>수행 중인 프로세스의 물리적 메모리 위치를 옮겨야하므로 프로그램 시간 도중에 프로세스의 주소가 동적으로 바뀌는 실행시간 바인딩 방식이 지원될 때만 가능하다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-불연속할당-기법\" style=\"position:relative;\"><a href=\"#2-%EB%B6%88%EC%97%B0%EC%86%8D%ED%95%A0%EB%8B%B9-%EA%B8%B0%EB%B2%95\" aria-label=\"2 불연속할당 기법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2) 불연속할당 기법</h3>\n<ul>\n<li>하나의 프로세스가 물리적 메모리의 여러 위치에 분산되어 올라갈 수 있는 메모리 할당 기법이다.</li>\n<li>하나의 프로그램을 동일한 크기로 나누는 페이징 기법</li>\n<li>크기가 일정하지 않지만 의미 단위로 나누는 세그멘테이션 기법</li>\n<li>세그멘테이션이 기본이지만 이것을 다시 동일한 크기의 페이지로 나누는 페이지드 세그멘테이션(paged segmentation)으로 나뉜다</li>\n</ul>\n<br>\n<h2 id=\"-4-페이징-기법\" style=\"position:relative;\"><a href=\"#-4-%ED%8E%98%EC%9D%B4%EC%A7%95-%EA%B8%B0%EB%B2%95\" aria-label=\" 4 페이징 기법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 4. 페이징 기법</h2>\n<ul>\n<li>프로세스 주소 공간을 <strong>동일한 크기의 페이지 단위</strong>로 나누어 <strong>물리적 메모리의 서로 다른 위치</strong>에 페이지들을 저장하는 방식</li>\n<li>프로세스 일부는 백킹스토어, 일부는 물리 메모리에 혼재할 수 있다.</li>\n<li>\n<p>메모리를 페이지와 동일한 크기인 프레임(frame)으로 미리 나눈다.</p>\n<ul>\n<li>동적 메모리 할당 문제가 발생하지 않는 장점</li>\n</ul>\n</li>\n<li>\n<p>주소 변환 절차가 연속할당 방식에 비해 다소 복잡하다.</p>\n<ul>\n<li>하나의 프로세스도 여러 페이지 단위로 물리적 메모리에서의 위치가 상이하기 때문이다.</li>\n<li>\n<p>따라서 프로세스 별 페이지 테이블(page table)을 가져 각 페이지가 물리 프로세스의 어느 frame에 매핑되는지 아는 주소 변환 엔트리를 가진다.</p>\n<ul>\n<li>페이지 테이블은 페이지 개수만큼 엔트리를 가지고 있다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>프로세스 주소 공간과 물리적 메모리가 모두 같은 크기의 페이지 단위이기 때문에 빈 공간은 항상 활용 가능하다.</p>\n<ul>\n<li>하지만 프로세스가 페이지 단위로 나누어 떨어지지 않기 때문에 마지막 조각의 마지막 페이지에서 내부조각이 발생할 수도 있다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"1-주소-변환-기법\" style=\"position:relative;\"><a href=\"#1-%EC%A3%BC%EC%86%8C-%EB%B3%80%ED%99%98-%EA%B8%B0%EB%B2%95\" aria-label=\"1 주소 변환 기법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1) 주소 변환 기법</h3>\n<ul>\n<li>\n<p>CPU가 사용하는 논리적 주소를 번호(p)와 페이지 오프셋(d)로 나누어 주소 변환(address translation)에 사용한다.</p>\n<ul>\n<li>페이지 번호는 페이지별 주소 변환 정보를 담고있는 페이지 테이블 접근 인덱스(index)로 사용</li>\n<li>해당 인덱스의 항목(entry)에는 페이지의 물리적 메모리상 기준 주소(base address) 시작 위치가 저장</li>\n<li>\n<p>페이지 오프셋은 하나의 페이지 내에서의 변위(displacement)를 알려준다.</p>\n<ul>\n<li>기준 주소값 + 변위값으로 논리적 주소에 대응하는 물리적 주소를 얻는다.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-페이지-테이블의-구현\" style=\"position:relative;\"><a href=\"#2-%ED%8E%98%EC%9D%B4%EC%A7%80-%ED%85%8C%EC%9D%B4%EB%B8%94%EC%9D%98-%EA%B5%AC%ED%98%84\" aria-label=\"2 페이지 테이블의 구현 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2) 페이지 테이블의 구현</h3>\n<ul>\n<li>페이징 기법에서 주소 변환을 하기 위한 자료구조이다.</li>\n<li>\n<p>실행중인 프로세스의 페이지 테이블에 접근하기 위해 2개 레지스터를 사용한다.</p>\n<ul>\n<li>\n<p>페이지 테이블 기준 레지스터(page-table base register) PTBR</p>\n<ul>\n<li>물리적 메모리 내에서 페이지 테이블의 시작위치</li>\n</ul>\n</li>\n<li>\n<p>페이지 테이블 길이 레지스터(page-table length register) PTLR</p>\n<ul>\n<li>페이지 테이블의 크기</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>페이징에서 메모리에 접근하려면 <strong>1) 페이지 테이블 접근을 위해 메모리 접근 2) 주소 변환된 메모리에 접근</strong> 이렇게 두번 메모리에 접근하여 오버헤드가 있다.</p>\n<ul>\n<li>페이지 테이블 접근 오버헤드를 줄이고 메모리 접근 속도를 향상시키기 위해 TLB(Translation Look-aside Buffer) 고속 주소 변환용 하드웨어 캐시가 사용되기도 한다.</li>\n<li>메모리에 비해 TLB는 비싸기 때문에 빈번히 참조되는 페이지에 대한 주소변환 정보만 담는다. 따라서 TLB에 요청 페이지의 주소 변환 정보가 있을 수도 있고 없을 수도 있다.</li>\n<li>TLB에 존재한다면 얻고 그렇지 않다면 메인 메모리 페이지 테이블로부터 프레임 번호를 알아내도록 한다.</li>\n<li>문맥 교환시 이전 프로세스의 주소변환 정보를 담는 TLB를 초기화해야한다.</li>\n</ul>\n<p align=\"center\"><img width=\"85%\" src=\"https://user-images.githubusercontent.com/63405904/141051950-79afbe37-5ee2-4627-876c-a51de9083ca5.png\"></p>\n</li>\n<li>\n<p>TLB와 페이지 테이블의 정보 구조 차이</p>\n<ul>\n<li>페이지 테이블에는 페이지 주소 변환 정보가 페이지 번호에 따라 순차적으로 들어있으므로 페이지 번호로 바로 항모겡 접근하여 프레임 번호를 구할 수 있다.</li>\n<li>TLB는 모든 페이지에 대한 주소 변환 정보를 가지고 있는 것이 아니기 때문에 페이지 번호와 프레임 번호가 쌍으로 저장되어야 한다. (두 값이 모두 있어야한다. 페이징 테이블은 프레임 번호만 순차적으로 있다. 그림참조)</li>\n<li>TLB에 있는지 확인하려면 모든 엔트리를 다 찾아봐야하는 오버헤드가 발생한다.</li>\n</ul>\n</li>\n<li>\n<p>TLB 엔트리를 모두 탐색하는 오버헤드를 줄이기위해 병렬탐색(parallel search)이 가능한 연관 레지스터(associative register)를 사용한다.</p>\n<ul>\n<li>TLB 항목을 동시에 탐색할 수 있는 기능이다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-계층적-페이징\" style=\"position:relative;\"><a href=\"#3-%EA%B3%84%EC%B8%B5%EC%A0%81-%ED%8E%98%EC%9D%B4%EC%A7%95\" aria-label=\"3 계층적 페이징 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3) 계층적 페이징</h3>\n<ul>\n<li>페이지 테이블에 메모리의 상당 부분이 소요되어 실제 사용 가능한 메모리 공간이 줄어드는 문제가 발생한다.</li>\n<li>페이지 테이블로 낭비되는 공간을 줄이기 위해 2단계 페이징(two-level paging)을 기법을 사용한다.</li>\n<li>\n<p>외부 페이지 테이블 (outer page table)과 내부 페이지 테이블 (inner page table)을 사용하고 사용하지 않는 주소 공간은 외부 페이지 테이블 항목을 null로 두어 대응하는 내부 페이지 테이블 항목을 설정하지 않아 메모리 낭비를 줄인다.</p>\n<ul>\n<li>하지만 주소변환을 위해 페이지 테이블을 2개 접근해야하므로 시간적 손해가 있다.</li>\n<li>TLB를 사용해 접근 속도를 높일 수 있다.</li>\n</ul>\n</li>\n</ul>\n<p align=\"center\"><img width=\"85%\" src=\"https://user-images.githubusercontent.com/63405904/141052309-99c2a925-799e-4da8-838c-816ca979b37d.png\"></p>\n<h3 id=\"4-역페이지-테이블-inverted-page-table\" style=\"position:relative;\"><a href=\"#4-%EC%97%AD%ED%8E%98%EC%9D%B4%EC%A7%80-%ED%85%8C%EC%9D%B4%EB%B8%94-inverted-page-table\" aria-label=\"4 역페이지 테이블 inverted page table permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4) 역페이지 테이블 inverted page table</h3>\n<ul>\n<li>물리적 메모리의 페이지 프레임 하나당 페이지 테이블 항목을 하나씩 둔다.</li>\n<li>\n<p>논리적 주소에 대한 페이지 테이블을 만드는 것이 아니라 물리적 주소에 대한 페이지 테이블을 만드는 것이다.</p>\n<ul>\n<li>각 프로세스마다 페이지 테이블을 두지 않고 시스템 전체에 대한 페이지 테이블을 하나만 둔다.</li>\n<li>\n<p>페이지 테이블의 각 항목은 <strong>어느 프로세스의 어느 페이지</strong>가 이 프레임에 저장되었는지 정보를 보관한다.</p>\n<ul>\n<li>pid와 페이지 번호 p를 담는다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>물리적 주소에서 논리적 주소를 얻기 수월한 방법이므로 어느 정도의 비효율적인 측면이 있다.</p>\n<ul>\n<li>주소 변환 요청이 들어오면 페이지 테이블을 다 탐색해야하고 시간을 소요한다.</li>\n<li>따라서 페이지 테이블을 메모리에 유지하는 대신 연관 레지스터 (associative register)에 보관히 전체 항목을 병렬 탐색 가능하게 한다.</li>\n</ul>\n</li>\n</ul>\n<p align=\"center\"><img width=\"85%\" src=\"https://user-images.githubusercontent.com/63405904/141052223-35660eb2-db9c-4f94-8496-a89a587b06d0.png\"></p>\n<h3 id=\"5-공유-페이지\" style=\"position:relative;\"><a href=\"#5-%EA%B3%B5%EC%9C%A0-%ED%8E%98%EC%9D%B4%EC%A7%80\" aria-label=\"5 공유 페이지 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5) 공유 페이지</h3>\n<ul>\n<li>\n<p>공유 코드(shared code)는 여러 프로세스에 의해 공통으로 사용될 수 있도록 작성된 코드이다.</p>\n<ul>\n<li>메모리 공간의 효율적인 사용을 위함</li>\n</ul>\n</li>\n<li>재진입 가능 코드 (re-entrant code) 또는 순수 코드 (pure code)로 불리며 read-only 특성을 가진다.</li>\n<li>공유 페이지(shared page)는 공유 코드를 담고있는 페이지이다.</li>\n<li>\n<p>공유 페이지는 여러 프로세스에 공유되기 때문에 물리 메모리에 하나만 적재되어 메모리를 효율적으로 사용할 수 있다.</p>\n<ul>\n<li>문서 편집기를 공유 페이지 사용해서 작성한 경우, 이 프로세스를 여러개 수행시켜도 공유 코드를 담은 페이지는 하나만 올라간다.</li>\n</ul>\n</li>\n<li>공유 코드는 읽기 전용이며 논리적 주소에서 같은 위치에 있어야하는 제약점도 있다.</li>\n<li>\n<p>대비되는 개념으로 사유 페이지(private page)가 있다.</p>\n<ul>\n<li>프로세스별로 독자적으로 사용하는 페이지이며 논리적 주소 공간 중 어디에 있어도 된다.</li>\n</ul>\n</li>\n</ul>\n<p align=\"center\"><img width=\"85%\" src=\"https://user-images.githubusercontent.com/63405904/141052240-708a31c5-6b2e-48b4-beee-b6cf66b8fcca.png\"></p>\n<h3 id=\"6-메모리-보호\" style=\"position:relative;\"><a href=\"#6-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%B3%B4%ED%98%B8\" aria-label=\"6 메모리 보호 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>6) 메모리 보호</h3>\n<ul>\n<li>메모리 보호를 위한 보호 비트(protection bit)와 유효-무효 비트(valid-invalid bit)를두고 있다.</li>\n<li>\n<p>보호 비트</p>\n<ul>\n<li>각 페이지에 대한 접근 권한 내용을 담는다.</li>\n<li>읽기-쓰기/읽기 전용 등의 접근 권한을 설정하여 ‘어떠한’ 접근을 제한한다.</li>\n</ul>\n</li>\n<li>\n<p>유효-무효 비트</p>\n<ul>\n<li>해당 페이지의 내용이 유효한지 내용을 담는다.</li>\n<li>유효로 세팅한다면 해당 메모리 프레임에 그 페이지가 존재하여 접근이 허용된다.</li>\n<li>무효라면 프로세스가 그 주소 부분을 사용하지 않거나 해당 페이지가 물리적 메모리가 아닌 백킹 스토에어에 존재하여 <strong>해당 메모리 프레임</strong>에 접근 권한이 없는 것이다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-5-세그멘테이션\" style=\"position:relative;\"><a href=\"#-5-%EC%84%B8%EA%B7%B8%EB%A9%98%ED%85%8C%EC%9D%B4%EC%85%98\" aria-label=\" 5 세그멘테이션 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 5. 세그멘테이션</h2>\n<ul>\n<li>프로세스의 주소 공간을 의미있는 단위인 세그먼트(segment)로 나누어 물리적 메모리에 올리는 기법이다.</li>\n<li>\n<p>프로세스는 코드, 데이터, 스택 등인 논리적 단위로 구성된다. 이것에 따라서 나눈다.</p>\n<ul>\n<li>많게는 프로그램 함수 하나하나를 세그먼트로 정의할 수도 있다.</li>\n</ul>\n</li>\n<li>크기가 균일하지 않으며 통째로 메모리에 적재되지 않고 나누어져 메모리에 적재되어 페이징과 유사하다.</li>\n<li>균일하지 않은 세그먼트들을 적재하기 때문에 그것을 관리하는 오버헤드가 있다.</li>\n<li>논리적 주소가 <strong>&#x3C;세그먼트 번호, 오프셋></strong> 으로 나뉘어 사용되어 몇번째 세그먼트와 해당 세그먼트 내에서 오프셋 정보를 나타낸다.</li>\n<li>\n<p>세그먼트 테이블을 사용한다.</p>\n<ul>\n<li>기준점(base)와 한계점(limit)을 가지고 있다.</li>\n<li>기준점은 물리 메모리에서 시작위치, 한계점은 세그먼트의 길이이다.</li>\n</ul>\n</li>\n<li>\n<p>두 register의 도움을 받는다.</p>\n<ul>\n<li>\n<p>세그먼트 테이블 기준 레지스터 STBR (Segment Table Base Register)</p>\n<ul>\n<li>세그먼트 테이블이 물리 메모리 어느 위치에 있는지 시작주소</li>\n</ul>\n</li>\n<li>\n<p>세그먼트 테이블 길이 레지스터 STLR (Segment Table Legnth Register)</p>\n<ul>\n<li>해당 프로세스의 주소 공간이 몇개의 세그먼트로 구성되었는지 세그먼트 개수</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>논리적 주소를 물리적 주소로 변환하기 전 두 가지를 확인한다.</p>\n<ol>\n<li>\n<p>요청된 세그먼트 번호가 STLR에 저장된 값보다 작은 값인지</p>\n<ol>\n<li>아니라면 존재하지 않는 세그먼트 접근이므로 예외상황 발생</li>\n</ol>\n</li>\n<li>\n<p>논리적 주소의 오프셋 값이 그 세그먼트의 길이보다 작은지 </p>\n<ol>\n<li>테이블의 해당 항목의 한계점과 논리적 주소의 오프셋을 비교</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>페이징 기법과 마찬가지로 보호비트와 유효비트를 둔다.</li>\n</ul>\n<p align=\"center\"><img width=\"85%\" src=\"https://user-images.githubusercontent.com/63405904/141052384-1976d0e9-efce-440b-bd42-469064f09aac.png\"></p>\n<ul>\n<li>\n<p>여러 프로세스가 특정 세그먼트를 공유해 사용하는 공유 세그먼트(shared segment) 개념이 있다.</p>\n<ul>\n<li>공유 세그먼트는 공유하는 모든 프로세스의 동일한 논리적 주소에 있어야한다.</li>\n</ul>\n</li>\n<li>\n<p>세그먼트는 의미 단위로 나뉘어지므로 공유와 보안 측면에서 페이징 기법보다 효과적이다.</p>\n<ul>\n<li>주소 공간의 일부를 공유하거나 접근 권한 제어 등이 가능하다.</li>\n<li>의미 단위로 업무를 수행할 수 있다.</li>\n</ul>\n</li>\n<li>\n<p>하지만 길이가 균일하지 않아서 물리적 메모리에 외부조각이 발생한다.</p>\n<ul>\n<li>세그먼트를 어느 가용 공간에 할당할 문제도 있다.</li>\n<li>최초적합과 최적적합 방식이 있다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-6-페이지드-세그먼테이션\" style=\"position:relative;\"><a href=\"#-6-%ED%8E%98%EC%9D%B4%EC%A7%80%EB%93%9C-%EC%84%B8%EA%B7%B8%EB%A8%BC%ED%85%8C%EC%9D%B4%EC%85%98\" aria-label=\" 6 페이지드 세그먼테이션 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 6. 페이지드 세그먼테이션</h2>\n<ul>\n<li>페이징과 세그먼테이션의 장점을 취하는 기법이다.</li>\n<li>의미단위로 세그먼트를 나누고 세그먼트의 길이가 동일한 크기의 페이지들의 집합으로 이루어지도록 한다.</li>\n<li>물리 메모리 적재는 페이지 단위로 한다.</li>\n<li>하나의 세그먼트 크기를 페이지크기의 배수가 되도록 하여 외부조각 문제를 해결하고 세그먼트 단위로 공유나 접근 권한 보호가 이루어질 수 있도록 한다.</li>\n<li>주소 변환을 위해 <strong>1) 외부의 세그먼트 테이블 2) 내부의 페이지 테이블</strong> 두가지를 사용한다.</li>\n<li>\n<p><strong>&#x3C;세그먼트 번호, 오프셋></strong> 으로 논리주소가 구성되었다.</p>\n<ul>\n<li>\n<p>세그먼트 번호로 세그먼트 테이블에 접근하여 세그먼트의 길이와 세그먼트의 페이지 테이블 시작주소를 얻는다.</p>\n<ul>\n<li>세그먼트 길이와 논리주소의 오프셋을 비교하여 메모리 접근 유효성을 검사한다.</li>\n</ul>\n</li>\n<li>오프셋을 상위, 하위로 나누어 상위는 세그먼트 내의 페이지 테이블 번호로 사용하고 하위는 페이지 내에서의 변위로 사용한다.</li>\n<li>페이지 번호로 페이지 테이블 항목에서 물리적 메모리의 프레임 위치를 얻는다.</li>\n</ul>\n</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#-%EB%93%A4%EC%96%B4%EA%B0%80%EA%B8%B0-%EC%A0%84\">🌩 들어가기 전</a></li>\n<li>\n<p><a href=\"#-1-%EC%A3%BC%EC%86%8C-%EB%B0%94%EC%9D%B8%EB%94%A9\">🌩 1. 주소 바인딩</a></p>\n<ul>\n<li><a href=\"#%EC%A3%BC%EC%86%8C-%EB%B0%94%EC%9D%B8%EB%94%A9-%EB%B0%A9%EC%8B%9D\">주소 바인딩 방식</a></li>\n<li><a href=\"#mmu-%EA%B8%B0%EB%B2%95\">MMU 기법</a></li>\n<li><a href=\"#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%B3%B4%EC%95%88-memory-protection\">메모리 보안 Memory protection</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-2-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC%EC%99%80-%EA%B4%80%EB%A0%A8%EB%90%9C-%EC%9A%A9%EC%96%B4\">🌩 2. 메모리 관리와 관련된 용어</a></p>\n<ul>\n<li><a href=\"#1-%EB%8F%99%EC%A0%81%EB%A1%9C%EB%94%A9-dynamic-loading\">1) 동적로딩 dynamic loading</a></li>\n<li><a href=\"#2-%EB%8F%99%EC%A0%81%EC%97%B0%EA%B2%B0-dynamic-linking\">2) 동적연결 dynamic linking</a></li>\n<li><a href=\"#3-%EC%A4%91%EC%B2%A9-overlays\">3) 중첩 overlays</a></li>\n<li><a href=\"#4-%EC%8A%A4%EC%99%80%ED%95%91-swapping\">4) 스와핑 swapping</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-3-%EB%AC%BC%EB%A6%AC%EC%A0%81-%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%9D%98-%ED%95%A0%EB%8B%B9%EB%B0%A9%EC%8B%9D\">🌩 3. 물리적 메모리의 할당방식</a></p>\n<ul>\n<li><a href=\"#1-%EC%97%B0%EC%86%8D%ED%95%A0%EB%8B%B9-%EB%B0%A9%EC%8B%9D\">1) 연속할당 방식</a></li>\n<li><a href=\"#2-%EB%B6%88%EC%97%B0%EC%86%8D%ED%95%A0%EB%8B%B9-%EA%B8%B0%EB%B2%95\">2) 불연속할당 기법</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-4-%ED%8E%98%EC%9D%B4%EC%A7%95-%EA%B8%B0%EB%B2%95\">🌩 4. 페이징 기법</a></p>\n<ul>\n<li><a href=\"#1-%EC%A3%BC%EC%86%8C-%EB%B3%80%ED%99%98-%EA%B8%B0%EB%B2%95\">1) 주소 변환 기법</a></li>\n<li><a href=\"#2-%ED%8E%98%EC%9D%B4%EC%A7%80-%ED%85%8C%EC%9D%B4%EB%B8%94%EC%9D%98-%EA%B5%AC%ED%98%84\">2) 페이지 테이블의 구현</a></li>\n<li><a href=\"#3-%EA%B3%84%EC%B8%B5%EC%A0%81-%ED%8E%98%EC%9D%B4%EC%A7%95\">3) 계층적 페이징</a></li>\n<li><a href=\"#4-%EC%97%AD%ED%8E%98%EC%9D%B4%EC%A7%80-%ED%85%8C%EC%9D%B4%EB%B8%94-inverted-page-table\">4) 역페이지 테이블 inverted page table</a></li>\n<li><a href=\"#5-%EA%B3%B5%EC%9C%A0-%ED%8E%98%EC%9D%B4%EC%A7%80\">5) 공유 페이지</a></li>\n<li><a href=\"#6-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%B3%B4%ED%98%B8\">6) 메모리 보호</a></li>\n</ul>\n</li>\n<li><a href=\"#-5-%EC%84%B8%EA%B7%B8%EB%A9%98%ED%85%8C%EC%9D%B4%EC%85%98\">🌩 5. 세그멘테이션</a></li>\n<li><a href=\"#-6-%ED%8E%98%EC%9D%B4%EC%A7%80%EB%93%9C-%EC%84%B8%EA%B7%B8%EB%A8%BC%ED%85%8C%EC%9D%B4%EC%85%98\">🌩 6. 페이지드 세그먼테이션</a></li>\n</ul>\n</div>","excerpt":"다음은 반효경 교수님의 ‘운영체제와 정보기술의 원리’ CH7. 메모리 관리를 읽고 정리한 내용입니다 🙌 🌩 들어가기 전 우리가 흔히 사용하는 컴퓨터 주소 체계는 32비트 혹은 64비트로 나뉘어져 있다. 32비트면 32개의 비트로 주소를 표현할 수 있는 것이다. 2^32가지 다른 메모리 위치를 구분할 수 있다. 컴퓨터는 바이트 단위(8비트)로 주소를 부여한다. 따라서 2^32 바이트 만큼의 메모리 공간에 서로 다른 주소를 할당할 수 있다. 32 비트를 계층적으로 묶어서 관리한다. 보통 4KB (2^12 바이트) 단위로 묶어서 페이지(page)를 구성한다. 페이지 내에서 주소를 구분하기 위해서는 12비트가 필요하다. 따라서 32비트 중 하위 12비트는 페이지 내에서 주소를 나타낸다. 🌩 1. 주소 바인딩 프로세스의 주소 공간 (address space)는 프로그램이 실행되기 위해 메모리에 적재되면 프로세스를 위한 독자적인 주소 공간이 생성된다. 논리적 주소 (logical addres…","frontmatter":{"date":"October 16, 2021","title":"운영체제와 정보기술의 원리 - CH7. 메모리 관리","categories":"운영체제 책","author":"코다","emoji":"🧁"},"fields":{"slug":"/operating-system-6/"}},"next":{"id":"6a22f61a-df2e-50fa-b1ee-dcb3734cbb98","html":"<blockquote>\n<p>다음은 반효경 교수님의 ‘운영체제와 정보기술의 원리’ <em>CH6. CPU 스케줄링</em>를 읽고 정리한 내용입니다 🙌</p>\n</blockquote>\n<br>\n<br>\n<h2 id=\"-intro\" style=\"position:relative;\"><a href=\"#-intro\" aria-label=\" intro permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 INTRO</h2>\n<ul>\n<li>CPU는 PC가 가리키는 명령어를 하나씩 수행하기 때문에 효율적으로 관리해야한다.</li>\n<li>\n<p>기계어 명령은 다음 3가지로 나뉜다.</p>\n<ol>\n<li>\n<p>CPU 내에서 수행되는 명령 </p>\n<ol>\n<li>ADD 명령</li>\n<li>수행 속도 빠르며 일반명령</li>\n<li>CPU 버스트 </li>\n</ol>\n</li>\n<li>\n<p>메모리 접근을 필요로 하는 명령</p>\n<ol>\n<li>LOAD 명령</li>\n<li>메모리에 있는 데이터를 CPU로 읽는 명령</li>\n<li>CPU 명령보다는 오래 걸리지만 비교적 빠르며 일반명령</li>\n<li>CPU 버스트 </li>\n</ol>\n</li>\n<li>\n<p>입출력을 동반하는 명령</p>\n<ol>\n<li>입출력 작업이필요한 경우이며 오랜 시간이 소요</li>\n<li>특권명령으로 운영체제를 통해 서비스를 대행해야한다. </li>\n<li>I/O 버스트 </li>\n</ol>\n</li>\n<li>CPU 수행은 위 명령어의 조합과 반복으로 이루어진다.</li>\n</ol>\n</li>\n<li>\n<p>각 프로그램마다 위 명령어들의 비율이 다르며 CPU 연산이 많이 이루어지는 것을 CPU 바운드 프로세스, I/O 연산이 많이 일어나는 것을 I/O 바운트 프로세스라고 한다.</p>\n<ul>\n<li>I/O 바운드 프로세스는 사용자 인터렉션이 많은 대화형 프로그램이 해당된다.</li>\n</ul>\n</li>\n<li>프로그램마다 CPU 사용패턴이 다르므로 버스트가 균일하지 않다. 때문에 효율적인 CPU 스캐줄링이 필요하다.</li>\n<li>\n<p>컴퓨터에서 수행되는 대부분의 프로세스는 다수의 짧은 CPU 버스트와 소수의 긴 CPU 버스트로 구성이 된다.</p>\n<ul>\n<li>CPU 버스트가 짧은 프로세스들은 대화형 작업으로 사용자와 인터렉션을 하며 입력을 받아서 연산을 수행하는 것이다.</li>\n<li>이런 작업은 빠른 응답을 위해 CPU의 빠른 서비스를 필요로 한다.</li>\n</ul>\n</li>\n<li>\n<p>CPU 스캐줄링 시 버스트가 짧은 프로세스에게 우선적으로 CPU를 사용할 수 있도록 하는 스캐줄링이 필요하다.</p>\n<ul>\n<li>I/O 바운드 프로세스의 우선순위를 높이는 것이 필요하다.</li>\n</ul>\n</li>\n<li>I/O 바운드 프로세스에게 우선권을 주면 I/O 장치의 효율성을 높이며 CPU 연산을 하는 동안 I/O 장치가 휴먼 상태인 것도 방지할 수 있다.</li>\n</ul>\n<br>\n<h2 id=\"-1-cpu-스캐줄러\" style=\"position:relative;\"><a href=\"#-1-cpu-%EC%8A%A4%EC%BA%90%EC%A4%84%EB%9F%AC\" aria-label=\" 1 cpu 스캐줄러 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 1. CPU 스캐줄러</h2>\n<ul>\n<li>운영체제의 코드로 준비 상태에 있는 프로세스들 중 어느 프로세스에게 CPU를 할당할지 결정한다.</li>\n<li>대표적으로 <strong>타이머 인터럽트가 발생</strong>하면 CPU 스캐줄러가 호출되며 준비 큐에 있는 프로세스 중 하나를 선택해서 CPU를 할당한다.</li>\n<li>\n<p>다음과 같은 경우에도 호출된다.</p>\n<ol>\n<li>실행상태 프로세스는 I/O 요청 등에 의해 봉쇄 상태로 바뀌는 경우 - 비선점형 </li>\n<li>실행상태 프로세스가 타이머 인터럽트로 준비 상태로 바뀌는 경우 - 선점형 </li>\n<li>봉쇄상태 프로세스가 I/O 작업이 완료되어 인터럽트가 발생하고 준비상태로 바뀌는 경우 - 선점형 </li>\n<li>CPU의 실행상태에 있던 프로세스가 종료되는 경우 - 비선점형 </li>\n</ol>\n</li>\n<li>\n<p>스캐줄링 방식 2가지가 있다.</p>\n<ul>\n<li>\n<p>비선점형 (nonpreemptive) 방식</p>\n<ul>\n<li>CPU를 차지한 프로세스가 스스로 반납하기 전에 CPU를 뺏기지 않는 방법이다.</li>\n</ul>\n</li>\n<li>\n<p>선점형 (preemptive) 방식</p>\n<ul>\n<li>프로세스에게서 CPU를 강제로 빼앗을 수 있는 방식이다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>CPU 빼앗는 방법</p>\n<ul>\n<li>할당시간 time quantum을 부여하여 타이머 인터럽트를 발생시켜서 빼앗는다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-2-디스패처\" style=\"position:relative;\"><a href=\"#-2-%EB%94%94%EC%8A%A4%ED%8C%A8%EC%B2%98\" aria-label=\" 2 디스패처 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 2. 디스패처</h2>\n<ul>\n<li>\n<p>다음 프로세스에게 CPU를 이양하는 작업을 수행하는 운영체제의 코드를 dispatcher라고 부른다.</p>\n<ul>\n<li>현재 프로세스의 문맥을 해당 프로세스의 PCB에 저장하고</li>\n<li>새로운 프로세스의 문맥을 PCB로부터 CPU에 복원한다.</li>\n<li>시스템의 상태를 사용자 모드로 전환하고 사용자 프로그램에게 CPU 제어권을 넘긴다.</li>\n</ul>\n</li>\n<li>위 과정이 걸리는 시간은 디스패처 지연시간 dispatch latency라고 하며 문맥교환 오버헤드에 해당한다.</li>\n</ul>\n<br>\n<h2 id=\"-3-스캐줄링의-성능-평가\" style=\"position:relative;\"><a href=\"#-3-%EC%8A%A4%EC%BA%90%EC%A4%84%EB%A7%81%EC%9D%98-%EC%84%B1%EB%8A%A5-%ED%8F%89%EA%B0%80\" aria-label=\" 3 스캐줄링의 성능 평가 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 3. 스캐줄링의 성능 평가</h2>\n<ul>\n<li>\n<p>2가지 지표</p>\n<ul>\n<li>\n<p>시스템 관점 지표</p>\n<ul>\n<li>CPU 이용률 및 처리량</li>\n</ul>\n</li>\n<li>\n<p>사용자 관점 지표</p>\n<ul>\n<li>소요시간, 대기시간, 응답시간 등 기다린 시간</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>CPU utilization</p>\n<ul>\n<li>전체 시간 중 CPU가 일을 한 시간 비율이며 이용률은 시스템 전체 성능과 밀접하게 관련있다.</li>\n<li>CPU의 휴면 idle 상태를 최대한 줄이는 것이 중요하다.</li>\n</ul>\n</li>\n<li>\n<p>처리량 throughput</p>\n<ul>\n<li>\n<p>주어진 시간 동안 준비 큐에서 기다리고 있는 프로세스 중 몇개를 끝냈는지를 나타낸다.</p>\n<ul>\n<li>CPU 버스트를 완료한 프로세스 수</li>\n</ul>\n</li>\n<li>처리량을 높이기 위해서는 CPU 버스트가 짧은 프로세스에게 우선적으로 CPU를 할당하는 것이 유리하다.</li>\n</ul>\n</li>\n<li>\n<p>소요시간 turnaround time</p>\n<ul>\n<li>프로세스가 CPU를 요청한 시점부터 원하는 만큼 CPU를 다 쓰고 CPU 버스트가 끝날 때까지 걸린 시간</li>\n<li>준비큐에서 기다린 시간 + CPU 사용한 시간</li>\n<li>각 소요시간은 프로그램의 시작 및 종료 시간보다 CPU 버스트 단위로 별도로 측정한다.</li>\n</ul>\n</li>\n<li>\n<p>대기시간 waiting time</p>\n<ul>\n<li>CPU 버스트 기간 중 프로세스가 준비 큐에서 CPU를 얻기 위해 기다린 시간의 합</li>\n<li>시분할 시스템에서는 한번의 CPU 버스트 중 준비큐에서 기다린 시간이 많을 수 있으며 이것의 합이다</li>\n</ul>\n</li>\n<li>\n<p>응답시간 response time</p>\n<ul>\n<li>프로세스가 준비 큐에 들어온 이후 첫번째 CPU 획득까지 걸린 시간</li>\n<li>타이머 인터럽트 주기가 짧을 경우 프로세스가 빨리 돌아가서 응답시간이 줄어드므로 향상된다.</li>\n<li>대화형 시스템에 적합한 성능 척도이며 사용자 입장에서 가장 중요한 척도이다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-4-스캐줄링-알고리즘\" style=\"position:relative;\"><a href=\"#-4-%EC%8A%A4%EC%BA%90%EC%A4%84%EB%A7%81-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" aria-label=\" 4 스캐줄링 알고리즘 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 4. 스캐줄링 알고리즘</h2>\n<h3 id=\"선입선출-스케줄링-fcfs\" style=\"position:relative;\"><a href=\"#%EC%84%A0%EC%9E%85%EC%84%A0%EC%B6%9C-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81-fcfs\" aria-label=\"선입선출 스케줄링 fcfs permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>선입선출 스케줄링 FCFS</h3>\n<ul>\n<li>프로세스가 준비 큐에 도착한 시간 순대로 CPU를 할당하는 방식</li>\n<li>해당 프로세스가 자발적으로 CPU를 반납할 때까지 CPU를 빼앗기지 않는다.</li>\n<li>\n<p>때로 비효율적인 결과를 초래한다.</p>\n<ul>\n<li>CPU 버스트가 긴 프로세스가 짧은 프로세스 여러 개 보다 먼저 도착하면 CPU를 잠깐 사용하고 I/O 작업을 할 수 있는 프로세스가 앞의 긴 프로세스 하나 때문에 오래 기다려야 한다.</li>\n<li>I/O 장치 이용률도 떨어진다.</li>\n</ul>\n</li>\n<li>먼저 도착한 프로세스의 버스트 길이에 따라 평균 대기시간이 크게 달라진다.</li>\n<li>convoy effect 콘보이 현상 - CPU 버스트가 짧은 프로세스가 버스트가 긴 프로세스부터 나중에 도착해 오랜 시간을 기다려야 하는 현상</li>\n</ul>\n<h3 id=\"최단작업-우선-스캐줄링-sjf-shortest-job-first\" style=\"position:relative;\"><a href=\"#%EC%B5%9C%EB%8B%A8%EC%9E%91%EC%97%85-%EC%9A%B0%EC%84%A0-%EC%8A%A4%EC%BA%90%EC%A4%84%EB%A7%81-sjf-shortest-job-first\" aria-label=\"최단작업 우선 스캐줄링 sjf shortest job first permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>최단작업 우선 스캐줄링 SJF (Shortest Job First)</h3>\n<ul>\n<li>CPU 버스트가 가장 짧은 프로세스에게 가장먼저 CPU를 할당하는 방식으로 프로세스의 준비 큐에서 기다리는 전체적인 시간이 줄어든다.</li>\n<li>대기시간을 가장 짧게 하는 최적 알고리즘이다.</li>\n<li>\n<p>비선점형 방식과 선점형 방식</p>\n<ul>\n<li>비선점형은 CPU를 획득하면 해당 프로세스가 CPU를 자진 반납하기 전까지 CPU 할당</li>\n<li>\n<p>선점형은 CPU에서 버스트가 가장 짧은 프로세스에게 할당하더라도 중간에 더 짧은 버스트 프로세스가 도착하면 CPU를 빼앗아 더 짧은 프로세스에게 우선 부여하는 방식</p>\n<ul>\n<li>현재 진행 중이던 프로세스의 <strong>남은 버스트 시간</strong>보다 더 짧은 경우이다.</li>\n<li>SRTF Shortest Remaining Time First 라고도 부른다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>일반적으로 프로세스가 한꺼번에 도착하지 않으므로 선점형 방식이 평균 대기시간을 가장 많이 줄일 수 있는 방법이다.</li>\n<li>\n<p><strong>하지만 프로세스의 CPU 버스트 시간을 미리 알 수 없다.</strong></p>\n<ul>\n<li>따라서 CPU 시간을 예측하여 스캐줄링한다.</li>\n<li>이전 CPU 버스트 시간의 예측값과 실제값의 반영정도를 매개변수로 한 공식을 사용한다.</li>\n<li>과거의 CPU 버스트 시간들을 통해 미래 CPU 버스트 시간을 예측하는 것인데 최근 것일수록 가중치를 눂여서 반영하는 형식이다.</li>\n</ul>\n</li>\n<li>\n<p>평균 대기시간을 최소화 하기는 하지만 평균 CPU 버스트 시간이 긴 프로세스는 준비큐에서 무한정 기다려야하는 문제가 발생한다.</p>\n<ul>\n<li>기아 현상 starvation이라고 한다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"우선순위-스케줄링-priority-scheduling\" style=\"position:relative;\"><a href=\"#%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81-priority-scheduling\" aria-label=\"우선순위 스케줄링 priority scheduling permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>우선순위 스케줄링 priority scheduling</h3>\n<ul>\n<li>준비 큐에서 기다리는 프로세스 중 우선순위가 가장 높은 프로세스에게 먼저 CPU를 할당한다.</li>\n<li>우선순위 값을 할당하며 숫자가 적은 것이 우선순위가 높은것으로 판단한다.</li>\n<li>\n<p>우선순위값의 정의는 여러가지이다.</p>\n<ul>\n<li>CPU 버스트 시간을 그 값으로 정하면 SJF 알고리즘과 동일하다.</li>\n</ul>\n</li>\n<li>\n<p>선점형과 비선점형이 있다.</p>\n<ul>\n<li>선점형은 수행중인 프로세스 보다 높은 우선순위 프로세스가 들어오면 선점하여 CPU를 할당한다.</li>\n</ul>\n</li>\n<li>\n<p>기아 현상이 발생할 수 있다.</p>\n<ul>\n<li>우선순위가 높은 프로세스가 계속 들어올 경우 CPU를 계속 할당받지 못하는 프로세스가 있을 수 있다.</li>\n<li>\n<p>노화 aging 기법을 사용한다.</p>\n<ul>\n<li>기다리는 시간이 길어지면 우선순위를 조금씩 높여서 CPU를 할당받을 수 있게 한다.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"라운드-로빈-스캐줄링-round-robin-scheduling\" style=\"position:relative;\"><a href=\"#%EB%9D%BC%EC%9A%B4%EB%93%9C-%EB%A1%9C%EB%B9%88-%EC%8A%A4%EC%BA%90%EC%A4%84%EB%A7%81-round-robin-scheduling\" aria-label=\"라운드 로빈 스캐줄링 round robin scheduling permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>라운드 로빈 스캐줄링 round robin scheduling</h3>\n<ul>\n<li>시분할 시스템의 성질을 가장 잘 이용한 스캐줄링 방식이다.</li>\n<li>각 프로세스가 <strong>CPU를 연속적으로 사용할 수 있는 시간이 제한되며 시간이 경과하면 CPU를 회수</strong>해 다른 프로세스에게 할당한다.</li>\n<li>\n<p>할당 시간 time quantum - CPU를 연속적으로 사용할 수 있는 최대시간</p>\n<ul>\n<li>할당시간이 너무 길면 FCFS와 동일해진다.</li>\n<li>할당시간이 너무 짧으면 문맥교환의 오버헤드가 커진다.</li>\n<li>일반적으로 수십밀리초 정도의 규모로 설정한다.</li>\n</ul>\n</li>\n<li>\n<p>n 개의 프로세스에 q만큼의 할당시간이라고 하면 모든 프로세스는 적어도 (n-1)q 시간 이내에 적어도 한번 CPU를 할당받을 수 있다.</p>\n<ul>\n<li>대화형 프로세스에 빠른 응답시간을 보장한다.</li>\n</ul>\n</li>\n<li>\n<p>n 개의 프로세스에 q만큼의 할당시간이라고 하면 모든 프로세스는 적어도 (n-1)q 시간 이내에 적어도 한번 CPU를 할당받을 수 있다.</p>\n<ul>\n<li>대화형 프로세스에 빠른 응답시간을 보장한다.</li>\n</ul>\n</li>\n<li>CPU 버스트가 긴 프로세스는 대기 시간이 비례해서 길어지고 적게 쓰는 프로세스는 대기시간도 짧아진다.</li>\n<li><strong>SJF 보다 평균 대기 시간은 길지만 응답시간은 더 짧다.</strong></li>\n<li>\n<p>할당시간이 만료되면 타이머 인터럽트로 CPU를 회수한다. 만일 CPU 버스트 시간이 할당 시간보다 짧으면 자진 반납한다.</p>\n<ul>\n<li>짧은 프로세스는 빨리 CPU를 얻으며 긴 프로세스도 불이익 당하지 않아서 매우 공정하다.</li>\n</ul>\n</li>\n<li><strong>소요시간과 대기시간이 CPU 버스트의 길이와 비례하여 공정하다.</strong></li>\n<li>\n<p>FCFS와 비교했을 때 FCFS는 하나씩 프로세스를 끝마쳐 가므로 해당 프로세스의 소요시간 및 대기 시간이 짧아지지만 라운드 로빈 스케줄링은 CPU를 조금씩 같이 쓰고 거의 동시에 끝나게 되어 소요시간 및 대기시간이 가장 긴 프로세스에 어느정도 맞춰진다.</p>\n<ul>\n<li>동일한 CPU 버스트 시간을 가진 프로세스들이 도착할 경우 평균 소요시간 및 대기시간이 길어지지만 여전히 평균 응답시간은 더 짧다.</li>\n</ul>\n</li>\n<li>하지만 주로 프로세스의 CPU 버스트 시간이 균일하지 않으므로 라운드 로빈 스캐줄링 기법이 타당한다.</li>\n</ul>\n<h3 id=\"멀티레벨-큐-multi-level-queue\" style=\"position:relative;\"><a href=\"#%EB%A9%80%ED%8B%B0%EB%A0%88%EB%B2%A8-%ED%81%90-multi-level-queue\" aria-label=\"멀티레벨 큐 multi level queue permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>멀티레벨 큐 multi-level queue</h3>\n<ul>\n<li>큐를 여러개 분할해 관리하는 스캐줄링 기법이다.</li>\n<li>어떤 줄의 프로세스에 CPU를 할당하며 프로세스를 어떤 줄에 세워야할지 고려해야한다.</li>\n<li>\n<p>성격이 다른 프로세스들을 별도로 관리하고 각각의 성격에 맞는 스케줄링을 큐마다 적용한다.</p>\n<ul>\n<li>예를 들어 대화형 작업과 그렇지 않은 작업을 따로 두어 대화형 작업에 우선적으로 CPU를 할당한다.</li>\n</ul>\n</li>\n<li>\n<p>일반적으로 전위큐 (foreground queue)와 후위큐(background queue)로 분할하여 운영한다.</p>\n<ul>\n<li>전위큐는 응답시간을 짧게하기 위한 라운드 로빈 스캐줄링</li>\n<li>후위큐는 계산 위주 작업으로 응답시간이 중요하지 않은 FCFS 스캐줄링 기법으로 문맥교환 오버헤드를 줄인다.</li>\n</ul>\n</li>\n<li>\n<p>큐 자체에 대한 스캐줄링도 필요하다.</p>\n<ul>\n<li>\n<p>가장 쉬운 방법은 고정 우선순위 방식 fixed priority scheduling 이다.</p>\n<ul>\n<li>우선순위가 높은 큐를 먼저 서비스하고 해당 큐가 비면 우선순위가 낮은 큐를 서비스한다.</li>\n</ul>\n</li>\n<li>\n<p>타임 슬라이스 time slice 방식</p>\n<ul>\n<li>큐의 기아 현상을 해소하기위해 각 큐에 CPU 시간을 적절한 비율로 할당한다.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"멀티레벨-피드백-큐-multilevel-feedback-queue\" style=\"position:relative;\"><a href=\"#%EB%A9%80%ED%8B%B0%EB%A0%88%EB%B2%A8-%ED%94%BC%EB%93%9C%EB%B0%B1-%ED%81%90-multilevel-feedback-queue\" aria-label=\"멀티레벨 피드백 큐 multilevel feedback queue permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>멀티레벨 피드백 큐 multilevel feedback queue</h3>\n<ul>\n<li>\n<p>멀티레벨큐와 비슷하나 프로세스가 하나의 큐에서 다른 큐로 이동할 수 있다.</p>\n<ul>\n<li>예를 들어 노화 기법을 사용하여 우선순위가 낮은 큐에서 높은 큐로 이동할 수 있다.</li>\n</ul>\n</li>\n<li>큐의 수, 각 큐의 스캐줄링 알고리즘, 프로세스를 상위 큐로 승격시키는 기준, 프로세스를 강등시키는 기준, 프로세스가 도착할 대 큐를 결정하는 기준 등을 고려해야한다.</li>\n<li>\n<p>일반적인 멀티레벨 피드백 큐는</p>\n<ul>\n<li>3개의 큐로 구성되며 우선순위 순으로 라운드로빈 (할당시간 5) → 라운드로빈 (할당시간 10) → FCFS 이다.</li>\n<li>대화형 서비스는 빨리 작업을 완료할 수 있다.</li>\n<li>모든 프로세스들은 처음에 상위 큐에 있다가 할당시간만큼 서비스 되고 나서 버스트 기간이 남으면 하위 큐로 강등된다.</li>\n<li>큐는 최상위 큐가 비었을 때 하위 큐가 서비스 받는다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"다중처리기-스케줄링-multi-processor-system\" style=\"position:relative;\"><a href=\"#%EB%8B%A4%EC%A4%91%EC%B2%98%EB%A6%AC%EA%B8%B0-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81-multi-processor-system\" aria-label=\"다중처리기 스케줄링 multi processor system permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>다중처리기 스케줄링 multi-processor system</h3>\n<ul>\n<li>각 CPU 별로 줄을 세워야하므로 더 복잡하다.</li>\n<li>일부 CPU에 작업이 편중될 수도 있는데 이것을 방지하기 위해 적절히 분산되도록 부하균형(load balancing) 매커니즘이 필요하다.</li>\n<li>\n<p>대칭형 다중처리</p>\n<ul>\n<li>CPU가 각자 알아서 스케줄링을 결정한다.</li>\n</ul>\n</li>\n<li>\n<p>비대칭형 다중처리</p>\n<ul>\n<li>하나의 CPU가 다른 CPU 스캐줄링 및 데이터 접근을 책임진다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"실시간-스케줄링\" style=\"position:relative;\"><a href=\"#%EC%8B%A4%EC%8B%9C%EA%B0%84-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81\" aria-label=\"실시간 스케줄링 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>실시간 스케줄링</h3>\n<ul>\n<li>각 작업마다 데드라인이 있어서 반드시 처리해야하는 real-time system에서 사용된다.</li>\n<li>\n<p>경성 실시간 시스템 hard real-time system과 연성 실시간 시스템 soft real-time system 으로 나뉜다.</p>\n<ul>\n<li>전자는 미사일 원자로 제어 등 반드시 정확해야하는 시스템</li>\n<li>후자는 위험하지는 않은 멀티미디어 스트리밍 시스템</li>\n</ul>\n</li>\n<li>데드라인이 얼마 남지 않은 요청을 먼저 처리하는 EDF earliest dedline first 스캐줄링을 사용한다.</li>\n</ul>\n<br>\n<h2 id=\"-5-스캐줄링-알고리즘의-평가\" style=\"position:relative;\"><a href=\"#-5-%EC%8A%A4%EC%BA%90%EC%A4%84%EB%A7%81-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%98-%ED%8F%89%EA%B0%80\" aria-label=\" 5 스캐줄링 알고리즘의 평가 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 5. 스캐줄링 알고리즘의 평가</h2>\n<ul>\n<li>\n<p>큐잉 모델</p>\n<ul>\n<li>확률분포 등 수학적으로 구해서 평가한다.</li>\n</ul>\n</li>\n<li>\n<p>구현 및 실측</p>\n<ul>\n<li>실제로 수행하여 커널을 컴파일하여 실행시간 측정하여 평가한다.</li>\n</ul>\n</li>\n<li>\n<p>시물레이션</p>\n<ul>\n<li>가상 CPU 스캐줄링 프로그램을 작성하여 결과를 확인한다.</li>\n</ul>\n</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#-intro\">🌩 INTRO</a></li>\n<li><a href=\"#-1-cpu-%EC%8A%A4%EC%BA%90%EC%A4%84%EB%9F%AC\">🌩 1. CPU 스캐줄러</a></li>\n<li><a href=\"#-2-%EB%94%94%EC%8A%A4%ED%8C%A8%EC%B2%98\">🌩 2. 디스패처</a></li>\n<li><a href=\"#-3-%EC%8A%A4%EC%BA%90%EC%A4%84%EB%A7%81%EC%9D%98-%EC%84%B1%EB%8A%A5-%ED%8F%89%EA%B0%80\">🌩 3. 스캐줄링의 성능 평가</a></li>\n<li>\n<p><a href=\"#-4-%EC%8A%A4%EC%BA%90%EC%A4%84%EB%A7%81-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\">🌩 4. 스캐줄링 알고리즘</a></p>\n<ul>\n<li><a href=\"#%EC%84%A0%EC%9E%85%EC%84%A0%EC%B6%9C-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81-fcfs\">선입선출 스케줄링 FCFS</a></li>\n<li><a href=\"#%EC%B5%9C%EB%8B%A8%EC%9E%91%EC%97%85-%EC%9A%B0%EC%84%A0-%EC%8A%A4%EC%BA%90%EC%A4%84%EB%A7%81-sjf-shortest-job-first\">최단작업 우선 스캐줄링 SJF (Shortest Job First)</a></li>\n<li><a href=\"#%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81-priority-scheduling\">우선순위 스케줄링 priority scheduling</a></li>\n<li><a href=\"#%EB%9D%BC%EC%9A%B4%EB%93%9C-%EB%A1%9C%EB%B9%88-%EC%8A%A4%EC%BA%90%EC%A4%84%EB%A7%81-round-robin-scheduling\">라운드 로빈 스캐줄링 round robin scheduling</a></li>\n<li><a href=\"#%EB%A9%80%ED%8B%B0%EB%A0%88%EB%B2%A8-%ED%81%90-multi-level-queue\">멀티레벨 큐 multi-level queue</a></li>\n<li><a href=\"#%EB%A9%80%ED%8B%B0%EB%A0%88%EB%B2%A8-%ED%94%BC%EB%93%9C%EB%B0%B1-%ED%81%90-multilevel-feedback-queue\">멀티레벨 피드백 큐 multilevel feedback queue</a></li>\n<li><a href=\"#%EB%8B%A4%EC%A4%91%EC%B2%98%EB%A6%AC%EA%B8%B0-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81-multi-processor-system\">다중처리기 스케줄링 multi-processor system</a></li>\n<li><a href=\"#%EC%8B%A4%EC%8B%9C%EA%B0%84-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81\">실시간 스케줄링</a></li>\n</ul>\n</li>\n<li><a href=\"#-5-%EC%8A%A4%EC%BA%90%EC%A4%84%EB%A7%81-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%98-%ED%8F%89%EA%B0%80\">🌩 5. 스캐줄링 알고리즘의 평가</a></li>\n</ul>\n</div>","frontmatter":{"date":"October 15, 2021","title":"운영체제와 정보기술의 원리 - CH6. CPU 스케줄링","categories":"운영체제 책","author":"코다","emoji":"🧁"},"fields":{"slug":"/operating-system-5/"}},"prev":{"id":"6d288200-6a5c-5a45-b4b9-a99ac34bd599","html":"<blockquote>\n<p>다음은 반효경 교수님의 ‘운영체제와 정보기술의 원리’ <em>CH8. 가상 메모리</em>를 읽고 정리한 내용입니다 🙌</p>\n</blockquote>\n<br>\n<br>\n<h2 id=\"-들어가기-전\" style=\"position:relative;\"><a href=\"#-%EB%93%A4%EC%96%B4%EA%B0%80%EA%B8%B0-%EC%A0%84\" aria-label=\" 들어가기 전 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 들어가기 전</h2>\n<ul>\n<li>시분할 환경에서는 여러 프로세스가 동시에 메모리에 올라와서 수행되기 때문에 어떤 메모리에 어느 정도의 메모리를 할당해야할지가 문제이다.</li>\n<li>\n<p>운영체제는 몇몀 프로그램에게 집중적으로 메모리를 할당하고 시간이 흐른다음 메모리를 회수하여 다른 프로그램에게 집중적으로 메모리를 할당하는 방식을 택한다.</p>\n<ul>\n<li>프로그램마다 프로세스를 빠르게 수행하기 위해서 확보해야하는 최소한의 메모리 크기가 있기 때문이다.</li>\n</ul>\n</li>\n<li>프로세스의 전체가 올라가는 것이 아니라 스왑 영역에 일부분은 내려놓기 때문에 프로세스 입장에서 물리 메모리 크기 제약은 생각하지 않게 된다.</li>\n<li>\n<p>또한 운영체제는 각 프로세스가 자기만 메모리에 올라간 것처럼 여겨질 수 있는 가장 메모리를 지원한다.</p>\n<ul>\n<li>각자의 주소 공간을 가정하여 모든 프로세스가 0번지부터 시작한다.</li>\n<li>일부는 스왑 영역에 일부는 메모리에 있다.</li>\n</ul>\n</li>\n<li>\n<p>프로세스의 주소 공간을 메모리로 적재하는 단위에 따라 가상메모리 기법은 요구 페이징 (demand paging) 방식과 요구 세그멘테이션 (demand segmentation) 으로 구현된다.</p>\n<ul>\n<li>대부분 요구 페이징을 사용하고 요구 세그먼테이션은 페이지드 세그먼테이션 기법을 사용하는 경우에 많이 사용한다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-1-요구-페이징\" style=\"position:relative;\"><a href=\"#-1-%EC%9A%94%EA%B5%AC-%ED%8E%98%EC%9D%B4%EC%A7%95\" aria-label=\" 1 요구 페이징 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 1. 요구 페이징</h2>\n<ul>\n<li>당장 사용될 페이지만 메모리에 올리는 방식이다.</li>\n<li>요구 페이징은 특정 페이지에 대한 CPU의 요청이 들어온 후에 페이지를 메모리에 적재한다.</li>\n<li>\n<p>장점</p>\n<ul>\n<li>메모리 사용량 감소</li>\n<li>프로세스 전체를 메모리에 올리는 입출력 오버헤드 감소</li>\n<li>사용하지 않을 주소 영역의 입출력은 안해도 되므로 응답시간 단축</li>\n<li>시스템이 더 많은 프로세스를 수용할 수 있도록 함</li>\n<li>프로그램이 물리적 메모리의 용량 제약에서 벗어남</li>\n</ul>\n</li>\n<li>\n<p>어떤 페이지가 메모리에 존재하고 어떤 페이지가 메모리에 존재하지 않은지 구별이 필요하다.</p>\n<ul>\n<li>유효-무효 비트 (valid-invalid bit)를 두어 각 페이지가 메모리에 존재하는지 표시한다.</li>\n<li>페이지 테이블의 각 엔트리에 저장된다.</li>\n<li>프로세스 시작 전 모든 페이지의 유효-무효 비트는 무효값이다.</li>\n<li>특정 페이지가 참조되면 유효값으로 바뀌고 스왑 영역으로 쫓겨나면 다시 무효값이 된다.</li>\n</ul>\n</li>\n<li>유효-무효 비트는 페이지가 속한 영역을 프로세스가 사용하지 않는 경우도 표시한다.</li>\n<li>CPU 참조 페이지가 메모리에 올라와 있지 않아서 무효값인 경우를 페이지 부재 page fault 라고 한다.</li>\n</ul>\n<h3 id=\"1-요구-페이징의-페이지-부재-처리\" style=\"position:relative;\"><a href=\"#1-%EC%9A%94%EA%B5%AC-%ED%8E%98%EC%9D%B4%EC%A7%95%EC%9D%98-%ED%8E%98%EC%9D%B4%EC%A7%80-%EB%B6%80%EC%9E%AC-%EC%B2%98%EB%A6%AC\" aria-label=\"1 요구 페이징의 페이지 부재 처리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1) 요구 페이징의 페이지 부재 처리</h3>\n<ul>\n<li>CPU가 무효 페이지에 접근하면 주소 변환 담당 하드웨어 MMU가 페이지 부재 트랩 page fault trap을 발생시킨다.</li>\n<li>\n<p>제어권이 커널모드로 전환되어 운영체제의 페이지 부재 처리루틴 page fulat handler가 호출되어 다음 순서로 페이지 부재를 처리한다.</p>\n<ol>\n<li>\n<p>해당 페이지에 대한 접근이 적법한지 체크</p>\n<ul>\n<li>사용되지 않는 주소 영역이거나 해당 페이지에 대한 접근 권한을 위반 protection violation한 경우 해당 프로세스를 종료</li>\n</ul>\n</li>\n<li>\n<p>적법하다면 물리 메모리의 비어있는 프레임 frame을 할당받아 그 공간에 해당 페이지를 읽는다. </p>\n<ul>\n<li>비어있는 프레임이 없다면 기존에 메모리에 올라와 있는 페이지 중 하나를 디스크로 쫓아낸다. (스왑 아웃)</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>\n<p>페이지 부재로 페이지를 메모리에 적재하기까지 오랜 시간이 걸리기 때문에 페이지 부재 프로세스는 봉쇄 상태가 된다. (CPU 제어권이 없어진다)</p>\n<ul>\n<li>CPU 레지스터 상태 및 카운터값을 PCB에 저장한다.</li>\n</ul>\n</li>\n<li>디스크 입출력이 완료되고 인터럽트가 발생하면 페이지 테이블의 페이지 유효-무효 비트를 유효로 설정하고 봉쇄 상태 프로세스를 준비큐로 옮긴다.</li>\n</ul>\n<h3 id=\"2-요구-페이징의-성능\" style=\"position:relative;\"><a href=\"#2-%EC%9A%94%EA%B5%AC-%ED%8E%98%EC%9D%B4%EC%A7%95%EC%9D%98-%EC%84%B1%EB%8A%A5\" aria-label=\"2 요구 페이징의 성능 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2) 요구 페이징의 성능</h3>\n<ul>\n<li><strong>페이지 부재의 발생 빈도</strong>로 성능에 가장 큰 영향을 미친다.</li>\n<li>\n<p>페이지가 메모리에 있다면 메모리 접근 시간만 걸리지만 페이지 부재가 일어나면 많은 오버헤드가 동반된다.</p>\n<ul>\n<li>페이지 부재 발생 처리 오버헤드</li>\n<li>스왑 아웃 오버헤드</li>\n<li>수왑 인 오버헤드</li>\n<li>프로세스 재시작 오버헤드</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-2-페이지-교체\" style=\"position:relative;\"><a href=\"#-2-%ED%8E%98%EC%9D%B4%EC%A7%80-%EA%B5%90%EC%B2%B4\" aria-label=\" 2 페이지 교체 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 2. 페이지 교체</h2>\n<ul>\n<li>물리 메모리에 빈 프레임이 존재하지 않는다면 올라와 있는 페이를 스왑 아웃 시켜야하는데 그것을 페이지 교체라고 한다. page replacement</li>\n<li>\n<p>어떤 페이지를 쫓아낼 것인지 교체 알고리즘 replacement algorithm으로 결정한다.</p>\n<ul>\n<li>페이지 부재를 최소화 하는 것이 알고리즘의 목표이다.</li>\n</ul>\n</li>\n<li>페이지 교체 알고리즘은 페이지 참조열 page reference string에 대한 페이지 부재율을 계산하여 평가한다.</li>\n<li>페이지가 이미 메모리에 올라와 있으면 hit 아니면 페이지 부재이다.</li>\n</ul>\n<h3 id=\"1-최적-페이지-교체\" style=\"position:relative;\"><a href=\"#1-%EC%B5%9C%EC%A0%81-%ED%8E%98%EC%9D%B4%EC%A7%80-%EA%B5%90%EC%B2%B4\" aria-label=\"1 최적 페이지 교체 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1) 최적 페이지 교체</h3>\n<ul>\n<li>가장 먼 미래에 참조될 페이지를 쫓아내는 방법이다.</li>\n<li>빌레디 최적 알고리즘, MIN, OPT, Belady’s optimal algorithm 라고 부른다.</li>\n<li>미래에 어떤 페이지가 어떤 순서로 참조될지 미라 알고 있는 전제로 알고리즘을 운영하므로 실제 시스템에서 사용할 수 있는 알고리즘은 아니다. ⇒ 오프라인 알고리즘</li>\n<li>빌레디 최적 알고리즘은 실제 시스템에 활용되기 보다 다른 알고리즘의 성능의 상한선을 제공한다.</li>\n</ul>\n<h3 id=\"2-선입선출-알고리즘-fifo\" style=\"position:relative;\"><a href=\"#2-%EC%84%A0%EC%9E%85%EC%84%A0%EC%B6%9C-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-fifo\" aria-label=\"2 선입선출 알고리즘 fifo permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2) 선입선출 알고리즘 FIFO</h3>\n<ul>\n<li>페이지 교체 시 물리 메모리에 가장 먼저 올라온 페이지를 우선 내쫓는다.</li>\n<li>비효율적인 상황이 발생할 가능성이 있다. 물리 메모리 공간이 늘어나도 페이지 참조 순서에 따라서 성능이 더 나빠질 수도 있다.</li>\n<li>FIFO에서 물리 메모리 영역에 올라갔는데도 페이지 부재가 늘어난 상황을 FIFO 이상 현상 (FIFO anomaly)라고 한다.</li>\n</ul>\n<h3 id=\"3-lru-least-recently-used\" style=\"position:relative;\"><a href=\"#3-lru-least-recently-used\" aria-label=\"3 lru least recently used permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3) LRU Least Recently Used</h3>\n<ul>\n<li>\n<p>메모리 참조 성향 중 시간지역성 (temporal locality) 라는 것이 있다.</p>\n<ul>\n<li>최근 참조된 페이지가 가까운 미래에 다시 참조될 가능성이 높은 성질이다.</li>\n</ul>\n</li>\n<li>위 성질을 이용하여 페이지 교체 시 가장 오래전에 참조한 페이지를 쫓아낸다.</li>\n</ul>\n<h3 id=\"4-lfu-least-frequently-used\" style=\"position:relative;\"><a href=\"#4-lfu-least-frequently-used\" aria-label=\"4 lfu least frequently used permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4) LFU Least Frequently Used</h3>\n<ul>\n<li>페이지 참조 횟수로 교체 페이지를 결정한다.</li>\n<li>과거에 참조 횟수 reference count가 가장 적었던 페이지를 교체하도록 한다.</li>\n<li>여러개의 페이지가 후보라면 그 중 하나를 임의로 선정하며 주로 상대적으로 오래 전에 참조된 페이지를 스왑 아웃한다.</li>\n<li>\n<p>LFU의 페이지 참조 횟수 계산 방식</p>\n<ol>\n<li>\n<p>Incache-LFU</p>\n<ul>\n<li>페이지가 물리 메모리에 올라온 후부터 참조 횟수를 카운트 한다.</li>\n<li>메모리에서 쫓겨났다가 다시 올라오면 참조 횟수를 1부터 시작한다.</li>\n</ul>\n</li>\n<li>\n<p>Perfect-LFU</p>\n<ul>\n<li>그 페이지의 과거 참조 횟수를 모두 카운ㅌ한다.</li>\n<li>정확하나 메모리에서 쫓겨난 페이지 참조 기록까지 보관해야하는 오버헤드가 있다.</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>LFU는 LRU 보다 오랜 시간 동안의 참조 기록을 반영하고 장기적 시간 규모의 참조 성향을 고려한다.</li>\n<li>하지만 LFU는 시간에 따른 페이지 참조 변화를 반영하지 못하며 구현이 LRU보다 복잡하다.</li>\n</ul>\n<h3 id=\"5-클럭-알고리즘\" style=\"position:relative;\"><a href=\"#5-%ED%81%B4%EB%9F%AD-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" aria-label=\"5 클럭 알고리즘 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5) 클럭 알고리즘</h3>\n<ul>\n<li>LRU, LFU 는 참조 시각, 참조 횟수를 소프트웨어적으로 유지하고 비교하므로 알고리즘 운영 비용이 발생한다.</li>\n<li>클럭 알고리즘은 하드웨어의 지원으로 알고리즘의 운영 오버헤드를 줄인 것이다.</li>\n<li>클럭 알고리즘은 LRU를 근사시킨 알고리즘으로 NUR Not Used Recently 또는 NRU Not recently Used 라고 불린다.</li>\n<li>오래전에 참조된 페이지 중 하나를 교체하는데 가장 오래된 것은 보장할 수 없다.</li>\n<li>\n<p>하드웨어의 지원이 있기 때문에 LRU에 비해 페이지 관리가 빠르고 효율적이다.</p>\n<ul>\n<li>대부분이 클럭 알고리즘으로 페이지 교체 알고리즘을 사용한다.</li>\n</ul>\n</li>\n<li>\n<p>클럭알고리즘은 페이지 프레임의 참조비트를 순차적으로 조사한다.</p>\n<ul>\n<li>참조비트는 각 프레임에 존재하며 해당 프레임의 페이지가 참조될 때 하드웨어로 1로 자동 세팅된다.</li>\n</ul>\n</li>\n<li>\n<p>클럭 알고리즘은 참조비트가 1인 페이지를 0으로 바꾸고 지나간다. 참조비트가 0인 페이지는 교체한다.</p>\n<ul>\n<li>즉, 시간을 한바퀴 돌 동안 참조되지 않은 페이지들을 교체하는 것이다.</li>\n</ul>\n</li>\n<li>특정 클럭 주기동안 참조된 페이지를 메모리에 유지시켜둠으로 페이지 부재를 줄이기 때문에 2차 기회 알고리즘 second chance algorithm이라고 하기도 한다.</li>\n</ul>\n<br>\n<h2 id=\"-3-페이지-프레임의-할당\" style=\"position:relative;\"><a href=\"#-3-%ED%8E%98%EC%9D%B4%EC%A7%80-%ED%94%84%EB%A0%88%EC%9E%84%EC%9D%98-%ED%95%A0%EB%8B%B9\" aria-label=\" 3 페이지 프레임의 할당 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 3. 페이지 프레임의 할당</h2>\n<ul>\n<li>어느 프로세스에게  얼만큼의 페이지 프레임을 할당할지 결정한다.</li>\n<li>\n<p>기본적인 할당 알고리즘 allocation algorithm은 다음 3가지 이다.</p>\n<ol>\n<li>균등할당 equal allocation - 모든 프로세스에게 페이지 프레임을 균일하게 할당</li>\n<li>비례할당 proportional allocation - 프로세스의 크기에 비례해 프레임 할당</li>\n<li>\n<p>우선순위 할당 priority allocation - 프로세스의 우선순위에 따라 프레임 할당</p>\n<ul>\n<li>당장 CPU에서 실행될 프로세스에게 더 많은 페이지 프레임을 할당</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>\n<p>하지만 할당 알고리즘으로 프로세스 페이지 참조 특성을 제대로 반영하지 못할 수도 있다.</p>\n<ul>\n<li>현재 수행중인 프로세스가 지나치게 많으면 프로세스당 할당되는 메모리가 과도하게 적다.</li>\n<li>프로세스를 정상적으로 수행하려면 일정 수준 이상의 페이지 프레임을 각 프로세스에게 할당해야한다. (여러 프레임을 동시에 참조하기 때문이다. 코드, 데이터 영역 등등)</li>\n<li>반복문인 경우 관련 페이지를 한꺼번에 올리는 것이 성능에 좋다.</li>\n</ul>\n</li>\n<li>종합적으로 각 프로세스의 프레임 수를 결정할 필요가 있다.</li>\n</ul>\n<br>\n<h2 id=\"-4-전역교체와-지역교체\" style=\"position:relative;\"><a href=\"#-4-%EC%A0%84%EC%97%AD%EA%B5%90%EC%B2%B4%EC%99%80-%EC%A7%80%EC%97%AD%EA%B5%90%EC%B2%B4\" aria-label=\" 4 전역교체와 지역교체 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 4. 전역교체와 지역교체</h2>\n<ul>\n<li>교체 페이지를 결정할 때 교체 대상 프레임의 범위에 따라서 교체 방법을 전역교체 global replacement, 지역교체  local replacement로 구분한다.</li>\n<li>\n<p>전역 교체 - 모든 페이지 프레임이 교체 대상</p>\n<ul>\n<li>다른 프로세스에게 할당된 프레임도 빼앗을 수 있다.</li>\n<li>프로세스별 프레임 할당량이 조절될 수 있다.</li>\n</ul>\n</li>\n<li>\n<p>지역 교체 - 현재 수행 중인 프로세스에게 할당된 프레임 내에서만 교체 대상을 선정</p>\n<ul>\n<li>지역 교체는 프로세스마다 프레임을 미리 할당한다.</li>\n<li>LRU, LFU 알고리즘을 프로세스별로 독자적 운영하면 지역교체가 된다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-5-스레싱-thrashing\" style=\"position:relative;\"><a href=\"#-5-%EC%8A%A4%EB%A0%88%EC%8B%B1-thrashing\" aria-label=\" 5 스레싱 thrashing permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 5. 스레싱 thrashing</h2>\n<ul>\n<li>\n<p>프로세스가 원활하게 수행되기 위해서는 일정 수준 이상의 페이지 프레임을 할당받아야한다.</p>\n<ul>\n<li>집중적으로 참조되는 페이지를 한꺼번에 적재하지 않으면 페이지 부재율이 높아진다.</li>\n<li>입출력이 많아지므로 CPU 이용률이 떨어진다.</li>\n<li>위 현상을 스레싱이라고 한다.</li>\n</ul>\n</li>\n<li>운영체제는 CPU 이용률이 낮다는 것은 메모리에 올라온 프로세스의 수가 적기 때문이라고 판단한다. 따라서 CPU 이용률이 떨어지면 운영체제는 메모리에 올라와 있는 프로세스 수를 늘린다.</li>\n<li>\n<p>다중 프로그래밍의 정도 Multi-programming Degree MPD 라고 부른다.</p>\n<ul>\n<li>CPU 이용률이 낮으면 운영체제는 MPD를 높인다.</li>\n</ul>\n</li>\n<li>과도하게 MPD가 높아지면 각 프로세스에게 할당되는 메모리가 줄어들고 필요한 최소한 프레임 할당이 어렵다.</li>\n<li>따라서 페이지 부재가 더 빈번하게 발생하게 되고 디스크 I/O 작업이 많이 일어나며서 문맥교환으로 다른 프로세스에게 CPU를 넘긴다.</li>\n<li>\n<p>반복되면서 CPU는 문맥교환과 페이지 부재 처리를 하느라 바빠지고 CPU이용률이 떨어지게 된다.</p>\n<ul>\n<li>그러면 또 운영체제는 메모리에 프로세스를 더욱 올려 상황을 악화시킨다.</li>\n</ul>\n</li>\n<li>이것을 방지하기 위해 MPD를 조절하는 알고리즘으로 <strong>1) 워킹셋 알고리즘 2) 페이지 부재 빈도 알고리즘</strong>이 있다.</li>\n</ul>\n<h3 id=\"1-워킹셋-알고리즘-working-set-algorithm\" style=\"position:relative;\"><a href=\"#1-%EC%9B%8C%ED%82%B9%EC%85%8B-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-working-set-algorithm\" aria-label=\"1 워킹셋 알고리즘 working set algorithm permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1) 워킹셋 알고리즘 working-set algorithm</h3>\n<ul>\n<li>지역성 집합 locality set: 프로세스가 특정 주소 영역을 집중적으로 참조하는 경향</li>\n<li>워킹셋 알고리즘은 이런 지역성 집합이 메모리에 동시에 올라갈 수 있도록 보장해주는 메모리 관리 알고리즘이다.</li>\n<li>\n<p>한꺼번에 메모리에 올라와야하는 페이지 집합을 working set으로 정의하여 한꺼번에 메모리에 올라갈 수 있을 때만 메모리를 할당한다.</p>\n<ul>\n<li>그렇지 않다면 프로세스에 할당된 페이지 프레임을 모두 반납시키고 프로세스 전체를 스왑아웃시킨다.</li>\n</ul>\n</li>\n<li>다중 프로그래밍의 정도를 조절하고 스레싱을 방지한다.</li>\n<li>\n<p>구현 방법</p>\n<ul>\n<li>한꺼번에 올라갈 워킹셋을 정의하기 위해 워킹셋 윈도우 working-set window를 사용한다.</li>\n<li>워킹셋 윈도우는 특정 시간동안 참조된 페이지의 중복제거된 집합이다. 그 시간 이후 워킹셋에 포함된 페이지만 메모리에 유지되고 아닌 페이지는 메모리에서 쫓겨난다.</li>\n<li>\n<p>워킹셋의 크기의 합이 프레임의 수보다 크면 일부 프로세스를 스왑 아웃 시켜 프레임에 워킹셋이 모두 올라갈 수 있도록 보장한다.</p>\n<ul>\n<li>MPD 를 줄인다.</li>\n</ul>\n</li>\n<li>\n<p>만일 프레임이 남으면 스왑 아웃 프로세스를 다시 메모리에 올려 워킹셋을 할당한다.</p>\n<ul>\n<li>MPD를 증가시킨다.</li>\n</ul>\n</li>\n<li>\n<p>윈도우 크기의 결정이 중요하다.</p>\n<ul>\n<li>너무 작으면 지역성 집합 수용이 어렵댜.</li>\n<li>크면 MPD가 감소하여 CPU 이용률이 낮아질 수 잇다.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-페이지-부재-빈도-알고리즘-pff-page-fault-frequency\" style=\"position:relative;\"><a href=\"#2-%ED%8E%98%EC%9D%B4%EC%A7%80-%EB%B6%80%EC%9E%AC-%EB%B9%88%EB%8F%84-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-pff-page-fault-frequency\" aria-label=\"2 페이지 부재 빈도 알고리즘 pff page fault frequency permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2) 페이지 부재 빈도 알고리즘 PFF page fault frequency</h3>\n<ul>\n<li>프로세스의 페이지 부재율을 주기적으로 조사하여 근거해 프로세스 할당 메모리를 동적으로 조절한다.</li>\n<li>\n<p>어떤 프로세스의 페이지 부재율이 시스템의 상한값을 넘으면 이 프로세스에게 할당된 프레임 수가 부족하다고 판단한다.</p>\n<ul>\n<li>프레임을 추가로 할당한다.</li>\n</ul>\n</li>\n<li>추가로 할당할 프레임이 없으면 일부 프로세스를 스왑 아웃시켜 프로세스의 수를 조절한다.</li>\n<li>부재율이 하한값 이하로 떨어지면 지나치게 많은 프레임을 할당받은 것으로 간주하고 할당 프레임 수를 줄인다.</li>\n<li>\n<p>이렇게 다 조절 후 프레임이 남으면 스왑 아웃 프로세스에게 프레임을 할당한다.</p>\n<ul>\n<li>MPD 증가</li>\n</ul>\n</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#-%EB%93%A4%EC%96%B4%EA%B0%80%EA%B8%B0-%EC%A0%84\">🌩 들어가기 전</a></li>\n<li>\n<p><a href=\"#-1-%EC%9A%94%EA%B5%AC-%ED%8E%98%EC%9D%B4%EC%A7%95\">🌩 1. 요구 페이징</a></p>\n<ul>\n<li><a href=\"#1-%EC%9A%94%EA%B5%AC-%ED%8E%98%EC%9D%B4%EC%A7%95%EC%9D%98-%ED%8E%98%EC%9D%B4%EC%A7%80-%EB%B6%80%EC%9E%AC-%EC%B2%98%EB%A6%AC\">1) 요구 페이징의 페이지 부재 처리</a></li>\n<li><a href=\"#2-%EC%9A%94%EA%B5%AC-%ED%8E%98%EC%9D%B4%EC%A7%95%EC%9D%98-%EC%84%B1%EB%8A%A5\">2) 요구 페이징의 성능</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-2-%ED%8E%98%EC%9D%B4%EC%A7%80-%EA%B5%90%EC%B2%B4\">🌩 2. 페이지 교체</a></p>\n<ul>\n<li><a href=\"#1-%EC%B5%9C%EC%A0%81-%ED%8E%98%EC%9D%B4%EC%A7%80-%EA%B5%90%EC%B2%B4\">1) 최적 페이지 교체</a></li>\n<li><a href=\"#2-%EC%84%A0%EC%9E%85%EC%84%A0%EC%B6%9C-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-fifo\">2) 선입선출 알고리즘 FIFO</a></li>\n<li><a href=\"#3-lru-least-recently-used\">3) LRU Least Recently Used</a></li>\n<li><a href=\"#4-lfu-least-frequently-used\">4) LFU Least Frequently Used</a></li>\n<li><a href=\"#5-%ED%81%B4%EB%9F%AD-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\">5) 클럭 알고리즘</a></li>\n</ul>\n</li>\n<li><a href=\"#-3-%ED%8E%98%EC%9D%B4%EC%A7%80-%ED%94%84%EB%A0%88%EC%9E%84%EC%9D%98-%ED%95%A0%EB%8B%B9\">🌩 3. 페이지 프레임의 할당</a></li>\n<li><a href=\"#-4-%EC%A0%84%EC%97%AD%EA%B5%90%EC%B2%B4%EC%99%80-%EC%A7%80%EC%97%AD%EA%B5%90%EC%B2%B4\">🌩 4. 전역교체와 지역교체</a></li>\n<li>\n<p><a href=\"#-5-%EC%8A%A4%EB%A0%88%EC%8B%B1-thrashing\">🌩 5. 스레싱 thrashing</a></p>\n<ul>\n<li><a href=\"#1-%EC%9B%8C%ED%82%B9%EC%85%8B-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-working-set-algorithm\">1) 워킹셋 알고리즘 working-set algorithm</a></li>\n<li><a href=\"#2-%ED%8E%98%EC%9D%B4%EC%A7%80-%EB%B6%80%EC%9E%AC-%EB%B9%88%EB%8F%84-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-pff-page-fault-frequency\">2) 페이지 부재 빈도 알고리즘 PFF page fault frequency</a></li>\n</ul>\n</li>\n</ul>\n</div>","frontmatter":{"date":"October 17, 2021","title":"운영체제와 정보기술의 원리 - CH8. 가상 메모리","categories":"운영체제 책","author":"코다","emoji":"🧁"},"fields":{"slug":"/operating-system-7/"}},"site":{"siteMetadata":{"siteUrl":"https://yjksw.github.io","comments":{"utterances":{"repo":"yjksw/yjksw.github.io"}}}}},"pageContext":{"slug":"/operating-system-6/","nextSlug":"/operating-system-5/","prevSlug":"/operating-system-7/"}},"staticQueryHashes":["1073350324","2938748437"]}
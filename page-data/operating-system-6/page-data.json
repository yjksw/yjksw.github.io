{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/operating-system-6/",
    "result": {"data":{"cur":{"id":"15c686a2-e380-5751-aa10-a46cbef8c812","html":"<blockquote>\n<p>다음은 반효경 교수님의 ‘운영체제와 정보기술의 원리’ <em>CH7. 메모리 관리</em>를 읽고 정리한 내용입니다 🙌</p>\n</blockquote>\n<br>\n<br>\n<h2 id=\"-들어가기-전\" style=\"position:relative;\"><a href=\"#-%EB%93%A4%EC%96%B4%EA%B0%80%EA%B8%B0-%EC%A0%84\" aria-label=\" 들어가기 전 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 들어가기 전</h2>\n<ul>\n<li>우리가 흔히 사용하는 컴퓨터 주소 체계는 32비트 혹은 64비트로 나뉘어져 있다.\n<ul>\n<li>32비트면 32개의 비트로 주소를 표현할 수 있는 것이다.</li>\n<li>2^32가지 다른 메모리 위치를 구분할 수 있다.</li>\n<li>컴퓨터는 바이트 단위(8비트)로 주소를 부여한다. 따라서 2^32 바이트 만큼의 메모리 공간에 서로 다른 주소를 할당할 수 있다.</li>\n</ul>\n</li>\n<li>32 비트를 계층적으로 묶어서 관리한다.</li>\n<li>보통 4KB (2^12 바이트) 단위로 묶어서 페이지(page)를 구성한다.\n<ul>\n<li>페이지 내에서 주소를 구분하기 위해서는 12비트가 필요하다. 따라서 32비트 중 하위 12비트는 페이지 내에서 주소를 나타낸다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-1-주소-바인딩\" style=\"position:relative;\"><a href=\"#-1-%EC%A3%BC%EC%86%8C-%EB%B0%94%EC%9D%B8%EB%94%A9\" aria-label=\" 1 주소 바인딩 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 1. 주소 바인딩</h2>\n<ul>\n<li>프로세스의 주소 공간 (address space)는 프로그램이 실행되기 위해 메모리에 적재되면 프로세스를 위한 독자적인 주소 공간이 생성된다.\n<ul>\n<li>논리적 주소 (logical address) 혹은 가상 주소 (virtual address)라고 부른다.</li>\n<li>CPU는 논리적 주소에 근거해 명령을 실행한다.</li>\n</ul>\n</li>\n<li>논리적 주소는 프로세스 마다 <strong>독립적</strong>으로 할당되고 모두 0번지부터 시작한다.</li>\n<li>물리적 주소 (physical address)는 물리적 메모리에 실제로 올라가는 위치이다.\n<ul>\n<li>물리적 메모리의 낮은 주소에는 운영체제가 올라가고 높은 주소에는 사용자 프로세스들이 올라간다.</li>\n</ul>\n</li>\n<li>메모리 참조를 할 때 프로세스의 논리적 주소가 물리적 주소의 어느 위치인지 확인해야하는 주소 바인딩 (address binding)이라는 작업이 필요하다.</li>\n</ul>\n<h3 id=\"주소-바인딩-방식\" style=\"position:relative;\"><a href=\"#%EC%A3%BC%EC%86%8C-%EB%B0%94%EC%9D%B8%EB%94%A9-%EB%B0%A9%EC%8B%9D\" aria-label=\"주소 바인딩 방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>주소 바인딩 방식</h3>\n<ul>\n<li>물리 메모리 주소가 결정되는 시기에 따라서 분류된다.</li>\n</ul>\n<ol>\n<li>컴파일 타임 바인딩 (compile time binding)\n<ul>\n<li>프로그램을 컴파일할 때 물리적 메모리 주소가 결정</li>\n<li>컴파일 시점에 해당 프로그램이 물리적 메모리 몇 번지에 위치할 것인지 결정</li>\n<li>프로그램이 절대주소로 적재된다는 뜻으로 절대코드를 생성하는 바인딩 (absolute code)</li>\n<li>프로그램의 물리적 주소를 변경하고 싶다면 프로그램을 다시 컴파일해야한다.</li>\n<li>비현실적이며 현대 시분할 컴퓨팅 환경에서는 잘 사용하지 않는다.</li>\n</ul>\n</li>\n<li>로드 타임 바인딩 (load time binding)\n<ul>\n<li>프로그램이 시작될 때 물리적 메모리 주소가 결정</li>\n<li>loader의 책임하에 물리적 메모리 주소가 부여되고 프로그램 종료까지 물리적 메모리상의 위치가 고정\n<ul>\n<li>로더는 사용자 프로그램을 메모리에 적재시키는 프로그램</li>\n</ul>\n</li>\n<li>컴파일러가 재배치 가능 코드(relocatable code)를 생성한 경우에 가능한 주소 바인딩 방식</li>\n</ul>\n</li>\n<li>실행시간 바인딩 (execution time binding or run time binding)\n<ul>\n<li>프로그램 시작 후에도 물리적 메모리 주소가 변경될 수 있음</li>\n<li>CPU가 메모리 주소를 참조할 때마다 데이터가 물리적 메모리의 어느 위치에 있는지 주소 매핑 테이블 (address mapping table)을 참조해 바인딩을 점검</li>\n<li>기준 레지스터 (base register)와 한계 레지스터 (limit register) 를 포함하여 MMU (Memeory Management Unit)이라는 하드웨어적 자원 뒷받침이 필요\n<ul>\n<li>MMU는 논리적 주소를 물리적 주소로 매핑해주는 하드웨어 장치</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"mmu-기법\" style=\"position:relative;\"><a href=\"#mmu-%EA%B8%B0%EB%B2%95\" aria-label=\"mmu 기법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>MMU 기법</h3>\n<ul>\n<li>MMU를 사용하여 주소 변환하는 기본적인 방식</li>\n<li>MMU 기법은 논리적 주소값에 기준 레지스터 값을 더해 물리적 주소값을 얻어낸다.\n<ul>\n<li>기준 레지스터는 재배치 레지스터 (reload register)라고도 하며 프로세스의 물리적 메모리 시작 주소를 가지고 있다.</li>\n<li>offset 개념</li>\n</ul>\n</li>\n<li>MMU 기법은 프로그램의 주소가 물리적 메모리에 연속적으로 적재된 것을 가정한다.</li>\n<li>따라서 물리적 메모리의 시작 주소만 알면 변환을 쉽게 할 수 있으며 사용자 프로그램이나 CPU는 물리적 메모리를 알 필요 없이 논리적 메모리 주소만 다룬다.</li>\n<li>프로세스마다 고유의 메모리 주소를 가지고 있기 때문에 같은 주소 (논리적 메모리 주소 100번지)도 각기 다른 물리적 메모리 위치를 가리켜야한다.\n<ul>\n<li>이것을 기준 레지스터를 해당 프로세스에 맞는 값으로 설정하므로 여러 프로세스에 대한 주소 매핑을 한다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"메모리-보안-memory-protection\" style=\"position:relative;\"><a href=\"#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%B3%B4%EC%95%88-memory-protection\" aria-label=\"메모리 보안 memory protection permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>메모리 보안 Memory protection</h3>\n<ul>\n<li>메모리에 여러 프로세스가 올라가 있기 때문에 한 프로세스가 다른 프로세스의 물리적 주소를 참조하여 문제가 발생할수도 있다.</li>\n<li>한계 레지스터 (limit register)를 이용하여 해당 프로세스가 자신의 주소 공간을 넘어 메모리를 참조하면 (base register + limit register) 트랩을 발생시켜 해당 프로세스를 종료시킨다.</li>\n</ul>\n<br>\n<h2 id=\"-2-메모리-관리와-관련된-용어\" style=\"position:relative;\"><a href=\"#-2-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC%EC%99%80-%EA%B4%80%EB%A0%A8%EB%90%9C-%EC%9A%A9%EC%96%B4\" aria-label=\" 2 메모리 관리와 관련된 용어 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 2. 메모리 관리와 관련된 용어</h2>\n<h3 id=\"1-동적로딩-dynamic-loading\" style=\"position:relative;\"><a href=\"#1-%EB%8F%99%EC%A0%81%EB%A1%9C%EB%94%A9-dynamic-loading\" aria-label=\"1 동적로딩 dynamic loading permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1) 동적로딩 dynamic loading</h3>\n<ul>\n<li>여러 프로그램이 동시에 메모리에 올라가서 수행되는 다중 프로그래밍(multi-programming) 환경에서 메모리 효율을 높이는 기법이다.</li>\n<li>프로세스가 시작될 때 그 프로세스의 주소 공간 전체를 물리적 메모리에 올리는 것이 아니라 해당 부분이 호출될 때 메모리에 적재되는 방식이다.\n<ul>\n<li>프로그램의 오류 처리루틴 등등은 가끔씩만 사용되는 방어용 코드이므로 항상 적재될 필요는 없다.</li>\n</ul>\n</li>\n<li>필요하지 않은 코드가 한꺼번에 적재되어 메모리가 낭비되는 것을 막아 메모리를 효율적으로 사용할 수 있도록 한다.\n<ul>\n<li>프로그램 자체에서 구현 가능하고 운영체제가 라이브러리로 지원하기도 한다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-동적연결-dynamic-linking\" style=\"position:relative;\"><a href=\"#2-%EB%8F%99%EC%A0%81%EC%97%B0%EA%B2%B0-dynamic-linking\" aria-label=\"2 동적연결 dynamic linking permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2) 동적연결 dynamic linking</h3>\n<ul>\n<li>연결은 개발자가 작성한 소스코드를 컴파일하여 생성된 object file과 이미 컴파일된 라이브러리 파일 library file을 묶어 하나의 실행파일을 생성하는 과정이다.</li>\n<li>동적연결은 이 연결을 프로그램 실행 시점까지 지연시키는 기법이다.\n<ul>\n<li>정적 연결 static linking은 미리 작성된 코드와 라이브러리 코드가 합쳐져서 실행파일이 생성된다.</li>\n<li>따라서 실행파일의 크기가 크고 동일한 라이브러리를 각 프로세스가 개별적으로 메모리에 적재하여 물리적 메모리가 낭비된다.</li>\n</ul>\n</li>\n<li>동적연결은 라이브러리가 실행시점에 연결되어 실행파일에 라이브러리 코드가 포함되어 있지 않고 라이브러리 함수 호출 시 라이브러리에 연결된다.</li>\n<li>동적연결을 위해 코드의 라이브러리 호출 부분에 스텁 stub이라는 작은 코드를 둔다.\n<ul>\n<li>stub으로 해당 라이브러리가 메모리에 존재하는지 보고 있다면 그 주소에서 직접 참조하고 없다면 디스크에서 라이브러리를 메모리로 적재한다.</li>\n</ul>\n</li>\n<li>공동으로 사용하는 라이브러리는 한번 적재하여 메모리 효율을 높인다.</li>\n<li>운영체제의 지원이 필요하다.</li>\n</ul>\n<h3 id=\"3-중첩-overlays\" style=\"position:relative;\"><a href=\"#3-%EC%A4%91%EC%B2%A9-overlays\" aria-label=\"3 중첩 overlays permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3) 중첩 overlays</h3>\n<ul>\n<li>프로세스의 주소 공간을 분할해 실제 필요한 부분만 메모리에 적재하는 기법이다.</li>\n<li>동적로딩과 비슷하나 중첩의 배경은 초창기에 물리적 메모리의 공간이 부족하여 프로세스의 주소 공간을 분할해 당장 필요한 부분을 올리고 해당 부분의 실행이 끝나면 나머지 부분을 올려서 실행한 기법이다. (단일 프로세스를 올릴 때 메모리가 부족한 경우..)\n<ul>\n<li>동적로딩은 다중 프로그래밍 환경에서 메모리 이용률을 높이기 위한 기법이다.</li>\n</ul>\n</li>\n<li>중첩은 운영체제의 지원이 없고 프로그래머가 직접 구현되어야 했으며 따라서 수작업 중첩(manual overlays)라고도 부른다.</li>\n</ul>\n<h3 id=\"4-스와핑-swapping\" style=\"position:relative;\"><a href=\"#4-%EC%8A%A4%EC%99%80%ED%95%91-swapping\" aria-label=\"4 스와핑 swapping permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4) 스와핑 swapping</h3>\n<ul>\n<li>메모리에 올라온 프로세스의 주소공간 전체를 스왑 영역에 일시적으로 내려놓는 것이다.</li>\n<li>스왑 영역을 백킹스토어 backing store 라고도 부른다.\n<ul>\n<li>디스크 내에서 파일 시스템과는 별도로 존재한다.</li>\n<li>스왑 영역은 디스크에 일시적으로 저장하여 저장기간이 짧은 저장공간이다.</li>\n</ul>\n</li>\n<li>스왑 영역은 다수의 프로세스를 담을 수 있는 충분한 저장공간이면서 접근 속도가 보장되어야 한다.</li>\n<li>스와핑은 프로세스 종료 후 디스크에 프로세스를 내려놓는 것이 아니라, 특정 이유로 <strong>수행 중인 프로세스</strong>를 메모리에서 디스크로 내려놓는 것이다.\n<ul>\n<li>디스크 → 메모리 : 스왑인</li>\n<li>메모리 → 디스크: 스왑아웃</li>\n</ul>\n</li>\n<li>스와핑 과정\n<ul>\n<li>스와퍼 swapper라고 불리는 중기 스캐줄러(medium-term scheduler)로 스왑시킬 프로세스를 선정</li>\n<li>해당 프로세스는 메모리에 올라가있는 전체 내용이 스왑 영역으로 스왑 아웃</li>\n</ul>\n</li>\n<li>스와핑의 중요 역할은 메모리의 프로세스 수를 조절하는 것이다.\n<ul>\n<li>degree of multiprogramming 다중 프로그래밍의 정도를 조절한다.</li>\n<li>메모리에 너무 많은 양의 프로세스가 올라와있으면 시스템 전체 성능이 떨어지기 때문이다.</li>\n</ul>\n</li>\n<li><strong>컴파일 타임 바인딩</strong>과 <strong>로드 타임 바인딩</strong>은 스왑 아웃된 프로세스가 스왑인 될 때 동일한 메모리 위치로 올라가야한다.</li>\n<li>스와핑에서 스왑 영역에 프로세스의 주소 공간이 순차적으로 저장된다.\n<ul>\n<li>스와핑 소요시간은 디스크 탐색시간이나 회전지연시간(rotational latency)보다 디스크 섹터에서 실제 데이터를 읽고 쓰는 전송시간 transfer time이 대부분을 차지한다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-3-물리적-메모리의-할당방식\" style=\"position:relative;\"><a href=\"#-3-%EB%AC%BC%EB%A6%AC%EC%A0%81-%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%9D%98-%ED%95%A0%EB%8B%B9%EB%B0%A9%EC%8B%9D\" aria-label=\" 3 물리적 메모리의 할당방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 3. 물리적 메모리의 할당방식</h2>\n<ul>\n<li>운영체제 상주 영역과 사용자 프로세스영역으로 나뉜다.\n<ul>\n<li>운영체제 상주 영역은 인터럽트 벡터와 함께 낮은 주소 영역을 사용한다.</li>\n<li>운영체제 커널이 위치한다.</li>\n</ul>\n</li>\n<li>사용자 프로세스 영역은 연속할당(contiguous allocation)과 불연속할당(noncontiguous alloation) 방식으로 나뉜다.\n<ul>\n<li>연속할당 - 각각의 프로세스를 물리적 메모리 연속적인 공간에 올림\n<ul>\n<li>물리적 메모리를 다수의 분할로 나누어 하나의 분할에 하나의 프로세스가 적재</li>\n<li>분할은 고정분할(fixed partition allocation)과 가변분할(variable partition allocation) 방식으로 나뉜다. 고정분할은 미리 메모리를 나누어 놓는다.</li>\n</ul>\n</li>\n<li>불연속 할당 - 하나의 프로세스를 물리적 메모리 여러 영역에 분산하여 적재하는 방식\n<ul>\n<li>동일한 페이지로 잘라서 메모리에 페이지 단위로 적재시키는 페이징(paging) 기법</li>\n<li>프로그램 주소 공간을 코드, 데이터, 스택 등 의미있는 단위인 세그먼트로 나누는 세그멘테이션(segmentation) 기법이 있다.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"1-연속할당-방식\" style=\"position:relative;\"><a href=\"#1-%EC%97%B0%EC%86%8D%ED%95%A0%EB%8B%B9-%EB%B0%A9%EC%8B%9D\" aria-label=\"1 연속할당 방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1) 연속할당 방식</h3>\n<ul>\n<li>고정분할이나 가변분할로 나뉘어진 크기에 프로세스를 연속적으로 적재한다.</li>\n<li>고정분할 방식\n<ul>\n<li>물리적 메모리를 주어진 개수만큼 영구적인 분할(partition)으로 나누고 각 분할에 하나의 프로세스를 적재한다.</li>\n<li>분할의 크기가 모두 같을수도 다를수도 있다.</li>\n<li>메모리에 올릴 수 있는 프로세스의 수가 분할개수 만큼으로 고정되어 있고 수행 가능한 프로그램의 최대 크기가 정해져있다. (분할의 최대크기)</li>\n<li>외부조각(external fragmentation)과 내부조각(internal fragmentation)이 발생할 수 있다.\n<ul>\n<li>외부조각은 분할이 비었는데 프로그램의 크기보다 작아서 적재하는 못하는 경우 발생</li>\n<li>내부조각은 프로그램에게 배정되었는데 조각의 크기가 상대적으로 커서 내부에 사용하지 않는 메모리 공간이 생기는 경우 발생</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>가변분할 방식\n<ul>\n<li>적재되는 프로그램의 크기에 따라 분할의 크기와 개수가 동적으로 변하는 방식이다.\n<ul>\n<li>관리를 위한 프로그래밍 기법이 필요하다.</li>\n</ul>\n</li>\n<li>프로그램의 크기만큼 분할하므로 내부조각은 발생하지 않는다. 하지만 외부조각은 여전히 발생한다.</li>\n<li>중요한 점은 주소 공간의 크기가 n인 프로세스를 메모리에 올릴 때 메모리 가용공간 중 어느 위치에 올릴지 이다.\n<ul>\n<li>동적 메모리 할당 문제 dynamic storage-allocation problem 이라고 한다.</li>\n<li>가용공간은 사용되지 않은 메모리 공간이고 산발적으로 존재한다.</li>\n<li>연속할당 기법에서는 프로세스 전체를 담을 수 있는 가용공간을 찾아야한다.</li>\n<li>운영체제는 이미 사용중인 메모리와 가용 공간에 대한 정보를 유지하여 가용 공간을 효율적으로 관리해야한다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>동적 메모리 할당 문제 해결 방법 3가지\n<ol>\n<li>크기가 n 이상인 가용 공간 중 가장 먼저 찾아지는 공간에 프로세스를 할당하는 최초적합 (first-fit) 방법\n<ul>\n<li>가용공간을 모두 탐색하지 않으므로 시간적인 면에서 효율적이다.</li>\n</ul>\n</li>\n<li>크기가 n 이상인 가장 작은 가용 공간을 찾아가곳에 프로세스를 할당하는 최적적합(best-fit) 방법\n<ul>\n<li>가용공간 리스트가 크기순으로 정렬되어 있지 않는다면 모든 가용공간 리스트를 탐색하여 시간적 오버헤드가 발생</li>\n<li>다수의 매우 작은 가용 공간들이 생성될 수 있다는 단점</li>\n<li>공간적인 면에서 효율적인 장점이 존재한다.</li>\n</ul>\n</li>\n<li>가용 공간 중 가장 크기가 큰 곳에 새로운 프로그램을 할당하는 최악적합(worst-fit) 방법\n<ul>\n<li>가용 공간 리스트를 탐색하는 시간적 오버헤드 발생</li>\n<li>상대적으로 더 큰 프로그램을 담을 수 있는 가용 공간을 빨리 소진한다는 문제</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li>최초척합과 최적적합 방식이 최악적합 방식에 비해 속도와 공간 이용률 측면에서 효과적이다.</li>\n</ul>\n</li>\n<li>컴팩션 compaction - 가변분할 방식에서 외부조각 문제를 해결하는 방법\n<ul>\n<li>물리적 메모리 중 프로세스에 의해 사용중인 메모리 영역을 한쪽으로 몰고 가용 공간들을 다른 한쪽으로 모아 하나의 큰 가용 공간을 만드는 방법</li>\n<li>수행 중인 프로세스의 메모리상의 위치를 상당 부분 이동시키므로 비용이 많이 든다.</li>\n<li>중간에 일부 가용 공간이 발생하더라도 적은 수의 메모리 이동으로 효율적인 컴팩션을 수행해야하는데 이론적으로 복잡하다.</li>\n<li>수행 중인 프로세스의 물리적 메모리 위치를 옮겨야하므로 프로그램 시간 도중에 프로세스의 주소가 동적으로 바뀌는 실행시간 바인딩 방식이 지원될 때만 가능하다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-불연속할당-기법\" style=\"position:relative;\"><a href=\"#2-%EB%B6%88%EC%97%B0%EC%86%8D%ED%95%A0%EB%8B%B9-%EA%B8%B0%EB%B2%95\" aria-label=\"2 불연속할당 기법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2) 불연속할당 기법</h3>\n<ul>\n<li>하나의 프로세스가 물리적 메모리의 여러 위치에 분산되어 올라갈 수 있는 메모리 할당 기법이다.</li>\n<li>하나의 프로그램을 동일한 크기로 나누는 페이징 기법</li>\n<li>크기가 일정하지 않지만 의미 단위로 나누는 세그멘테이션 기법</li>\n<li>세그멘테이션이 기본이지만 이것을 다시 동일한 크기의 페이지로 나누는 페이지드 세그멘테이션(paged segmentation)으로 나뉜다</li>\n</ul>\n<br>\n<h2 id=\"-4-페이징-기법\" style=\"position:relative;\"><a href=\"#-4-%ED%8E%98%EC%9D%B4%EC%A7%95-%EA%B8%B0%EB%B2%95\" aria-label=\" 4 페이징 기법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 4. 페이징 기법</h2>\n<ul>\n<li>프로세스 주소 공간을 <strong>동일한 크기의 페이지 단위</strong>로 나누어 <strong>물리적 메모리의 서로 다른 위치</strong>에 페이지들을 저장하는 방식</li>\n<li>프로세스 일부는 백킹스토어, 일부는 물리 메모리에 혼재할 수 있다.</li>\n<li>메모리를 페이지와 동일한 크기인 프레임(frame)으로 미리 나눈다.\n<ul>\n<li>동적 메모리 할당 문제가 발생하지 않는 장점</li>\n</ul>\n</li>\n<li>주소 변환 절차가 연속할당 방식에 비해 다소 복잡하다.\n<ul>\n<li>하나의 프로세스도 여러 페이지 단위로 물리적 메모리에서의 위치가 상이하기 때문이다.</li>\n<li>따라서 프로세스 별 페이지 테이블(page table)을 가져 각 페이지가 물리 프로세스의 어느 frame에 매핑되는지 아는 주소 변환 엔트리를 가진다.\n<ul>\n<li>페이지 테이블은 페이지 개수만큼 엔트리를 가지고 있다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>프로세스 주소 공간과 물리적 메모리가 모두 같은 크기의 페이지 단위이기 때문에 빈 공간은 항상 활용 가능하다.\n<ul>\n<li>하지만 프로세스가 페이지 단위로 나누어 떨어지지 않기 때문에 마지막 조각의 마지막 페이지에서 내부조각이 발생할 수도 있다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"1-주소-변환-기법\" style=\"position:relative;\"><a href=\"#1-%EC%A3%BC%EC%86%8C-%EB%B3%80%ED%99%98-%EA%B8%B0%EB%B2%95\" aria-label=\"1 주소 변환 기법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1) 주소 변환 기법</h3>\n<ul>\n<li>CPU가 사용하는 논리적 주소를 번호(p)와 페이지 오프셋(d)로 나누어 주소 변환(address translation)에 사용한다.\n<ul>\n<li>페이지 번호는 페이지별 주소 변환 정보를 담고있는 페이지 테이블 접근 인덱스(index)로 사용</li>\n<li>해당 인덱스의 항목(entry)에는 페이지의 물리적 메모리상 기준 주소(base address) 시작 위치가 저장</li>\n<li>페이지 오프셋은 하나의 페이지 내에서의 변위(displacement)를 알려준다.\n<ul>\n<li>기준 주소값 + 변위값으로 논리적 주소에 대응하는 물리적 주소를 얻는다.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-페이지-테이블의-구현\" style=\"position:relative;\"><a href=\"#2-%ED%8E%98%EC%9D%B4%EC%A7%80-%ED%85%8C%EC%9D%B4%EB%B8%94%EC%9D%98-%EA%B5%AC%ED%98%84\" aria-label=\"2 페이지 테이블의 구현 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2) 페이지 테이블의 구현</h3>\n<ul>\n<li>\n<p>페이징 기법에서 주소 변환을 하기 위한 자료구조이다.</p>\n</li>\n<li>\n<p>실행중인 프로세스의 페이지 테이블에 접근하기 위해 2개 레지스터를 사용한다.</p>\n<ul>\n<li>페이지 테이블 기준 레지스터(page-table base register) PTBR\n<ul>\n<li>물리적 메모리 내에서 페이지 테이블의 시작위치</li>\n</ul>\n</li>\n<li>페이지 테이블 길이 레지스터(page-table length register) PTLR\n<ul>\n<li>페이지 테이블의 크기</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>페이징에서 메모리에 접근하려면 <strong>1) 페이지 테이블 접근을 위해 메모리 접근 2) 주소 변환된 메모리에 접근</strong> 이렇게 두번 메모리에 접근하여 오버헤드가 있다.</p>\n<ul>\n<li>페이지 테이블 접근 오버헤드를 줄이고 메모리 접근 속도를 향상시키기 위해 TLB(Translation Look-aside Buffer) 고속 주소 변환용 하드웨어 캐시가 사용되기도 한다.</li>\n<li>메모리에 비해 TLB는 비싸기 때문에 빈번히 참조되는 페이지에 대한 주소변환 정보만 담는다. 따라서 TLB에 요청 페이지의 주소 변환 정보가 있을 수도 있고 없을 수도 있다.</li>\n<li>TLB에 존재한다면 얻고 그렇지 않다면 메인 메모리 페이지 테이블로부터 프레임 번호를 알아내도록 한다.</li>\n<li>문맥 교환시 이전 프로세스의 주소변환 정보를 담는 TLB를 초기화해야한다.</li>\n</ul>\n<p align=\"center\"><img width=\"85%\" src=\"https://user-images.githubusercontent.com/63405904/141051950-79afbe37-5ee2-4627-876c-a51de9083ca5.png\"></p>\n</li>\n<li>\n<p>TLB와 페이지 테이블의 정보 구조 차이</p>\n<ul>\n<li>페이지 테이블에는 페이지 주소 변환 정보가 페이지 번호에 따라 순차적으로 들어있으므로 페이지 번호로 바로 항모겡 접근하여 프레임 번호를 구할 수 있다.</li>\n<li>TLB는 모든 페이지에 대한 주소 변환 정보를 가지고 있는 것이 아니기 때문에 페이지 번호와 프레임 번호가 쌍으로 저장되어야 한다. (두 값이 모두 있어야한다. 페이징 테이블은 프레임 번호만 순차적으로 있다. 그림참조)</li>\n<li>TLB에 있는지 확인하려면 모든 엔트리를 다 찾아봐야하는 오버헤드가 발생한다.</li>\n</ul>\n</li>\n<li>\n<p>TLB 엔트리를 모두 탐색하는 오버헤드를 줄이기위해 병렬탐색(parallel search)이 가능한 연관 레지스터(associative register)를 사용한다.</p>\n<ul>\n<li>TLB 항목을 동시에 탐색할 수 있는 기능이다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-계층적-페이징\" style=\"position:relative;\"><a href=\"#3-%EA%B3%84%EC%B8%B5%EC%A0%81-%ED%8E%98%EC%9D%B4%EC%A7%95\" aria-label=\"3 계층적 페이징 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3) 계층적 페이징</h3>\n<ul>\n<li>페이지 테이블에 메모리의 상당 부분이 소요되어 실제 사용 가능한 메모리 공간이 줄어드는 문제가 발생한다.</li>\n<li>페이지 테이블로 낭비되는 공간을 줄이기 위해 2단계 페이징(two-level paging)을 기법을 사용한다.</li>\n<li>외부 페이지 테이블 (outer page table)과 내부 페이지 테이블 (inner page table)을 사용하고 사용하지 않는 주소 공간은 외부 페이지 테이블 항목을 null로 두어 대응하는 내부 페이지 테이블 항목을 설정하지 않아 메모리 낭비를 줄인다.\n<ul>\n<li>하지만 주소변환을 위해 페이지 테이블을 2개 접근해야하므로 시간적 손해가 있다.</li>\n<li>TLB를 사용해 접근 속도를 높일 수 있다.</li>\n</ul>\n</li>\n</ul>\n<p align=\"center\"><img width=\"85%\" src=\"https://user-images.githubusercontent.com/63405904/141052309-99c2a925-799e-4da8-838c-816ca979b37d.png\"></p>\n<h3 id=\"4-역페이지-테이블-inverted-page-table\" style=\"position:relative;\"><a href=\"#4-%EC%97%AD%ED%8E%98%EC%9D%B4%EC%A7%80-%ED%85%8C%EC%9D%B4%EB%B8%94-inverted-page-table\" aria-label=\"4 역페이지 테이블 inverted page table permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4) 역페이지 테이블 inverted page table</h3>\n<ul>\n<li>물리적 메모리의 페이지 프레임 하나당 페이지 테이블 항목을 하나씩 둔다.</li>\n<li>논리적 주소에 대한 페이지 테이블을 만드는 것이 아니라 물리적 주소에 대한 페이지 테이블을 만드는 것이다.\n<ul>\n<li>각 프로세스마다 페이지 테이블을 두지 않고 시스템 전체에 대한 페이지 테이블을 하나만 둔다.</li>\n<li>페이지 테이블의 각 항목은 <strong>어느 프로세스의 어느 페이지</strong>가 이 프레임에 저장되었는지 정보를 보관한다.\n<ul>\n<li>pid와 페이지 번호 p를 담는다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>물리적 주소에서 논리적 주소를 얻기 수월한 방법이므로 어느 정도의 비효율적인 측면이 있다.\n<ul>\n<li>주소 변환 요청이 들어오면 페이지 테이블을 다 탐색해야하고 시간을 소요한다.</li>\n<li>따라서 페이지 테이블을 메모리에 유지하는 대신 연관 레지스터 (associative register)에 보관히 전체 항목을 병렬 탐색 가능하게 한다.</li>\n</ul>\n</li>\n</ul>\n<p align=\"center\"><img width=\"85%\" src=\"https://user-images.githubusercontent.com/63405904/141052223-35660eb2-db9c-4f94-8496-a89a587b06d0.png\"></p>\n<h3 id=\"5-공유-페이지\" style=\"position:relative;\"><a href=\"#5-%EA%B3%B5%EC%9C%A0-%ED%8E%98%EC%9D%B4%EC%A7%80\" aria-label=\"5 공유 페이지 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5) 공유 페이지</h3>\n<ul>\n<li>공유 코드(shared code)는 여러 프로세스에 의해 공통으로 사용될 수 있도록 작성된 코드이다.\n<ul>\n<li>메모리 공간의 효율적인 사용을 위함</li>\n</ul>\n</li>\n<li>재진입 가능 코드 (re-entrant code) 또는 순수 코드 (pure code)로 불리며 read-only 특성을 가진다.</li>\n<li>공유 페이지(shared page)는 공유 코드를 담고있는 페이지이다.</li>\n<li>공유 페이지는 여러 프로세스에 공유되기 때문에 물리 메모리에 하나만 적재되어 메모리를 효율적으로 사용할 수 있다.\n<ul>\n<li>문서 편집기를 공유 페이지 사용해서 작성한 경우, 이 프로세스를 여러개 수행시켜도 공유 코드를 담은 페이지는 하나만 올라간다.</li>\n</ul>\n</li>\n<li>공유 코드는 읽기 전용이며 논리적 주소에서 같은 위치에 있어야하는 제약점도 있다.</li>\n<li>대비되는 개념으로 사유 페이지(private page)가 있다.\n<ul>\n<li>프로세스별로 독자적으로 사용하는 페이지이며 논리적 주소 공간 중 어디에 있어도 된다.</li>\n</ul>\n</li>\n</ul>\n<p align=\"center\"><img width=\"85%\" src=\"https://user-images.githubusercontent.com/63405904/141052240-708a31c5-6b2e-48b4-beee-b6cf66b8fcca.png\"></p>\n<h3 id=\"6-메모리-보호\" style=\"position:relative;\"><a href=\"#6-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%B3%B4%ED%98%B8\" aria-label=\"6 메모리 보호 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>6) 메모리 보호</h3>\n<ul>\n<li>메모리 보호를 위한 보호 비트(protection bit)와 유효-무효 비트(valid-invalid bit)를두고 있다.</li>\n<li>보호 비트\n<ul>\n<li>각 페이지에 대한 접근 권한 내용을 담는다.</li>\n<li>읽기-쓰기/읽기 전용 등의 접근 권한을 설정하여 ‘어떠한’ 접근을 제한한다.</li>\n</ul>\n</li>\n<li>유효-무효 비트\n<ul>\n<li>해당 페이지의 내용이 유효한지 내용을 담는다.</li>\n<li>유효로 세팅한다면 해당 메모리 프레임에 그 페이지가 존재하여 접근이 허용된다.</li>\n<li>무효라면 프로세스가 그 주소 부분을 사용하지 않거나 해당 페이지가 물리적 메모리가 아닌 백킹 스토에어에 존재하여 <strong>해당 메모리 프레임</strong>에 접근 권한이 없는 것이다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-5-세그멘테이션\" style=\"position:relative;\"><a href=\"#-5-%EC%84%B8%EA%B7%B8%EB%A9%98%ED%85%8C%EC%9D%B4%EC%85%98\" aria-label=\" 5 세그멘테이션 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 5. 세그멘테이션</h2>\n<ul>\n<li>프로세스의 주소 공간을 의미있는 단위인 세그먼트(segment)로 나누어 물리적 메모리에 올리는 기법이다.</li>\n<li>프로세스는 코드, 데이터, 스택 등인 논리적 단위로 구성된다. 이것에 따라서 나눈다.\n<ul>\n<li>많게는 프로그램 함수 하나하나를 세그먼트로 정의할 수도 있다.</li>\n</ul>\n</li>\n<li>크기가 균일하지 않으며 통째로 메모리에 적재되지 않고 나누어져 메모리에 적재되어 페이징과 유사하다.</li>\n<li>균일하지 않은 세그먼트들을 적재하기 때문에 그것을 관리하는 오버헤드가 있다.</li>\n<li>논리적 주소가 <strong>&#x3C;세그먼트 번호, 오프셋></strong> 으로 나뉘어 사용되어 몇번째 세그먼트와 해당 세그먼트 내에서 오프셋 정보를 나타낸다.</li>\n<li>세그먼트 테이블을 사용한다.\n<ul>\n<li>기준점(base)와 한계점(limit)을 가지고 있다.</li>\n<li>기준점은 물리 메모리에서 시작위치, 한계점은 세그먼트의 길이이다.</li>\n</ul>\n</li>\n<li>두 register의 도움을 받는다.\n<ul>\n<li>세그먼트 테이블 기준 레지스터 STBR (Segment Table Base Register)\n<ul>\n<li>세그먼트 테이블이 물리 메모리 어느 위치에 있는지 시작주소</li>\n</ul>\n</li>\n<li>세그먼트 테이블 길이 레지스터 STLR (Segment Table Legnth Register)\n<ul>\n<li>해당 프로세스의 주소 공간이 몇개의 세그먼트로 구성되었는지 세그먼트 개수</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>논리적 주소를 물리적 주소로 변환하기 전 두 가지를 확인한다.\n<ol>\n<li>요청된 세그먼트 번호가 STLR에 저장된 값보다 작은 값인지\n<ol>\n<li>아니라면 존재하지 않는 세그먼트 접근이므로 예외상황 발생</li>\n</ol>\n</li>\n<li>논리적 주소의 오프셋 값이 그 세그먼트의 길이보다 작은지\n<ol>\n<li>테이블의 해당 항목의 한계점과 논리적 주소의 오프셋을 비교</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>페이징 기법과 마찬가지로 보호비트와 유효비트를 둔다.</li>\n</ul>\n<p align=\"center\"><img width=\"85%\" src=\"https://user-images.githubusercontent.com/63405904/141052384-1976d0e9-efce-440b-bd42-469064f09aac.png\"></p>\n<ul>\n<li>여러 프로세스가 특정 세그먼트를 공유해 사용하는 공유 세그먼트(shared segment) 개념이 있다.\n<ul>\n<li>공유 세그먼트는 공유하는 모든 프로세스의 동일한 논리적 주소에 있어야한다.</li>\n</ul>\n</li>\n<li>세그먼트는 의미 단위로 나뉘어지므로 공유와 보안 측면에서 페이징 기법보다 효과적이다.\n<ul>\n<li>주소 공간의 일부를 공유하거나 접근 권한 제어 등이 가능하다.</li>\n<li>의미 단위로 업무를 수행할 수 있다.</li>\n</ul>\n</li>\n<li>하지만 길이가 균일하지 않아서 물리적 메모리에 외부조각이 발생한다.\n<ul>\n<li>세그먼트를 어느 가용 공간에 할당할 문제도 있다.</li>\n<li>최초적합과 최적적합 방식이 있다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-6-페이지드-세그먼테이션\" style=\"position:relative;\"><a href=\"#-6-%ED%8E%98%EC%9D%B4%EC%A7%80%EB%93%9C-%EC%84%B8%EA%B7%B8%EB%A8%BC%ED%85%8C%EC%9D%B4%EC%85%98\" aria-label=\" 6 페이지드 세그먼테이션 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 6. 페이지드 세그먼테이션</h2>\n<ul>\n<li>페이징과 세그먼테이션의 장점을 취하는 기법이다.</li>\n<li>의미단위로 세그먼트를 나누고 세그먼트의 길이가 동일한 크기의 페이지들의 집합으로 이루어지도록 한다.</li>\n<li>물리 메모리 적재는 페이지 단위로 한다.</li>\n<li>하나의 세그먼트 크기를 페이지크기의 배수가 되도록 하여 외부조각 문제를 해결하고 세그먼트 단위로 공유나 접근 권한 보호가 이루어질 수 있도록 한다.</li>\n<li>주소 변환을 위해 <strong>1) 외부의 세그먼트 테이블 2) 내부의 페이지 테이블</strong> 두가지를 사용한다.</li>\n<li><strong>&#x3C;세그먼트 번호, 오프셋></strong> 으로 논리주소가 구성되었다.\n<ul>\n<li>세그먼트 번호로 세그먼트 테이블에 접근하여 세그먼트의 길이와 세그먼트의 페이지 테이블 시작주소를 얻는다.\n<ul>\n<li>세그먼트 길이와 논리주소의 오프셋을 비교하여 메모리 접근 유효성을 검사한다.</li>\n</ul>\n</li>\n<li>오프셋을 상위, 하위로 나누어 상위는 세그먼트 내의 페이지 테이블 번호로 사용하고 하위는 페이지 내에서의 변위로 사용한다.</li>\n<li>페이지 번호로 페이지 테이블 항목에서 물리적 메모리의 프레임 위치를 얻는다.</li>\n</ul>\n</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#-%EB%93%A4%EC%96%B4%EA%B0%80%EA%B8%B0-%EC%A0%84\">🌩 들어가기 전</a></p>\n</li>\n<li>\n<p><a href=\"#-1-%EC%A3%BC%EC%86%8C-%EB%B0%94%EC%9D%B8%EB%94%A9\">🌩 1. 주소 바인딩</a></p>\n<ul>\n<li><a href=\"#%EC%A3%BC%EC%86%8C-%EB%B0%94%EC%9D%B8%EB%94%A9-%EB%B0%A9%EC%8B%9D\">주소 바인딩 방식</a></li>\n<li><a href=\"#mmu-%EA%B8%B0%EB%B2%95\">MMU 기법</a></li>\n<li><a href=\"#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%B3%B4%EC%95%88-memory-protection\">메모리 보안 Memory protection</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-2-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC%EC%99%80-%EA%B4%80%EB%A0%A8%EB%90%9C-%EC%9A%A9%EC%96%B4\">🌩 2. 메모리 관리와 관련된 용어</a></p>\n<ul>\n<li><a href=\"#1-%EB%8F%99%EC%A0%81%EB%A1%9C%EB%94%A9-dynamic-loading\">1) 동적로딩 dynamic loading</a></li>\n<li><a href=\"#2-%EB%8F%99%EC%A0%81%EC%97%B0%EA%B2%B0-dynamic-linking\">2) 동적연결 dynamic linking</a></li>\n<li><a href=\"#3-%EC%A4%91%EC%B2%A9-overlays\">3) 중첩 overlays</a></li>\n<li><a href=\"#4-%EC%8A%A4%EC%99%80%ED%95%91-swapping\">4) 스와핑 swapping</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-3-%EB%AC%BC%EB%A6%AC%EC%A0%81-%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%9D%98-%ED%95%A0%EB%8B%B9%EB%B0%A9%EC%8B%9D\">🌩 3. 물리적 메모리의 할당방식</a></p>\n<ul>\n<li><a href=\"#1-%EC%97%B0%EC%86%8D%ED%95%A0%EB%8B%B9-%EB%B0%A9%EC%8B%9D\">1) 연속할당 방식</a></li>\n<li><a href=\"#2-%EB%B6%88%EC%97%B0%EC%86%8D%ED%95%A0%EB%8B%B9-%EA%B8%B0%EB%B2%95\">2) 불연속할당 기법</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-4-%ED%8E%98%EC%9D%B4%EC%A7%95-%EA%B8%B0%EB%B2%95\">🌩 4. 페이징 기법</a></p>\n<ul>\n<li><a href=\"#1-%EC%A3%BC%EC%86%8C-%EB%B3%80%ED%99%98-%EA%B8%B0%EB%B2%95\">1) 주소 변환 기법</a></li>\n<li><a href=\"#2-%ED%8E%98%EC%9D%B4%EC%A7%80-%ED%85%8C%EC%9D%B4%EB%B8%94%EC%9D%98-%EA%B5%AC%ED%98%84\">2) 페이지 테이블의 구현</a></li>\n<li><a href=\"#3-%EA%B3%84%EC%B8%B5%EC%A0%81-%ED%8E%98%EC%9D%B4%EC%A7%95\">3) 계층적 페이징</a></li>\n<li><a href=\"#4-%EC%97%AD%ED%8E%98%EC%9D%B4%EC%A7%80-%ED%85%8C%EC%9D%B4%EB%B8%94-inverted-page-table\">4) 역페이지 테이블 inverted page table</a></li>\n<li><a href=\"#5-%EA%B3%B5%EC%9C%A0-%ED%8E%98%EC%9D%B4%EC%A7%80\">5) 공유 페이지</a></li>\n<li><a href=\"#6-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%B3%B4%ED%98%B8\">6) 메모리 보호</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-5-%EC%84%B8%EA%B7%B8%EB%A9%98%ED%85%8C%EC%9D%B4%EC%85%98\">🌩 5. 세그멘테이션</a></p>\n</li>\n<li>\n<p><a href=\"#-6-%ED%8E%98%EC%9D%B4%EC%A7%80%EB%93%9C-%EC%84%B8%EA%B7%B8%EB%A8%BC%ED%85%8C%EC%9D%B4%EC%85%98\">🌩 6. 페이지드 세그먼테이션</a></p>\n</li>\n</ul>\n</div>","excerpt":"다음은 반효경 교수님의 ‘운영체제와 정보기술의 원리’ CH7. 메모리 관리를 읽고 정리한 내용입니다 🙌 🌩 들어가기 전 우리가 흔히 사용하는 컴퓨터 주소 체계는 32비트 혹은 64비트로 나뉘어져 있다. 32비트면 32개의 비트로 주소를 표현할 수 있는 것이다. 2^32가지 다른 메모리 위치를 구분할 수 있다. 컴퓨터는 바이트 단위(8비트)로 주소를 부여한다. 따라서 2^32 바이트 만큼의 메모리 공간에 서로 다른 주소를 할당할 수 있다. 32 비트를 계층적으로 묶어서 관리한다. 보통 4KB (2^12 바이트) 단위로 묶어서 페이지(page)를 구성한다. 페이지 내에서 주소를 구분하기 위해서는 12비트가 필요하다. 따라서 32비트 중 하위 12비트는 페이지 내에서 주소를 나타낸다. 🌩 1. 주소 바인딩 프로세스의 주소 공간 (address space)는 프로그램이 실행되기 위해 메모리에 적재되면 프로세스를 위한 독자적인 주소 공간이 생성된다. 논리적 주소 (logical addres…","frontmatter":{"date":"October 16, 2021","title":"운영체제와 정보기술의 원리 - CH7. 메모리 관리","categories":"운영체제 책","author":"코다","emoji":"🧁"},"fields":{"slug":"/operating-system-6/"}},"next":{"id":"2eba1279-e1e0-5811-91ac-0f45dbfc508a","html":"<blockquote>\n<p>이 글은 다음 <a href=\"https://netflixtechblog.com/linux-performance-analysis-in-60-000-milliseconds-accc10403c55\">링크</a>를 번역하며 공부한 글입니다 🙌</p>\n</blockquote>\n<br>\n<h2 id=\"-intro\" style=\"position:relative;\"><a href=\"#-intro\" aria-label=\" intro permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>💡 Intro</h2>\n<ul>\n<li>성능 테스트에 관련한 공부 및 적용을 하면서 좋은 아티클을 추천 받았다. (Thanks to 제리 👍)</li>\n<li>관련 명령어들에 대해서 공부하고 각 칼럼이 의미하는 os 및 네트워크 기초 지식을 메꾸보자.</li>\n</ul>\n<br>\n<h2 id=\"1-uptime\" style=\"position:relative;\"><a href=\"#1-uptime\" aria-label=\"1 uptime permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. uptime</h2>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">uptime</span> \n<span class=\"token number\">23</span>:51:26 up <span class=\"token number\">21</span>:31, <span class=\"token number\">1</span> user, load average: <span class=\"token number\">30.02</span>, <span class=\"token number\">26.43</span>, <span class=\"token number\">19.02</span></code></pre></div>\n<ul>\n<li>실행되기를 기다리는 프로세스의 갯수를 출력한다. 리눅스 시스템에서는 CPU를 기다리는 프로세스와 uninterruptible I/O (disk I/O) 에 의해 프로세스가 막혀있을 수 있다. 따라서 이 수치를 통해서 리소스 부하를 간편하게 확인 할 수 있다.</li>\n<li>위 세개의 번호는 각각 1분, 5분, 15분 간 실행되지 못하고 대기 중인 프로세스 갯수를 나타낸다. 시간 추이에 따른 부하 상태를 통해 상황을 유추할 수도 있다.</li>\n</ul>\n<br>\n<h2 id=\"2-dmesg--tail\" style=\"position:relative;\"><a href=\"#2-dmesg--tail\" aria-label=\"2 dmesg  tail permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. dmesg | tail</h2>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">dmesg</span> <span class=\"token operator\">|</span> <span class=\"token function\">tail</span>\n<span class=\"token punctuation\">[</span><span class=\"token number\">1880957.563150</span><span class=\"token punctuation\">]</span> perl invoked oom-killer: <span class=\"token assign-left variable\">gfp_mask</span><span class=\"token operator\">=</span>0x280da, <span class=\"token assign-left variable\">order</span><span class=\"token operator\">=</span><span class=\"token number\">0</span>, <span class=\"token assign-left variable\">oom_score_adj</span><span class=\"token operator\">=</span><span class=\"token number\">0</span>\n<span class=\"token punctuation\">[</span><span class=\"token punctuation\">..</span>.<span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">[</span><span class=\"token number\">1880957.563400</span><span class=\"token punctuation\">]</span> Out of memory: Kill process <span class=\"token number\">18694</span> <span class=\"token punctuation\">(</span>perl<span class=\"token punctuation\">)</span> score <span class=\"token number\">246</span> or sacrifice child\n<span class=\"token punctuation\">[</span><span class=\"token number\">1880957.563408</span><span class=\"token punctuation\">]</span> Killed process <span class=\"token number\">18694</span> <span class=\"token punctuation\">(</span>perl<span class=\"token punctuation\">)</span> total-vm:1972392kB, anon-rss:1953348kB, file-rss:0kB\n<span class=\"token punctuation\">[</span><span class=\"token number\">2320864.954447</span><span class=\"token punctuation\">]</span> TCP: Possible SYN flooding on port <span class=\"token number\">7001</span>. Dropping request.  Check SNMP counters.</code></pre></div>\n<ul>\n<li>마지막 10개의 시스템 메세지를 출력한다. 여기서 성능에 이슈를 일으킨 에러 메세지를 확인할 수 있다. oom-killer나 TCP 요청 드랍 같은 경우를 확인할 수 있으므로 필수다.</li>\n</ul>\n<br>\n<h2 id=\"3-vmstat-1\" style=\"position:relative;\"><a href=\"#3-vmstat-1\" aria-label=\"3 vmstat 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. vmstat 1</h2>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">procs ---------memory---------- ---swap-- -----io---- -system-- ------cpu-----\n r  b swpd   <span class=\"token function\">free</span>   buff  cache   si   so    bi    bo   <span class=\"token keyword\">in</span>   cs us sy <span class=\"token function\">id</span> wa st\n<span class=\"token number\">34</span>  <span class=\"token number\">0</span>    <span class=\"token number\">0</span> <span class=\"token number\">200889792</span>  <span class=\"token number\">73708</span> <span class=\"token number\">591828</span>    <span class=\"token number\">0</span>    <span class=\"token number\">0</span>     <span class=\"token number\">0</span>     <span class=\"token number\">5</span>    <span class=\"token number\">6</span>   <span class=\"token number\">10</span> <span class=\"token number\">96</span>  <span class=\"token number\">1</span>  <span class=\"token number\">3</span>  <span class=\"token number\">0</span>  <span class=\"token number\">0</span>\n<span class=\"token number\">32</span>  <span class=\"token number\">0</span>    <span class=\"token number\">0</span> <span class=\"token number\">200889920</span>  <span class=\"token number\">73708</span> <span class=\"token number\">591860</span>    <span class=\"token number\">0</span>    <span class=\"token number\">0</span>     <span class=\"token number\">0</span>   <span class=\"token number\">592</span> <span class=\"token number\">13284</span> <span class=\"token number\">4282</span> <span class=\"token number\">98</span>  <span class=\"token number\">1</span>  <span class=\"token number\">1</span>  <span class=\"token number\">0</span>  <span class=\"token number\">0</span>\n<span class=\"token number\">32</span>  <span class=\"token number\">0</span>    <span class=\"token number\">0</span> <span class=\"token number\">200890112</span>  <span class=\"token number\">73708</span> <span class=\"token number\">591860</span>    <span class=\"token number\">0</span>    <span class=\"token number\">0</span>     <span class=\"token number\">0</span>     <span class=\"token number\">0</span> <span class=\"token number\">9501</span> <span class=\"token number\">2154</span> <span class=\"token number\">99</span>  <span class=\"token number\">1</span>  <span class=\"token number\">0</span>  <span class=\"token number\">0</span>  <span class=\"token number\">0</span>\n<span class=\"token number\">32</span>  <span class=\"token number\">0</span>    <span class=\"token number\">0</span> <span class=\"token number\">200889568</span>  <span class=\"token number\">73712</span> <span class=\"token number\">591856</span>    <span class=\"token number\">0</span>    <span class=\"token number\">0</span>     <span class=\"token number\">0</span>    <span class=\"token number\">48</span> <span class=\"token number\">11900</span> <span class=\"token number\">2459</span> <span class=\"token number\">99</span>  <span class=\"token number\">0</span>  <span class=\"token number\">0</span>  <span class=\"token number\">0</span>  <span class=\"token number\">0</span>\n<span class=\"token number\">32</span>  <span class=\"token number\">0</span>    <span class=\"token number\">0</span> <span class=\"token number\">200890208</span>  <span class=\"token number\">73712</span> <span class=\"token number\">591860</span>    <span class=\"token number\">0</span>    <span class=\"token number\">0</span>     <span class=\"token number\">0</span>     <span class=\"token number\">0</span> <span class=\"token number\">15898</span> <span class=\"token number\">4840</span> <span class=\"token number\">98</span>  <span class=\"token number\">1</span>  <span class=\"token number\">1</span>  <span class=\"token number\">0</span>  <span class=\"token number\">0</span>\n^C</code></pre></div>\n<ul>\n<li>가상 메모리 stat를 보여준다. 서버의 중요한 statistics를 출력한다.</li>\n<li>vmstat 명령어와 1을 클릭하면 1초마다 서버의 statictics를 출력한다. (단 첫번째 행은 서버가 부팅되었을 때부터의 평균 수치를 보여준다)</li>\n</ul>\n<h3 id=\"중요한-칼럼\" style=\"position:relative;\"><a href=\"#%EC%A4%91%EC%9A%94%ED%95%9C-%EC%B9%BC%EB%9F%BC\" aria-label=\"중요한 칼럼 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>중요한 칼럼</h3>\n<ul>\n<li>\n<p><strong>r</strong>: CPU에서 실행되는 프로세스와 기다리고 있는 프로세스 숫자이다. I/O에 의해 생기는 부하를 제외하고 CPU에 대해서만 보여주기 때문에 load average의 원인이 CPU인지 아닌지를 확인 할 수 있다.</p>\n<p>참고로, “r” 칼럼 값이 CPU 코어 갯수보다 많다면 saturation 상황이다.</p>\n</li>\n<li>\n<p><strong>free</strong>: 비어있는 메모리를 kilobytes 단위로 보여준다.</p>\n</li>\n<li>\n<p><strong>si, so</strong>: swap-ins, swap-outs를 보여준다. 이 값이 0이 아니라면 메모리 부족이다.</p>\n</li>\n<li>\n<p><strong>us, sy, id, wa, st</strong>: CPU 시간을 분할하여 모든 CPU 시간의 평균 정보를 보여준다.</p>\n<ul>\n<li>user time, system time(kernel), idle, wait I/O, stolen time(다른 게스트, Xen 등등) 지표를 보여준다.</li>\n</ul>\n</li>\n<li>\n<p>여기서 user + system time을 통해 CPU가 바쁜 상태인지 확인할 수 있다.</p>\n</li>\n<li>\n<p>wait I/O에 특정 값이 유지된다면 disk 병목 현상이 있다고 볼 수 있다. 이 경우는 작업이 disk I/O 작업을 기다리느라 CPU 가 유휴 상태에 있는 때이다.</p>\n</li>\n<li>\n<p>System time은 I/O 작업을 하기 위해서 필수이다. high system time 평균은 20% 이상이며 이런 수치를 보이면 커널이 I/O 작업을 비효율적으로 처리하고 있다고 볼 수 있다.</p>\n</li>\n<li>\n<p>CPU 사용률(user-level)은 평균 90% 이상일 수도 있으나 이것이 꼭 문제를 뜻하는 것은 아니다. CPU에 부하가 걸리고 있는지는 “r” 칼럼을 통해서 판단해야한다.</p>\n</li>\n<li>\n<p><a href=\"https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&#x26;blogId=ggaibi1004&#x26;logNo=221398356656\">여기서</a> 각 칼럼에 대한 자세한 설명을 확인할 수 있다. 개인적으로 매우 유용하게 참고하고 있다. <a href=\"https://im-recording-of-sw-studies.tistory.com/30\">여기도..</a></p>\n</li>\n</ul>\n<br>\n<h2 id=\"4-mpstat--p-all-1\" style=\"position:relative;\"><a href=\"#4-mpstat--p-all-1\" aria-label=\"4 mpstat  p all 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. mpstat -P ALL 1</h2>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ mpstat -P ALL <span class=\"token number\">1</span>\nLinux <span class=\"token number\">3.13</span>.0-49-generic <span class=\"token punctuation\">(</span>titanclusters-xxxxx<span class=\"token punctuation\">)</span>  07/14/2015  _x86_64_ <span class=\"token punctuation\">(</span><span class=\"token number\">32</span> CPU<span class=\"token punctuation\">)</span>\n\n07:38:49 PM  CPU   %usr  %nice   %sys %iowait   %irq  %soft  %steal  %guest  %gnice  %idle\n07:38:50 PM  all  <span class=\"token number\">98.47</span>   <span class=\"token number\">0.00</span>   <span class=\"token number\">0.75</span>    <span class=\"token number\">0.00</span>   <span class=\"token number\">0.00</span>   <span class=\"token number\">0.00</span>    <span class=\"token number\">0.00</span>    <span class=\"token number\">0.00</span>    <span class=\"token number\">0.00</span>   <span class=\"token number\">0.78</span>\n07:38:50 PM    <span class=\"token number\">0</span>  <span class=\"token number\">96.04</span>   <span class=\"token number\">0.00</span>   <span class=\"token number\">2.97</span>    <span class=\"token number\">0.00</span>   <span class=\"token number\">0.00</span>   <span class=\"token number\">0.00</span>    <span class=\"token number\">0.00</span>    <span class=\"token number\">0.00</span>    <span class=\"token number\">0.00</span>   <span class=\"token number\">0.99</span>\n07:38:50 PM    <span class=\"token number\">1</span>  <span class=\"token number\">97.00</span>   <span class=\"token number\">0.00</span>   <span class=\"token number\">1.00</span>    <span class=\"token number\">0.00</span>   <span class=\"token number\">0.00</span>   <span class=\"token number\">0.00</span>    <span class=\"token number\">0.00</span>    <span class=\"token number\">0.00</span>    <span class=\"token number\">0.00</span>   <span class=\"token number\">2.00</span>\n07:38:50 PM    <span class=\"token number\">2</span>  <span class=\"token number\">98.00</span>   <span class=\"token number\">0.00</span>   <span class=\"token number\">1.00</span>    <span class=\"token number\">0.00</span>   <span class=\"token number\">0.00</span>   <span class=\"token number\">0.00</span>    <span class=\"token number\">0.00</span>    <span class=\"token number\">0.00</span>    <span class=\"token number\">0.00</span>   <span class=\"token number\">1.00</span>\n07:38:50 PM    <span class=\"token number\">3</span>  <span class=\"token number\">96.97</span>   <span class=\"token number\">0.00</span>   <span class=\"token number\">0.00</span>    <span class=\"token number\">0.00</span>   <span class=\"token number\">0.00</span>   <span class=\"token number\">0.00</span>    <span class=\"token number\">0.00</span>    <span class=\"token number\">0.00</span>    <span class=\"token number\">0.00</span>   <span class=\"token number\">3.03</span>\n<span class=\"token punctuation\">[</span><span class=\"token punctuation\">..</span>.<span class=\"token punctuation\">]</span></code></pre></div>\n<ul>\n<li>CPU 코어 별 CPU 시간을 출력한다. 이것을 통해 한 코어에 프로세스가 집중되어 비효율적이지는 않은지 확인할 수 있다.</li>\n<li>만일 하나의 CPU에 부하가 심하다면 single thread application에 의한 부하일 수 있다.</li>\n</ul>\n<br>\n<h2 id=\"5-pidstat-1\" style=\"position:relative;\"><a href=\"#5-pidstat-1\" aria-label=\"5 pidstat 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5. pidstat 1</h2>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ pidstat <span class=\"token number\">1</span>\nLinux <span class=\"token number\">3.13</span>.0-49-generic <span class=\"token punctuation\">(</span>titanclusters-xxxxx<span class=\"token punctuation\">)</span>  07/14/2015    _x86_64_    <span class=\"token punctuation\">(</span><span class=\"token number\">32</span> CPU<span class=\"token punctuation\">)</span>\n\n07:41:02 PM   <span class=\"token environment constant\">UID</span>       PID    %usr %system  %guest    %CPU   CPU  Command\n07:41:03 PM     <span class=\"token number\">0</span>         <span class=\"token number\">9</span>    <span class=\"token number\">0.00</span>    <span class=\"token number\">0.94</span>    <span class=\"token number\">0.00</span>    <span class=\"token number\">0.94</span>     <span class=\"token number\">1</span>  rcuos/0\n07:41:03 PM     <span class=\"token number\">0</span>      <span class=\"token number\">4214</span>    <span class=\"token number\">5.66</span>    <span class=\"token number\">5.66</span>    <span class=\"token number\">0.00</span>   <span class=\"token number\">11.32</span>    <span class=\"token number\">15</span>  mesos-slave\n07:41:03 PM     <span class=\"token number\">0</span>      <span class=\"token number\">4354</span>    <span class=\"token number\">0.94</span>    <span class=\"token number\">0.94</span>    <span class=\"token number\">0.00</span>    <span class=\"token number\">1.89</span>     <span class=\"token number\">8</span>  java\n07:41:03 PM     <span class=\"token number\">0</span>      <span class=\"token number\">6521</span> <span class=\"token number\">1596.23</span>    <span class=\"token number\">1.89</span>    <span class=\"token number\">0.00</span> <span class=\"token number\">1598.11</span>    <span class=\"token number\">27</span>  java\n07:41:03 PM     <span class=\"token number\">0</span>      <span class=\"token number\">6564</span> <span class=\"token number\">1571.70</span>    <span class=\"token number\">7.55</span>    <span class=\"token number\">0.00</span> <span class=\"token number\">1579.25</span>    <span class=\"token number\">28</span>  java\n07:41:03 PM <span class=\"token number\">60004</span>     <span class=\"token number\">60154</span>    <span class=\"token number\">0.94</span>    <span class=\"token number\">4.72</span>    <span class=\"token number\">0.00</span>    <span class=\"token number\">5.66</span>     <span class=\"token number\">9</span>  pidstat\n\n07:41:03 PM   <span class=\"token environment constant\">UID</span>       PID    %usr %system  %guest    %CPU   CPU  Command\n07:41:04 PM     <span class=\"token number\">0</span>      <span class=\"token number\">4214</span>    <span class=\"token number\">6.00</span>    <span class=\"token number\">2.00</span>    <span class=\"token number\">0.00</span>    <span class=\"token number\">8.00</span>    <span class=\"token number\">15</span>  mesos-slave\n07:41:04 PM     <span class=\"token number\">0</span>      <span class=\"token number\">6521</span> <span class=\"token number\">1590.00</span>    <span class=\"token number\">1.00</span>    <span class=\"token number\">0.00</span> <span class=\"token number\">1591.00</span>    <span class=\"token number\">27</span>  java\n07:41:04 PM     <span class=\"token number\">0</span>      <span class=\"token number\">6564</span> <span class=\"token number\">1573.00</span>   <span class=\"token number\">10.00</span>    <span class=\"token number\">0.00</span> <span class=\"token number\">1583.00</span>    <span class=\"token number\">28</span>  java\n07:41:04 PM   <span class=\"token number\">108</span>      <span class=\"token number\">6718</span>    <span class=\"token number\">1.00</span>    <span class=\"token number\">0.00</span>    <span class=\"token number\">0.00</span>    <span class=\"token number\">1.00</span>     <span class=\"token number\">0</span>  snmp-pass\n07:41:04 PM <span class=\"token number\">60004</span>     <span class=\"token number\">60154</span>    <span class=\"token number\">1.00</span>    <span class=\"token number\">4.00</span>    <span class=\"token number\">0.00</span>    <span class=\"token number\">5.00</span>     <span class=\"token number\">9</span>  pidstat\n^C</code></pre></div>\n<ul>\n<li>pidstat는 프로세스 별 top 명령어 같은 느낌이다. 하지만 rollling 방식으로 매 시간마다의 모니터링 결과를 출력해준다.</li>\n<li>이 명령을 통해 시간에 흐름에 따른 패턴을 확인할 수 있고, 현상을 기록할 수 있는 장점이 있다.</li>\n<li>위 예시를 보면 2개의 자바 프로세스가 CPU를 과하게 소비하고 있음을 알 수 있다.</li>\n<li>위에서 <code class=\"language-text\">%CPU</code> 칼럼은 서버의 모든 CPU를 포함한 수치이다. 따라서 1591%라는 수치는 해당 자바 프로세스가 거의 16개의 CPU를 소비하고 있음을 나타낸다. (리눅스에서 CPU 사용률은 주로 각 CPU 당 100%의 수치로 그 합을 의미한다)</li>\n</ul>\n<br>\n<h2 id=\"6-iostat--xz-1\" style=\"position:relative;\"><a href=\"#6-iostat--xz-1\" aria-label=\"6 iostat  xz 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>6. iostat -xz 1</h2>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ iostat -xz <span class=\"token number\">1</span>\nLinux <span class=\"token number\">3.13</span>.0-49-generic <span class=\"token punctuation\">(</span>titanclusters-xxxxx<span class=\"token punctuation\">)</span>  07/14/2015  _x86_64_ <span class=\"token punctuation\">(</span><span class=\"token number\">32</span> CPU<span class=\"token punctuation\">)</span>\n\navg-cpu:  %user   %nice %system %iowait  %steal   %idle\n          <span class=\"token number\">73.96</span>    <span class=\"token number\">0.00</span>    <span class=\"token number\">3.73</span>    <span class=\"token number\">0.03</span>    <span class=\"token number\">0.06</span>   <span class=\"token number\">22.21</span>\n\nDevice:   rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util\nxvda        <span class=\"token number\">0.00</span>     <span class=\"token number\">0.23</span>    <span class=\"token number\">0.21</span>    <span class=\"token number\">0.18</span>     <span class=\"token number\">4.52</span>     <span class=\"token number\">2.08</span>    <span class=\"token number\">34.37</span>     <span class=\"token number\">0.00</span>    <span class=\"token number\">9.98</span>   <span class=\"token number\">13.80</span>    <span class=\"token number\">5.42</span>   <span class=\"token number\">2.44</span>   <span class=\"token number\">0.09</span>\nxvdb        <span class=\"token number\">0.01</span>     <span class=\"token number\">0.00</span>    <span class=\"token number\">1.02</span>    <span class=\"token number\">8.94</span>   <span class=\"token number\">127.97</span>   <span class=\"token number\">598.53</span>   <span class=\"token number\">145.79</span>     <span class=\"token number\">0.00</span>    <span class=\"token number\">0.43</span>    <span class=\"token number\">1.78</span>    <span class=\"token number\">0.28</span>   <span class=\"token number\">0.25</span>   <span class=\"token number\">0.25</span>\nxvdc        <span class=\"token number\">0.01</span>     <span class=\"token number\">0.00</span>    <span class=\"token number\">1.02</span>    <span class=\"token number\">8.86</span>   <span class=\"token number\">127.79</span>   <span class=\"token number\">595.94</span>   <span class=\"token number\">146.50</span>     <span class=\"token number\">0.00</span>    <span class=\"token number\">0.45</span>    <span class=\"token number\">1.82</span>    <span class=\"token number\">0.30</span>   <span class=\"token number\">0.27</span>   <span class=\"token number\">0.26</span>\ndm-0        <span class=\"token number\">0.00</span>     <span class=\"token number\">0.00</span>    <span class=\"token number\">0.69</span>    <span class=\"token number\">2.32</span>    <span class=\"token number\">10.47</span>    <span class=\"token number\">31.69</span>    <span class=\"token number\">28.01</span>     <span class=\"token number\">0.01</span>    <span class=\"token number\">3.23</span>    <span class=\"token number\">0.71</span>    <span class=\"token number\">3.98</span>   <span class=\"token number\">0.13</span>   <span class=\"token number\">0.04</span>\ndm-1        <span class=\"token number\">0.00</span>     <span class=\"token number\">0.00</span>    <span class=\"token number\">0.00</span>    <span class=\"token number\">0.94</span>     <span class=\"token number\">0.01</span>     <span class=\"token number\">3.78</span>     <span class=\"token number\">8.00</span>     <span class=\"token number\">0.33</span>  <span class=\"token number\">345.84</span>    <span class=\"token number\">0.04</span>  <span class=\"token number\">346.81</span>   <span class=\"token number\">0.01</span>   <span class=\"token number\">0.00</span>\ndm-2        <span class=\"token number\">0.00</span>     <span class=\"token number\">0.00</span>    <span class=\"token number\">0.09</span>    <span class=\"token number\">0.07</span>     <span class=\"token number\">1.35</span>     <span class=\"token number\">0.36</span>    <span class=\"token number\">22.50</span>     <span class=\"token number\">0.00</span>    <span class=\"token number\">2.55</span>    <span class=\"token number\">0.23</span>    <span class=\"token number\">5.62</span>   <span class=\"token number\">1.78</span>   <span class=\"token number\">0.03</span>\n<span class=\"token punctuation\">[</span><span class=\"token punctuation\">..</span>.<span class=\"token punctuation\">]</span>\n^C</code></pre></div>\n<ul>\n<li>블록 디바이스 (disks)를 확인하기 매우 좋은 명령어다. 해당 디바이스의 부하와 퍼포먼스까지 확인할 수 있다. 다음 칼럼들을 유의해서 보자.</li>\n</ul>\n<ol>\n<li><strong>r/s, w/s, rkB/s, wkB/s</strong>\n<ul>\n<li>위 수치들은 1초 동안 해당 디바이스에게 전달된 읽기, 쓰기, Kbytes 읽기, Kbytes 쓰기이다.</li>\n<li>디바이스의 작업량 정도를 확인할 수 있다. 이 수치가 지나치게 높다면 과부하에 의한 성능 문제가 발생할 수 있다.</li>\n</ul>\n</li>\n<li><strong>await</strong>\n<ul>\n<li>ms 단위의 I/O 평균 시간이다. 이것은 어플리케이션이 queue에 있는 시간과 서비스되는 시간이 모두 포함된 시간이다.</li>\n<li>예상보다 긴 평균시간은 디바이스 포화 여부 혹은 디바이스에 오류 가능성을 의미할 수 있다.</li>\n</ul>\n</li>\n<li><strong>avgqu-sz</strong>\n<ul>\n<li>디바이스의 평균 요청 수이다. 1 보다 큰 수치는 포화상태의 근거일 수 있다. (여러 디스크에 대한 가장 디바이스 같은 경우 요청을 병렬로 처리할 수 있긴 하다는 것을 참고)</li>\n</ul>\n</li>\n<li><strong>%util</strong>\n<ul>\n<li>디바이스 사용률이다. 매 초마다 디바이스가 처리하고 있는 퍼센트를 나타닌다.</li>\n<li>디바이스 마다 상이하지만 60% 보다 큰 수치는 주로 좋지 않은 성능을 나타낸다. (await 칼럼에서 함께 확인할 수 있는 상태이다)</li>\n<li>100%에 가까운 것은 포화상태임을 뜻한다.</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li>만일 storage device가 여러 물리 디스크 앞에 있는 논리 디스크라면 100% 의 사용률은 어떤 I/O 프로세스가 100% 시간동안 처리되고 있으나 실제 물리 디스크는 포화상태가 아닐 수도 있다.</li>\n<li>참고할 것은 disk I/O의 낮은 성능이 어플리케이션의 성능을 저하시키는 요인이 아닐 수도 있다는 것이다. 많은 기술들은 I/O 작업을 비동기로 처리하여 어플리케이션이 봉쇄상태에 머물거나 지연시간(latency)에 영향이 가지 않도록 한다.</li>\n</ul>\n<br>\n<h2 id=\"7-free--m\" style=\"position:relative;\"><a href=\"#7-free--m\" aria-label=\"7 free  m permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>7. free -m</h2>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">free</span> -m\n             total       used       <span class=\"token function\">free</span>     shared    buffers     cached\nMem:        <span class=\"token number\">245998</span>      <span class=\"token number\">24545</span>     <span class=\"token number\">221453</span>         <span class=\"token number\">83</span>         <span class=\"token number\">59</span>        <span class=\"token number\">541</span>\n-/+ buffers/cache:      <span class=\"token number\">23944</span>     <span class=\"token number\">222053</span>\nSwap:            <span class=\"token number\">0</span>          <span class=\"token number\">0</span>          <span class=\"token number\">0</span></code></pre></div>\n<ul>\n<li>중요 칼럼 (가장 오른쪽 칼럼)\n<ol>\n<li><strong>buffers</strong>\n<ul>\n<li>버퍼 캐시이며 block device I/O 에 사용</li>\n</ul>\n</li>\n<li><strong>cached</strong>\n<ul>\n<li>페이지 캐시이며 file systems에 사용</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>위 두 칼럼의 수치가 <code class=\"language-text\">0</code>이 아니도록 주의하자. 0 이라면 disk I/O가 빈번하게 발생하며(<code class=\"language-text\">iostat</code>으로 확인) 가장 느린 연산이므로 최악의 성능을 낸다. 위 경우 Mbytes 이상의 여유 공간을 가지고 있으니 양호한 상태이다.</li>\n<li><code class=\"language-text\">/+ buffers/cache</code> 은 <code class=\"language-text\">free</code> 수치에 대해서 더 명확하게 알려준다.\n<ul>\n<li>운영체제의 물리 메모리는 그 빈 공간을 캐싱을 하기 위해서 사용한다. 하지만 프로세스가 필요로 하다면 곧바로 회수하여 필요한 프로세스에게 할당한다. 따라서 엄밀히 말하먄 캐시 데이터가 차지하고 있는 메모리의 용량도 free에 포함되어야 마땅하다.</li>\n<li>이 수치의 free는 캐시 데이터 메모리 용량까지 포함한 수치이다.</li>\n<li>이 부분에 대한 많은 혼란이 있기에 관련 <a href=\"https://www.linuxatemyram.com/\">사이트</a>가 따로 있을 정도이다. (ㅋㅋㅋㅋ)</li>\n</ul>\n</li>\n<li>리눅스에서 <a href=\"https://itsfoss.com/what-is-zfs/\">ZFS</a> 라는 향상된 file system을 사용하고 있다면 위 수치가 더 혼란스러울 수 있다. ZFS는 별도의 캐시가 존재하며 <code class=\"language-text\">free -m</code> 에 제대로 반영이 되지 않기 때문이다.\n<ul>\n<li>시스템이 가용 가능한 메모리 공간이 적어보이지만 ZFS 캐시에 의해 가용 가능한 메모리가 존재할 수도 있다는 것을 참고하자.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"8-sar--n-dev-1\" style=\"position:relative;\"><a href=\"#8-sar--n-dev-1\" aria-label=\"8 sar  n dev 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>8. sar -n DEV 1</h2>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ sar -n DEV <span class=\"token number\">1</span>\nLinux <span class=\"token number\">3.13</span>.0-49-generic <span class=\"token punctuation\">(</span>titanclusters-xxxxx<span class=\"token punctuation\">)</span>  07/14/2015     _x86_64_    <span class=\"token punctuation\">(</span><span class=\"token number\">32</span> CPU<span class=\"token punctuation\">)</span>\n\n<span class=\"token number\">12</span>:16:48 AM     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s   %ifutil\n<span class=\"token number\">12</span>:16:49 AM      eth0  <span class=\"token number\">18763.00</span>   <span class=\"token number\">5032.00</span>  <span class=\"token number\">20686.42</span>    <span class=\"token number\">478.30</span>      <span class=\"token number\">0.00</span>      <span class=\"token number\">0.00</span>      <span class=\"token number\">0.00</span>      <span class=\"token number\">0.00</span>\n<span class=\"token number\">12</span>:16:49 AM        lo     <span class=\"token number\">14.00</span>     <span class=\"token number\">14.00</span>      <span class=\"token number\">1.36</span>      <span class=\"token number\">1.36</span>      <span class=\"token number\">0.00</span>      <span class=\"token number\">0.00</span>      <span class=\"token number\">0.00</span>      <span class=\"token number\">0.00</span>\n<span class=\"token number\">12</span>:16:49 AM   docker0      <span class=\"token number\">0.00</span>      <span class=\"token number\">0.00</span>      <span class=\"token number\">0.00</span>      <span class=\"token number\">0.00</span>      <span class=\"token number\">0.00</span>      <span class=\"token number\">0.00</span>      <span class=\"token number\">0.00</span>      <span class=\"token number\">0.00</span>\n\n<span class=\"token number\">12</span>:16:49 AM     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s   %ifutil\n<span class=\"token number\">12</span>:16:50 AM      eth0  <span class=\"token number\">19763.00</span>   <span class=\"token number\">5101.00</span>  <span class=\"token number\">21999.10</span>    <span class=\"token number\">482.56</span>      <span class=\"token number\">0.00</span>      <span class=\"token number\">0.00</span>      <span class=\"token number\">0.00</span>      <span class=\"token number\">0.00</span>\n<span class=\"token number\">12</span>:16:50 AM        lo     <span class=\"token number\">20.00</span>     <span class=\"token number\">20.00</span>      <span class=\"token number\">3.25</span>      <span class=\"token number\">3.25</span>      <span class=\"token number\">0.00</span>      <span class=\"token number\">0.00</span>      <span class=\"token number\">0.00</span>      <span class=\"token number\">0.00</span>\n<span class=\"token number\">12</span>:16:50 AM   docker0      <span class=\"token number\">0.00</span>      <span class=\"token number\">0.00</span>      <span class=\"token number\">0.00</span>      <span class=\"token number\">0.00</span>      <span class=\"token number\">0.00</span>      <span class=\"token number\">0.00</span>      <span class=\"token number\">0.00</span>      <span class=\"token number\">0.00</span>\n^C</code></pre></div>\n<ul>\n<li>이 명령어를 통해 네트워크 인터페이스 처리량을 확인할 수 있다.\n<ul>\n<li><code class=\"language-text\">rxkB/s</code> 와 <code class=\"language-text\">txkB/s</code> 를 통해 작업량을 확인하고 한계치에 다다랐는지 확인할 수 있다.</li>\n<li>위 예시를 보면 eth0 는 22 Mbytes/s (176 Mbits/sec) 이다. (1 Gbit/sec 제한 보다 낮은 수치이다)</li>\n</ul>\n</li>\n<li><code class=\"language-text\">%ifutil</code> 칼럼을 통해 디바이스 사용률을 확인할 수 있다. (full-duplex인 경우 양쪽 방향의 최대값이다) 이것은 정확한 수치를 알기 어렵고 사용하지 않는 0.00 수치를 보이기도 한다.</li>\n</ul>\n<br>\n<h2 id=\"9-sar--n-tcpetcp-1\" style=\"position:relative;\"><a href=\"#9-sar--n-tcpetcp-1\" aria-label=\"9 sar  n tcpetcp 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>9. sar -n TCP,ETCP 1</h2>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ sar -n TCP,ETCP <span class=\"token number\">1</span>\nLinux <span class=\"token number\">3.13</span>.0-49-generic <span class=\"token punctuation\">(</span>titanclusters-xxxxx<span class=\"token punctuation\">)</span>  07/14/2015    _x86_64_    <span class=\"token punctuation\">(</span><span class=\"token number\">32</span> CPU<span class=\"token punctuation\">)</span>\n\n<span class=\"token number\">12</span>:17:19 AM  active/s passive/s    iseg/s    oseg/s\n<span class=\"token number\">12</span>:17:20 AM      <span class=\"token number\">1.00</span>      <span class=\"token number\">0.00</span>  <span class=\"token number\">10233.00</span>  <span class=\"token number\">18846.00</span>\n\n<span class=\"token number\">12</span>:17:19 AM  atmptf/s  estres/s retrans/s isegerr/s   orsts/s\n<span class=\"token number\">12</span>:17:20 AM      <span class=\"token number\">0.00</span>      <span class=\"token number\">0.00</span>      <span class=\"token number\">0.00</span>      <span class=\"token number\">0.00</span>      <span class=\"token number\">0.00</span>\n\n<span class=\"token number\">12</span>:17:20 AM  active/s passive/s    iseg/s    oseg/s\n<span class=\"token number\">12</span>:17:21 AM      <span class=\"token number\">1.00</span>      <span class=\"token number\">0.00</span>   <span class=\"token number\">8359.00</span>   <span class=\"token number\">6039.00</span>\n\n<span class=\"token number\">12</span>:17:20 AM  atmptf/s  estres/s retrans/s isegerr/s   orsts/s\n<span class=\"token number\">12</span>:17:21 AM      <span class=\"token number\">0.00</span>      <span class=\"token number\">0.00</span>      <span class=\"token number\">0.00</span>      <span class=\"token number\">0.00</span>      <span class=\"token number\">0.00</span>\n^C</code></pre></div>\n<ul>\n<li>중요한 TCP 수치에 대해서 보여준다.\n<ol>\n<li><strong>active/s</strong>\n<ul>\n<li>로컬에서 시작된 초당 TCP 커넥션 개수 (<code class=\"language-text\">connect()</code>를 명령어로 시작된 커넥션)</li>\n</ul>\n</li>\n<li><strong>passive/s</strong>\n<ul>\n<li>리모트에서 시작된 초당 TCP 커넥션 개수 (<code class=\"language-text\">accept()</code>로 연결된 커넥션)</li>\n</ul>\n</li>\n<li><strong>retrans/s</strong>\n<ul>\n<li>초당 TCP 재전송량</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>active와 passive 수는 서버 부하를 대략적으로 산출할 수 있는 좋은 수치이다.\n<ul>\n<li>새롭게 들어온 passive 커넥션 개수와 내보내지고 있는 active 커넥션 개수</li>\n<li>active를 outbound, passive을 inbound 수치로 판단할 수 있으나 정확히 그렇지만은 않다. (<a href=\"http://localhost\">localhost</a>와 localhost connection의 차이를 고려해보라)</li>\n</ul>\n</li>\n<li>네트워크 재전송량은 네트워크 혹은 서버 이슈 일 수 있다.\n<ul>\n<li>네트워크 문제라면 네트워크가 안정적이지 않은 네트워크 일 수 있다.</li>\n<li>혹은 서버 과부화로 인해 패킷이 유실되는 문제일 수도 있다.</li>\n<li>위 예시에서는 초당 1개의 TCP 커넥션이 재전송되고 있다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"10-top\" style=\"position:relative;\"><a href=\"#10-top\" aria-label=\"10 top permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>10. top</h2>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">top</span>\n<span class=\"token function\">top</span> - 00:15:40 up <span class=\"token number\">21</span>:56,  <span class=\"token number\">1</span> user,  load average: <span class=\"token number\">31.09</span>, <span class=\"token number\">29.87</span>, <span class=\"token number\">29.92</span>\nTasks: <span class=\"token number\">871</span> total,   <span class=\"token number\">1</span> running, <span class=\"token number\">868</span> sleeping,   <span class=\"token number\">0</span> stopped,   <span class=\"token number\">2</span> zombie\n%Cpu<span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span>: <span class=\"token number\">96.8</span> us,  <span class=\"token number\">0.4</span> sy,  <span class=\"token number\">0.0</span> ni,  <span class=\"token number\">2.7</span> id,  <span class=\"token number\">0.1</span> wa,  <span class=\"token number\">0.0</span> hi,  <span class=\"token number\">0.0</span> si,  <span class=\"token number\">0.0</span> st\nKiB Mem:  <span class=\"token number\">25190241</span>+total, <span class=\"token number\">24921688</span> used, <span class=\"token number\">22698073</span>+free,    <span class=\"token number\">60448</span> buffers\nKiB Swap:        <span class=\"token number\">0</span> total,        <span class=\"token number\">0</span> used,        <span class=\"token number\">0</span> free.   <span class=\"token number\">554208</span> cached Mem\n\n   PID <span class=\"token environment constant\">USER</span>      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND\n <span class=\"token number\">20248</span> root      <span class=\"token number\">20</span>   <span class=\"token number\">0</span>  <span class=\"token number\">0</span>.227t <span class=\"token number\">0</span>.012t  <span class=\"token number\">18748</span> S  <span class=\"token number\">3090</span>  <span class=\"token number\">5.2</span>  <span class=\"token number\">29812</span>:58 java\n  <span class=\"token number\">4213</span> root      <span class=\"token number\">20</span>   <span class=\"token number\">0</span> <span class=\"token number\">2722544</span>  <span class=\"token number\">64640</span>  <span class=\"token number\">44232</span> S  <span class=\"token number\">23.5</span>  <span class=\"token number\">0.0</span> <span class=\"token number\">233</span>:35.37 mesos-slave\n <span class=\"token number\">66128</span> titancl+  <span class=\"token number\">20</span>   <span class=\"token number\">0</span>   <span class=\"token number\">24344</span>   <span class=\"token number\">2332</span>   <span class=\"token number\">1172</span> R   <span class=\"token number\">1.0</span>  <span class=\"token number\">0.0</span>   <span class=\"token number\">0</span>:00.07 <span class=\"token function\">top</span>\n  <span class=\"token number\">5235</span> root      <span class=\"token number\">20</span>   <span class=\"token number\">0</span> <span class=\"token number\">38</span>.227g <span class=\"token number\">547004</span>  <span class=\"token number\">49996</span> S   <span class=\"token number\">0.7</span>  <span class=\"token number\">0.2</span>   <span class=\"token number\">2</span>:02.74 java\n  <span class=\"token number\">4299</span> root      <span class=\"token number\">20</span>   <span class=\"token number\">0</span> <span class=\"token number\">20</span>.015g <span class=\"token number\">2</span>.682g  <span class=\"token number\">16836</span> S   <span class=\"token number\">0.3</span>  <span class=\"token number\">1.1</span>  <span class=\"token number\">33</span>:14.42 java\n     <span class=\"token number\">1</span> root      <span class=\"token number\">20</span>   <span class=\"token number\">0</span>   <span class=\"token number\">33620</span>   <span class=\"token number\">2920</span>   <span class=\"token number\">1496</span> S   <span class=\"token number\">0.0</span>  <span class=\"token number\">0.0</span>   <span class=\"token number\">0</span>:03.82 init\n     <span class=\"token number\">2</span> root      <span class=\"token number\">20</span>   <span class=\"token number\">0</span>       <span class=\"token number\">0</span>      <span class=\"token number\">0</span>      <span class=\"token number\">0</span> S   <span class=\"token number\">0.0</span>  <span class=\"token number\">0.0</span>   <span class=\"token number\">0</span>:00.02 kthreadd\n     <span class=\"token number\">3</span> root      <span class=\"token number\">20</span>   <span class=\"token number\">0</span>       <span class=\"token number\">0</span>      <span class=\"token number\">0</span>      <span class=\"token number\">0</span> S   <span class=\"token number\">0.0</span>  <span class=\"token number\">0.0</span>   <span class=\"token number\">0</span>:05.35 ksoftirqd/0\n     <span class=\"token number\">5</span> root       <span class=\"token number\">0</span> -20       <span class=\"token number\">0</span>      <span class=\"token number\">0</span>      <span class=\"token number\">0</span> S   <span class=\"token number\">0.0</span>  <span class=\"token number\">0.0</span>   <span class=\"token number\">0</span>:00.00 kworker/0:0H\n     <span class=\"token number\">6</span> root      <span class=\"token number\">20</span>   <span class=\"token number\">0</span>       <span class=\"token number\">0</span>      <span class=\"token number\">0</span>      <span class=\"token number\">0</span> S   <span class=\"token number\">0.0</span>  <span class=\"token number\">0.0</span>   <span class=\"token number\">0</span>:06.94 kworker/u256:0\n     <span class=\"token number\">8</span> root      <span class=\"token number\">20</span>   <span class=\"token number\">0</span>       <span class=\"token number\">0</span>      <span class=\"token number\">0</span>      <span class=\"token number\">0</span> S   <span class=\"token number\">0.0</span>  <span class=\"token number\">0.0</span>   <span class=\"token number\">2</span>:38.05 rcu_sched</code></pre></div>\n<ul>\n<li><code class=\"language-text\">top</code> 명령어는 이전에 다룬 다른 명령어로 확인할 수 있는 수치를 전반적으로 포함한 지표들을 보여준다. 때문에 편리하게 사용된다.</li>\n<li><code class=\"language-text\">top</code> 명령어의 단점은 시간의 흐름에 따른 패턴 확인이 어렵고 당시 전반적인 서버의 상태만을 확인할 수 있다는 것이다. 시간의 흐름에 따른 패턴을 확인하고 싶다면 <code class=\"language-text\">vmstat</code> 혹은 <code class=\"language-text\">pidstat</code> 으로 확인할 수 있다. (rolling output을 보여준다)</li>\n</ul>\n <br>\n <br>\n<h2 id=\"-느낀-점\" style=\"position:relative;\"><a href=\"#-%EB%8A%90%EB%82%80-%EC%A0%90\" aria-label=\" 느낀 점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 느낀 점</h2>\n<ul>\n<li>확실히 os 에 대한 지식이 필요한 것을 느꼈다. os와 네트워크 공부와 병행하며 지표를 살피니 의미하는 바를 잘 이해할 수 있었다.</li>\n<li>서버의 부하를 살펴보려면 크게 CPU부하, I/O 디바이스 부하, 네트워크 부하를 확인해야한다.</li>\n<li>어플리케이션을 구현하고 제대로 서비스 하기 위해서는 서버를 제대로 모니터링하고 미리 어느 정도를 감당할 수 있는지 확인할 수 있어야 한다.</li>\n<li>또한 지표를 보고 어느 부분을 개선하여 성능을 개선시킬 수 있을지도 판단할 수 있어야 한다.</li>\n<li>결국 경험이 답이다…!!</li>\n</ul>\n<br>\n<br>\n<p><strong>[참고자료]</strong></p>\n<ul>\n<li><a href=\"https://netflixtechblog.com/linux-performance-analysis-in-60-000-milliseconds-accc10403c55\">https://netflixtechblog.com/linux-performance-analysis-in-60-000-milliseconds-accc10403c55</a></li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#-intro\">💡 Intro</a></p>\n</li>\n<li>\n<p><a href=\"#1-uptime\">1. uptime</a></p>\n</li>\n<li>\n<p><a href=\"#2-dmesg--tail\">2. dmesg | tail</a></p>\n</li>\n<li>\n<p><a href=\"#3-vmstat-1\">3. vmstat 1</a></p>\n<ul>\n<li><a href=\"#%EC%A4%91%EC%9A%94%ED%95%9C-%EC%B9%BC%EB%9F%BC\">중요한 칼럼</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#4-mpstat--p-all-1\">4. mpstat -P ALL 1</a></p>\n</li>\n<li>\n<p><a href=\"#5-pidstat-1\">5. pidstat 1</a></p>\n</li>\n<li>\n<p><a href=\"#6-iostat--xz-1\">6. iostat -xz 1</a></p>\n</li>\n<li>\n<p><a href=\"#7-free--m\">7. free -m</a></p>\n</li>\n<li>\n<p><a href=\"#8-sar--n-dev-1\">8. sar -n DEV 1</a></p>\n</li>\n<li>\n<p><a href=\"#9-sar--n-tcpetcp-1\">9. sar -n TCP,ETCP 1</a></p>\n</li>\n<li>\n<p><a href=\"#10-top\">10. top</a></p>\n</li>\n<li>\n<p><a href=\"#-%EB%8A%90%EB%82%80-%EC%A0%90\">🌩 느낀 점</a></p>\n</li>\n</ul>\n</div>","frontmatter":{"date":"October 15, 2021","title":"넷플릭스에서 60000ms 만에 리눅스 서버 성능을 진단하는 방법 10가지","categories":"웹 성능테스트","author":"코다","emoji":"📈"},"fields":{"slug":"/netflix-performance-analysis/"}},"prev":{"id":"6d288200-6a5c-5a45-b4b9-a99ac34bd599","html":"<blockquote>\n<p>다음은 반효경 교수님의 ‘운영체제와 정보기술의 원리’ <em>CH8. 가상 메모리</em>를 읽고 정리한 내용입니다 🙌</p>\n</blockquote>\n<br>\n<br>\n<h2 id=\"-들어가기-전\" style=\"position:relative;\"><a href=\"#-%EB%93%A4%EC%96%B4%EA%B0%80%EA%B8%B0-%EC%A0%84\" aria-label=\" 들어가기 전 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 들어가기 전</h2>\n<ul>\n<li>시분할 환경에서는 여러 프로세스가 동시에 메모리에 올라와서 수행되기 때문에 어떤 메모리에 어느 정도의 메모리를 할당해야할지가 문제이다.</li>\n<li>운영체제는 몇몀 프로그램에게 집중적으로 메모리를 할당하고 시간이 흐른다음 메모리를 회수하여 다른 프로그램에게 집중적으로 메모리를 할당하는 방식을 택한다.\n<ul>\n<li>프로그램마다 프로세스를 빠르게 수행하기 위해서 확보해야하는 최소한의 메모리 크기가 있기 때문이다.</li>\n</ul>\n</li>\n<li>프로세스의 전체가 올라가는 것이 아니라 스왑 영역에 일부분은 내려놓기 때문에 프로세스 입장에서 물리 메모리 크기 제약은 생각하지 않게 된다.</li>\n<li>또한 운영체제는 각 프로세스가 자기만 메모리에 올라간 것처럼 여겨질 수 있는 가장 메모리를 지원한다.\n<ul>\n<li>각자의 주소 공간을 가정하여 모든 프로세스가 0번지부터 시작한다.</li>\n<li>일부는 스왑 영역에 일부는 메모리에 있다.</li>\n</ul>\n</li>\n<li>프로세스의 주소 공간을 메모리로 적재하는 단위에 따라 가상메모리 기법은 요구 페이징 (demand paging) 방식과 요구 세그멘테이션 (demand segmentation) 으로 구현된다.\n<ul>\n<li>대부분 요구 페이징을 사용하고 요구 세그먼테이션은 페이지드 세그먼테이션 기법을 사용하는 경우에 많이 사용한다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-1-요구-페이징\" style=\"position:relative;\"><a href=\"#-1-%EC%9A%94%EA%B5%AC-%ED%8E%98%EC%9D%B4%EC%A7%95\" aria-label=\" 1 요구 페이징 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 1. 요구 페이징</h2>\n<ul>\n<li>당장 사용될 페이지만 메모리에 올리는 방식이다.</li>\n<li>요구 페이징은 특정 페이지에 대한 CPU의 요청이 들어온 후에 페이지를 메모리에 적재한다.</li>\n<li>장점\n<ul>\n<li>메모리 사용량 감소</li>\n<li>프로세스 전체를 메모리에 올리는 입출력 오버헤드 감소</li>\n<li>사용하지 않을 주소 영역의 입출력은 안해도 되므로 응답시간 단축</li>\n<li>시스템이 더 많은 프로세스를 수용할 수 있도록 함</li>\n<li>프로그램이 물리적 메모리의 용량 제약에서 벗어남</li>\n</ul>\n</li>\n<li>어떤 페이지가 메모리에 존재하고 어떤 페이지가 메모리에 존재하지 않은지 구별이 필요하다.\n<ul>\n<li>유효-무효 비트 (valid-invalid bit)를 두어 각 페이지가 메모리에 존재하는지 표시한다.</li>\n<li>페이지 테이블의 각 엔트리에 저장된다.</li>\n<li>프로세스 시작 전 모든 페이지의 유효-무효 비트는 무효값이다.</li>\n<li>특정 페이지가 참조되면 유효값으로 바뀌고 스왑 영역으로 쫓겨나면 다시 무효값이 된다.</li>\n</ul>\n</li>\n<li>유효-무효 비트는 페이지가 속한 영역을 프로세스가 사용하지 않는 경우도 표시한다.</li>\n<li>CPU 참조 페이지가 메모리에 올라와 있지 않아서 무효값인 경우를 페이지 부재 page fault 라고 한다.</li>\n</ul>\n<h3 id=\"1-요구-페이징의-페이지-부재-처리\" style=\"position:relative;\"><a href=\"#1-%EC%9A%94%EA%B5%AC-%ED%8E%98%EC%9D%B4%EC%A7%95%EC%9D%98-%ED%8E%98%EC%9D%B4%EC%A7%80-%EB%B6%80%EC%9E%AC-%EC%B2%98%EB%A6%AC\" aria-label=\"1 요구 페이징의 페이지 부재 처리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1) 요구 페이징의 페이지 부재 처리</h3>\n<ul>\n<li>CPU가 무효 페이지에 접근하면 주소 변환 담당 하드웨어 MMU가 페이지 부재 트랩 page fault trap을 발생시킨다.</li>\n<li>제어권이 커널모드로 전환되어 운영체제의 페이지 부재 처리루틴 page fulat handler가 호출되어 다음 순서로 페이지 부재를 처리한다.\n<ol>\n<li>해당 페이지에 대한 접근이 적법한지 체크\n<ul>\n<li>사용되지 않는 주소 영역이거나 해당 페이지에 대한 접근 권한을 위반 protection violation한 경우 해당 프로세스를 종료</li>\n</ul>\n</li>\n<li>적법하다면 물리 메모리의 비어있는 프레임 frame을 할당받아 그 공간에 해당 페이지를 읽는다.\n<ul>\n<li>비어있는 프레임이 없다면 기존에 메모리에 올라와 있는 페이지 중 하나를 디스크로 쫓아낸다. (스왑 아웃)</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>페이지 부재로 페이지를 메모리에 적재하기까지 오랜 시간이 걸리기 때문에 페이지 부재 프로세스는 봉쇄 상태가 된다. (CPU 제어권이 없어진다)\n<ul>\n<li>CPU 레지스터 상태 및 카운터값을 PCB에 저장한다.</li>\n</ul>\n</li>\n<li>디스크 입출력이 완료되고 인터럽트가 발생하면 페이지 테이블의 페이지 유효-무효 비트를 유효로 설정하고 봉쇄 상태 프로세스를 준비큐로 옮긴다.</li>\n</ul>\n<h3 id=\"2-요구-페이징의-성능\" style=\"position:relative;\"><a href=\"#2-%EC%9A%94%EA%B5%AC-%ED%8E%98%EC%9D%B4%EC%A7%95%EC%9D%98-%EC%84%B1%EB%8A%A5\" aria-label=\"2 요구 페이징의 성능 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2) 요구 페이징의 성능</h3>\n<ul>\n<li><strong>페이지 부재의 발생 빈도</strong>로 성능에 가장 큰 영향을 미친다.</li>\n<li>페이지가 메모리에 있다면 메모리 접근 시간만 걸리지만 페이지 부재가 일어나면 많은 오버헤드가 동반된다.\n<ul>\n<li>페이지 부재 발생 처리 오버헤드</li>\n<li>스왑 아웃 오버헤드</li>\n<li>수왑 인 오버헤드</li>\n<li>프로세스 재시작 오버헤드</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-2-페이지-교체\" style=\"position:relative;\"><a href=\"#-2-%ED%8E%98%EC%9D%B4%EC%A7%80-%EA%B5%90%EC%B2%B4\" aria-label=\" 2 페이지 교체 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 2. 페이지 교체</h2>\n<ul>\n<li>물리 메모리에 빈 프레임이 존재하지 않는다면 올라와 있는 페이를 스왑 아웃 시켜야하는데 그것을 페이지 교체라고 한다. page replacement</li>\n<li>어떤 페이지를 쫓아낼 것인지 교체 알고리즘 replacement algorithm으로 결정한다.\n<ul>\n<li>페이지 부재를 최소화 하는 것이 알고리즘의 목표이다.</li>\n</ul>\n</li>\n<li>페이지 교체 알고리즘은 페이지 참조열 page reference string에 대한 페이지 부재율을 계산하여 평가한다.</li>\n<li>페이지가 이미 메모리에 올라와 있으면 hit 아니면 페이지 부재이다.</li>\n</ul>\n<h3 id=\"1-최적-페이지-교체\" style=\"position:relative;\"><a href=\"#1-%EC%B5%9C%EC%A0%81-%ED%8E%98%EC%9D%B4%EC%A7%80-%EA%B5%90%EC%B2%B4\" aria-label=\"1 최적 페이지 교체 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1) 최적 페이지 교체</h3>\n<ul>\n<li>가장 먼 미래에 참조될 페이지를 쫓아내는 방법이다.</li>\n<li>빌레디 최적 알고리즘, MIN, OPT, Belady’s optimal algorithm 라고 부른다.</li>\n<li>미래에 어떤 페이지가 어떤 순서로 참조될지 미라 알고 있는 전제로 알고리즘을 운영하므로 실제 시스템에서 사용할 수 있는 알고리즘은 아니다. ⇒ 오프라인 알고리즘</li>\n<li>빌레디 최적 알고리즘은 실제 시스템에 활용되기 보다 다른 알고리즘의 성능의 상한선을 제공한다.</li>\n</ul>\n<h3 id=\"2-선입선출-알고리즘-fifo\" style=\"position:relative;\"><a href=\"#2-%EC%84%A0%EC%9E%85%EC%84%A0%EC%B6%9C-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-fifo\" aria-label=\"2 선입선출 알고리즘 fifo permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2) 선입선출 알고리즘 FIFO</h3>\n<ul>\n<li>페이지 교체 시 물리 메모리에 가장 먼저 올라온 페이지를 우선 내쫓는다.</li>\n<li>비효율적인 상황이 발생할 가능성이 있다. 물리 메모리 공간이 늘어나도 페이지 참조 순서에 따라서 성능이 더 나빠질 수도 있다.</li>\n<li>FIFO에서 물리 메모리 영역에 올라갔는데도 페이지 부재가 늘어난 상황을 FIFO 이상 현상 (FIFO anomaly)라고 한다.</li>\n</ul>\n<h3 id=\"3-lru-least-recently-used\" style=\"position:relative;\"><a href=\"#3-lru-least-recently-used\" aria-label=\"3 lru least recently used permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3) LRU Least Recently Used</h3>\n<ul>\n<li>메모리 참조 성향 중 시간지역성 (temporal locality) 라는 것이 있다.\n<ul>\n<li>최근 참조된 페이지가 가까운 미래에 다시 참조될 가능성이 높은 성질이다.</li>\n</ul>\n</li>\n<li>위 성질을 이용하여 페이지 교체 시 가장 오래전에 참조한 페이지를 쫓아낸다.</li>\n</ul>\n<h3 id=\"4-lfu-least-frequently-used\" style=\"position:relative;\"><a href=\"#4-lfu-least-frequently-used\" aria-label=\"4 lfu least frequently used permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4) LFU Least Frequently Used</h3>\n<ul>\n<li>페이지 참조 횟수로 교체 페이지를 결정한다.</li>\n<li>과거에 참조 횟수 reference count가 가장 적었던 페이지를 교체하도록 한다.</li>\n<li>여러개의 페이지가 후보라면 그 중 하나를 임의로 선정하며 주로 상대적으로 오래 전에 참조된 페이지를 스왑 아웃한다.</li>\n<li>LFU의 페이지 참조 횟수 계산 방식\n<ol>\n<li>Incache-LFU\n<ul>\n<li>페이지가 물리 메모리에 올라온 후부터 참조 횟수를 카운트 한다.</li>\n<li>메모리에서 쫓겨났다가 다시 올라오면 참조 횟수를 1부터 시작한다.</li>\n</ul>\n</li>\n<li>Perfect-LFU\n<ul>\n<li>그 페이지의 과거 참조 횟수를 모두 카운ㅌ한다.</li>\n<li>정확하나 메모리에서 쫓겨난 페이지 참조 기록까지 보관해야하는 오버헤드가 있다.</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>LFU는 LRU 보다 오랜 시간 동안의 참조 기록을 반영하고 장기적 시간 규모의 참조 성향을 고려한다.</li>\n<li>하지만 LFU는 시간에 따른 페이지 참조 변화를 반영하지 못하며 구현이 LRU보다 복잡하다.</li>\n</ul>\n<h3 id=\"5-클럭-알고리즘\" style=\"position:relative;\"><a href=\"#5-%ED%81%B4%EB%9F%AD-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" aria-label=\"5 클럭 알고리즘 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5) 클럭 알고리즘</h3>\n<ul>\n<li>LRU, LFU 는 참조 시각, 참조 횟수를 소프트웨어적으로 유지하고 비교하므로 알고리즘 운영 비용이 발생한다.</li>\n<li>클럭 알고리즘은 하드웨어의 지원으로 알고리즘의 운영 오버헤드를 줄인 것이다.</li>\n<li>클럭 알고리즘은 LRU를 근사시킨 알고리즘으로 NUR Not Used Recently 또는 NRU Not recently Used 라고 불린다.</li>\n<li>오래전에 참조된 페이지 중 하나를 교체하는데 가장 오래된 것은 보장할 수 없다.</li>\n<li>하드웨어의 지원이 있기 때문에 LRU에 비해 페이지 관리가 빠르고 효율적이다.\n<ul>\n<li>대부분이 클럭 알고리즘으로 페이지 교체 알고리즘을 사용한다.</li>\n</ul>\n</li>\n<li>클럭알고리즘은 페이지 프레임의 참조비트를 순차적으로 조사한다.\n<ul>\n<li>참조비트는 각 프레임에 존재하며 해당 프레임의 페이지가 참조될 때 하드웨어로 1로 자동 세팅된다.</li>\n</ul>\n</li>\n<li>클럭 알고리즘은 참조비트가 1인 페이지를 0으로 바꾸고 지나간다. 참조비트가 0인 페이지는 교체한다.\n<ul>\n<li>즉, 시간을 한바퀴 돌 동안 참조되지 않은 페이지들을 교체하는 것이다.</li>\n</ul>\n</li>\n<li>특정 클럭 주기동안 참조된 페이지를 메모리에 유지시켜둠으로 페이지 부재를 줄이기 때문에 2차 기회 알고리즘 second chance algorithm이라고 하기도 한다.</li>\n</ul>\n<br>\n<h2 id=\"-3-페이지-프레임의-할당\" style=\"position:relative;\"><a href=\"#-3-%ED%8E%98%EC%9D%B4%EC%A7%80-%ED%94%84%EB%A0%88%EC%9E%84%EC%9D%98-%ED%95%A0%EB%8B%B9\" aria-label=\" 3 페이지 프레임의 할당 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 3. 페이지 프레임의 할당</h2>\n<ul>\n<li>어느 프로세스에게  얼만큼의 페이지 프레임을 할당할지 결정한다.</li>\n<li>기본적인 할당 알고리즘 allocation algorithm은 다음 3가지 이다.\n<ol>\n<li>균등할당 equal allocation - 모든 프로세스에게 페이지 프레임을 균일하게 할당</li>\n<li>비례할당 proportional allocation - 프로세스의 크기에 비례해 프레임 할당</li>\n<li>우선순위 할당 priority allocation - 프로세스의 우선순위에 따라 프레임 할당\n<ul>\n<li>당장 CPU에서 실행될 프로세스에게 더 많은 페이지 프레임을 할당</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>하지만 할당 알고리즘으로 프로세스 페이지 참조 특성을 제대로 반영하지 못할 수도 있다.\n<ul>\n<li>현재 수행중인 프로세스가 지나치게 많으면 프로세스당 할당되는 메모리가 과도하게 적다.</li>\n<li>프로세스를 정상적으로 수행하려면 일정 수준 이상의 페이지 프레임을 각 프로세스에게 할당해야한다. (여러 프레임을 동시에 참조하기 때문이다. 코드, 데이터 영역 등등)</li>\n<li>반복문인 경우 관련 페이지를 한꺼번에 올리는 것이 성능에 좋다.</li>\n</ul>\n</li>\n<li>종합적으로 각 프로세스의 프레임 수를 결정할 필요가 있다.</li>\n</ul>\n<br>\n<h2 id=\"-4-전역교체와-지역교체\" style=\"position:relative;\"><a href=\"#-4-%EC%A0%84%EC%97%AD%EA%B5%90%EC%B2%B4%EC%99%80-%EC%A7%80%EC%97%AD%EA%B5%90%EC%B2%B4\" aria-label=\" 4 전역교체와 지역교체 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 4. 전역교체와 지역교체</h2>\n<ul>\n<li>교체 페이지를 결정할 때 교체 대상 프레임의 범위에 따라서 교체 방법을 전역교체 global replacement, 지역교체  local replacement로 구분한다.</li>\n<li>전역 교체 - 모든 페이지 프레임이 교체 대상\n<ul>\n<li>다른 프로세스에게 할당된 프레임도 빼앗을 수 있다.</li>\n<li>프로세스별 프레임 할당량이 조절될 수 있다.</li>\n</ul>\n</li>\n<li>지역 교체 - 현재 수행 중인 프로세스에게 할당된 프레임 내에서만 교체 대상을 선정\n<ul>\n<li>지역 교체는 프로세스마다 프레임을 미리 할당한다.</li>\n<li>LRU, LFU 알고리즘을 프로세스별로 독자적 운영하면 지역교체가 된다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-5-스레싱-thrashing\" style=\"position:relative;\"><a href=\"#-5-%EC%8A%A4%EB%A0%88%EC%8B%B1-thrashing\" aria-label=\" 5 스레싱 thrashing permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 5. 스레싱 thrashing</h2>\n<ul>\n<li>프로세스가 원활하게 수행되기 위해서는 일정 수준 이상의 페이지 프레임을 할당받아야한다.\n<ul>\n<li>집중적으로 참조되는 페이지를 한꺼번에 적재하지 않으면 페이지 부재율이 높아진다.</li>\n<li>입출력이 많아지므로 CPU 이용률이 떨어진다.</li>\n<li>위 현상을 스레싱이라고 한다.</li>\n</ul>\n</li>\n<li>운영체제는 CPU 이용률이 낮다는 것은 메모리에 올라온 프로세스의 수가 적기 때문이라고 판단한다. 따라서 CPU 이용률이 떨어지면 운영체제는 메모리에 올라와 있는 프로세스 수를 늘린다.</li>\n<li>다중 프로그래밍의 정도 Multi-programming Degree MPD 라고 부른다.\n<ul>\n<li>CPU 이용률이 낮으면 운영체제는 MPD를 높인다.</li>\n</ul>\n</li>\n<li>과도하게 MPD가 높아지면 각 프로세스에게 할당되는 메모리가 줄어들고 필요한 최소한 프레임 할당이 어렵다.</li>\n<li>따라서 페이지 부재가 더 빈번하게 발생하게 되고 디스크 I/O 작업이 많이 일어나며서 문맥교환으로 다른 프로세스에게 CPU를 넘긴다.</li>\n<li>반복되면서 CPU는 문맥교환과 페이지 부재 처리를 하느라 바빠지고 CPU이용률이 떨어지게 된다.\n<ul>\n<li>그러면 또 운영체제는 메모리에 프로세스를 더욱 올려 상황을 악화시킨다.</li>\n</ul>\n</li>\n<li>이것을 방지하기 위해 MPD를 조절하는 알고리즘으로 <strong>1) 워킹셋 알고리즘 2) 페이지 부재 빈도 알고리즘</strong>이 있다.</li>\n</ul>\n<h3 id=\"1-워킹셋-알고리즘-working-set-algorithm\" style=\"position:relative;\"><a href=\"#1-%EC%9B%8C%ED%82%B9%EC%85%8B-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-working-set-algorithm\" aria-label=\"1 워킹셋 알고리즘 working set algorithm permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1) 워킹셋 알고리즘 working-set algorithm</h3>\n<ul>\n<li>지역성 집합 locality set: 프로세스가 특정 주소 영역을 집중적으로 참조하는 경향</li>\n<li>워킹셋 알고리즘은 이런 지역성 집합이 메모리에 동시에 올라갈 수 있도록 보장해주는 메모리 관리 알고리즘이다.</li>\n<li>한꺼번에 메모리에 올라와야하는 페이지 집합을 working set으로 정의하여 한꺼번에 메모리에 올라갈 수 있을 때만 메모리를 할당한다.\n<ul>\n<li>그렇지 않다면 프로세스에 할당된 페이지 프레임을 모두 반납시키고 프로세스 전체를 스왑아웃시킨다.</li>\n</ul>\n</li>\n<li>다중 프로그래밍의 정도를 조절하고 스레싱을 방지한다.</li>\n<li>구현 방법\n<ul>\n<li>한꺼번에 올라갈 워킹셋을 정의하기 위해 워킹셋 윈도우 working-set window를 사용한다.</li>\n<li>워킹셋 윈도우는 특정 시간동안 참조된 페이지의 중복제거된 집합이다. 그 시간 이후 워킹셋에 포함된 페이지만 메모리에 유지되고 아닌 페이지는 메모리에서 쫓겨난다.</li>\n<li>워킹셋의 크기의 합이 프레임의 수보다 크면 일부 프로세스를 스왑 아웃 시켜 프레임에 워킹셋이 모두 올라갈 수 있도록 보장한다.\n<ul>\n<li>MPD 를 줄인다.</li>\n</ul>\n</li>\n<li>만일 프레임이 남으면 스왑 아웃 프로세스를 다시 메모리에 올려 워킹셋을 할당한다.\n<ul>\n<li>MPD를 증가시킨다.</li>\n</ul>\n</li>\n<li>윈도우 크기의 결정이 중요하다.\n<ul>\n<li>너무 작으면 지역성 집합 수용이 어렵댜.</li>\n<li>크면 MPD가 감소하여 CPU 이용률이 낮아질 수 잇다.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-페이지-부재-빈도-알고리즘-pff-page-fault-frequency\" style=\"position:relative;\"><a href=\"#2-%ED%8E%98%EC%9D%B4%EC%A7%80-%EB%B6%80%EC%9E%AC-%EB%B9%88%EB%8F%84-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-pff-page-fault-frequency\" aria-label=\"2 페이지 부재 빈도 알고리즘 pff page fault frequency permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2) 페이지 부재 빈도 알고리즘 PFF page fault frequency</h3>\n<ul>\n<li>프로세스의 페이지 부재율을 주기적으로 조사하여 근거해 프로세스 할당 메모리를 동적으로 조절한다.</li>\n<li>어떤 프로세스의 페이지 부재율이 시스템의 상한값을 넘으면 이 프로세스에게 할당된 프레임 수가 부족하다고 판단한다.\n<ul>\n<li>프레임을 추가로 할당한다.</li>\n</ul>\n</li>\n<li>추가로 할당할 프레임이 없으면 일부 프로세스를 스왑 아웃시켜 프로세스의 수를 조절한다.</li>\n<li>부재율이 하한값 이하로 떨어지면 지나치게 많은 프레임을 할당받은 것으로 간주하고 할당 프레임 수를 줄인다.</li>\n<li>이렇게 다 조절 후 프레임이 남으면 스왑 아웃 프로세스에게 프레임을 할당한다.\n<ul>\n<li>MPD 증가</li>\n</ul>\n</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#-%EB%93%A4%EC%96%B4%EA%B0%80%EA%B8%B0-%EC%A0%84\">🌩 들어가기 전</a></p>\n</li>\n<li>\n<p><a href=\"#-1-%EC%9A%94%EA%B5%AC-%ED%8E%98%EC%9D%B4%EC%A7%95\">🌩 1. 요구 페이징</a></p>\n<ul>\n<li><a href=\"#1-%EC%9A%94%EA%B5%AC-%ED%8E%98%EC%9D%B4%EC%A7%95%EC%9D%98-%ED%8E%98%EC%9D%B4%EC%A7%80-%EB%B6%80%EC%9E%AC-%EC%B2%98%EB%A6%AC\">1) 요구 페이징의 페이지 부재 처리</a></li>\n<li><a href=\"#2-%EC%9A%94%EA%B5%AC-%ED%8E%98%EC%9D%B4%EC%A7%95%EC%9D%98-%EC%84%B1%EB%8A%A5\">2) 요구 페이징의 성능</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-2-%ED%8E%98%EC%9D%B4%EC%A7%80-%EA%B5%90%EC%B2%B4\">🌩 2. 페이지 교체</a></p>\n<ul>\n<li><a href=\"#1-%EC%B5%9C%EC%A0%81-%ED%8E%98%EC%9D%B4%EC%A7%80-%EA%B5%90%EC%B2%B4\">1) 최적 페이지 교체</a></li>\n<li><a href=\"#2-%EC%84%A0%EC%9E%85%EC%84%A0%EC%B6%9C-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-fifo\">2) 선입선출 알고리즘 FIFO</a></li>\n<li><a href=\"#3-lru-least-recently-used\">3) LRU Least Recently Used</a></li>\n<li><a href=\"#4-lfu-least-frequently-used\">4) LFU Least Frequently Used</a></li>\n<li><a href=\"#5-%ED%81%B4%EB%9F%AD-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\">5) 클럭 알고리즘</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-3-%ED%8E%98%EC%9D%B4%EC%A7%80-%ED%94%84%EB%A0%88%EC%9E%84%EC%9D%98-%ED%95%A0%EB%8B%B9\">🌩 3. 페이지 프레임의 할당</a></p>\n</li>\n<li>\n<p><a href=\"#-4-%EC%A0%84%EC%97%AD%EA%B5%90%EC%B2%B4%EC%99%80-%EC%A7%80%EC%97%AD%EA%B5%90%EC%B2%B4\">🌩 4. 전역교체와 지역교체</a></p>\n</li>\n<li>\n<p><a href=\"#-5-%EC%8A%A4%EB%A0%88%EC%8B%B1-thrashing\">🌩 5. 스레싱 thrashing</a></p>\n<ul>\n<li><a href=\"#1-%EC%9B%8C%ED%82%B9%EC%85%8B-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-working-set-algorithm\">1) 워킹셋 알고리즘 working-set algorithm</a></li>\n<li><a href=\"#2-%ED%8E%98%EC%9D%B4%EC%A7%80-%EB%B6%80%EC%9E%AC-%EB%B9%88%EB%8F%84-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-pff-page-fault-frequency\">2) 페이지 부재 빈도 알고리즘 PFF page fault frequency</a></li>\n</ul>\n</li>\n</ul>\n</div>","frontmatter":{"date":"October 17, 2021","title":"운영체제와 정보기술의 원리 - CH8. 가상 메모리","categories":"운영체제 책","author":"코다","emoji":"🧁"},"fields":{"slug":"/operating-system-7/"}},"site":{"siteMetadata":{"siteUrl":"https://yjksw.github.io","comments":{"utterances":{"repo":"yjksw/yjksw.github.io"}}}}},"pageContext":{"slug":"/operating-system-6/","nextSlug":"/netflix-performance-analysis/","prevSlug":"/operating-system-7/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}
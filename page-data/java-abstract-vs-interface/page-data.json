{"componentChunkName":"component---src-templates-blog-template-js","path":"/java-abstract-vs-interface/","result":{"data":{"cur":{"id":"0f7262a6-8cc3-5ad6-a8f8-5c468e91c6c6","html":"<h2 id=\"-intro\" style=\"position:relative;\"><a href=\"#-intro\" aria-label=\" intro permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>💡 Intro</h2>\n<ul>\n<li>인터페이스와 추상클래스의 차이를 명확하게 구분해보자.</li>\n<li>언제 무엇을 쓰는 것이 좋은지 나름의 정의를 내려본다.</li>\n<li>상속의 위험성에 대해서 고민해본다.</li>\n</ul>\n<br>\n<h2 id=\"-추상클래스\" style=\"position:relative;\"><a href=\"#-%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4\" aria-label=\" 추상클래스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 추상클래스</h2>\n<ul>\n<li>추상 클래스는 “미완성 설계도” 이다.</li>\n<li>\n<p>공통부분을 우선 정의한 미완성 설계도를 만들고 각기 다른 상황에 대해서 추가로 구현할 수 있다.</p>\n<ul>\n<li>완성되지 않은 abstract 메소드를 포함하고 있다.</li>\n</ul>\n</li>\n<li>추상클래스는 abstract 메소드가 있다는 것을 제외하고는 일반클래스와 동일하다.</li>\n<li><strong>상속은 자손 클래스를 만드는데 조상 클래스를 사용하는 것</strong></li>\n<li><strong>추상화는 자손 클래스의 공통부분을 뽑아내서 조상 클래스를 만드는 것</strong></li>\n</ul>\n<h3 id=\"상속\" style=\"position:relative;\"><a href=\"#%EC%83%81%EC%86%8D\" aria-label=\"상속 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>상속</h3>\n<ul>\n<li>추상클래스를 <code class=\"language-text\">extends</code> 하는 명령어가 상속에서 사용되기 때문에 두 개념이 혼용되어서 사용되기도 한다. 엄밀히 말하면 두 개념이 겹칠수도 있지만 완전히 동일한 것은 아니다.</li>\n<li>\n<p>상속이란 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것</p>\n<ul>\n<li>적은 양의 코드로 새로운 클래스를 작성할 수 있고 공통부분을 관리할 수 있다는 장점이 있다.</li>\n</ul>\n</li>\n<li><strong>상속은 is-a 관계로 표현될 수 있다.</strong></li>\n<li><code class=\"language-text\">**final</code>로 정의된 클래스가 아니라면 모두 상속이 가능하다. 추상클래스는 그 일부분이다.**</li>\n<li>\n<p>상속을 할 때 주의할 점 ‼️</p>\n<ul>\n<li>상속은 조상 클래스의 캡슐화가 깨지는 위험이 있다.</li>\n<li>또한 조상 클래스와 자손 클래스간의 강한 결합이기 때문에 조상 클래스 메서드에 변화가 생기면 자손 클래스에 아무런 변화가 없음에도 다르게 동작할 수 있다.</li>\n<li>따라서 상속보다는 <strong>조합</strong>을 사용하도록 추천한다. (Deck는 Card를 가지고 있다 와 같은 경우에 조합 사용 has-a 관계)</li>\n<li>\n<p>일반 클래스는 <code class=\"language-text\">final</code>을 추가하여 상속을 막거나 미완성 설계도인 abstract 클래스를 정의하도록 추천한다.</p>\n<ul>\n<li>또한 추상클래스의 부모 메소드를 수정하지 않는 것이 좋다.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"왜-자바는-단일-상속일까-single-inheritance\" style=\"position:relative;\"><a href=\"#%EC%99%9C-%EC%9E%90%EB%B0%94%EB%8A%94-%EB%8B%A8%EC%9D%BC-%EC%83%81%EC%86%8D%EC%9D%BC%EA%B9%8C-single-inheritance\" aria-label=\"왜 자바는 단일 상속일까 single inheritance permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>왜 자바는 단일 상속일까? (single inheritance)</h3>\n<ul>\n<li>다중상속을 하게 되면 복합적인 기능을 가진 클래스를 손쉽게 구현할 수 있지만 클래스 간 관계가 굉장히 복잡해진다.</li>\n<li>여러 다른 클래스로 상속받은 멤버의 이름이나 메서드가 같은 경우 구별도 어렵다.</li>\n</ul>\n<br>\n<h2 id=\"-인터페이스\" style=\"position:relative;\"><a href=\"#-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4\" aria-label=\" 인터페이스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 인터페이스</h2>\n<ul>\n<li>인터페이스는 “기본 설계도”이다. (추상클래스는 “미완성 설계도”)</li>\n<li>인터페이스는 면대면이 만나는 부분이라는 뜻을 가지고 있으며 2개의 구성요소가 상호작용할 수 있도록 접속 경계를 연결하는 부분이다. (플러그와 같은 역할)</li>\n<li>인터페이스끼리 상속받을 수 있으며 다중상속이 가능하다.</li>\n<li>인터페이스는 <code class=\"language-text\">implements</code> 를 사용해서 구현하며 다중구현이 가능하다.</li>\n<li>\n<p>인터페이스는 구현 메서드나 멤버 필드가 없다.</p>\n<ul>\n<li>default 메서드가 가능하도록 jdk1.8부터 추가가 되었고, static 변수만 가능하다.</li>\n</ul>\n</li>\n<li>인터페이스는 해당 인터페이스를 구현하는 모든 클래스가 특정 메소드를 반드시 구현하도록 강제하는 역할을 한다 → 따라서 명세의 역할을 한다고도 한다.</li>\n</ul>\n<h3 id=\"추상클래스와의-차이점\" style=\"position:relative;\"><a href=\"#%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90\" aria-label=\"추상클래스와의 차이점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>추상클래스와의 차이점</h3>\n<ul>\n<li>우선 구현메서드 존재 여부, 필드 존재 여부, 다중 상속 및 구현에 대한 차이점이 존재한다</li>\n<li>추상클래스는 공통기능에 대한 재사용과 정제의 역할을 한다. (정제란 불완전한 행동을 완전하게 만드는 것을 의미)</li>\n<li>인터페이스는 구현체가 특정 메소드가 반드시 존재하도록 하는 역할을 하여 특정 기능을 반드시 제공한다는 것을 보장하는 역할을 한다.</li>\n</ul>\n<h3 id=\"동일-메서드를-가진-인터페이스\" style=\"position:relative;\"><a href=\"#%EB%8F%99%EC%9D%BC-%EB%A9%94%EC%84%9C%EB%93%9C%EB%A5%BC-%EA%B0%80%EC%A7%84-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4\" aria-label=\"동일 메서드를 가진 인터페이스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>동일 메서드를 가진 인터페이스</h3>\n<ul>\n<li>\n<p>동일한 메서드 명과 시그니처를 가진 메서드가 두 개의 인터페이스에 있을때는 어떻게 할까?</p>\n<ul>\n<li>이때는 컴파일 오류로 충돌을 해결해야만 컴파일이 가능하다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-느낀-점\" style=\"position:relative;\"><a href=\"#-%EB%8A%90%EB%82%80-%EC%A0%90\" aria-label=\" 느낀 점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🛋 느낀 점</h2>\n<ul>\n<li>\n<p>추상클래스와 인터페이스는 역할 자체가 다르다.</p>\n<ul>\n<li>추상 클래스는 정제의 역할을 인터페이스는 기능 구현 강제의 역할을 한다.</li>\n<li>인터페이스를 통해서는 중복을 해결할 수 없다. 어떤 두 요소가 연결되기 위해 사전에 정의한 기능들이 모두 구현이 된다는 것을 보장할 뿐이다.</li>\n<li>상속은 부모 클래스의 캡슐화가 깨지기 때문에 조합을 이용하는 것이 더 적절하다.</li>\n</ul>\n</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#-intro\">💡 Intro</a></li>\n<li>\n<p><a href=\"#-%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4\">🌩 추상클래스</a></p>\n<ul>\n<li><a href=\"#%EC%83%81%EC%86%8D\">상속</a></li>\n<li><a href=\"#%EC%99%9C-%EC%9E%90%EB%B0%94%EB%8A%94-%EB%8B%A8%EC%9D%BC-%EC%83%81%EC%86%8D%EC%9D%BC%EA%B9%8C-single-inheritance\">왜 자바는 단일 상속일까? (single inheritance)</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4\">🌩 인터페이스</a></p>\n<ul>\n<li><a href=\"#%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90\">추상클래스와의 차이점</a></li>\n<li><a href=\"#%EB%8F%99%EC%9D%BC-%EB%A9%94%EC%84%9C%EB%93%9C%EB%A5%BC-%EA%B0%80%EC%A7%84-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4\">동일 메서드를 가진 인터페이스</a></li>\n</ul>\n</li>\n<li><a href=\"#-%EB%8A%90%EB%82%80-%EC%A0%90\">🛋 느낀 점</a></li>\n</ul>\n</div>","excerpt":"💡 Intro 인터페이스와 추상클래스의 차이를 명확하게 구분해보자. 언제 무엇을 쓰는 것이 좋은지 나름의 정의를 내려본다. 상속의 위험성에 대해서 고민해본다. 🌩 추상클래스 추상 클래스는 “미완성 설계도” 이다. 공통부분을 우선 정의한 미완성 설계도를 만들고 각기 다른 상황에 대해서 추가로 구현할 수 있다. 완성되지 않은 abstract 메소드를 포함하고 있다. 추상클래스는 abstract 메소드가 있다는 것을 제외하고는 일반클래스와 동일하다. 상속은 자손 클래스를 만드는데 조상 클래스를 사용하는 것 추상화는 자손 클래스의 공통부분을 뽑아내서 조상 클래스를 만드는 것 상속 추상클래스를  하는 명령어가 상속에서 사용되기 때문에 두 개념이 혼용되어서 사용되기도 한다. 엄밀히 말하면 두 개념이 겹칠수도 있지만 완전히 동일한 것은 아니다. 상속이란 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것 적은 양의 코드로 새로운 클래스를 작성할 수 있고 공통부분을 관리할 수 있다는 장점이 …","frontmatter":{"date":"November 15, 2021","title":"추상클래스와 인터페이스 더 이상 헷갈리지 않기","categories":"자바","author":"코다","emoji":"✊"},"fields":{"slug":"/java-abstract-vs-interface/"}},"next":{"id":"1549b4b9-74b3-5275-b573-eb2609ad7eff","html":"<h2 id=\"-intro\" style=\"position:relative;\"><a href=\"#-intro\" aria-label=\" intro permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>💡 Intro</h2>\n<ul>\n<li>효율적인 프로그래밍을 위해 멀티 스레드 환경에서 구동을 할 때가 많다.</li>\n<li>멀티 스레드의 간단한 장점과 항상 헷갈렸던 사용자 레벨 스레드 vs. 커널 레벨 스레드에 대해서 알아보자.</li>\n</ul>\n<br>\n<h2 id=\"-multi-thread-장점\" style=\"position:relative;\"><a href=\"#-multi-thread-%EC%9E%A5%EC%A0%90\" aria-label=\" multi thread 장점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 Multi-thread 장점</h2>\n<h3 id=\"1-응답성\" style=\"position:relative;\"><a href=\"#1-%EC%9D%91%EB%8B%B5%EC%84%B1\" aria-label=\"1 응답성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 응답성</h3>\n<ul>\n<li>어플리케이션의 일부분이 봉쇄되거나 긴 작업을 실행하더라도 다른 부분의 프로그램이 계속 실행되는 것을 허용하기 때문에 사용자의 입장에서 응답성이 증가한다.</li>\n<li>예를 들어 다운로드가 오래 걸리는 파일을 다운로드 하면서 사용자와의 상호작용이 가능하다.</li>\n</ul>\n<h3 id=\"2-자원-공유-resource-sharing\" style=\"position:relative;\"><a href=\"#2-%EC%9E%90%EC%9B%90-%EA%B3%B5%EC%9C%A0-resource-sharing\" aria-label=\"2 자원 공유 resource sharing permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 자원 공유 resource sharing</h3>\n<ul>\n<li>프로세스는 완전히 별도의 메모리 공간을 할당받기 때문에 (code, data, heap) 서로 통신하기 위해서는 공유 메모리를 사용하거나 메세지 전달 기법 (IPC)를 사용해야한다.</li>\n<li>스레드는 속한 프로세스의 자원을 공유하기 때문에 한 프로그램이 <strong>같은 주소 내에서 여러개의 다른 작업을 하는 단위</strong>로 나뉘어질 수 있다는 이점이 있다.</li>\n</ul>\n<h3 id=\"3-경제성-economy\" style=\"position:relative;\"><a href=\"#3-%EA%B2%BD%EC%A0%9C%EC%84%B1-economy\" aria-label=\"3 경제성 economy permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 경제성 economy</h3>\n<ul>\n<li>프로세스의 자원을 공유하므로 메모리 측면과 문맥교환 오버헤드 측면에서 경제적이다.</li>\n</ul>\n<h3 id=\"4-규모-가변성-scalability\" style=\"position:relative;\"><a href=\"#4-%EA%B7%9C%EB%AA%A8-%EA%B0%80%EB%B3%80%EC%84%B1-scalability\" aria-label=\"4 규모 가변성 scalability permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. 규모 가변성 scalability</h3>\n<ul>\n<li>멀티코어 환경에서 각각의 스레드가 다른 코어에서 병렬로 실행될 수 있기 때문에 이점이 증가한다.</li>\n<li>단일 스레드라면 코어의 개수와 상관없이 한번에 한 개의 처리기에서만 실행되지만 멀티코어에 멀티스레드라면 병렬성을 증가시킨다.</li>\n</ul>\n<br>\n<h2 id=\"-multi-thread-모델\" style=\"position:relative;\"><a href=\"#-multi-thread-%EB%AA%A8%EB%8D%B8\" aria-label=\" multi thread 모델 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 Multi-thread 모델</h2>\n<ul>\n<li>\n<p>스레드는 사용자 스레드와 커널 스레드로 나뉜다.</p>\n<ul>\n<li>사용자 스레드는 사용자 수준에서 관리되며 os가 관여하지 않는다.</li>\n<li>사용자 수준의 라이브러리를 사용하여 생성되고 커널의 개입을 받지 않는다.</li>\n<li>커널 스레드는 os에 의해 직접 지원되고 관리된다.</li>\n</ul>\n</li>\n<li>다양한 Mutli-thread 모델이 있는 이유는 스레드가 작업을 처리하기 위해서는 CPU를 점유해야하기 때문에 궁극적으로는 사용자 스레드와 커널 스레드간의 어떠한 연관관계가 존재해야 하기 때문이다.</li>\n</ul>\n<h3 id=\"모델-3가지\" style=\"position:relative;\"><a href=\"#%EB%AA%A8%EB%8D%B8-3%EA%B0%80%EC%A7%80\" aria-label=\"모델 3가지 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>모델 3가지</h3>\n<ul>\n<li>\n<p>다대일 모델</p>\n<ul>\n<li>여러 사용자 스레드를 하나의 커널 스레드에 사상하며 스레드 관리는 사용자 레벨의 스레드 라이브러리가 수행한다.</li>\n<li>한 스레드가 봉쇄 상태에 들어가면 커널 스레드가 함께 봉쇄 상태에 들어가게 되므로 모두 봉쇄된다.</li>\n<li>한번에 하나의 스레드만 커널에 접근이 가능하기 때문에 멀티코어 환경에서 병렬로 실행될 수 없다.</li>\n</ul>\n</li>\n<li>\n<p>일대일 모델</p>\n<ul>\n<li>하나의 사용자 스레드를 각각 하나의 커널 스레드로 사상한다.</li>\n<li>하나의 스레드가 봉쇄상태에 들어가더라도 다른 스레드가 커널 스레드와 매핑되어 작업을 처리할 수 있으므로 멀티코어 환경에서 더 병렬성을 제공한다.</li>\n<li>사용자 레벨에서 스레드를 하나 생성할 때 커널의 스레도 생성해야 하기 대문에 오버헤드가 발생한다. 따라서 이 모델을 사용할 경우 대부분 시스템에 의해 지원되는 스레드 개수를 제한한다.</li>\n<li>Linux가 대표적인 일대일 모델을 사용하는 os이다.</li>\n</ul>\n</li>\n<li>\n<p>다대다 모델</p>\n<ul>\n<li>여러 사용자 스레드를 여러 커널 스레드에 사상한다. (사용자 스레드 ≤ 커널 스레드 숫자로 사상한다)</li>\n<li>\n<p>다대일 모델과 일대일 모델의 단점을 극복한다.</p>\n<ul>\n<li>진정한 동시성을 지원하지 못하는 단점과, 스레드 개수에 제한이 있는 단점을 커버한다.</li>\n</ul>\n</li>\n<li>개발자는 원하는 만큼 스레드를 생성하고 여러개의 커널 스레드에 의해 병렬성을 보장한다. 따라서 하나의 스레드가 봉쇄상태에 들어가더라도 다른 커널 스레드에 의해 실행을 스케줄 할 수 있다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-thread-스케줄링\" style=\"position:relative;\"><a href=\"#-thread-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81\" aria-label=\" thread 스케줄링 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 Thread 스케줄링</h2>\n<ul>\n<li>사용자 스레드와 커널 스레드가 나뉘지만 os에서 스캐줄링 되는 대상은 커널 스레드이다.</li>\n<li>사용자 스레드는 스레드 라이브러리에 의해서 관리되고 커널은 사용자 스레드의 존재에 대해서 알지 못하기 때문에 궁극적으로 사용자 스레드는 커널 스레드에 사상되어야 한다.</li>\n<li>따라서 사용자 수준과 커널 수준의 스레드 스케줄링에 대해서 간략히 다루어보자.</li>\n</ul>\n<h3 id=\"경쟁-범위-contention-scope\" style=\"position:relative;\"><a href=\"#%EA%B2%BD%EC%9F%81-%EB%B2%94%EC%9C%84-contention-scope\" aria-label=\"경쟁 범위 contention scope permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>경쟁 범위 Contention scope</h3>\n<ul>\n<li>\n<p><strong>Process-Contention scope(PCS)</strong></p>\n<ul>\n<li>다대일, 다대다 모델에서는 스레드 라이브러리가 사용자 스레드를 가용한 커널 스레드에 스케줄링한다.</li>\n<li>동일한 프로세스의 스레드들끼리 CPU를 경쟁하는 형태</li>\n<li>스레드 라이브러리가사용자 스레드를 ‘가용한 LWP(Light Weight Process) 상에서 스케줄한다’ 라고 하더라도 그것이 CPU 점유를 의미하지 않는다. CPU 점유는 커널 스레드의 스캐줄링이 필요하다.</li>\n<li>주로 우선순위에 따라서 행해지며 가장 높은 우선순위를 선점하여 스캐줄링한다.</li>\n</ul>\n</li>\n<li>\n<p><strong>System-Contention scope(SCS)</strong></p>\n<ul>\n<li>실제 CPU에서 실행되기 위해서 os가 커널 스레드를 물리적 CPU로 스캐줄링 해야한다.</li>\n<li>어느 커널 스레드가 CPU를 점유할 것인지 결정하는 형태</li>\n<li>SCS 스캐줄링은 시스템 상의 모든 스레드 사이에서 일어난다.</li>\n<li>일대일 모델 같은 경우 오직 SCS만 사용한다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-느낀-점\" style=\"position:relative;\"><a href=\"#-%EB%8A%90%EB%82%80-%EC%A0%90\" aria-label=\" 느낀 점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🛋 느낀 점</h2>\n<ul>\n<li>한번도 제대로 이해하지 못했는데 os를 처음부터 차근차근 공부하며 ‘커널’에 대한 이해도를 쌓은 후 공부하니 조금 더 감이 잡히는 듯 하다.</li>\n<li>사용자 스레드의 이점이 아직 그렇게 잘 와닿지 않는다. 우선 하나의 프로세스 내에서 여러 작업 단위를 나눈다는 점만 이해하고 넘어가야겠다.</li>\n<li>자바의 Thread와 스레드 라이브러리에 대해서 더 깊이 공부해 봐야겠다 🙌</li>\n</ul>\n<br>\n<p>[참고자료]</p>\n<ul>\n<li>Operating System 공룡책 </li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#-intro\">💡 Intro</a></li>\n<li>\n<p><a href=\"#-multi-thread-%EC%9E%A5%EC%A0%90\">🌩 Multi-thread 장점</a></p>\n<ul>\n<li><a href=\"#1-%EC%9D%91%EB%8B%B5%EC%84%B1\">1. 응답성</a></li>\n<li><a href=\"#2-%EC%9E%90%EC%9B%90-%EA%B3%B5%EC%9C%A0-resource-sharing\">2. 자원 공유 resource sharing</a></li>\n<li><a href=\"#3-%EA%B2%BD%EC%A0%9C%EC%84%B1-economy\">3. 경제성 economy</a></li>\n<li><a href=\"#4-%EA%B7%9C%EB%AA%A8-%EA%B0%80%EB%B3%80%EC%84%B1-scalability\">4. 규모 가변성 scalability</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-multi-thread-%EB%AA%A8%EB%8D%B8\">🌩 Multi-thread 모델</a></p>\n<ul>\n<li><a href=\"#%EB%AA%A8%EB%8D%B8-3%EA%B0%80%EC%A7%80\">모델 3가지</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-thread-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81\">🌩 Thread 스케줄링</a></p>\n<ul>\n<li><a href=\"#%EA%B2%BD%EC%9F%81-%EB%B2%94%EC%9C%84-contention-scope\">경쟁 범위 Contention scope</a></li>\n</ul>\n</li>\n<li><a href=\"#-%EB%8A%90%EB%82%80-%EC%A0%90\">🛋 느낀 점</a></li>\n</ul>\n</div>","frontmatter":{"date":"November 10, 2021","title":"사용자 레벨 스레드 vs. 커널 레벨 스레드","categories":"운영체제","author":"코다","emoji":"🧁"},"fields":{"slug":"/os-user-kernel-thread/"}},"prev":null,"site":{"siteMetadata":{"siteUrl":"https://yjksw.github.io","comments":{"utterances":{"repo":"yjksw/yjksw.github.io"}}}}},"pageContext":{"slug":"/java-abstract-vs-interface/","nextSlug":"/os-user-kernel-thread/","prevSlug":""}},"staticQueryHashes":["1073350324","2938748437"]}
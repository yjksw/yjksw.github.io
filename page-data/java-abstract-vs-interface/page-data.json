{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/java-abstract-vs-interface/",
    "result": {"data":{"cur":{"id":"0f7262a6-8cc3-5ad6-a8f8-5c468e91c6c6","html":"<h2 id=\"-intro\" style=\"position:relative;\"><a href=\"#-intro\" aria-label=\" intro permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>💡 Intro</h2>\n<ul>\n<li>인터페이스와 추상클래스의 차이를 명확하게 구분해보자.</li>\n<li>언제 무엇을 쓰는 것이 좋은지 나름의 정의를 내려본다.</li>\n<li>상속의 위험성에 대해서 고민해본다.</li>\n</ul>\n<br>\n<h2 id=\"-추상클래스\" style=\"position:relative;\"><a href=\"#-%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4\" aria-label=\" 추상클래스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 추상클래스</h2>\n<ul>\n<li>추상 클래스는 “미완성 설계도” 이다.</li>\n<li>공통부분을 우선 정의한 미완성 설계도를 만들고 각기 다른 상황에 대해서 추가로 구현할 수 있다.\n<ul>\n<li>완성되지 않은 abstract 메소드를 포함하고 있다.</li>\n</ul>\n</li>\n<li>추상클래스는 abstract 메소드가 있다는 것을 제외하고는 일반클래스와 동일하다.</li>\n<li><strong>상속은 자손 클래스를 만드는데 조상 클래스를 사용하는 것</strong></li>\n<li><strong>추상화는 자손 클래스의 공통부분을 뽑아내서 조상 클래스를 만드는 것</strong></li>\n</ul>\n<h3 id=\"상속\" style=\"position:relative;\"><a href=\"#%EC%83%81%EC%86%8D\" aria-label=\"상속 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>상속</h3>\n<ul>\n<li>추상클래스를 <code class=\"language-text\">extends</code> 하는 명령어가 상속에서 사용되기 때문에 두 개념이 혼용되어서 사용되기도 한다. 엄밀히 말하면 두 개념이 겹칠수도 있지만 완전히 동일한 것은 아니다.</li>\n<li>상속이란 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것\n<ul>\n<li>적은 양의 코드로 새로운 클래스를 작성할 수 있고 공통부분을 관리할 수 있다는 장점이 있다.</li>\n</ul>\n</li>\n<li><strong>상속은 is-a 관계로 표현될 수 있다.</strong></li>\n<li><code class=\"language-text\">**final</code>로 정의된 클래스가 아니라면 모두 상속이 가능하다. 추상클래스는 그 일부분이다.**</li>\n<li>상속을 할 때 주의할 점 ‼️\n<ul>\n<li>상속은 조상 클래스의 캡슐화가 깨지는 위험이 있다.</li>\n<li>또한 조상 클래스와 자손 클래스간의 강한 결합이기 때문에 조상 클래스 메서드에 변화가 생기면 자손 클래스에 아무런 변화가 없음에도 다르게 동작할 수 있다.</li>\n<li>따라서 상속보다는 <strong>조합</strong>을 사용하도록 추천한다. (Deck는 Card를 가지고 있다 와 같은 경우에 조합 사용 has-a 관계)</li>\n<li>일반 클래스는 <code class=\"language-text\">final</code>을 추가하여 상속을 막거나 미완성 설계도인 abstract 클래스를 정의하도록 추천한다.\n<ul>\n<li>또한 추상클래스의 부모 메소드를 수정하지 않는 것이 좋다.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"왜-자바는-단일-상속일까-single-inheritance\" style=\"position:relative;\"><a href=\"#%EC%99%9C-%EC%9E%90%EB%B0%94%EB%8A%94-%EB%8B%A8%EC%9D%BC-%EC%83%81%EC%86%8D%EC%9D%BC%EA%B9%8C-single-inheritance\" aria-label=\"왜 자바는 단일 상속일까 single inheritance permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>왜 자바는 단일 상속일까? (single inheritance)</h3>\n<ul>\n<li>다중상속을 하게 되면 복합적인 기능을 가진 클래스를 손쉽게 구현할 수 있지만 클래스 간 관계가 굉장히 복잡해진다.</li>\n<li>여러 다른 클래스로 상속받은 멤버의 이름이나 메서드가 같은 경우 구별도 어렵다.</li>\n</ul>\n<br>\n<h2 id=\"-인터페이스\" style=\"position:relative;\"><a href=\"#-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4\" aria-label=\" 인터페이스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 인터페이스</h2>\n<ul>\n<li>인터페이스는 “기본 설계도”이다. (추상클래스는 “미완성 설계도”)</li>\n<li>인터페이스는 면대면이 만나는 부분이라는 뜻을 가지고 있으며 2개의 구성요소가 상호작용할 수 있도록 접속 경계를 연결하는 부분이다. (플러그와 같은 역할)</li>\n<li>인터페이스끼리 상속받을 수 있으며 다중상속이 가능하다.</li>\n<li>인터페이스는 <code class=\"language-text\">implements</code> 를 사용해서 구현하며 다중구현이 가능하다.</li>\n<li>인터페이스는 구현 메서드나 멤버 필드가 없다.\n<ul>\n<li>default 메서드가 가능하도록 jdk1.8부터 추가가 되었고, static 변수만 가능하다.</li>\n</ul>\n</li>\n<li>인터페이스는 해당 인터페이스를 구현하는 모든 클래스가 특정 메소드를 반드시 구현하도록 강제하는 역할을 한다 → 따라서 명세의 역할을 한다고도 한다.</li>\n</ul>\n<h3 id=\"추상클래스와의-차이점\" style=\"position:relative;\"><a href=\"#%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90\" aria-label=\"추상클래스와의 차이점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>추상클래스와의 차이점</h3>\n<ul>\n<li>우선 구현메서드 존재 여부, 필드 존재 여부, 다중 상속 및 구현에 대한 차이점이 존재한다</li>\n<li>추상클래스는 공통기능에 대한 재사용과 정제의 역할을 한다. (정제란 불완전한 행동을 완전하게 만드는 것을 의미)</li>\n<li>인터페이스는 구현체가 특정 메소드가 반드시 존재하도록 하는 역할을 하여 특정 기능을 반드시 제공한다는 것을 보장하는 역할을 한다.</li>\n</ul>\n<h3 id=\"동일-메서드를-가진-인터페이스\" style=\"position:relative;\"><a href=\"#%EB%8F%99%EC%9D%BC-%EB%A9%94%EC%84%9C%EB%93%9C%EB%A5%BC-%EA%B0%80%EC%A7%84-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4\" aria-label=\"동일 메서드를 가진 인터페이스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>동일 메서드를 가진 인터페이스</h3>\n<ul>\n<li>동일한 메서드 명과 시그니처를 가진 메서드가 두 개의 인터페이스에 있을때는 어떻게 할까?\n<ul>\n<li>이때는 컴파일 오류로 충돌을 해결해야만 컴파일이 가능하다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-느낀-점\" style=\"position:relative;\"><a href=\"#-%EB%8A%90%EB%82%80-%EC%A0%90\" aria-label=\" 느낀 점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🛋 느낀 점</h2>\n<ul>\n<li>추상클래스와 인터페이스는 역할 자체가 다르다.\n<ul>\n<li>추상 클래스는 정제의 역할을 인터페이스는 기능 구현 강제의 역할을 한다.</li>\n<li>인터페이스를 통해서는 중복을 해결할 수 없다. 어떤 두 요소가 연결되기 위해 사전에 정의한 기능들이 모두 구현이 된다는 것을 보장할 뿐이다.</li>\n<li>상속은 부모 클래스의 캡슐화가 깨지기 때문에 조합을 이용하는 것이 더 적절하다.</li>\n</ul>\n</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#-intro\">💡 Intro</a></p>\n</li>\n<li>\n<p><a href=\"#-%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4\">🌩 추상클래스</a></p>\n<ul>\n<li><a href=\"#%EC%83%81%EC%86%8D\">상속</a></li>\n<li><a href=\"#%EC%99%9C-%EC%9E%90%EB%B0%94%EB%8A%94-%EB%8B%A8%EC%9D%BC-%EC%83%81%EC%86%8D%EC%9D%BC%EA%B9%8C-single-inheritance\">왜 자바는 단일 상속일까? (single inheritance)</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4\">🌩 인터페이스</a></p>\n<ul>\n<li><a href=\"#%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90\">추상클래스와의 차이점</a></li>\n<li><a href=\"#%EB%8F%99%EC%9D%BC-%EB%A9%94%EC%84%9C%EB%93%9C%EB%A5%BC-%EA%B0%80%EC%A7%84-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4\">동일 메서드를 가진 인터페이스</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-%EB%8A%90%EB%82%80-%EC%A0%90\">🛋 느낀 점</a></p>\n</li>\n</ul>\n</div>","excerpt":"💡 Intro 인터페이스와 추상클래스의 차이를 명확하게 구분해보자. 언제 무엇을 쓰는 것이 좋은지 나름의 정의를 내려본다. 상속의 위험성에 대해서 고민해본다. 🌩 추상클래스 추상 클래스는 “미완성 설계도” 이다. 공통부분을 우선 정의한 미완성 설계도를 만들고 각기 다른 상황에 대해서 추가로 구현할 수 있다. 완성되지 않은 abstract 메소드를 포함하고 있다. 추상클래스는 abstract 메소드가 있다는 것을 제외하고는 일반클래스와 동일하다. 상속은 자손 클래스를 만드는데 조상 클래스를 사용하는 것 추상화는 자손 클래스의 공통부분을 뽑아내서 조상 클래스를 만드는 것 상속 추상클래스를  하는 명령어가 상속에서 사용되기 때문에 두 개념이 혼용되어서 사용되기도 한다. 엄밀히 말하면 두 개념이 겹칠수도 있지만 완전히 동일한 것은 아니다. 상속이란 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것 적은 양의 코드로 새로운 클래스를 작성할 수 있고 공통부분을 관리할 수 있다는 장점이 …","frontmatter":{"date":"November 15, 2021","title":"추상클래스와 인터페이스 더 이상 헷갈리지 않기","categories":"자바","author":"코다","emoji":"✊"},"fields":{"slug":"/java-abstract-vs-interface/"}},"next":{"id":"1549b4b9-74b3-5275-b573-eb2609ad7eff","html":"<h2 id=\"-intro\" style=\"position:relative;\"><a href=\"#-intro\" aria-label=\" intro permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>💡 Intro</h2>\n<ul>\n<li>효율적인 프로그래밍을 위해 멀티 스레드 환경에서 구동을 할 때가 많다.</li>\n<li>멀티 스레드의 간단한 장점과 항상 헷갈렸던 사용자 레벨 스레드 vs. 커널 레벨 스레드에 대해서 알아보자.</li>\n</ul>\n<br>\n<h2 id=\"-multi-thread-장점\" style=\"position:relative;\"><a href=\"#-multi-thread-%EC%9E%A5%EC%A0%90\" aria-label=\" multi thread 장점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 Multi-thread 장점</h2>\n<h3 id=\"1-응답성\" style=\"position:relative;\"><a href=\"#1-%EC%9D%91%EB%8B%B5%EC%84%B1\" aria-label=\"1 응답성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 응답성</h3>\n<ul>\n<li>어플리케이션의 일부분이 봉쇄되거나 긴 작업을 실행하더라도 다른 부분의 프로그램이 계속 실행되는 것을 허용하기 때문에 사용자의 입장에서 응답성이 증가한다.</li>\n<li>예를 들어 다운로드가 오래 걸리는 파일을 다운로드 하면서 사용자와의 상호작용이 가능하다.</li>\n</ul>\n<h3 id=\"2-자원-공유-resource-sharing\" style=\"position:relative;\"><a href=\"#2-%EC%9E%90%EC%9B%90-%EA%B3%B5%EC%9C%A0-resource-sharing\" aria-label=\"2 자원 공유 resource sharing permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 자원 공유 resource sharing</h3>\n<ul>\n<li>프로세스는 완전히 별도의 메모리 공간을 할당받기 때문에 (code, data, heap) 서로 통신하기 위해서는 공유 메모리를 사용하거나 메세지 전달 기법 (IPC)를 사용해야한다.</li>\n<li>스레드는 속한 프로세스의 자원을 공유하기 때문에 한 프로그램이 <strong>같은 주소 내에서 여러개의 다른 작업을 하는 단위</strong>로 나뉘어질 수 있다는 이점이 있다.</li>\n</ul>\n<h3 id=\"3-경제성-economy\" style=\"position:relative;\"><a href=\"#3-%EA%B2%BD%EC%A0%9C%EC%84%B1-economy\" aria-label=\"3 경제성 economy permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 경제성 economy</h3>\n<ul>\n<li>프로세스의 자원을 공유하므로 메모리 측면과 문맥교환 오버헤드 측면에서 경제적이다.</li>\n</ul>\n<h3 id=\"4-규모-가변성-scalability\" style=\"position:relative;\"><a href=\"#4-%EA%B7%9C%EB%AA%A8-%EA%B0%80%EB%B3%80%EC%84%B1-scalability\" aria-label=\"4 규모 가변성 scalability permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. 규모 가변성 scalability</h3>\n<ul>\n<li>멀티코어 환경에서 각각의 스레드가 다른 코어에서 병렬로 실행될 수 있기 때문에 이점이 증가한다.</li>\n<li>단일 스레드라면 코어의 개수와 상관없이 한번에 한 개의 처리기에서만 실행되지만 멀티코어에 멀티스레드라면 병렬성을 증가시킨다.</li>\n</ul>\n<br>\n<h2 id=\"-multi-thread-모델\" style=\"position:relative;\"><a href=\"#-multi-thread-%EB%AA%A8%EB%8D%B8\" aria-label=\" multi thread 모델 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 Multi-thread 모델</h2>\n<ul>\n<li>스레드는 사용자 스레드와 커널 스레드로 나뉜다.\n<ul>\n<li>사용자 스레드는 사용자 수준에서 관리되며 os가 관여하지 않는다.</li>\n<li>사용자 수준의 라이브러리를 사용하여 생성되고 커널의 개입을 받지 않는다.</li>\n<li>커널 스레드는 os에 의해 직접 지원되고 관리된다.</li>\n</ul>\n</li>\n<li>다양한 Mutli-thread 모델이 있는 이유는 스레드가 작업을 처리하기 위해서는 CPU를 점유해야하기 때문에 궁극적으로는 사용자 스레드와 커널 스레드간의 어떠한 연관관계가 존재해야 하기 때문이다.</li>\n</ul>\n<h3 id=\"모델-3가지\" style=\"position:relative;\"><a href=\"#%EB%AA%A8%EB%8D%B8-3%EA%B0%80%EC%A7%80\" aria-label=\"모델 3가지 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>모델 3가지</h3>\n<ul>\n<li>다대일 모델\n<ul>\n<li>여러 사용자 스레드를 하나의 커널 스레드에 사상하며 스레드 관리는 사용자 레벨의 스레드 라이브러리가 수행한다.</li>\n<li>한 스레드가 봉쇄 상태에 들어가면 커널 스레드가 함께 봉쇄 상태에 들어가게 되므로 모두 봉쇄된다.</li>\n<li>한번에 하나의 스레드만 커널에 접근이 가능하기 때문에 멀티코어 환경에서 병렬로 실행될 수 없다.</li>\n</ul>\n</li>\n<li>일대일 모델\n<ul>\n<li>하나의 사용자 스레드를 각각 하나의 커널 스레드로 사상한다.</li>\n<li>하나의 스레드가 봉쇄상태에 들어가더라도 다른 스레드가 커널 스레드와 매핑되어 작업을 처리할 수 있으므로 멀티코어 환경에서 더 병렬성을 제공한다.</li>\n<li>사용자 레벨에서 스레드를 하나 생성할 때 커널의 스레도 생성해야 하기 대문에 오버헤드가 발생한다. 따라서 이 모델을 사용할 경우 대부분 시스템에 의해 지원되는 스레드 개수를 제한한다.</li>\n<li>Linux가 대표적인 일대일 모델을 사용하는 os이다.</li>\n</ul>\n</li>\n<li>다대다 모델\n<ul>\n<li>여러 사용자 스레드를 여러 커널 스레드에 사상한다. (사용자 스레드 ≤ 커널 스레드 숫자로 사상한다)</li>\n<li>다대일 모델과 일대일 모델의 단점을 극복한다.\n<ul>\n<li>진정한 동시성을 지원하지 못하는 단점과, 스레드 개수에 제한이 있는 단점을 커버한다.</li>\n</ul>\n</li>\n<li>개발자는 원하는 만큼 스레드를 생성하고 여러개의 커널 스레드에 의해 병렬성을 보장한다. 따라서 하나의 스레드가 봉쇄상태에 들어가더라도 다른 커널 스레드에 의해 실행을 스케줄 할 수 있다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-thread-스케줄링\" style=\"position:relative;\"><a href=\"#-thread-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81\" aria-label=\" thread 스케줄링 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 Thread 스케줄링</h2>\n<ul>\n<li>사용자 스레드와 커널 스레드가 나뉘지만 os에서 스캐줄링 되는 대상은 커널 스레드이다.</li>\n<li>사용자 스레드는 스레드 라이브러리에 의해서 관리되고 커널은 사용자 스레드의 존재에 대해서 알지 못하기 때문에 궁극적으로 사용자 스레드는 커널 스레드에 사상되어야 한다.</li>\n<li>따라서 사용자 수준과 커널 수준의 스레드 스케줄링에 대해서 간략히 다루어보자.</li>\n</ul>\n<h3 id=\"경쟁-범위-contention-scope\" style=\"position:relative;\"><a href=\"#%EA%B2%BD%EC%9F%81-%EB%B2%94%EC%9C%84-contention-scope\" aria-label=\"경쟁 범위 contention scope permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>경쟁 범위 Contention scope</h3>\n<ul>\n<li><strong>Process-Contention scope(PCS)</strong>\n<ul>\n<li>다대일, 다대다 모델에서는 스레드 라이브러리가 사용자 스레드를 가용한 커널 스레드에 스케줄링한다.</li>\n<li>동일한 프로세스의 스레드들끼리 CPU를 경쟁하는 형태</li>\n<li>스레드 라이브러리가사용자 스레드를 ‘가용한 LWP(Light Weight Process) 상에서 스케줄한다’ 라고 하더라도 그것이 CPU 점유를 의미하지 않는다. CPU 점유는 커널 스레드의 스캐줄링이 필요하다.</li>\n<li>주로 우선순위에 따라서 행해지며 가장 높은 우선순위를 선점하여 스캐줄링한다.</li>\n</ul>\n</li>\n<li><strong>System-Contention scope(SCS)</strong>\n<ul>\n<li>실제 CPU에서 실행되기 위해서 os가 커널 스레드를 물리적 CPU로 스캐줄링 해야한다.</li>\n<li>어느 커널 스레드가 CPU를 점유할 것인지 결정하는 형태</li>\n<li>SCS 스캐줄링은 시스템 상의 모든 스레드 사이에서 일어난다.</li>\n<li>일대일 모델 같은 경우 오직 SCS만 사용한다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-느낀-점\" style=\"position:relative;\"><a href=\"#-%EB%8A%90%EB%82%80-%EC%A0%90\" aria-label=\" 느낀 점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🛋 느낀 점</h2>\n<ul>\n<li>한번도 제대로 이해하지 못했는데 os를 처음부터 차근차근 공부하며 ‘커널’에 대한 이해도를 쌓은 후 공부하니 조금 더 감이 잡히는 듯 하다.</li>\n<li>사용자 스레드의 이점이 아직 그렇게 잘 와닿지 않는다. 우선 하나의 프로세스 내에서 여러 작업 단위를 나눈다는 점만 이해하고 넘어가야겠다.</li>\n<li>자바의 Thread와 스레드 라이브러리에 대해서 더 깊이 공부해 봐야겠다 🙌</li>\n</ul>\n<br>\n<p>[참고자료]</p>\n<ul>\n<li>Operating System 공룡책</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#-intro\">💡 Intro</a></p>\n</li>\n<li>\n<p><a href=\"#-multi-thread-%EC%9E%A5%EC%A0%90\">🌩 Multi-thread 장점</a></p>\n<ul>\n<li><a href=\"#1-%EC%9D%91%EB%8B%B5%EC%84%B1\">1. 응답성</a></li>\n<li><a href=\"#2-%EC%9E%90%EC%9B%90-%EA%B3%B5%EC%9C%A0-resource-sharing\">2. 자원 공유 resource sharing</a></li>\n<li><a href=\"#3-%EA%B2%BD%EC%A0%9C%EC%84%B1-economy\">3. 경제성 economy</a></li>\n<li><a href=\"#4-%EA%B7%9C%EB%AA%A8-%EA%B0%80%EB%B3%80%EC%84%B1-scalability\">4. 규모 가변성 scalability</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-multi-thread-%EB%AA%A8%EB%8D%B8\">🌩 Multi-thread 모델</a></p>\n<ul>\n<li><a href=\"#%EB%AA%A8%EB%8D%B8-3%EA%B0%80%EC%A7%80\">모델 3가지</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-thread-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81\">🌩 Thread 스케줄링</a></p>\n<ul>\n<li><a href=\"#%EA%B2%BD%EC%9F%81-%EB%B2%94%EC%9C%84-contention-scope\">경쟁 범위 Contention scope</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-%EB%8A%90%EB%82%80-%EC%A0%90\">🛋 느낀 점</a></p>\n</li>\n</ul>\n</div>","frontmatter":{"date":"November 10, 2021","title":"사용자 레벨 스레드 vs. 커널 레벨 스레드","categories":"운영체제","author":"코다","emoji":"🧁"},"fields":{"slug":"/os-user-kernel-thread/"}},"prev":{"id":"c988bf66-5fcc-5cb8-a6d8-82290bf4de3a","html":"<h2 id=\"-intro\" style=\"position:relative;\"><a href=\"#-intro\" aria-label=\" intro permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>💡 Intro</h2>\n<ul>\n<li>POJO에 대해서 ‘그냥 자바 객체요!’라고 말하는 것 이상으로 이해해보자.</li>\n<li>POJO기반 프레임워크란 무엇인지 이해해보고 스프링에서 POJO는 어떠한 형태를 띄는지 알아보자</li>\n<li>스프링이 개발의 복잡도를 낮춰주고 효과적으로 프로그래밍을 할 수 있도록 구체적으로 <strong>어떻게</strong> 가능하게 하는지 공부해보자.</li>\n</ul>\n<br>\n<h2 id=\"-pojo-란\" style=\"position:relative;\"><a href=\"#-pojo-%EB%9E%80\" aria-label=\" pojo 란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 POJO 란?</h2>\n<ul>\n<li>\n<p>유명한 스프링의 삼각형으로 기본 컨텍스트를 맞추고 설명을 시작해보자.</p>\n<ul>\n<li>스프링은 POJO에 주요기술인 IoC/DI, AOP, PSA를 사용한 코드와 POJO가 어떻게 관계를 맺고 동작하는지 정의한 설계정보로 구분된다.</li>\n</ul>\n<p align=\"center\"><img width=\"80%\" src=\"https://user-images.githubusercontent.com/63405904/142145957-19052d27-8363-4f06-9a36-5527c8eaf391.png\"></p>\n</li>\n<li>\n<p>스프링에서 DI는 <strong>유연하게 확장 가능한 오브젝트를 만들고, 그 관계를 외부에서 dynamic하게 설정해주는 것</strong>이며 스프링에서는 이 아이디어를 전반에 걸쳐서 적용한다.</p>\n</li>\n<li>\n<p>POJO는 EJB처럼 복잡하고 제한이 많은 기술로 엔터프라이즈 애플리케이션의 비지니스 로직을 구현하는 것보다 순수 자바 객체를 사용하여 비지니스 로직을 구현하는 것이 더 좋다고 생각하여 나온 개념이다.</p>\n</li>\n</ul>\n<h3 id=\"pojo의-조건\" style=\"position:relative;\"><a href=\"#pojo%EC%9D%98-%EC%A1%B0%EA%B1%B4\" aria-label=\"pojo의 조건 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>POJO의 조건</h3>\n<ol>\n<li>특정 규약에 종속되지 않는다.\n<ul>\n<li>자바 언어와 필요 API를 제외하고 다른 것에 종속되지 말아야 한다.\n<ul>\n<li>특정 규약에 따른 비지니스 컴포넌트를 만들어야하면 POJO가 아니다.</li>\n<li>또한 특정 클래스를 상속해서 만들어야하면 POJO가 아니다 → 단일 상속 제한 때문에 객체지향적인 설계 기법을 적용하기 어렵다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>특정 환경에 종속되지 않는다.\n<ul>\n<li>특정 무언가가 없는 환경에서 그대로 사용하기가 어렵다면 POJO가 아니다.</li>\n<li>그렇다면 JPA를 사용하는 Service 클래스는 POJO라고 할 수 있을까? 🤔\n<ul>\n<li>Service 클래스에서 의존하고 있는 JPA 레파지토리는 구현체인 하이버네이트에 의존하기 보다는 표준 스펙을 정의한 인터페이스이다. 따라서 POJO 프레임워크를 제공하는 것이라고 할 수 있다.</li>\n<li>그런 도메인의 인터페이스에 의존하는 서비스는 POJO라고 할 수 있을 것 같다.</li>\n<li>개인적인 의견이므로 틀리면 댓글로 얼마든지 알려주세요 🙌</li>\n</ul>\n</li>\n<li>특정 벤더의 서버나 프레임워크 안에서만 동작 가능한 코드는 POJO가 아니다.</li>\n<li>웹이라는 환경정보나 웹 기술을 담고 있는 클래스나 인터페이스를 사용하는 것은 POJO가 아니다.\n<ul>\n<li>예를 들어 비즈니스 코드에 HttpServletRequest나 HttpSession 등의 API가 등장하거나 클래스에서 그것을 직접 이용한다면 POJO가 아니다.</li>\n<li>웹 이외의 클라이언트는 해당 객체를 사용하지 못하며 독립적으로 테스트하기 어려워진다.</li>\n</ul>\n</li>\n<li>어노테이션을 쓰면 POJO가 아니다 라고 말할수는 없다. 해당 어노테이션이 환경에 종속되지 않고 부가적인 정보를 담고 있다면 POJO라고 할 수 있다.\n<ul>\n<li>만일 해당 어노테이션이 element에 특정 기술에 환경에 종속적인 정보를 담고 있다면 POJO라고 할 수 없다.\n<ul>\n<li>개인적인 의견) 따라서 JPA의 <code class=\"language-text\">@Entity</code>가 붙은 클래스는 POJO라고 할 수 없을 것 같다. @Id가 반드시 있어야하는 등의 제약사항이 있기 때문이다.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>그렇다고 위 2조건을 만족하는 나머지가 모두 POJO인 것은 아니다!\n<ul>\n<li>객체지향적인 자바의 언어를 잘 활용한 것이 POJO이다.</li>\n<li>재사용이 가능하고 상속과 다형성을 적용하여 객체지향적으로 설계된 오브젝트를 말한다.</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"pojo의-장점\" style=\"position:relative;\"><a href=\"#pojo%EC%9D%98-%EC%9E%A5%EC%A0%90\" aria-label=\"pojo의 장점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>POJO의 장점</h3>\n<ul>\n<li>기술과 환경에 종속되지 않으면 깔끔한 코드를 짤 수 있으며 순수 비즈니스 로직을 담을 수 있다.</li>\n<li>테스트 작성이나 검증이 쉽다.</li>\n<li>기술이나 환경의 변화에 취약하지 않다.</li>\n<li>재사용이 가능하고, 변경에 자유로우며, 확장이 용이한 객체지향적 설계가 가능하다.</li>\n</ul>\n<br>\n<h2 id=\"-pojo-프레임워크\" style=\"position:relative;\"><a href=\"#-pojo-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC\" aria-label=\" pojo 프레임워크 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 POJO 프레임워크</h2>\n<ul>\n<li>“스프링의 정수는 엔터프라이즈 서비스 기능을 POJO에 제공하는 것” 이라고 한다.</li>\n<li>즉, 트랜잭션과 같이 엔터프라이즈 시스템에서 필요한 기술을 순수 자바 객체에서 가능하게 한다는 것이다.</li>\n<li>다시 말하면 엔터프라이즈 서비스 기술과 자바 객체(POJO)를 효과적으로 분리했다는 의미이며 스프링의 가장 큰 장점이다.</li>\n<li>POJO 프로그래밍이 가능하도록 기술적인 기반을 제공하는 것이 POJO 프레임워크이다. 하이버네이트와 스프링이 대표적인 POJO 프레임워크이다.</li>\n<li>스프링은 POJO 기반으로 구현하고 엔터프라이즈 환경의 서비스와 기술을 POJO 방식으로 구현된 코드에 적용할 수 있다.\n<ul>\n<li>비즈니스 로직과 엔터프라이즈 기술을 분리하여 구성한다.</li>\n<li>스프링은 기술영역에만 관여하고 비즈니스 로직을 다루는 POJO에서 모습을 드러내지 않는다.</li>\n<li>데이터 액세스 로직이나 웹 UI 로직에서 최소한의 방법으로 관여한다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-느낀-점\" style=\"position:relative;\"><a href=\"#-%EB%8A%90%EB%82%80-%EC%A0%90\" aria-label=\" 느낀 점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🛋 느낀 점</h2>\n<ul>\n<li>개발자가 POJO 프레임워크를 사용한다고 해서 자동으로 객체지향적인 코드를 짜는 것은 아니다.</li>\n<li>객체지향적 코드가 가능한 기반에서 어떻게 효과적으로 객체지향적 설계를 잘 할지는 개발자의 남은 몫이다.\n<ul>\n<li>JVM, JDK API, 디자인패턴에 대해서 잘 공부하고 적용할 수 있도록 공부해야겠다.</li>\n</ul>\n</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#-intro\">💡 Intro</a></p>\n</li>\n<li>\n<p><a href=\"#-pojo-%EB%9E%80\">🌩 POJO 란?</a></p>\n<ul>\n<li><a href=\"#pojo%EC%9D%98-%EC%A1%B0%EA%B1%B4\">POJO의 조건</a></li>\n<li><a href=\"#pojo%EC%9D%98-%EC%9E%A5%EC%A0%90\">POJO의 장점</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-pojo-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC\">🌩 POJO 프레임워크</a></p>\n</li>\n<li>\n<p><a href=\"#-%EB%8A%90%EB%82%80-%EC%A0%90\">🛋 느낀 점</a></p>\n</li>\n</ul>\n</div>","frontmatter":{"date":"November 15, 2021","title":"스프링, POJO 프레임워크가 무슨 뜻일까","categories":"스프링 웹","author":"코다","emoji":"🍀"},"fields":{"slug":"/spring-pojo/"}},"site":{"siteMetadata":{"siteUrl":"https://yjksw.github.io","comments":{"utterances":{"repo":"yjksw/yjksw.github.io"}}}}},"pageContext":{"slug":"/java-abstract-vs-interface/","nextSlug":"/os-user-kernel-thread/","prevSlug":"/spring-pojo/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}
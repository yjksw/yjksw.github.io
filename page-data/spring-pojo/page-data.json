{"componentChunkName":"component---src-templates-blog-template-js","path":"/spring-pojo/","result":{"data":{"cur":{"id":"c988bf66-5fcc-5cb8-a6d8-82290bf4de3a","html":"<h2 id=\"-intro\" style=\"position:relative;\"><a href=\"#-intro\" aria-label=\" intro permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>💡 Intro</h2>\n<ul>\n<li>POJO에 대해서 ‘그냥 자바 객체요!’라고 말하는 것 이상으로 이해해보자.</li>\n<li>POJO기반 프레임워크란 무엇인지 이해해보고 스프링에서 POJO는 어떠한 형태를 띄는지 알아보자</li>\n<li>스프링이 개발의 복잡도를 낮춰주고 효과적으로 프로그래밍을 할 수 있도록 구체적으로 <strong>어떻게</strong> 가능하게 하는지 공부해보자.</li>\n</ul>\n<br>\n<h2 id=\"-pojo-란\" style=\"position:relative;\"><a href=\"#-pojo-%EB%9E%80\" aria-label=\" pojo 란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 POJO 란?</h2>\n<ul>\n<li>\n<p>유명한 스프링의 삼각형으로 기본 컨텍스트를 맞추고 설명을 시작해보자.</p>\n<ul>\n<li>스프링은 POJO에 주요기술인 IoC/DI, AOP, PSA를 사용한 코드와 POJO가 어떻게 관계를 맺고 동작하는지 정의한 설계정보로 구분된다.</li>\n</ul>\n<p align=\"center\"><img width=\"80%\" src=\"https://user-images.githubusercontent.com/63405904/142145957-19052d27-8363-4f06-9a36-5527c8eaf391.png\"></p>\n</li>\n<li>스프링에서 DI는 <strong>유연하게 확장 가능한 오브젝트를 만들고, 그 관계를 외부에서 dynamic하게 설정해주는 것</strong>이며 스프링에서는 이 아이디어를 전반에 걸쳐서 적용한다.</li>\n<li>POJO는 EJB처럼 복잡하고 제한이 많은 기술로 엔터프라이즈 애플리케이션의 비지니스 로직을 구현하는 것보다 순수 자바 객체를 사용하여 비지니스 로직을 구현하는 것이 더 좋다고 생각하여 나온 개념이다.</li>\n</ul>\n<h3 id=\"pojo의-조건\" style=\"position:relative;\"><a href=\"#pojo%EC%9D%98-%EC%A1%B0%EA%B1%B4\" aria-label=\"pojo의 조건 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>POJO의 조건</h3>\n<ol>\n<li>\n<p>특정 규약에 종속되지 않는다. </p>\n<ul>\n<li>\n<p>자바 언어와 필요 API를 제외하고 다른 것에 종속되지 말아야 한다.</p>\n<ul>\n<li>특정 규약에 따른 비지니스 컴포넌트를 만들어야하면 POJO가 아니다.</li>\n<li>또한 특정 클래스를 상속해서 만들어야하면 POJO가 아니다 → 단일 상속 제한 때문에 객체지향적인 설계 기법을 적용하기 어렵다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>특정 환경에 종속되지 않는다. </p>\n<ul>\n<li>특정 무언가가 없는 환경에서 그대로 사용하기가 어렵다면 POJO가 아니다.</li>\n<li>\n<p>그렇다면 JPA를 사용하는 Service 클래스는 POJO라고 할 수 있을까? 🤔</p>\n<ul>\n<li>Service 클래스에서 의존하고 있는 JPA 레파지토리는 구현체인 하이버네이트에 의존하기 보다는 표준 스펙을 정의한 인터페이스이다. 따라서 POJO 프레임워크를 제공하는 것이라고 할 수 있다.</li>\n<li>그런 도메인의 인터페이스에 의존하는 서비스는 POJO라고 할 수 있을 것 같다.</li>\n<li>개인적인 의견이므로 틀리면 댓글로 얼마든지 알려주세요 🙌</li>\n</ul>\n</li>\n<li>특정 벤더의 서버나 프레임워크 안에서만 동작 가능한 코드는 POJO가 아니다.</li>\n<li>\n<p>웹이라는 환경정보나 웹 기술을 담고 있는 클래스나 인터페이스를 사용하는 것은 POJO가 아니다.</p>\n<ul>\n<li>예를 들어 비즈니스 코드에 HttpServletRequest나 HttpSession 등의 API가 등장하거나 클래스에서 그것을 직접 이용한다면 POJO가 아니다.</li>\n<li>웹 이외의 클라이언트는 해당 객체를 사용하지 못하며 독립적으로 테스트하기 어려워진다.</li>\n</ul>\n</li>\n<li>\n<p>어노테이션을 쓰면 POJO가 아니다 라고 말할수는 없다. 해당 어노테이션이 환경에 종속되지 않고 부가적인 정보를 담고 있다면 POJO라고 할 수 있다.</p>\n<ul>\n<li>\n<p>만일 해당 어노테이션이 element에 특정 기술에 환경에 종속적인 정보를 담고 있다면 POJO라고 할 수 없다.</p>\n<ul>\n<li>개인적인 의견) 따라서 JPA의 <code class=\"language-text\">@Entity</code>가 붙은 클래스는 POJO라고 할 수 없을 것 같다. @Id가 반드시 있어야하는 등의 제약사항이 있기 때문이다.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>그렇다고 위 2조건을 만족하는 나머지가 모두 POJO인 것은 아니다!</p>\n<ul>\n<li>객체지향적인 자바의 언어를 잘 활용한 것이 POJO이다.</li>\n<li>재사용이 가능하고 상속과 다형성을 적용하여 객체지향적으로 설계된 오브젝트를 말한다.</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"pojo의-장점\" style=\"position:relative;\"><a href=\"#pojo%EC%9D%98-%EC%9E%A5%EC%A0%90\" aria-label=\"pojo의 장점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>POJO의 장점</h3>\n<ul>\n<li>기술과 환경에 종속되지 않으면 깔끔한 코드를 짤 수 있으며 순수 비즈니스 로직을 담을 수 있다.</li>\n<li>테스트 작성이나 검증이 쉽다.</li>\n<li>기술이나 환경의 변화에 취약하지 않다.</li>\n<li>재사용이 가능하고, 변경에 자유로우며, 확장이 용이한 객체지향적 설계가 가능하다.</li>\n</ul>\n<br>\n<h2 id=\"-pojo-프레임워크\" style=\"position:relative;\"><a href=\"#-pojo-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC\" aria-label=\" pojo 프레임워크 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 POJO 프레임워크</h2>\n<ul>\n<li>“스프링의 정수는 엔터프라이즈 서비스 기능을 POJO에 제공하는 것” 이라고 한다.</li>\n<li>즉, 트랜잭션과 같이 엔터프라이즈 시스템에서 필요한 기술을 순수 자바 객체에서 가능하게 한다는 것이다.</li>\n<li>다시 말하면 엔터프라이즈 서비스 기술과 자바 객체(POJO)를 효과적으로 분리했다는 의미이며 스프링의 가장 큰 장점이다.</li>\n<li>POJO 프로그래밍이 가능하도록 기술적인 기반을 제공하는 것이 POJO 프레임워크이다. 하이버네이트와 스프링이 대표적인 POJO 프레임워크이다.</li>\n<li>\n<p>스프링은 POJO 기반으로 구현하고 엔터프라이즈 환경의 서비스와 기술을 POJO 방식으로 구현된 코드에 적용할 수 있다.</p>\n<ul>\n<li>비즈니스 로직과 엔터프라이즈 기술을 분리하여 구성한다.</li>\n<li>스프링은 기술영역에만 관여하고 비즈니스 로직을 다루는 POJO에서 모습을 드러내지 않는다.</li>\n<li>데이터 액세스 로직이나 웹 UI 로직에서 최소한의 방법으로 관여한다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-느낀-점\" style=\"position:relative;\"><a href=\"#-%EB%8A%90%EB%82%80-%EC%A0%90\" aria-label=\" 느낀 점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🛋 느낀 점</h2>\n<ul>\n<li>개발자가 POJO 프레임워크를 사용한다고 해서 자동으로 객체지향적인 코드를 짜는 것은 아니다.</li>\n<li>\n<p>객체지향적 코드가 가능한 기반에서 어떻게 효과적으로 객체지향적 설계를 잘 할지는 개발자의 남은 몫이다.</p>\n<ul>\n<li>JVM, JDK API, 디자인패턴에 대해서 잘 공부하고 적용할 수 있도록 공부해야겠다.</li>\n</ul>\n</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#-intro\">💡 Intro</a></li>\n<li>\n<p><a href=\"#-pojo-%EB%9E%80\">🌩 POJO 란?</a></p>\n<ul>\n<li><a href=\"#pojo%EC%9D%98-%EC%A1%B0%EA%B1%B4\">POJO의 조건</a></li>\n<li><a href=\"#pojo%EC%9D%98-%EC%9E%A5%EC%A0%90\">POJO의 장점</a></li>\n</ul>\n</li>\n<li><a href=\"#-pojo-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC\">🌩 POJO 프레임워크</a></li>\n<li><a href=\"#-%EB%8A%90%EB%82%80-%EC%A0%90\">🛋 느낀 점</a></li>\n</ul>\n</div>","excerpt":"💡 Intro POJO에 대해서 ‘그냥 자바 객체요!’라고 말하는 것 이상으로 이해해보자. POJO기반 프레임워크란 무엇인지 이해해보고 스프링에서 POJO는 어떠한 형태를 띄는지 알아보자 스프링이 개발의 복잡도를 낮춰주고 효과적으로 프로그래밍을 할 수 있도록 구체적으로 어떻게 가능하게 하는지 공부해보자. 🌩 POJO 란? 유명한 스프링의 삼각형으로 기본 컨텍스트를 맞추고 설명을 시작해보자. 스프링은 POJO에 주요기술인 IoC/DI, AOP, PSA를 사용한 코드와 POJO가 어떻게 관계를 맺고 동작하는지 정의한 설계정보로 구분된다. 스프링에서 DI는 유연하게 확장 가능한 오브젝트를 만들고, 그 관계를 외부에서 dynamic하게 설정해주는 것이며 스프링에서는 이 아이디어를 전반에 걸쳐서 적용한다. POJO는 EJB처럼 복잡하고 제한이 많은 기술로 엔터프라이즈 애플리케이션의 비지니스 로직을 구현하는 것보다 순수 자바 객체를 사용하여 비지니스 로직을 구현하는 것이 더 좋다고 생각하여 …","frontmatter":{"date":"November 15, 2021","title":"스프링, POJO 프레임워크가 무슨 뜻일까","categories":"스프링 웹","author":"코다","emoji":"🍀"},"fields":{"slug":"/spring-pojo/"}},"next":{"id":"0f7262a6-8cc3-5ad6-a8f8-5c468e91c6c6","html":"<h2 id=\"-intro\" style=\"position:relative;\"><a href=\"#-intro\" aria-label=\" intro permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>💡 Intro</h2>\n<ul>\n<li>인터페이스와 추상클래스의 차이를 명확하게 구분해보자.</li>\n<li>언제 무엇을 쓰는 것이 좋은지 나름의 정의를 내려본다.</li>\n<li>상속의 위험성에 대해서 고민해본다.</li>\n</ul>\n<br>\n<h2 id=\"-추상클래스\" style=\"position:relative;\"><a href=\"#-%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4\" aria-label=\" 추상클래스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 추상클래스</h2>\n<ul>\n<li>추상 클래스는 “미완성 설계도” 이다.</li>\n<li>\n<p>공통부분을 우선 정의한 미완성 설계도를 만들고 각기 다른 상황에 대해서 추가로 구현할 수 있다.</p>\n<ul>\n<li>완성되지 않은 abstract 메소드를 포함하고 있다.</li>\n</ul>\n</li>\n<li>추상클래스는 abstract 메소드가 있다는 것을 제외하고는 일반클래스와 동일하다.</li>\n<li><strong>상속은 자손 클래스를 만드는데 조상 클래스를 사용하는 것</strong></li>\n<li><strong>추상화는 자손 클래스의 공통부분을 뽑아내서 조상 클래스를 만드는 것</strong></li>\n</ul>\n<h3 id=\"상속\" style=\"position:relative;\"><a href=\"#%EC%83%81%EC%86%8D\" aria-label=\"상속 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>상속</h3>\n<ul>\n<li>추상클래스를 <code class=\"language-text\">extends</code> 하는 명령어가 상속에서 사용되기 때문에 두 개념이 혼용되어서 사용되기도 한다. 엄밀히 말하면 두 개념이 겹칠수도 있지만 완전히 동일한 것은 아니다.</li>\n<li>\n<p>상속이란 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것</p>\n<ul>\n<li>적은 양의 코드로 새로운 클래스를 작성할 수 있고 공통부분을 관리할 수 있다는 장점이 있다.</li>\n</ul>\n</li>\n<li><strong>상속은 is-a 관계로 표현될 수 있다.</strong></li>\n<li><code class=\"language-text\">**final</code>로 정의된 클래스가 아니라면 모두 상속이 가능하다. 추상클래스는 그 일부분이다.**</li>\n<li>\n<p>상속을 할 때 주의할 점 ‼️</p>\n<ul>\n<li>상속은 조상 클래스의 캡슐화가 깨지는 위험이 있다.</li>\n<li>또한 조상 클래스와 자손 클래스간의 강한 결합이기 때문에 조상 클래스 메서드에 변화가 생기면 자손 클래스에 아무런 변화가 없음에도 다르게 동작할 수 있다.</li>\n<li>따라서 상속보다는 <strong>조합</strong>을 사용하도록 추천한다. (Deck는 Card를 가지고 있다 와 같은 경우에 조합 사용 has-a 관계)</li>\n<li>\n<p>일반 클래스는 <code class=\"language-text\">final</code>을 추가하여 상속을 막거나 미완성 설계도인 abstract 클래스를 정의하도록 추천한다.</p>\n<ul>\n<li>또한 추상클래스의 부모 메소드를 수정하지 않는 것이 좋다.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"왜-자바는-단일-상속일까-single-inheritance\" style=\"position:relative;\"><a href=\"#%EC%99%9C-%EC%9E%90%EB%B0%94%EB%8A%94-%EB%8B%A8%EC%9D%BC-%EC%83%81%EC%86%8D%EC%9D%BC%EA%B9%8C-single-inheritance\" aria-label=\"왜 자바는 단일 상속일까 single inheritance permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>왜 자바는 단일 상속일까? (single inheritance)</h3>\n<ul>\n<li>다중상속을 하게 되면 복합적인 기능을 가진 클래스를 손쉽게 구현할 수 있지만 클래스 간 관계가 굉장히 복잡해진다.</li>\n<li>여러 다른 클래스로 상속받은 멤버의 이름이나 메서드가 같은 경우 구별도 어렵다.</li>\n</ul>\n<br>\n<h2 id=\"-인터페이스\" style=\"position:relative;\"><a href=\"#-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4\" aria-label=\" 인터페이스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 인터페이스</h2>\n<ul>\n<li>인터페이스는 “기본 설계도”이다. (추상클래스는 “미완성 설계도”)</li>\n<li>인터페이스는 면대면이 만나는 부분이라는 뜻을 가지고 있으며 2개의 구성요소가 상호작용할 수 있도록 접속 경계를 연결하는 부분이다. (플러그와 같은 역할)</li>\n<li>인터페이스끼리 상속받을 수 있으며 다중상속이 가능하다.</li>\n<li>인터페이스는 <code class=\"language-text\">implements</code> 를 사용해서 구현하며 다중구현이 가능하다.</li>\n<li>\n<p>인터페이스는 구현 메서드나 멤버 필드가 없다.</p>\n<ul>\n<li>default 메서드가 가능하도록 jdk1.8부터 추가가 되었고, static 변수만 가능하다.</li>\n</ul>\n</li>\n<li>인터페이스는 해당 인터페이스를 구현하는 모든 클래스가 특정 메소드를 반드시 구현하도록 강제하는 역할을 한다 → 따라서 명세의 역할을 한다고도 한다.</li>\n</ul>\n<h3 id=\"추상클래스와의-차이점\" style=\"position:relative;\"><a href=\"#%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90\" aria-label=\"추상클래스와의 차이점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>추상클래스와의 차이점</h3>\n<ul>\n<li>우선 구현메서드 존재 여부, 필드 존재 여부, 다중 상속 및 구현에 대한 차이점이 존재한다</li>\n<li>추상클래스는 공통기능에 대한 재사용과 정제의 역할을 한다. (정제란 불완전한 행동을 완전하게 만드는 것을 의미)</li>\n<li>인터페이스는 구현체가 특정 메소드가 반드시 존재하도록 하는 역할을 하여 특정 기능을 반드시 제공한다는 것을 보장하는 역할을 한다.</li>\n</ul>\n<h3 id=\"동일-메서드를-가진-인터페이스\" style=\"position:relative;\"><a href=\"#%EB%8F%99%EC%9D%BC-%EB%A9%94%EC%84%9C%EB%93%9C%EB%A5%BC-%EA%B0%80%EC%A7%84-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4\" aria-label=\"동일 메서드를 가진 인터페이스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>동일 메서드를 가진 인터페이스</h3>\n<ul>\n<li>\n<p>동일한 메서드 명과 시그니처를 가진 메서드가 두 개의 인터페이스에 있을때는 어떻게 할까?</p>\n<ul>\n<li>이때는 컴파일 오류로 충돌을 해결해야만 컴파일이 가능하다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-느낀-점\" style=\"position:relative;\"><a href=\"#-%EB%8A%90%EB%82%80-%EC%A0%90\" aria-label=\" 느낀 점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🛋 느낀 점</h2>\n<ul>\n<li>\n<p>추상클래스와 인터페이스는 역할 자체가 다르다.</p>\n<ul>\n<li>추상 클래스는 정제의 역할을 인터페이스는 기능 구현 강제의 역할을 한다.</li>\n<li>인터페이스를 통해서는 중복을 해결할 수 없다. 어떤 두 요소가 연결되기 위해 사전에 정의한 기능들이 모두 구현이 된다는 것을 보장할 뿐이다.</li>\n<li>상속은 부모 클래스의 캡슐화가 깨지기 때문에 조합을 이용하는 것이 더 적절하다.</li>\n</ul>\n</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#-intro\">💡 Intro</a></li>\n<li>\n<p><a href=\"#-%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4\">🌩 추상클래스</a></p>\n<ul>\n<li><a href=\"#%EC%83%81%EC%86%8D\">상속</a></li>\n<li><a href=\"#%EC%99%9C-%EC%9E%90%EB%B0%94%EB%8A%94-%EB%8B%A8%EC%9D%BC-%EC%83%81%EC%86%8D%EC%9D%BC%EA%B9%8C-single-inheritance\">왜 자바는 단일 상속일까? (single inheritance)</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4\">🌩 인터페이스</a></p>\n<ul>\n<li><a href=\"#%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90\">추상클래스와의 차이점</a></li>\n<li><a href=\"#%EB%8F%99%EC%9D%BC-%EB%A9%94%EC%84%9C%EB%93%9C%EB%A5%BC-%EA%B0%80%EC%A7%84-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4\">동일 메서드를 가진 인터페이스</a></li>\n</ul>\n</li>\n<li><a href=\"#-%EB%8A%90%EB%82%80-%EC%A0%90\">🛋 느낀 점</a></li>\n</ul>\n</div>","frontmatter":{"date":"November 15, 2021","title":"추상클래스와 인터페이스 더 이상 헷갈리지 않기","categories":"자바","author":"코다","emoji":"✊"},"fields":{"slug":"/java-abstract-vs-interface/"}},"prev":{"id":"b07a3ebb-de77-55b2-820a-0f1162a587a2","html":"<h2 id=\"-intro\" style=\"position:relative;\"><a href=\"#-intro\" aria-label=\" intro permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>💡 Intro</h2>\n<ul>\n<li>스프링에서 어느날 등장한 개념은 아니고 어떠한 이름으로든 사용이 되고 있던 기술인데 스프링에서 더 잘 사용되도록 특정 형태를 부여했다.</li>\n<li>이 3가지 기술들이 그 자체로 스프링이기보다 POJO 기반 엔터프라이즈 개발을 편하게 해줄 수 있는 일종의 도구이다. 즉, 객체지향적인 구현에 충실하면서 자연스럽게 등장하게 된 결과라고 할 수 있다.</li>\n<li>스프링에서 제공하는 PSA, AOP만 사용하는 것이 아니라 그 개념을 차출하여 객체지향적 구현을 하는 것이 중요하다.</li>\n</ul>\n<br>\n<h2 id=\"-iocdi\" style=\"position:relative;\"><a href=\"#-iocdi\" aria-label=\" iocdi permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 IoC/DI</h2>\n<ul>\n<li>AOP, PSA도 IoC/DI에 바탕을 두고 있는 기술이다.</li>\n<li>느슨한 결합을 위해 인터페이스를 두고 실제 구현체를 DI를 통해 외부에서 주입하는 것이다.</li>\n</ul>\n<h3 id=\"왜-강한-결합보다-느슨한-결합이-나은가\" style=\"position:relative;\"><a href=\"#%EC%99%9C-%EA%B0%95%ED%95%9C-%EA%B2%B0%ED%95%A9%EB%B3%B4%EB%8B%A4-%EB%8A%90%EC%8A%A8%ED%95%9C-%EA%B2%B0%ED%95%A9%EC%9D%B4-%EB%82%98%EC%9D%80%EA%B0%80\" aria-label=\"왜 강한 결합보다 느슨한 결합이 나은가 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>왜 강한 결합보다 느슨한 결합이 나은가?</h3>\n<ul>\n<li>유연한 확장이 가능하게 하기 위해서 → OCP</li>\n<li>\n<p>변경에 닫혀있다는 것은 <strong>재사용이 가능하다</strong> 라는 뜻이다.</p>\n<ul>\n<li>A → B 의존관계일 때 B가 변경이 되어도 A가 아무 영향을 받지 않으면 A 입장에서는 폐쇄이며 B 관점에서는 유연한 확장이다.</li>\n<li>B가 B1, B2, B3로 바뀔수도 있고, A는 그대로 재사용이 가능하기 때문이다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"di의-활용-방법-및-장점\" style=\"position:relative;\"><a href=\"#di%EC%9D%98-%ED%99%9C%EC%9A%A9-%EB%B0%A9%EB%B2%95-%EB%B0%8F-%EC%9E%A5%EC%A0%90\" aria-label=\"di의 활용 방법 및 장점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>DI의 활용 방법 및 장점</h3>\n<ol>\n<li>\n<p>핵심기능의 변경</p>\n<ul>\n<li>구현체를 바꿀 수 있다.</li>\n<li>예를 들어 DAO를 사용하고 그 구현을 JDBC, JPA 하이버네이트, JDO 등으로 바꿀 수 있다.</li>\n</ul>\n</li>\n<li>\n<p>핵심기능의 동적인 변겅</p>\n<ul>\n<li>애플리케이션 동작 중간에 의존 대상을 다이나믹하게 변경할 수 있다.</li>\n<li>예를들어 사용자의 입력에 따라서 다른 DataSource를 사용하게 만들 수 있다.</li>\n<li>기술적으로 프록시를 활용한 것인데 이것은 DI 없이는 불가능한 기술이다.</li>\n</ul>\n</li>\n<li>\n<p>부가기능의 추가</p>\n<ul>\n<li>핵심 기능은 그대로 둔 채 부가기능을 추가하는 데코레이터 패턴과 같은 것이다.</li>\n<li>DI를 사용해서 데코레이터 패턴을 쉽게 적용할 수 있다.</li>\n<li>클라이언트 코드에는 영향을 주지 않으면서 부가기능 추가가 가능하다.</li>\n<li>부가 작업을 특정 오브젝트를 대상으로 하는 것이 아니라 많은 대상으로 일반화 한다면 AOP가 되는 것이다.</li>\n</ul>\n</li>\n<li>\n<p>인터페이스의 변경</p>\n<ul>\n<li>클라이언트에서 사용하는 인터페이스와 오브젝트의 인터페이스가 일치하지 않을 때 DI를 활용하여 어댑터 패턴을 응용할 수 있다.</li>\n<li>예를 들어 A가 B인터페이스에 의존하지만 C 오브젝트를 사용하고자 할 때, B 인터페이스를 상속하고 C기능을 제공하는 어댑터를 구현하여 해결할 수 있다.</li>\n<li>\n<p>일반화하여 인터페이스가 다양한 구현을 같은 방식으로 사용하도록 할 수도 있다. → PSA</p>\n<ul>\n<li>구현체는 다양하지만 클라이언트 입장에서는 같은 방식으로 늘 사용하는 것이다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>프록시</p>\n<ul>\n<li>필요한 시점에서 실제로 사용할 오브젝트를 초기화해고 지연된 로딩을 적용할 때 사용할 수 있다.</li>\n</ul>\n</li>\n<li>\n<p>템플릿과 콜백 </p>\n<ul>\n<li>작업의 흐름 사이에 자주 바뀌는 부분을 템플릿과 콜백으로 만들고 DI 원리를 사용하면 코드를 간결하게 구현할 수 있다.</li>\n</ul>\n</li>\n<li>\n<p>싱글톤과 오브젝트 스코프</p>\n<ul>\n<li>DI하는 오브젝트의 생명주기를 제어할 수 있다. DI를 컨테이너가 한다면 오브젝트의 생명주기를 마음대로 관리하고 제어할 수 있다.</li>\n<li>기본 스코프는 싱글톤이다. 웹 엔터프라이즈는 수많은 클라이언트를 대상으로 서비스를 제공해야하기 때문에 여러 스레드의 요청을 동시에 처리할 수 있도록 하기 위해서다.</li>\n<li>전통적인 싱글톤은 오브젝트에 많은 제약을 가했지만 IoC 방식의 싱글톤은 자유로운 설계가 가능하다.</li>\n</ul>\n</li>\n<li>\n<p>테스트</p>\n<ul>\n<li>오브젝트를 효과적으로 테스트하기 위해서는 오브젝트가 고립되어야 한다.</li>\n<li>다른 오브젝트와 협력하는 부분을 테스트하기 위해서는 환경 전체를 테스트해야한다는 부담감이 있다.</li>\n<li>\n<p>DI를 한다면 의존 오브젝트를 대신하여 스텁 혹은 목 오브젝트 같이 테스트 대역을 할 수 있다.</p>\n<ul>\n<li>\n<p>번외) stub과 mock의 차이</p>\n<p>stub은 더미 객체를 사용하여 실제로 동작하는 것 처럼 보이도록 하는 것이다. 상태검증을 한다. </p>\n<p>mock은 기대값을 명세하고 특정 결과를 반환하도록 하는 것이다. 행위검증을 한다. </p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<br>\n<h2 id=\"-aop\" style=\"position:relative;\"><a href=\"#-aop\" aria-label=\" aop permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 AOP</h2>\n<ul>\n<li>관점 지향 프로그래밍이라고도 많이 알려져 있다.</li>\n<li>관심사가 같은 코드를 분리해 객체지향의 원칙에 따라서 분리하고 응집된 것들을 한 곳에 모으는 것이 좋다.</li>\n<li>\n<p>트랜잭션의 경우</p>\n<ul>\n<li>트랜잭션은 한 곳에 모을 수 없고 여기저기에 흩어져있다. 따라서 모듈화가 힘들다.</li>\n<li>부가기능이기 때문에 스스로 독립적인 방식으로 존재하는 것이 어렵다.</li>\n<li>흩어져있는 부가로직을 분리하여 중복되지 않고, 변경이 필요한 경우 한 곳만 변경할 수 있도록 하는 것이 AOP의 역할이다.</li>\n</ul>\n</li>\n<li>Aspect는 부가 기능을 정의한 advice와 해당 advice를 적용할 포인트컷을 가지고 있다.</li>\n<li>부가기능이 핵심기능 모듈에 침투하면서 핵심기능을 파악하고 수정하고 테스트하기 어렵다.</li>\n<li>\n<p>AOP와 OOP</p>\n<ul>\n<li>AOP와 OOP가 대체관계라고 생각할 수 있지만 사실 보조하는 기술이다.</li>\n<li>부가기능이 핵심기능 안으로 침투하면 핵심기능에 객체지향 기술을 부여하기 힘들고 테스트하기 어려움으로 AOP로 해당 로직을 분리하여 객체지향적인 가치를 지킬 수 있도록 해주는 것이다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-psa\" style=\"position:relative;\"><a href=\"#-psa\" aria-label=\" psa permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 PSA</h2>\n<ul>\n<li>환경과 세부 기술의 변화와 관계없이 일관된 방식으로 기술에 접근할 수 있다.</li>\n<li>\n<p>POJO 코드가 JavaEE에 직접 노출되지 않도록 해준다.</p>\n<ul>\n<li>예를 들어서 트랜잭션이라는 엔터프라이즈 기술을 직접 POJO에 노출하는 것이 아니라 일관적인 서비스 추상화 기술의 형태로 제공해준다.</li>\n</ul>\n</li>\n<li>대신 설정을 통해 추상화 된 부분에 어떤 기술을 할 것인지 지정해주어야한다.</li>\n</ul>\n<br>\n<h2 id=\"-느낀-점\" style=\"position:relative;\"><a href=\"#-%EB%8A%90%EB%82%80-%EC%A0%90\" aria-label=\" 느낀 점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🛋 느낀 점</h2>\n<ul>\n<li>스프링 프레임워크의 목적은 “엔터프라이즈 기술을 사용하되 비즈니스 로직을 객체지향적으로 구현하고자 하는 것”이다.</li>\n<li>이해하기 어려운 스프링 프레임워크의 기술도 이 관점으로 보면 나름 이해할 수 있다.</li>\n<li>그리고 그 모든 기술의 기반은 바로 DI 다 !! 추상적으로 구현하여 확장성을 보장하고 변경에 자유로운 객체지향적 코드를 구현할 수 있도록 해준다.</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#-intro\">💡 Intro</a></li>\n<li>\n<p><a href=\"#-iocdi\">🌩 IoC/DI</a></p>\n<ul>\n<li><a href=\"#%EC%99%9C-%EA%B0%95%ED%95%9C-%EA%B2%B0%ED%95%A9%EB%B3%B4%EB%8B%A4-%EB%8A%90%EC%8A%A8%ED%95%9C-%EA%B2%B0%ED%95%A9%EC%9D%B4-%EB%82%98%EC%9D%80%EA%B0%80\">왜 강한 결합보다 느슨한 결합이 나은가?</a></li>\n<li><a href=\"#di%EC%9D%98-%ED%99%9C%EC%9A%A9-%EB%B0%A9%EB%B2%95-%EB%B0%8F-%EC%9E%A5%EC%A0%90\">DI의 활용 방법 및 장점</a></li>\n</ul>\n</li>\n<li><a href=\"#-aop\">🌩 AOP</a></li>\n<li><a href=\"#-psa\">🌩 PSA</a></li>\n<li><a href=\"#-%EB%8A%90%EB%82%80-%EC%A0%90\">🛋 느낀 점</a></li>\n</ul>\n</div>","frontmatter":{"date":"November 16, 2021","title":"스프링 3대 개념 - IoC/DI, AOP, PSA","categories":"스프링 웹","author":"코다","emoji":"🍀"},"fields":{"slug":"/spring-ioc-aop-psa/"}},"site":{"siteMetadata":{"siteUrl":"https://yjksw.github.io","comments":{"utterances":{"repo":"yjksw/yjksw.github.io"}}}}},"pageContext":{"slug":"/spring-pojo/","nextSlug":"/java-abstract-vs-interface/","prevSlug":"/spring-ioc-aop-psa/"}},"staticQueryHashes":["1073350324","2938748437"]}
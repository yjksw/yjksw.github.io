{"componentChunkName":"component---src-templates-blog-template-js","path":"/controller-vs-restcontroller/","result":{"data":{"cur":{"id":"154e5bdf-92b6-5e1e-a764-8f5e8aa71162","html":"<p>제일 핵심이 되는 차이점은 HTTPResponse Body의 생성 방식이다. </p>\n<h2 id=\"controller\" style=\"position:relative;\"><a href=\"#controller\" aria-label=\"controller permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>@Controller</h2>\n<p>본래 Spring MVC 컨트롤러의 주 역할은 View를 반환하는 것이다. </p>\n<p>아래 사진을 보면, 클라이언트가 URL을 통해서 Dispatcher Servlet 에 요청을 보내면 적절한 Handler를 매핍하고 컨트롤러에서 해당 View를 <code class=\"language-text\">ViewResolver</code>를 통해서 반환한다.  </p>\n<p align=\"center\"><img width=\"85%\" src=\"https://user-images.githubusercontent.com/63405904/134930324-a380f854-7718-4ef1-8161-1fe94cdd2e30.png\"></p>\n<p>하지만 컨트롤러는 항상 View를 반환하는 것이 아니라 data도 반환해야한다. 이때는 @ResponseBody 어노테이션을 통해서 Json 형태로 클라이언트에 데이터를 반환할 수 있도록 해야 한다. 이때는 View를 반환할 때 사용하는 ViewResolver를 반환하는 것이 아니라 HttpMessageConverter 을 사용해서 데이터를 반환한다. </p>\n<p align=\"center\"><img width=\"85%\" src=\"https://user-images.githubusercontent.com/63405904/134930518-240c33bd-f309-47d1-b836-2ad737a5c201.png\"></p>\n<p>따라서 Data를 반환하는 응답에 대해서는 <code class=\"language-text\">@ResponseBody</code>를 붙여주어야하는데 매번 그러기가 번거로우니 Controller에 <code class=\"language-text\">@ResponseBody</code>가 자동으로 붙어있는 <code class=\"language-text\">@RestController</code>가 등장하게 된 것이다.</p>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#controller\">@Controller</a></li>\n</ul>\n</div>","excerpt":"제일 핵심이 되는 차이점은 HTTPResponse Body의 생성 방식이다.  @Controller 본래 Spring MVC 컨트롤러의 주 역할은 View를 반환하는 것이다.  아래 사진을 보면, 클라이언트가 URL을 통해서 Dispatcher Servlet 에 요청을 보내면 적절한 Handler를 매핍하고 컨트롤러에서 해당 View를 를 통해서 반환한다.   하지만 컨트롤러는 항상 View를 반환하는 것이 아니라 data도 반환해야한다. 이때는 @ResponseBody 어노테이션을 통해서 Json 형태로 클라이언트에 데이터를 반환할 수 있도록 해야 한다. 이때는 View를 반환할 때 사용하는 ViewResolver를 반환하는 것이 아니라 HttpMessageConverter 을 사용해서 데이터를 반환한다.  따라서 Data를 반환하는 응답에 대해서는 를 붙여주어야하는데 매번 그러기가 번거로우니 Controller에 가 자동으로 붙어있는 가 등장하게 된 것이다. @Controller","frontmatter":{"date":"April 28, 2021","title":"@Controller vs. @RestController","categories":"스프링부트","author":"코다","emoji":"🖥"},"fields":{"slug":"/controller-vs-restcontroller/"}},"next":{"id":"b2092703-9d70-568e-bdb1-6b1553adfc63","html":"<blockquote>\n<p>다음은 우아한테크코스를 시작한지 얼마 되지 않은 시점에 쓴 글 입니다. 진솔한 마음으로 써서 올려봅니다 😶</p>\n</blockquote>\n<br>\n<h2 id=\"-국제학교-나온-문과생이-개발자를-꿈꾸기까지\" style=\"position:relative;\"><a href=\"#-%EA%B5%AD%EC%A0%9C%ED%95%99%EA%B5%90-%EB%82%98%EC%98%A8-%EB%AC%B8%EA%B3%BC%EC%83%9D%EC%9D%B4-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%A5%BC-%EA%BF%88%EA%BE%B8%EA%B8%B0%EA%B9%8C%EC%A7%80\" aria-label=\" 국제학교 나온 문과생이 개발자를 꿈꾸기까지 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>💭 국제학교 나온 문과생이 개발자를 꿈꾸기까지</h2>\n<p>“너 컴퓨터 전공이니까 와서 이것 좀 고쳐봐” </p>\n<p>컴퓨터 전공으로 전과하고 가장 많은 들은 말이다. 사실 나도 흔히 컴퓨터 공학을 전공하면 컴퓨터를 잘 고칠(?) 거로 생각하는 사람들 중 하나였다. 코딩이 무엇인지도 모르는 사람 말이다. 그리고 대학교 1학년 때 처음 코딩을 접했다. 교양 필수였던 <code class=\"language-text\">C 프로그래밍</code> 수업을 통해서 말이다. 국제 중고등학교를 나와서 국제 정치학 전공을 선택한 나에게 그렇게 우연히 코딩의 기회가 닿았다. </p>\n<p><code class=\"language-text\">이 친구 진짜 솔직하구나</code> 코딩의 첫인상이다. 누군가 나에게 어떤 종류의 사람들을 좋아하느냐고 물어본다면 단번에 <code class=\"language-text\">솔직한 사람</code>이라고 대답할 것이다. 눈속임으로 알맹이가 없는 것을 있는 것처럼 꾸미는 것보다 담백하게 있으면 있거나 없으면 없다고 말하는 사람이나 글을 좋아한다. 그런 의미에서 코드는 정말 너무나도 정직하다. 있어야 할 것만 딱 있어야지 가장 잘 돌아간다. 잘못 짰다면 실행되지 않는다. 괜히 있어보이려고 이것저것 추가하면 작동 시간만 늘어날 뿐 아무런 이득을 주지 않는다. 코드는 거짓말을 하지 않는다. </p>\n<p>코딩의 두 번째 매력은 <code class=\"language-text\">기승전결과 논리적 흐름이 있는 글</code>이라는 것이다. 우선 본캐는 문과생이기 때문에 글을 좋아한다. 좋은 글은 처음, 중간, 끝이 있고 앞 문장과 뒷 문장이 논리적으로 연결이 되어야 한다. 한마디로 표현하면 일단 <code class=\"language-text\">말이 되어야 한다</code>. 무언가랑 많이 닮지 않았나? 코드는 시작 시점과 중간 처리 과정 마무리(출력 혹은 저장) 과정이 있다. 그리고 그사이를 메꾸는 코드 한줄 한줄은 논리적인 흐름에 따라서 앞 과정과 그다음 과정이 이어져야 한다. </p>\n<p>‘나랑 잘 맞네?’ 문과생이 개발자를 꿈꾸게 된 매우 단순한 이유다. </p>\n<br>\n<h2 id=\"-첫-발자국-자취\" style=\"position:relative;\"><a href=\"#-%EC%B2%AB-%EB%B0%9C%EC%9E%90%EA%B5%AD-%EC%9E%90%EC%B7%A8\" aria-label=\" 첫 발자국 자취 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🐾 첫 발자국 자취</h2>\n<p>‘우아한테크코스’에 입문하기 위한 첫 발걸음은 프리코스다. 포비의 말을 인용하자면 <code class=\"language-text\">우테코도 나를 탐색하고 나도 우테코를 탐색하는 시간</code>. 탐색을 정말 열심히 했더랬다. Notion에 미션내용과 요구사항 분석한 것, 매일 해야 할 Todo와 회고를 정리했다. 우테코 생활을 한 달 넘게 한 이 시점에서 글을 쓰기 위해서 다시 한번 들여다보았다. </p>\n<p align=\"center\">\n<img src=\"https://user-images.githubusercontent.com/63405904/111900110-eacb5b80-8a73-11eb-8abc-d943b79ee484.png\" width=\"60%\" height=\"70%\" alt=\"첫 발을 잘 내딪자고 다짐하며 고른 발자국 이모지\">\n</p>\n<p>프리코스 첫 번째 미션을 시작했을 때 작성했던 <code class=\"language-text\">나만의 규칙 ver1.</code>이 마지막 미션 <code class=\"language-text\">나만의 규칙 ver3.</code>가 되기까지 짧다면 짧은 3주 동안 늘어난 규칙만큼 성장했다. 중간에 너무 좌절하지 않으려고 애를 써야 했던 시간도 있었지만 너무 재미있어서 반드시 합격하고 싶다는 간절함도 커졌다. 그리고 노력하고 기다린 끝에 루터회관 14층에 입성! </p>\n<p align=\"center\">\n<img src=\"https://user-images.githubusercontent.com/63405904/111900120-ffa7ef00-8a73-11eb-8c2c-6628fb29f434.png\" width=\"80%\" alt=\"프리코스를 진행하며 덧붙인 나만의 규칙 목록 변천사\">\n</p>\n<br>\n<h2 id=\"️-일단-루터회관-14층이-마음에-든-이유\" style=\"position:relative;\"><a href=\"#%EF%B8%8F-%EC%9D%BC%EB%8B%A8-%EB%A3%A8%ED%84%B0%ED%9A%8C%EA%B4%80-14%EC%B8%B5%EC%9D%B4-%EB%A7%88%EC%9D%8C%EC%97%90-%EB%93%A0-%EC%9D%B4%EC%9C%A0\" aria-label=\"️ 일단 루터회관 14층이 마음에 든 이유 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>☘️ 일단 루터회관 14층이 마음에 든 이유</h2>\n<p>첫 번째는 초록색이다. 한달 동안 온라인으로 진행하다가 3월 초 처음 교육장에 들어왔을 때 초록초록하고 싱그러운 분위기가 나를 맞았다. 눈이 좋아지겠구나 싶었다. 포근한 소파랑 빈백, 위트있는 문구들도 마음에 들었다. 본래 도서관같이 정숙하는 분위기보다 일상 소음이 있는 카페에서 더 집중을 잘하는 스타일이다. 역시 나랑 잘 맞네 ㅎㅎ</p>\n<p>두 번째는 같은 곳을 향해 가는 실력있는 크루들이다. 쇼파에 앉아서 무언가를 하고 있으면 지나가던 크루들이 와서 뭐하냐고 물어본다. 쓸모 있는 얘기도 하고 쓸모 없는 얘기도 하는 데 둘 다 좋다. 모르는 것들을 물어보면 자기가 공부한 것을 설명한다. 모르면 같이 찾아본다. 그리고 지루하면 딴짓을 하면서 조금 쉰다. 프리코스를 하면서 가장 힘들었던 것은 ‘내가 지금 잘하고 있나?’ 확신할 수 없었던 것이다. 잘못된 방향으로 열심히 달리고 있었던 것이면 어쩌지 하는 고민. 그러나 우테코에서는 그것을 걱정할 필요가 없다. 루터회관 14층에는 어디를 가도 물어볼 크루와 코치가 있다는 것이 가장 마음에 든다.</p>\n<br>\n<h2 id=\"-좋은-개발자가-되고-싶은데\" style=\"position:relative;\"><a href=\"#-%EC%A2%8B%EC%9D%80-%EA%B0%9C%EB%B0%9C%EC%9E%90%EA%B0%80-%EB%90%98%EA%B3%A0-%EC%8B%B6%EC%9D%80%EB%8D%B0\" aria-label=\" 좋은 개발자가 되고 싶은데 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>👾 좋은(?) 개발자가 되고 싶은데..</h2>\n<p>그럼 좋은 개발자가 뭐지? 지금 시점에서 되돌아보니, 우테코 레벨1 동안은 <code class=\"language-text\">좋은 개발자</code>에 대한 정의를 내리는 기간이라고 할 수 있을 것 같다. 정리하면 다음 두 가지를 갖춘 개발자다.</p>\n<ol>\n<li>같이 일하고 싶은 개발자</li>\n<li>좋은 코드를 작성하는 개발자</li>\n</ol>\n<p>먼저 내 동료에게 좋은 개발자이다. 페어 프로그래밍을 하면서 내가 좋은 페어였을까 돌아보면서 두 가지 질문을 했다. 페어에게 좋은 피드백을 했는지, 그리고 페어의 피드백을 잘 받아들였는지. 두 가지가 적당히 잘 어우러져야 좋은 페어다. 흔히 개발자는 혼자 컴퓨터랑만 이야기하는 이미지가 강한데 사실 그렇지 않다. 내가 짜는 코드도 페어가 이해하기 쉽도록 배려심이 가득한 코드여야 한다.</p>\n<p>두 번째는 좋은 코드를 작성하는 개발자다. 이건 좀 어렵다. 배운 키워드로 말하자면 TDD, 객체지향, 코드 컨벤션 등을 잘 적용해야 한다. 처음에는 <code class=\"language-text\">내가 보기 좋은 코드</code>를 짠다. 그다음에는 <code class=\"language-text\">페어가 보기 좋은 코드</code>. 그리고 그다음에는 <code class=\"language-text\">리뷰어가 보기에 좋은 코드</code>. 이 정도 오면 충돌 지점이 생긴다. 각자 보기에 좋은 코드가 다른 형태일 때가 오는 것이다. 그럼.. <code class=\"language-text\">포비가 보기에 좋은 코드</code>?</p>\n<br>\n<h2 id=\"-그래서-답을-좀-찾았어\" style=\"position:relative;\"><a href=\"#-%EA%B7%B8%EB%9E%98%EC%84%9C-%EB%8B%B5%EC%9D%84-%EC%A2%80-%EC%B0%BE%EC%95%98%EC%96%B4\" aria-label=\" 그래서 답을 좀 찾았어 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🤔 그래서 답을 좀 찾았어?</h2>\n<p>결론부터 말하자면 ‘아니요’ 이다. 우테코 레벨1을 지나면서 많은 것을 듣고 배웠지만 지금은 답을 정의할 때가 아니라 질문을 던질 때다. 그냥 질문이 아니라 좋은 질문을. 좋은 코드가 무엇일지 끊임없이 고민하면서 이런 코드 저런 코드를 탐색해야한다. 좋은 개발자가 무엇일지, 좋은 기술이 무엇일지, 정말 성장하고 있는지 스스로 물어봐야한다. 생각에 생각을 더하고 시야를 넓히는 질문을 던져야할 때다.</p>\n<p>그럴싸한 답은 아직 없지만.. 우선은 정직한 코드가 내가 애쓴 시간을 그대로 보여줄 때까지 열심히 해보는 수밖에! </p>","frontmatter":{"date":"March 30, 2021","title":"개발자를 본격 꿈꾸기 시작하면서 나의 마음가짐","categories":"아무말","author":"코다","emoji":"💡"},"fields":{"slug":"/start-journey-as-programmer/"}},"prev":{"id":"75f61000-50f8-58be-a445-5bda37396ef5","html":"<h2 id=\"트랜잭션을-사용하는-이유\" style=\"position:relative;\"><a href=\"#%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0\" aria-label=\"트랜잭션을 사용하는 이유 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>트랜잭션을 사용하는 이유</h2>\n<p>트랜잭션을 사용하면 각각의 단위로 나누어져있는 작업의 단위를 하나로 합칠 수 있다. 즉, 일련의 연산들을 하나의 독립된 작업 단위로 보고 <strong>하나</strong>로 취급하기 위해서 사용하는 것이다. <br></p>\n<p>언제 일련의 연산들을 하나로 봐야 할 때가 생길까? <br></p>\n<p>예를 들어서 돈을 송금하는 시스템이 있다고 가정해보자. 계좌A에서 계좌B로 돈을 송금해야 할 때, 계좌A에 충분한 잔액이 있는 것을 확인하고 돈을 송금하기 위해서 돈을 차감했다. 그리고 계좌B에 입금을 하려고 하는 순간 예외가 발생하면서 입금을 하지 못했다. 그런데 계좌A에서는 여전히 돈이 차감된 상태이다. 중간에 송금하려고 했던 돈이 사라지게 된 것이다. <br></p>\n<p>이때, 위의 과정을 <code class=\"language-text\">@Transactional</code>로 관리를 하게 된다면 위의 여러 작업들을 하나의 단위로 보고 중간에 예외가 발생한다면 위에서 실행중이던 작업을 한꺼번에 롤백해준다. </p>\n<h2 id=\"트랜잭션-기본-방법\" style=\"position:relative;\"><a href=\"#%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EA%B8%B0%EB%B3%B8-%EB%B0%A9%EB%B2%95\" aria-label=\"트랜잭션 기본 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>트랜잭션 기본 방법</h2>\n<p>2개 이상의 쿼리를 하나의 커넥션으로 묶어 DB에 전송하고, 에러가 발생할 경우 자동으로 모든 과정을 rollback 한다. 따라서 트랜잭션은 하나 이상의 쿼리를 처리할 때 동일한 connection 객체를 공유하도록 한다. <br></p>\n<p>트랜잭션은 코드기반의 트랜잭션(Programmactic Transaction)과 선언적 트랜잭션(Declarative Transaction)을 지원한다. Spring에서는 어노테이션을 활용한 선언적 트랜잭션을 주로 사용한다. </p>\n<h2 id=\"트랜잭션의-성질\" style=\"position:relative;\"><a href=\"#%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EC%9D%98-%EC%84%B1%EC%A7%88\" aria-label=\"트랜잭션의 성질 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>트랜잭션의 성질</h2>\n<p>워낙 많은 곳에서 트랜잭션의 성질에 대해서 말하지만 기록을 위해서 그대로 한번 옮겨보았다. </p>\n<ul>\n<li>원자성(Atomicity) : 한 트랜잭션 내에서 실행한 작업들을 하나로 간주</li>\n<li>일관성(Consistency) : 일관성 있는 데이터베이스 상태를 유지</li>\n<li>격리성(isolation) : 동시에 실행되는 트랜잭션들이 서로 영향을 미치지 않도록 격리. 따라서 트랜잭션의 동시 접근 데이터에 대한 제어가 필요함</li>\n<li>지속성(Durability) : 트랜잭션 성공시 결과가 항상 저장</li>\n</ul>\n<h2 id=\"다수의-트랜잭션-실행-시-발생-가능한-문제상황\" style=\"position:relative;\"><a href=\"#%EB%8B%A4%EC%88%98%EC%9D%98-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EC%8B%A4%ED%96%89-%EC%8B%9C-%EB%B0%9C%EC%83%9D-%EA%B0%80%EB%8A%A5%ED%95%9C-%EB%AC%B8%EC%A0%9C%EC%83%81%ED%99%A9\" aria-label=\"다수의 트랜잭션 실행 시 발생 가능한 문제상황 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>다수의 트랜잭션 실행 시 발생 가능한 문제상황</h2>\n<p><strong>Dirty Read</strong></p>\n<ul>\n<li>A가 변경 후 커밋하지 않은 상태에서 B가 조회를 한다.</li>\n<li>A가 중간에 문제가 생겨서 롤백되었으면 B는 잘못된 값을 조회한 상황이 된다.</li>\n</ul>\n<p><strong>Non-Repeatable Read</strong> </p>\n<ul>\n<li>A가 반복적으로 쿼리를 사용하는 사이에 B가 값을 변경하고 커밋을 해서, A의 쿼리 중간에 결과가 달라지는 상황이 된다.</li>\n<li>한 트랜잭션 안에서 같은 쿼리를 두번 실행했을 때, 데이터 불일치 문제 발생.</li>\n</ul>\n<p><strong>Phantom Read</strong> </p>\n<ul>\n<li>A가 특정 범위를 조회하는 쿼리를 두번 이상 실행할 때, B가 중간에 값을 추가해서 이후 실행된 A의 쿼리에 이전에 없던 유령 데이터가 생기는 문제가 발상한다.</li>\n</ul>\n<h2 id=\"문제상황을-해결하기-위한-격리수준\" style=\"position:relative;\"><a href=\"#%EB%AC%B8%EC%A0%9C%EC%83%81%ED%99%A9%EC%9D%84-%ED%95%B4%EA%B2%B0%ED%95%98%EA%B8%B0-%EC%9C%84%ED%95%9C-%EA%B2%A9%EB%A6%AC%EC%88%98%EC%A4%80\" aria-label=\"문제상황을 해결하기 위한 격리수준 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>문제상황을 해결하기 위한 격리수준</h2>\n<p><strong>사용방법</strong></p>\n<p><code class=\"language-text\">@Transactional(isolation = Isolation.DEFAULT)</code></p>\n<p><strong>DEFAULT</strong></p>\n<ul>\n<li>기본 격리 수준이며 DB의 격리수준을 따른다.</li>\n<li>MySql → Repeatable-read, Oracle → Read committed</li>\n</ul>\n<p><strong>READ_UNCOMMITED(level 0)</strong> </p>\n<ul>\n<li>커밋되지 않은 데이터에 대한 읽기를 허용</li>\n<li>Dirty Read 발생 가능</li>\n<li>데이터 잠금을 위한 간접 비용이 적고 교착 상태에 빠질 위험이 없어 성능이 빠름</li>\n</ul>\n<p><strong>READ_COMMITTED(level 1)</strong> </p>\n<ul>\n<li>커밋 확정된 데이터에 대해서만 읽기를 허용</li>\n<li>Dirty Read 방지</li>\n</ul>\n<p><strong>REPEATABLE_READ(level 2)</strong> </p>\n<ul>\n<li>트랜잭션이 완료될 때까지 <code class=\"language-text\">SELECT</code> 하는 데이터에 대해서 shared-lock이 걸리므로 해당 데이터는 수정이 불가하다.</li>\n<li>트랜잭션이 종료되기 전가지 한번 조회한 값은 계속 같은 값으로 조회되도록 한다.</li>\n<li><code class=\"language-text\">Non-Repeatable Read</code> 문제를 방지한다. (같은 값을 반복적으로 조회할 때 중간에 다른 값이 조회되는 문제)</li>\n</ul>\n<p><strong>SERIALIZABLE(level 3)</strong></p>\n<ul>\n<li>트랜잭션이 완료될 때까지 <code class=\"language-text\">SELECT</code> 하는 데이터에 대해서 shared-lock이 걸리므로 해당 데이터는 수정과 입력이 불가하다.</li>\n</ul>\n<p>하지만 격리수준이 올라갈 수록 성능 저하의 우려가 있다는 것을 명심하자. </p>\n<h2 id=\"transaction-안에-transaction--전파속성\" style=\"position:relative;\"><a href=\"#transaction-%EC%95%88%EC%97%90-transaction--%EC%A0%84%ED%8C%8C%EC%86%8D%EC%84%B1\" aria-label=\"transaction 안에 transaction  전파속성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Transaction 안에 Transaction : 전파속성</h2>\n<p>하나의 트랜잭션 안에서 또 다른 트랜잭션이 발생하면 어떻게 처리가 될지 전파속성에 따라서 다르게 관리할 수 있다. 여러가지 전파속성이 있지만,  그중 몇가지만 다루어보자. </p>\n<p><strong>사용방법</strong></p>\n<p><code class=\"language-text\">@Transactional(propagation=Propagation.REQUIRED)</code></p>\n<p><strong>PROPAGATION_MANDATORY</strong></p>\n<p>부모의 트랜잭션 내에서 실행되고 없으면 예외가 발생한다. </p>\n<p><strong>PROPAGATION_NESTED</strong> </p>\n<p>기존에 트랜잭션이 있는 경우, 포함하여서 실행한다. </p>\n<p><strong>PROPAGATION_NEVER</strong> </p>\n<p>트랜잭션이 있는 상황에서 다른 트랜잭션이 실행된다면 예외를 발생한다. </p>\n<p><strong>PROPAGATION_REQUIRED (기본설정)</strong> </p>\n<p>트랜잭션이 있으면 그 상황에서 실행하고, 없으면 새로운 트랜잭션을 실행한다. 즉, 부모의 트랜잭션에서 실행하거나, 없으면 새로운 트랜잭션을 생성하는 것이다. </p>\n<p><strong>PROPAGATION<em>REQUIRED</em>NEW</strong></p>\n<p>자신만의 고유한 트랜잭션을 실행한다. </p>\n<ul>\n<li>전파속성 관련 참고링크: <a href=\"https://happyer16.tistory.com/entry/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EC%A0%84%ED%8C%8C-%EC%86%8D%EC%84%B1-propagation-%EB%A1%A4%EB%B0%B1-%EC%98%88%EC%99%B8\">https://happyer16.tistory.com/entry/트랜잭션-전파-속성-propagation-롤백-예외</a></li>\n</ul>\n<h2 id=\"transaction-추가-옵션\" style=\"position:relative;\"><a href=\"#transaction-%EC%B6%94%EA%B0%80-%EC%98%B5%EC%85%98\" aria-label=\"transaction 추가 옵션 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Transaction 추가 옵션</h2>\n<p><code class=\"language-text\">@Transactional(readOnly = true)</code></p>\n<ul>\n<li>트랜잭션 작업 내에서 쓰기 작업이 일어나면 예외를 발생시킨다.</li>\n</ul>\n<p><code class=\"language-text\">@Transactional(rollbackFor = Exception.class)</code>, <code class=\"language-text\">@Transactional(rollbackForClassName={\"NullPointerException\"})</code></p>\n<ul>\n<li>기본적으로는 런타임 예외에 대해서 롤백을 하는데, 그 대상을 바꿀 수 있다.</li>\n</ul>\n<p><code class=\"language-text\">@Transactional(timeout = 10)</code></p>\n<ul>\n<li>지정한 시간 내에 작업을 완료하도록 설정할 수 있다.</li>\n</ul>\n<p><code class=\"language-text\">@EnableTransactionManagement</code></p>\n<ul>\n<li>빈 인스턴스에 트랜잭션을 적용하도록 한다.</li>\n</ul>\n<br>\n<h2 id=\"트랜잭션-동작-원리\" style=\"position:relative;\"><a href=\"#%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EB%8F%99%EC%9E%91-%EC%9B%90%EB%A6%AC\" aria-label=\"트랜잭션 동작 원리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>트랜잭션 동작 원리</h2>\n<p>일반적으로 JPA를 사용할 때 스프링과 같은 IoC 컨테이너를 사용하지 않을 경우 transaction management 기능을 직접 구현해줘야 한다. 트랜잭션의 흐름은 다음과 같다. </p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">UserTransaction</span> utx <span class=\"token operator\">=</span> entityManager<span class=\"token punctuation\">.</span><span class=\"token function\">getTransaction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n\tutx<span class=\"token punctuation\">.</span><span class=\"token function\">begin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">businessLogin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\tutx<span class=\"token punctuation\">.</span><span class=\"token function\">commit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\tutx<span class=\"token punctuation\">.</span><span class=\"token function\">rollback</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">throw</span> e<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"스프링에서-code-classlanguage-texttransactionalcode\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%ED%94%84%EB%A7%81%EC%97%90%EC%84%9C-code-classlanguage-texttransactionalcode\" aria-label=\"스프링에서 code classlanguage texttransactionalcode permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스프링에서 <code class=\"language-text\">@Transactional</code></h2>\n<p>스프링에서 트랜잭션을 알아서 관리해주지만 troubleshooting을 위해서 내부 동작 원리를 알아야 할 필요가 있다. <br></p>\n<p>이해하기 위해서 필요한 개념 2가지</p>\n<ul>\n<li>the persistence context</li>\n<li>the database transaction</li>\n</ul>\n<p>두번째 개념인 database transaction은 우리가 사용하는 메서드 레벨의 <code class=\"language-text\">@Transactional</code> 로 그 생명주기와 범위가 설명된다. 이 database  transaction은 persistence context의 범위 안에서 일어난다. <br></p>\n<p>JPA에서 persistence context는 <code class=\"language-text\">EntityManager</code>를 말한다. Persistence context는 한정된 자바 객체들의 상태를 확인하고, 변경 사항들이 DB에 반영이 되도록 관리한다. 따라서 database transaction과 비슷하다고 생각할 수 있지만, 둘은 다른 개념이다. 주로 하나의 Entity Manager가 여러 database transactions 에 대해 사용된다. <br></p>\n<p>우선 트랜잭션 동작원리에 대해서 알기 이전에 <code class=\"language-text\">@PersistenceContext</code> 의 동작 방식에 대해서 아는 것이 중요하다.  해당 어노테이션은 컨테이너의 시작 시점에서 단 한번 entity manager를 주입하는 것처럼 보인다. 실은 <code class=\"language-text\">EntityManager</code> 는 인터페이스이고 스프링 빈으로 주입되는 것은 실제 entity manager가 아닌, <em>context aware proxy</em> 이며, runtime 중 실제 entity manager에서 책임을 위임한다.  </p>\n<p><strong>트랜잭션 관리를 위해 필요한 3가지 components</strong></p>\n<ul>\n<li>\n<p>EntityManager Proxy</p>\n<ul>\n<li>비지니스 로직에서 EntityManager 관련 메소드를 호출했을 때 entity manager를 직접적으로 호출하지 않는다. 비지니스 로직은 proxy에 의존하고 해당 proxy가 스레드에서 현재 entity manager를 추출한다.</li>\n</ul>\n</li>\n<li>\n<p>Transactional Aspect</p>\n<ul>\n<li><code class=\"language-text\">TransactionInterceptor</code> 로 구현이 되며, 비지니스 메소드 이전과 이후에 (before &#x26; after) 호출된다.</li>\n<li>Before moment: 실행될 비지니스 메서드가 기존에 실행되고 있는 database transaction의 범위 내에서 실행되어야 하는 것인지, 새로운 transaction을 시작해야 하는지 판단</li>\n<li>After moment: 해당 transaction이 커밋, 롤백, 실행중지 되어야 하는지 등등을 판단</li>\n<li>여기서 ‘before moment’ 에 해당하는 책임은 Transactional Aspect 에서 실제로 담당하지 않고, 판단하는 책임을 Transaction Manager에 위임한다.</li>\n</ul>\n</li>\n<li>\n<p>Transaction Manager</p>\n<ul>\n<li>\n<p>다음 두가지에 대해서 판단 및 처리한다.</p>\n<ol>\n<li>새로운 Entity Manager가 생성되어야 하는지</li>\n<li>새로운 database transaction이 시작되어야 하는지 </li>\n</ol>\n<p>이 두가지는 Transactional Aspect의 ‘before moment’ 로직이 호출되었을 때 판단되어야 한다. </p>\n</li>\n<li>\n<p>판단은 다음에 기반한다.</p>\n<ol>\n<li>다른 transaction의 실행 중 여부</li>\n<li>해당 transaction 메서드의 propagation 속성 (예를 들어 <code class=\"language-text\">REQUIRES_NEW</code> 일 경우 항상 새로운 transaction을 시작한다)</li>\n</ol>\n</li>\n<li>\n<p>만일 새로운 transaction을 생성하도록 했다면 다음이 실행된다</p>\n<ol>\n<li>새로운 entity manager 생성</li>\n<li>생성된 entity manager를 현재 쓰레드에 바인딩</li>\n<li>DB connection pool에서 커넥션 가져오기</li>\n<li>해당 커넥션을 현재 쓰레드에 바인딩 </li>\n</ol>\n</li>\n<li>Entity manager와 connection 모두 현재 스레드(즉, 모두 스레드 단위로 실행 및 관리)에 바인딩 되어 있고, transaction이 끝났을 때 Transaction Manager가 제거한다. <strong>따라서 현재 entity manager나 connection이 필요한 경우 현재 스레드에서 추출하여 사용하고, 이 부분을 EntityManager proxy가 담당한다.</strong></li>\n</ul>\n</li>\n</ul>\n<p><em>Spring configuration에서 위 @Transactional 매커니즘이 동작하도록 설정해준다.</em> </p>\n <br>\n <br>\n<p><strong>[참고링크]</strong></p>\n<ul>\n<li><a href=\"https://dzone.com/articles/how-does-spring-transactional\">https://dzone.com/articles/how-does-spring-transactional</a></li>\n<li><a href=\"https://hleee.medium.com/%EA%B2%A9%EB%A6%AC-%EC%88%98%EC%A4%80-3287d4bcc64d\">https://hleee.medium.com/격리-수준-3287d4bcc64d</a></li>\n<li><a href=\"https://mangkyu.tistory.com/30\">https://mangkyu.tistory.com/30</a></li>\n</ul>\n<p><strong>MORE</strong></p>\n<ul>\n<li>하나의 Entity Manger(persistence context) 에 여러 database transactions가 연관되어 있는 경우는 무엇일까?</li>\n</ul>","frontmatter":{"date":"May 10, 2021","title":"@Transactional","categories":"스프링부트 웹 데이터베이스","author":"코다","emoji":"🖥"},"fields":{"slug":"/transaction-annotation/"}},"site":{"siteMetadata":{"siteUrl":"https://yjksw.github.io","comments":{"utterances":{"repo":"yjksw/yjksw.github.io"}}}}},"pageContext":{"slug":"/controller-vs-restcontroller/","nextSlug":"/start-journey-as-programmer/","prevSlug":"/transaction-annotation/"}},"staticQueryHashes":["1073350324","2938748437"]}
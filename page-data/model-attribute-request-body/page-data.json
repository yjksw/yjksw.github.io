{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/model-attribute-request-body/",
    "result": {"data":{"cur":{"id":"b0ca772e-1b48-53f1-8a7f-24d1a8ffe267","html":"<p>이번에 스프링 체스 자바 웹 어플리케이션을 사용하여 구현하면서 처음에는 모두 <code class=\"language-text\">@RequestParam</code> 으로 데이터를 가져왔었다. 하지만 인자가 너무 많아지는 경우 메서드에 파라미터가 많아지면서 가독성이 안 좋아졌다. 또한 DTO에 해당 데이터를 담아서 서비스 레이어에 전달해야하거나 할 때 일일이 데이터를 DTO에 담아서 가공해야 하는 작업을 해야하기도 했다. 코드를 구현할 때 손가락이 아프다면 수정할 부분을 찾으라고 했었는데 확실히 <code class=\"language-text\">@RequestParam</code>으로 받는 것은 손가락이 아팠다. <br></p>\n<p>아니나 다를까 리뷰어가 @ModelAttribute를 사용하는 걸 추천했다. 마침 레벨1 제이슨 톡방에서도 @ModelAttribute 에 대한 논의가 활발하길래 공부도 하고 코드에 적용을 하며 배운 것을 기록해본다.</p>\n<h2 id=\"modelattribute-vs-requestbody\" style=\"position:relative;\"><a href=\"#modelattribute-vs-requestbody\" aria-label=\"modelattribute vs requestbody permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>@ModelAttribute vs. @RequestBody</h2>\n<p>간단하게 말하면 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token number\">1.</span> <span class=\"token annotation punctuation\">@ModelAttribute</span>은 form data로 오는 데이터를 저장한다<span class=\"token punctuation\">.</span> \n<span class=\"token number\">2.</span> <span class=\"token annotation punctuation\">@RequestBody</span>는 JSON<span class=\"token operator\">/</span>xml 타입으로 오는 body에 담긴 데이터를 저장한다<span class=\"token punctuation\">.</span></code></pre></div>\n<p><code class=\"language-text\">@ModelAttribute</code> 같은 경우는 parameter 값으로 DTO에 바인딩한다. 따라서 해당 DTO 객체에 <code class=\"language-text\">setter</code> 메소드가 반드시 있어야 한다. 따라서 타입에 대한 검증을 한 후에 setting을 한다.</p>\n<p><code class=\"language-text\">@RequestBody</code>의 경우는 본문 body에 있는 Json/xml 타입을 바인딩하기 때문에 <code class=\"language-text\">HttpMessageReader</code>를 통해서 <code class=\"language-text\">ObjectMapper</code>를 한다.</p>\n<p>여기서 <code class=\"language-text\">HttpMessageReader</code>는 들어온 request body의 데이터값을 Java object로 역직렬화 해준다. 이때 역직렬화는 <code class=\"language-text\">ObjectMapper</code>의 <code class=\"language-text\">readValue()</code> 메서드로 변환하므로 setter가 필요가 없다. (단, 기본 생성자의 경우는 필요한 경우가 많다)</p>\n<h2 id=\"사용예시\" style=\"position:relative;\"><a href=\"#%EC%82%AC%EC%9A%A9%EC%98%88%EC%8B%9C\" aria-label=\"사용예시 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>사용예시</h2>\n<ul>\n<li>\n<p>form 데이터로 넘어오는 경우 @ModelAttribute를 사용해서 바인딩한다. 여기서 @RequestBody를 쓰면 에러가 발생한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@PostMapping</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/white-game\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">whiteStart</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Model</span> model<span class=\"token punctuation\">,</span> <span class=\"token class-name\">HttpSession</span> session<span class=\"token punctuation\">,</span> <span class=\"token annotation punctuation\">@ModelAttribute</span> <span class=\"token class-name\">RoomInfoRequestDto</span> roomInfoRequestDto<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">String</span> room <span class=\"token operator\">=</span> roomInfoRequestDto<span class=\"token punctuation\">.</span><span class=\"token function\">getRoomName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">String</span> password <span class=\"token operator\">=</span> roomInfoRequestDto<span class=\"token punctuation\">.</span><span class=\"token function\">getPassword</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        model<span class=\"token punctuation\">.</span><span class=\"token function\">addAttribute</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"room\"</span><span class=\"token punctuation\">,</span> room<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        session<span class=\"token punctuation\">.</span><span class=\"token function\">setAttribute</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"password\"</span><span class=\"token punctuation\">,</span> password<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">return</span> <span class=\"token string\">\"game\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n<li>\n<p>아래의 경우 js에서 데이터를 보내줄 content-type을 지정하지 않았을 때 오류가 났다. 이후에 @RequestBody는 json 타입을 받기 때문에 <code class=\"language-text\">Content-type</code>을  <code class=\"language-text\">application/json</code>으로 지정하니 잘 바인딩이 되었다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@PutMapping</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/game\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">MoveResponseDto</span> <span class=\"token function\">move</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">HttpSession</span> session<span class=\"token punctuation\">,</span> <span class=\"token annotation punctuation\">@RequestBody</span> <span class=\"token class-name\">MoveRequestDto</span> moveRequestDto<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">String</span> password <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">)</span> session<span class=\"token punctuation\">.</span><span class=\"token function\">getAttribute</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"password\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> chessService<span class=\"token punctuation\">.</span><span class=\"token function\">move</span><span class=\"token punctuation\">(</span>moveRequestDto<span class=\"token punctuation\">,</span> password<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n<li>\n<p>번외로, 서버로 내보내는 content-type에서 json을 지정하고 싶을 경우 <code class=\"language-text\">Content-type : 'application/json'</code> 으로 지정하고 서버에서 받는 데이터의 경우 <code class=\"language-text\">Data-type : 'json'</code> 으로 지정해야 한다. (중요한 이유는 없고 그냥 설정이 그렇게 되어 있음)</p>\n</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#modelattribute-vs-requestbody\">@ModelAttribute vs. @RequestBody</a></li>\n<li><a href=\"#%EC%82%AC%EC%9A%A9%EC%98%88%EC%8B%9C\">사용예시</a></li>\n</ul>\n</div>","excerpt":"이번에 스프링 체스 자바 웹 어플리케이션을 사용하여 구현하면서 처음에는 모두  으로 데이터를 가져왔었다. 하지만 인자가 너무 많아지는 경우 메서드에 파라미터가 많아지면서 가독성이 안 좋아졌다. 또한 DTO에 해당 데이터를 담아서 서비스 레이어에 전달해야하거나 할 때 일일이 데이터를 DTO에 담아서 가공해야 하는 작업을 해야하기도 했다. 코드를 구현할 때 손가락이 아프다면 수정할 부분을 찾으라고 했었는데 확실히 으로 받는 것은 손가락이 아팠다.  아니나 다를까 리뷰어가 @ModelAttribute를 사용하는 걸 추천했다. 마침 레벨1 제이슨 톡방에서도 @ModelAttribute 에 대한 논의가 활발하길래 공부도 하고 코드에 적용을 하며 배운 것을 기록해본다. @ModelAttribute vs. @RequestBody 간단하게 말하면 다음과 같다.  같은 경우는 parameter 값으로 DTO에 바인딩한다. 따라서 해당 DTO 객체에  메소드가 반드시 있어야 한다. 따라서 타입에 대…","frontmatter":{"date":"March 25, 2021","title":"@ModelAttribute vs. @RequestBody","categories":"스프링부트","author":"코다","emoji":"🖥"},"fields":{"slug":"/model-attribute-request-body/"}},"next":{"id":"c6060cb1-1a69-5cc5-8508-1df3c8357b5f","html":"<p>요약하자면 Stream과 Collection의 차이는 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token number\">1.</span> 스트림은 요소를 보관하지 않고 필요할 때 생성되거나 하위 <span class=\"token class-name\">Collection</span>에 보관한다<span class=\"token punctuation\">.</span> \n<span class=\"token number\">2.</span> 스트림은 원본을 변경하기보다 새로운 스트림을 생성하여 반환한다<span class=\"token punctuation\">.</span> \n<span class=\"token number\">3.</span> 스트림 연산은 lazy operation이다<span class=\"token punctuation\">.</span> <span class=\"token punctuation\">(</span>따라서 무한 스트림도 가능한 것이다<span class=\"token punctuation\">)</span></code></pre></div>\n<p>개념적으로 접근했을 때 Collection의 경우에는 어떠한 데이터를 담는 자료구조의 역할을 주로 하지만, Stream의 경우는 연산과 관련된 것이 주라고 볼 수 있다.</p>\n<ul>\n<li>\n<p>Quote</p>\n<p>Java <em>Collection</em>s offer efficient mechanisms to store and process the data by providing data structures like <em><a href=\"https://drafts.baeldung.com/java-linkedlist\">List</a></em>, <em><a href=\"https://drafts.baeldung.com/java-hashset\">Set</a></em>, and <em><a href=\"https://drafts.baeldung.com/java-hashmap\">Map</a></em>.</p>\n<p>However, the Stream API is useful for performing various operations on the data without the need for intermediate storage.</p>\n<p>출처: <a href=\"https://www.baeldung.com/java-return-stream-collection\">https://www.baeldung.com/java-return-stream-collection</a></p>\n</li>\n</ul>\n<h3 id=\"traversal\" style=\"position:relative;\"><a href=\"#traversal\" aria-label=\"traversal permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Traversal</h3>\n<p>Collection은 여러번 데이터를 횡단할 수 있지만, Stream은 한번만 가능하며 source로부터 새로운 Stream을 추출해야 새롭게 traverse 할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">Stream</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> numbers <span class=\"token operator\">=</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">;</span>\nnumbers<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//error 없음</span>\nnumbers<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//error 발생</span></code></pre></div>\n<h3 id=\"lazy-operation\" style=\"position:relative;\"><a href=\"#lazy-operation\" aria-label=\"lazy operation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Lazy Operation</h3>\n<p>Collection은 요소를 보관하기 때문에 해당 Collection에 어떠한 요소가 추가되기 전에 operation을 우선 실행해야한다. <br></p>\n<p>하지만 Stream은 lazy하기 연산을 하기 때문에 우선 Stream에 담겨진 요소들에 대해서 선실행을 하지 않는다. 이후에 필요할 때 요소를 꺼내오고 연산을 하도록 한다. 또한 Stream은 불변이므로 요소를 추가하거나 삭제할 수 없다.</p>\n<h3 id=\"외부반복-vs-내부반복\" style=\"position:relative;\"><a href=\"#%EC%99%B8%EB%B6%80%EB%B0%98%EB%B3%B5-vs-%EB%82%B4%EB%B6%80%EB%B0%98%EB%B3%B5\" aria-label=\"외부반복 vs 내부반복 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>외부반복 vs. 내부반복</h3>\n<p>외부에서 값을 꺼내서 반복해야하는 Collection과 다르게 Stream은 내부적으로 알아서 반복문을 돌면서 명령한 연산을 수행한다. <br></p>\n<p>내부 반복을 했을 경우 1) 반복자를 사용하여 명시적으로 표시할 필요가 없고 2) 병렬처리시 스레드간 공유자원에 대한 관리를 할 필요가 없다.</p>\n<h3 id=\"유연성\" style=\"position:relative;\"><a href=\"#%EC%9C%A0%EC%97%B0%EC%84%B1\" aria-label=\"유연성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>유연성</h3>\n<p>Stream은 여러 operation의 조합으로 유연하게 데이터 연산이 가능한 장점이 있다. 어떤 특정 result set을 도출해서 consumer에게 넘겨줄 필요 없이 필요한 연산을 조합하여 바로바로 처리할 수 있다.</p>\n<h3 id=\"functional-behavior\" style=\"position:relative;\"><a href=\"#functional-behavior\" aria-label=\"functional behavior permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Functional Behavior</h3>\n<p>Stream은 functional 하기 때문에 기존 데이터를 변경시키지 않는다. 따라서 result set도 immutable (연산 중에) 하기 때문에 병렬 처리에 강하다. <br></p>\n<br>\n<p>참고 링크:</p>\n<ul>\n<li><a href=\"https://bk-investing.tistory.com/42\">https://bk-investing.tistory.com/42</a></li>\n<li><a href=\"https://javaconceptoftheday.com/collections-and-streams-in-java/#:~:text=Difference%20Between%20Collections%20Vs%20Streams%20In%20Java%20%3A&#x26;text=Collections%20are%20mainly%20used%20to%20store%20and%20group%20the%20data,or%20remove%20elements%20from%20streams\">https://javaconceptoftheday.com/collections-and-streams-in-java/#:~:text=Difference Between Collections Vs Streams In Java %3A&#x26;text=Collections are mainly used to store and group the data,or remove elements from streams</a>.</li>\n<li><a href=\"https://www.baeldung.com/java-return-stream-collection\">https://www.baeldung.com/java-return-stream-collection</a></li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#traversal\">Traversal</a></li>\n<li><a href=\"#lazy-operation\">Lazy Operation</a></li>\n<li><a href=\"#%EC%99%B8%EB%B6%80%EB%B0%98%EB%B3%B5-vs-%EB%82%B4%EB%B6%80%EB%B0%98%EB%B3%B5\">외부반복 vs. 내부반복</a></li>\n<li><a href=\"#%EC%9C%A0%EC%97%B0%EC%84%B1\">유연성</a></li>\n<li><a href=\"#functional-behavior\">Functional Behavior</a></li>\n</ul>\n</div>","frontmatter":{"date":"March 20, 2021","title":"Stream vs. Collection","categories":"자바","author":"코다","emoji":"✊"},"fields":{"slug":"/stream-vs-collection/"}},"prev":{"id":"b2092703-9d70-568e-bdb1-6b1553adfc63","html":"<blockquote>\n<p>다음은 우아한테크코스를 시작한지 얼마 되지 않은 시점에 쓴 글 입니다. 진솔한 마음으로 써서 올려봅니다 😶</p>\n</blockquote>\n<br>\n<h2 id=\"-국제학교-나온-문과생이-개발자를-꿈꾸기까지\" style=\"position:relative;\"><a href=\"#-%EA%B5%AD%EC%A0%9C%ED%95%99%EA%B5%90-%EB%82%98%EC%98%A8-%EB%AC%B8%EA%B3%BC%EC%83%9D%EC%9D%B4-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%A5%BC-%EA%BF%88%EA%BE%B8%EA%B8%B0%EA%B9%8C%EC%A7%80\" aria-label=\" 국제학교 나온 문과생이 개발자를 꿈꾸기까지 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>💭 국제학교 나온 문과생이 개발자를 꿈꾸기까지</h2>\n<p>“너 컴퓨터 전공이니까 와서 이것 좀 고쳐봐”</p>\n<p>컴퓨터 전공으로 전과하고 가장 많은 들은 말이다. 사실 나도 흔히 컴퓨터 공학을 전공하면 컴퓨터를 잘 고칠(?) 거로 생각하는 사람들 중 하나였다. 코딩이 무엇인지도 모르는 사람 말이다. 그리고 대학교 1학년 때 처음 코딩을 접했다. 교양 필수였던 <code class=\"language-text\">C 프로그래밍</code> 수업을 통해서 말이다. 국제 중고등학교를 나와서 국제 정치학 전공을 선택한 나에게 그렇게 우연히 코딩의 기회가 닿았다.</p>\n<p><code class=\"language-text\">이 친구 진짜 솔직하구나</code> 코딩의 첫인상이다. 누군가 나에게 어떤 종류의 사람들을 좋아하느냐고 물어본다면 단번에 <code class=\"language-text\">솔직한 사람</code>이라고 대답할 것이다. 눈속임으로 알맹이가 없는 것을 있는 것처럼 꾸미는 것보다 담백하게 있으면 있거나 없으면 없다고 말하는 사람이나 글을 좋아한다. 그런 의미에서 코드는 정말 너무나도 정직하다. 있어야 할 것만 딱 있어야지 가장 잘 돌아간다. 잘못 짰다면 실행되지 않는다. 괜히 있어보이려고 이것저것 추가하면 작동 시간만 늘어날 뿐 아무런 이득을 주지 않는다. 코드는 거짓말을 하지 않는다.</p>\n<p>코딩의 두 번째 매력은 <code class=\"language-text\">기승전결과 논리적 흐름이 있는 글</code>이라는 것이다. 우선 본캐는 문과생이기 때문에 글을 좋아한다. 좋은 글은 처음, 중간, 끝이 있고 앞 문장과 뒷 문장이 논리적으로 연결이 되어야 한다. 한마디로 표현하면 일단 <code class=\"language-text\">말이 되어야 한다</code>. 무언가랑 많이 닮지 않았나? 코드는 시작 시점과 중간 처리 과정 마무리(출력 혹은 저장) 과정이 있다. 그리고 그사이를 메꾸는 코드 한줄 한줄은 논리적인 흐름에 따라서 앞 과정과 그다음 과정이 이어져야 한다.</p>\n<p>‘나랑 잘 맞네?’ 문과생이 개발자를 꿈꾸게 된 매우 단순한 이유다.</p>\n<br>\n<h2 id=\"-첫-발자국-자취\" style=\"position:relative;\"><a href=\"#-%EC%B2%AB-%EB%B0%9C%EC%9E%90%EA%B5%AD-%EC%9E%90%EC%B7%A8\" aria-label=\" 첫 발자국 자취 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🐾 첫 발자국 자취</h2>\n<p>‘우아한테크코스’에 입문하기 위한 첫 발걸음은 프리코스다. 포비의 말을 인용하자면 <code class=\"language-text\">우테코도 나를 탐색하고 나도 우테코를 탐색하는 시간</code>. 탐색을 정말 열심히 했더랬다. Notion에 미션내용과 요구사항 분석한 것, 매일 해야 할 Todo와 회고를 정리했다. 우테코 생활을 한 달 넘게 한 이 시점에서 글을 쓰기 위해서 다시 한번 들여다보았다.</p>\n<p align=\"center\">\n<img src=\"https://user-images.githubusercontent.com/63405904/111900110-eacb5b80-8a73-11eb-8abc-d943b79ee484.png\" width=\"60%\" height=\"70%\" alt=\"첫 발을 잘 내딪자고 다짐하며 고른 발자국 이모지\">\n</p>\n<p>프리코스 첫 번째 미션을 시작했을 때 작성했던 <code class=\"language-text\">나만의 규칙 ver1.</code>이 마지막 미션 <code class=\"language-text\">나만의 규칙 ver3.</code>가 되기까지 짧다면 짧은 3주 동안 늘어난 규칙만큼 성장했다. 중간에 너무 좌절하지 않으려고 애를 써야 했던 시간도 있었지만 너무 재미있어서 반드시 합격하고 싶다는 간절함도 커졌다. 그리고 노력하고 기다린 끝에 루터회관 14층에 입성!</p>\n<p align=\"center\">\n<img src=\"https://user-images.githubusercontent.com/63405904/111900120-ffa7ef00-8a73-11eb-8c2c-6628fb29f434.png\" width=\"80%\" alt=\"프리코스를 진행하며 덧붙인 나만의 규칙 목록 변천사\">\n</p>\n<br>\n<h2 id=\"️-일단-루터회관-14층이-마음에-든-이유\" style=\"position:relative;\"><a href=\"#%EF%B8%8F-%EC%9D%BC%EB%8B%A8-%EB%A3%A8%ED%84%B0%ED%9A%8C%EA%B4%80-14%EC%B8%B5%EC%9D%B4-%EB%A7%88%EC%9D%8C%EC%97%90-%EB%93%A0-%EC%9D%B4%EC%9C%A0\" aria-label=\"️ 일단 루터회관 14층이 마음에 든 이유 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>☘️ 일단 루터회관 14층이 마음에 든 이유</h2>\n<p>첫 번째는 초록색이다. 한달 동안 온라인으로 진행하다가 3월 초 처음 교육장에 들어왔을 때 초록초록하고 싱그러운 분위기가 나를 맞았다. 눈이 좋아지겠구나 싶었다. 포근한 소파랑 빈백, 위트있는 문구들도 마음에 들었다. 본래 도서관같이 정숙하는 분위기보다 일상 소음이 있는 카페에서 더 집중을 잘하는 스타일이다. 역시 나랑 잘 맞네 ㅎㅎ</p>\n<p>두 번째는 같은 곳을 향해 가는 실력있는 크루들이다. 쇼파에 앉아서 무언가를 하고 있으면 지나가던 크루들이 와서 뭐하냐고 물어본다. 쓸모 있는 얘기도 하고 쓸모 없는 얘기도 하는 데 둘 다 좋다. 모르는 것들을 물어보면 자기가 공부한 것을 설명한다. 모르면 같이 찾아본다. 그리고 지루하면 딴짓을 하면서 조금 쉰다. 프리코스를 하면서 가장 힘들었던 것은 ‘내가 지금 잘하고 있나?’ 확신할 수 없었던 것이다. 잘못된 방향으로 열심히 달리고 있었던 것이면 어쩌지 하는 고민. 그러나 우테코에서는 그것을 걱정할 필요가 없다. 루터회관 14층에는 어디를 가도 물어볼 크루와 코치가 있다는 것이 가장 마음에 든다.</p>\n<br>\n<h2 id=\"-좋은-개발자가-되고-싶은데\" style=\"position:relative;\"><a href=\"#-%EC%A2%8B%EC%9D%80-%EA%B0%9C%EB%B0%9C%EC%9E%90%EA%B0%80-%EB%90%98%EA%B3%A0-%EC%8B%B6%EC%9D%80%EB%8D%B0\" aria-label=\" 좋은 개발자가 되고 싶은데 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>👾 좋은(?) 개발자가 되고 싶은데..</h2>\n<p>그럼 좋은 개발자가 뭐지? 지금 시점에서 되돌아보니, 우테코 레벨1 동안은 <code class=\"language-text\">좋은 개발자</code>에 대한 정의를 내리는 기간이라고 할 수 있을 것 같다. 정리하면 다음 두 가지를 갖춘 개발자다.</p>\n<ol>\n<li>같이 일하고 싶은 개발자</li>\n<li>좋은 코드를 작성하는 개발자</li>\n</ol>\n<p>먼저 내 동료에게 좋은 개발자이다. 페어 프로그래밍을 하면서 내가 좋은 페어였을까 돌아보면서 두 가지 질문을 했다. 페어에게 좋은 피드백을 했는지, 그리고 페어의 피드백을 잘 받아들였는지. 두 가지가 적당히 잘 어우러져야 좋은 페어다. 흔히 개발자는 혼자 컴퓨터랑만 이야기하는 이미지가 강한데 사실 그렇지 않다. 내가 짜는 코드도 페어가 이해하기 쉽도록 배려심이 가득한 코드여야 한다.</p>\n<p>두 번째는 좋은 코드를 작성하는 개발자다. 이건 좀 어렵다. 배운 키워드로 말하자면 TDD, 객체지향, 코드 컨벤션 등을 잘 적용해야 한다. 처음에는 <code class=\"language-text\">내가 보기 좋은 코드</code>를 짠다. 그다음에는 <code class=\"language-text\">페어가 보기 좋은 코드</code>. 그리고 그다음에는 <code class=\"language-text\">리뷰어가 보기에 좋은 코드</code>. 이 정도 오면 충돌 지점이 생긴다. 각자 보기에 좋은 코드가 다른 형태일 때가 오는 것이다. 그럼.. <code class=\"language-text\">포비가 보기에 좋은 코드</code>?</p>\n<br>\n<h2 id=\"-그래서-답을-좀-찾았어\" style=\"position:relative;\"><a href=\"#-%EA%B7%B8%EB%9E%98%EC%84%9C-%EB%8B%B5%EC%9D%84-%EC%A2%80-%EC%B0%BE%EC%95%98%EC%96%B4\" aria-label=\" 그래서 답을 좀 찾았어 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🤔 그래서 답을 좀 찾았어?</h2>\n<p>결론부터 말하자면 ‘아니요’ 이다. 우테코 레벨1을 지나면서 많은 것을 듣고 배웠지만 지금은 답을 정의할 때가 아니라 질문을 던질 때다. 그냥 질문이 아니라 좋은 질문을. 좋은 코드가 무엇일지 끊임없이 고민하면서 이런 코드 저런 코드를 탐색해야한다. 좋은 개발자가 무엇일지, 좋은 기술이 무엇일지, 정말 성장하고 있는지 스스로 물어봐야한다. 생각에 생각을 더하고 시야를 넓히는 질문을 던져야할 때다.</p>\n<p>그럴싸한 답은 아직 없지만.. 우선은 정직한 코드가 내가 애쓴 시간을 그대로 보여줄 때까지 열심히 해보는 수밖에!</p>","frontmatter":{"date":"March 30, 2021","title":"개발자를 본격 꿈꾸기 시작하면서 나의 마음가짐","categories":"아무말","author":"코다","emoji":"💡"},"fields":{"slug":"/start-journey-as-programmer/"}},"site":{"siteMetadata":{"siteUrl":"https://yjksw.github.io","comments":{"utterances":{"repo":"yjksw/yjksw.github.io"}}}}},"pageContext":{"slug":"/model-attribute-request-body/","nextSlug":"/stream-vs-collection/","prevSlug":"/start-journey-as-programmer/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}
{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/one-percent-network-3/",
    "result": {"data":{"cur":{"id":"d93ef879-079d-56a0-858e-48a2ddb90717","html":"<blockquote>\n<p>다음은 <em>성공과 실패를 결정하는 1%의 네트워크 원리</em> 를 읽고 정리한 내용입니다. 본 글은 CH2. TCP/IP의 데이터를 전기 신호로 만들어 보낸다_프로토콜 스택과 LAN 어댑터의 탐험입니다 🙌</p>\n</blockquote>\n<br>\n<h2 id=\"-story1-소켓을-작성한다\" style=\"position:relative;\"><a href=\"#-story1-%EC%86%8C%EC%BC%93%EC%9D%84-%EC%9E%91%EC%84%B1%ED%95%9C%EB%8B%A4\" aria-label=\" story1 소켓을 작성한다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🛺 [Story1] 소켓을 작성한다.</h2>\n<h3 id=\"1-프로토콜-스택의-내부-구성\" style=\"position:relative;\"><a href=\"#1-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-%EC%8A%A4%ED%83%9D%EC%9D%98-%EB%82%B4%EB%B6%80-%EA%B5%AC%EC%84%B1\" aria-label=\"1 프로토콜 스택의 내부 구성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 프로토콜 스택의 내부 구성</h3>\n<ul>\n<li>네트워크를 제어하는 다음 두 가지가 필요하다.\n<ol>\n<li>소프트웨어 - (OS 내장) 프로토콜 스택</li>\n<li>하드웨어 - LAN 어댑터</li>\n</ol>\n</li>\n<li>아래가 네트워크 계층 구조이다.\n<ul>\n<li>\n<p>어플리케이션에서 데이터 송신을 시작한다. 이때 소켓 라이브러리를 사용하여 리졸버로 DNS 서버를 조회하는 등의 동작을 실행한다.</p>\n</li>\n<li>\n<p>OS 내부에 있는 프로토콜 스택이 그 다음 작업을 의뢰받는다.</p>\n<ul>\n<li>TCP 혹은 UDP로 데이터를 송수신한다.</li>\n<li><strong>IP 프로토콜로 패킷 송수신 동작을 제어한다. ICMP(패킷운반시 오류 통지, 제어용 메세지) 혹은 ARP(IP에 대응하는 MAC주소 조사)로 동작한다.</strong></li>\n</ul>\n</li>\n<li>\n<p>LAN 드라이버는 LAN 어댑터라는 하드웨어를 제어한다. LAN 어댑터라는 <strong>하드웨어가</strong> 실제 송수신 동작, 케이블 신호 송수신 동작을 제어한다.</p>\n<p align=\"center\"><img width=\"70%\" src=\"https://user-images.githubusercontent.com/63405904/138543586-0252b0b7-f015-466a-b5b5-1cc404b75d0b.png\"><br>출처: 상위 1% 네트워크</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-소켓은-통신-제어용-제어-정보이다\" style=\"position:relative;\"><a href=\"#2-%EC%86%8C%EC%BC%93%EC%9D%80-%ED%86%B5%EC%8B%A0-%EC%A0%9C%EC%96%B4%EC%9A%A9-%EC%A0%9C%EC%96%B4-%EC%A0%95%EB%B3%B4%EC%9D%B4%EB%8B%A4\" aria-label=\"2 소켓은 통신 제어용 제어 정보이다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 소켓은 통신 제어용 제어 정보이다</h3>\n<ul>\n<li>소켓 내부에 제어 정보를 기록하는 메모리 영역이 존재 → 통신 동작 제어용 정보를 기록한다.\n<ul>\n<li>ex. 통신 상대의 IP 주소, 포트 번호, 통신 동작 진행 상태 등등</li>\n<li>이것에 소켓의 실체이다 → 제어 정보의 집합</li>\n</ul>\n</li>\n<li>프로토콜 스택은 위 제어정보를 참조하여 동작한다.\n<ul>\n<li>제어 정보를 참조하여 송신 대상으로 데이터를 송신하고 응답을 기다린다.</li>\n<li>일정 시간 경과 후 응답이 오지 않으면 데이터를 재송신 한다. (즉, 경과 시간등을 기록한다)</li>\n<li>이외의 많은 역할들을 한다. (이후에 추가적으로 다룸)</li>\n</ul>\n</li>\n<li>소켓을 만든다는 것\n<ul>\n<li><code class=\"language-text\">netstat</code>(윈도우 경우) 명령어에 의해서 나오는 소켓 통신 정보에 해당 소켓에 대한 제어정보를 추가하는 것\n<ul>\n<li><code class=\"language-text\">netstat</code> 명령어 입력시 Local Address에 여러 IP 주소가 나온다면 여러 LAN 어댑터를 보유하고 있다는 뜻이다.</li>\n<li>IP가 <code class=\"language-text\">0.0.0.0</code> 으로 기재되는 것은 양측이 모두 통신을 시작하지 않아서 IP가 정해지지 않았기 때문이다.</li>\n</ul>\n</li>\n<li>통신을 시작하는 부분의 상태를 기록하고 송수신 데이터를 일시적으로 저장하는 버퍼 메모리를 준비하는 것 등등</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-소켓을-호출했을-때-동작\" style=\"position:relative;\"><a href=\"#3-%EC%86%8C%EC%BC%93%EC%9D%84-%ED%98%B8%EC%B6%9C%ED%96%88%EC%9D%84-%EB%95%8C-%EB%8F%99%EC%9E%91\" aria-label=\"3 소켓을 호출했을 때 동작 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 소켓을 호출했을 때 동작</h3>\n<p>먼저 Socket 라이브러리의 <code class=\"language-text\">socket</code> 메서드를 호출하여 프로토콜 스택에 의뢰해 소켓을 하나 생성한다.</p>\n<ul>\n<li>프로토콜 스택은 소켓 한 개가 사용하는 메모리 영역을 확보한다.</li>\n<li>아직 통신 이전이면 초기 상태의 정보를 메모리에 기록한다.</li>\n<li>포로토콜 스택은 소켓에 대한 디스크립터를 어플리케이션에 알려준다.</li>\n<li>이 디스크립터를 통해 어플리케이션은 이후 데이터 송수신을 프로토콜 스택에 의뢰한다.</li>\n<li>디스크립터만 있으면 프로토콜 스택이 소켓의 통신 상태, 상대 소켓 등등의 기타 정보를 모두 알 수 있다. (어플리케이션은 해당 정보에 대해서 알 필요가 없다)</li>\n</ul>\n<br>\n<h2 id=\"-story2-서버에-접속한다\" style=\"position:relative;\"><a href=\"#-story2-%EC%84%9C%EB%B2%84%EC%97%90-%EC%A0%91%EC%86%8D%ED%95%9C%EB%8B%A4\" aria-label=\" story2 서버에 접속한다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🛺 [Story2] 서버에 접속한다.</h2>\n<h3 id=\"1-접속의-의미\" style=\"position:relative;\"><a href=\"#1-%EC%A0%91%EC%86%8D%EC%9D%98-%EC%9D%98%EB%AF%B8\" aria-label=\"1 접속의 의미 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 접속의 의미</h3>\n<p>어플리케이션은 소켓 생성 후 <code class=\"language-text\">connect</code> 메서드를 호출하여 접속 동작을 시작한다. 여기서 말하는 접속 동작은 케이블 등을 연결하는 접속 동작이 아니다. 주로 필요한 회선 및 케이블은 이미 연결이 되어 있다.</p>\n<p>접속동작이라고 하는 것은 <strong>데이터를 주고받고자 하는 대상과 필요한 정보를 주고받아서 기록하고 데이터 송수신이 가능한 상태로 만드는 것</strong>이다.</p>\n<ul>\n<li>초기상태\n<ul>\n<li>아무것도 기록되어 있지 않으므로 상대 소켓에 대한 IP 주소와 포트번호에 대한 정보가 필요하다.</li>\n<li>connect 메소드는 어플리케이션이 알고 있는 상대 소켓의 IP 주소(DNS 리졸버를 통해서 획득한 정보) 및 포트 번호(사용자가 이미 알고 있는 정보)를 프로토콜 스택에 알려 소켓에 기록하는 로직을 수행한다.</li>\n</ul>\n</li>\n<li>대상 소켓B도 소켓을 생성한 후에 자신과 접속하고자 하는 소켓A를 알지 못하므로 소켓을 생성하고 소켓A가 접속을 원한다는 요청을 받기 이전까지 대기한다. 요청을 받으면 소켓B도 소켓A의 정보를 기록하여 통신할 수 있도록 한다.</li>\n<li>소켓에 접속하는 <code class=\"language-text\">connect</code> 수행 시 데이터 송수신 메모리 버퍼도 확보한다.</li>\n</ul>\n<h3 id=\"2-소켓-앞에-제어-정보를-기록한-헤더-배치\" style=\"position:relative;\"><a href=\"#2-%EC%86%8C%EC%BC%93-%EC%95%9E%EC%97%90-%EC%A0%9C%EC%96%B4-%EC%A0%95%EB%B3%B4%EB%A5%BC-%EA%B8%B0%EB%A1%9D%ED%95%9C-%ED%97%A4%EB%8D%94-%EB%B0%B0%EC%B9%98\" aria-label=\"2 소켓 앞에 제어 정보를 기록한 헤더 배치 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 소켓 앞에 제어 정보를 기록한 헤더 배치</h3>\n<ul>\n<li>소켓에 기록되는 제어정보는 무엇이 있을까 - 이 정보는 소켓의 헤더에 포함되서 보내진다.\n<ul>\n<li><strong>이더넷 혹은 IP 헤더</strong> + <strong>TCP 헤더</strong> - 클라이언트와 서버가 통신하기 위해서 필요한 정보이다. 이 정보는 소켓의 헤더에 포함되서 보내진다.\n<ul>\n<li>헤더 사양이 정해져있다. 점점 통신을 하면서 덧붙여간다.</li>\n</ul>\n</li>\n<li>소켓(프로토콜 스택 메모리 영역)에 기록되는 정보\n<ul>\n<li>송수신 동작은 진행상황</li>\n<li>어플리케이션에서 받은 정보, 통신 상대로부터 받은 정보</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>소켓의 제어 정보에 따라서 프로토콜 스택의 동작 대부분이 결정지어 지기 때문에 결합도가 매우 높다.</li>\n</ul>\n<h3 id=\"3-접속-동작의-실체\" style=\"position:relative;\"><a href=\"#3-%EC%A0%91%EC%86%8D-%EB%8F%99%EC%9E%91%EC%9D%98-%EC%8B%A4%EC%B2%B4\" aria-label=\"3 접속 동작의 실체 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 접속 동작의 실체</h3>\n<ul>\n<li><code class=\"language-text\">connect</code>를 호출하며 상대 IP와 포트 번호를 함께 쓴다.</li>\n<li>프로토콜 스택의 <strong>TCP 담당</strong>이 상대와 정보를 주고받아 헤더에 주고받은 정보를 기록하는 다음 과정을 거친다(송신처와 수신처 포트 번호 등등의 중요한 정보)\n<ul>\n<li>상대소켓 지정(IP주소와 포트번호)과 헤더설정 끝나면 SYN 비트(컨트롤비트)를 1로 설정한다.</li>\n</ul>\n</li>\n<li>TCP 헤더 생성 이후 프로토콜 스택 내부의 <strong>IP 담당</strong>에게 넘겨주어 패킷 송신 동작을 실행하도록 한다. (여기서 송신한 패킷은 상대서버의 IP 담당이 받아 TCP 담당에게 넘겨준다)</li>\n<li><strong>상대 소켓의 TCP 담당은 받은 패킷의 수신처 포트번호에 적힌 소켓을 찾는다.</strong> 소켓을 지정하여 필요한 정보를 기록하고 응답을 보낸다.</li>\n<li>응답을 보낼때, 마찬가지로 SYN을 1(시퀀스 초기번호)로 설정하고 TCP 헤더에 필요 정보를 설정한다. 추가로 패킷을 성공적으로 받았다고 알리는 ACK 비트를 1로 설정한다.</li>\n<li>생성된 헤더 정보를 IP 담당에게 넘겨 다시 응답한다.</li>\n<li>응답을 받은 소켓은 SYN 비트를 확인하여 접속이 성공했는지 보고 성공이라면 접속 완료를 기록한다. 그리고 상대 소켓에 패킷을 잘 받았다는 ACK 비트를 1로 만든 패킷으로 응답한다.</li>\n</ul>\n<p align=\"center\"><img width=\"70%\" src=\"https://user-images.githubusercontent.com/63405904/138543684-50c4a737-99d8-48cc-9c11-c47cb793dfb9.png\"><br>출처: 상위 1% 네트워크</p>\n<br>\n<h2 id=\"-story3-데이터를-송수신-한다\" style=\"position:relative;\"><a href=\"#-story3-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A5%BC-%EC%86%A1%EC%88%98%EC%8B%A0-%ED%95%9C%EB%8B%A4\" aria-label=\" story3 데이터를 송수신 한다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🛺 [Story3] 데이터를 송수신 한다.</h2>\n<h3 id=\"1-프로토콜-스택에-http-리퀘스트-메세지를-넘긴다\" style=\"position:relative;\"><a href=\"#1-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-%EC%8A%A4%ED%83%9D%EC%97%90-http-%EB%A6%AC%ED%80%98%EC%8A%A4%ED%8A%B8-%EB%A9%94%EC%84%B8%EC%A7%80%EB%A5%BC-%EB%84%98%EA%B8%B4%EB%8B%A4\" aria-label=\"1 프로토콜 스택에 http 리퀘스트 메세지를 넘긴다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 프로토콜 스택에 HTTP 리퀘스트 메세지를 넘긴다</h3>\n<p><code class=\"language-text\">write</code> 메서드를 호출하여 송신하고자 하는 데이터를 프로토콜 스택에 넘긴다.</p>\n<ul>\n<li>어플리케이션에서 받은 데이터를 프로토콜 스택 내부의 버퍼 메모리 영역에 우선 저장한다.\n<ul>\n<li>이유는, 어플리케이션에 건네주는 데이터의 크기는 프로토콜 스택이 제어할 수 없기 때문에 받은 데이터를 곧바로 보내면 데이터 송수신 동작이 지나치게 많이 일어나서 네트워크 효율이 떨어진다.</li>\n<li>패킷의 최대크기인 MTU에서 헤더를 제외한 MSS 만큼의 최대 데이터를 보낼 수 있다. (이것보다 작은 데이터를 보내는 경우 패킷이 예상치 못하게 나누어지지 않는다)</li>\n<li>하지만 항상 버퍼를 꽉 채워서 데이터를 보내는 경우 대기 시간이 길어지므로 송신 동작이 지연된다.</li>\n<li>네트워크 이용 효율을 중시하는지, 송신 동작 시간을 중시하는지 잘 절충해야한다. (프로토콜 스택을 구현한 OS에서 담당하며 어플리케이션 레벨에서 어느 정도 설정을 할 수도 있다)</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-데이터가-클-때는-분할하여-보낸다\" style=\"position:relative;\"><a href=\"#2-%EB%8D%B0%EC%9D%B4%ED%84%B0%EA%B0%80-%ED%81%B4-%EB%95%8C%EB%8A%94-%EB%B6%84%ED%95%A0%ED%95%98%EC%97%AC-%EB%B3%B4%EB%82%B8%EB%8B%A4\" aria-label=\"2 데이터가 클 때는 분할하여 보낸다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 데이터가 클 때는 분할하여 보낸다</h3>\n<ul>\n<li>데이터가 지나치게 크면 MSS 크기만큼 분할하여 패킷(헤더 + 데이터)을 만들어 보낸다.</li>\n</ul>\n<h3 id=\"3-ack-번호를-사용하여-패킷이-도착했는지-확인한다\" style=\"position:relative;\"><a href=\"#3-ack-%EB%B2%88%ED%98%B8%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EC%97%AC-%ED%8C%A8%ED%82%B7%EC%9D%B4-%EB%8F%84%EC%B0%A9%ED%96%88%EB%8A%94%EC%A7%80-%ED%99%95%EC%9D%B8%ED%95%9C%EB%8B%A4\" aria-label=\"3 ack 번호를 사용하여 패킷이 도착했는지 확인한다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. ACK 번호를 사용하여 패킷이 도착했는지 확인한다</h3>\n<ul>\n<li>\n<p><strong>ACK 번호 = 수신을 완료한 바이트 + 1</strong></p>\n</li>\n<li>\n<p>최초 3way handshake를 할 때 초기 시퀀스 번호를 함께 주고받는다.</p>\n<ul>\n<li>초기 시퀀스 번호를 악용할 수 있기 때문에 난수로 설정하여 미리 주고받는다.</li>\n</ul>\n</li>\n<li>\n<p>이후 <code class=\"language-text\">최초 시퀀스 번호 + 데이터의 크기</code> 만큼의 데이터를 수신했다면 그것에 대한 확인으로 <code class=\"language-text\">지금까지 수신한 바이트 + 1</code> 숫자를 ACK로 지정하여 응답한다.</p>\n<ul>\n<li>데이터의 크기는 어떻게 알 수 있을까? 보낸 패킷에 헤더길이를 빼면 수신한 데이터의 크기를 유추할 수 있기 때문에 따로 기재하지 않는다.</li>\n</ul>\n</li>\n<li>\n<p>이후 송신할 데이터를 시퀀스 번호로 지정하고 송신하고, 동일하게 수신한 마지막 바이트 + 1을 ACK로 응답한다.</p>\n<p align=\"center\"><img width=\"70%\" src=\"https://user-images.githubusercontent.com/63405904/138543698-a54e59f0-b7a5-48c8-896d-419eccce982f.png\"><br>출처: 상위 1% 네트워크</p>\n</li>\n<li>\n<p>시퀀스번호와 ACK 번호로 누락된 패킷 여부를 알 수 있다. 만일 누락되었으면 송신 버퍼 메모리에 저장되어 있는 데이터를 재송신한다.</p>\n<ul>\n<li><strong>이렇게 TCP는 누락을 검출하고 회복 처리를 한다.</strong></li>\n<li>LAN 어댑터, 버퍼, 라우터는 회복조치를 취하지 않는다. 오류가 검출되면 패킷을 버린다.</li>\n<li>TCP 여러번 패킷을 재송신해도 오류가 난다면 동작을 중지하고 어플리케이션에 오류를 통지한다.</li>\n</ul>\n</li>\n<li>\n<p>양방향 통신이 이루어지는 경우 역으로 동일하게 수행하면 된다.</p>\n<p align=\"center\"><img width=\"70%\" src=\"https://user-images.githubusercontent.com/63405904/138543707-85dcb8c9-5725-4039-828f-f588255ec919.png\"><br>출처: 상위 1% 네트워크</p>\n</li>\n</ul>\n<h3 id=\"4-패킷-평균-왕복-시간으로-ack-번호의-대기-시간을-조정한다\" style=\"position:relative;\"><a href=\"#4-%ED%8C%A8%ED%82%B7-%ED%8F%89%EA%B7%A0-%EC%99%95%EB%B3%B5-%EC%8B%9C%EA%B0%84%EC%9C%BC%EB%A1%9C-ack-%EB%B2%88%ED%98%B8%EC%9D%98-%EB%8C%80%EA%B8%B0-%EC%8B%9C%EA%B0%84%EC%9D%84-%EC%A1%B0%EC%A0%95%ED%95%9C%EB%8B%A4\" aria-label=\"4 패킷 평균 왕복 시간으로 ack 번호의 대기 시간을 조정한다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. 패킷 평균 왕복 시간으로 ACK 번호의 대기 시간을 조정한다</h3>\n<ul>\n<li>ACK가 오지 않는 것으로 패킷 유실을 판단하는데 ACK를 평생 기다릴 수 없으니 타임아웃 값 만큼 기다린다.\n<ul>\n<li>제대로 수신하였는데 네트워크가 혼잡하여 ACK가 오지 못하는 상황일수도 있으니 타임아웃 값을 적절하게 잘 설정해야한다.</li>\n<li>네트워크 혼잡으로 ACK를 받지 못했을때 패킷을 재송신 하면 네트워크에 부하를 얹는 것이다. 하지만 너무 오래 기다리면 속도가 지연의 원인이 된다.</li>\n<li>상황에 따라서 항상 다르기 때문에 대기 시간을 동적으로 변경한다.\n<ul>\n<li>항상 ACK가 돌아오는 시간을 기록하고 그 시간이 길어지면 대기 시간도 늘리며 짧으면 대기 시간도 줄인다.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"5-윈도우sliding-window-제어-방식으로-ack-번호를-관리한다\" style=\"position:relative;\"><a href=\"#5-%EC%9C%88%EB%8F%84%EC%9A%B0sliding-window-%EC%A0%9C%EC%96%B4-%EB%B0%A9%EC%8B%9D%EC%9C%BC%EB%A1%9C-ack-%EB%B2%88%ED%98%B8%EB%A5%BC-%EA%B4%80%EB%A6%AC%ED%95%9C%EB%8B%A4\" aria-label=\"5 윈도우sliding window 제어 방식으로 ack 번호를 관리한다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5. 윈도우(Sliding Window) 제어 방식으로 ACK 번호를 관리한다</h3>\n<ul>\n<li><a href=\"http://blog.skby.net/%EC%8A%AC%EB%9D%BC%EC%9D%B4%EB%94%A9-%EC%9C%88%EB%8F%84%EC%9A%B0sliding-window/\">http://blog.skby.net/슬라이딩-윈도우sliding-window/</a></li>\n<li>패킷을 하나 보내고 ACK를 기다리고 또 패킷을 보내고 ACK를 기다리는 핑퐁 방식은 시간을 소요한다. 복수개의 패킷을 보내는 슬라이딩 윈도우 기법으로 효율적으로 관리하도록 한다.\n<ul>\n<li>핑퐁의 경우 ack가 와야만 다음 패킷을 보내기 때문에 수신하는 측의 능력만큼 패킷을 보낸다.</li>\n<li>슬라이딩 윈도우는 여러개의 패킷을 우선 보내기 때문에 수신측의 능력을 초과하여 패킷을 보낼수도 있다. 이것을 방지하기 위해서 <strong>수신측의 수신버퍼만큼만 패킷을 보내도록 슬라이딩 윈도우 기법으로 송신</strong>하는 패킷 사이즈를 조절한다.</li>\n</ul>\n</li>\n<li>수신측이 ACK 값 산출 등의 후처리를 하는 동안 수신한 데이터를 일시적으로 수신 버퍼 메모리에 저장한다. 이때 송신측에서 수신 버퍼 메모리가 넘치도록 패킷을 보내면 수신측의 능력을 초과한 것이다.</li>\n<li>이것을 해결하기 위해 슬라이딩 윈도우 방식에서 <strong>수신 측에 빈 버퍼  최대 사이즈(윈도우 사이즈)를 TCP 헤더의 윈도우 필드에 기록</strong>하여 송신측에 알려준다.\n<ul>\n<li>\n<p>송신측에 알려주는 타이밍은 수신 버퍼에서 메모리를 추출하여 빈 공간이 추가로 생긴 타이밍이다. 점점 줄어드는 사이즈는 패킷의 데이터 사이즈를 통해서 유추할 수 있다.</p>\n<p align=\"center\"><img width=\"70%\" src=\"https://user-images.githubusercontent.com/63405904/138543713-a05c8851-30df-4e28-bd9e-9a1fc91b166d.png\"><br>출처: 상위 1% 네트워크</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"6-윈도우-사이즈--ack-합승\" style=\"position:relative;\"><a href=\"#6-%EC%9C%88%EB%8F%84%EC%9A%B0-%EC%82%AC%EC%9D%B4%EC%A6%88--ack-%ED%95%A9%EC%8A%B9\" aria-label=\"6 윈도우 사이즈  ack 합승 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>6. 윈도우 사이즈 + ACK 합승</h3>\n<ul>\n<li>ACK번호와 윈도우 사이즈를 각각 다른 패킷에 송신하면 주고받는 패킷이 너무 많기 때문에 효율적이지 않다.</li>\n<li>둘 중 하나만 생성되었을 때 기다리다가 두 개가 모두 일어나면 함께 하나의 패킷으로 송신한다.</li>\n<li>복수개의 ACK가 생겼을 때도 최후의 것만 송신한다.</li>\n<li>복수 윈도우 통지가 발생해도 최후 윈도우 사이즈만 보낸다.</li>\n</ul>\n<h3 id=\"7-http-응답-메세지를-수신한다\" style=\"position:relative;\"><a href=\"#7-http-%EC%9D%91%EB%8B%B5-%EB%A9%94%EC%84%B8%EC%A7%80%EB%A5%BC-%EC%88%98%EC%8B%A0%ED%95%9C%EB%8B%A4\" aria-label=\"7 http 응답 메세지를 수신한다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>7. HTTP 응답 메세지를 수신한다</h3>\n<ul>\n<li>프로토콜 스택이 HTTP 요청 메세지를 모두 보면 응답 메세지를 수신해야한다.</li>\n<li><code class=\"language-text\">read</code> 메서드를 호출해 프로토콜 수택이 수신 버퍼에 응답 메세지를 수신한다.</li>\n<li>응답 메세지가 일정 시간 후 도착해 수신 버퍼에 담기면 프로토콜 스택은 그것을 추출해 어플리케이션에 넘겨준다.</li>\n<li>수신 데이터에 TCP 헤더 정보를 통해 누락된 데이터가 없는지 확인하고 ACK를 응답한다. 데이터 조각을 버퍼에 보관하고 원래 데이터로 복원하여 어플리케이션에 보낸다.</li>\n<li>어플리케이션에 데이터를 추출한 타이밍에 윈도우 사이즈를 상대에 통지한다.</li>\n</ul>\n<br>\n<br>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[용어]\n\n패킷 - 네트워크에 운반되는 분할된 데이터의 덩어리 단위 \n\nMAC 주소 - LAN 방식의 기기가 가지고 있는 형식의 주소 \n\nPID - Process ID의 약자. OS가 각 프로세스에 할당하는 번호 \n\n소켓 - 통신 파이프 양 끝에 있는 출입구와 같은 것 \n\nMTU - Maximum Transmission Unit 패킷 하나에 운받하는 디지털 데이터의 최대길이 (이더넷 1500바이트)\n\nMSS - Maximum Segment Size 헤더를 제외한 TCP 데이터의 최대길이</code></pre></div>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#-story1-%EC%86%8C%EC%BC%93%EC%9D%84-%EC%9E%91%EC%84%B1%ED%95%9C%EB%8B%A4\">🛺 [Story1] 소켓을 작성한다.</a></p>\n<ul>\n<li><a href=\"#1-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-%EC%8A%A4%ED%83%9D%EC%9D%98-%EB%82%B4%EB%B6%80-%EA%B5%AC%EC%84%B1\">1. 프로토콜 스택의 내부 구성</a></li>\n<li><a href=\"#2-%EC%86%8C%EC%BC%93%EC%9D%80-%ED%86%B5%EC%8B%A0-%EC%A0%9C%EC%96%B4%EC%9A%A9-%EC%A0%9C%EC%96%B4-%EC%A0%95%EB%B3%B4%EC%9D%B4%EB%8B%A4\">2. 소켓은 통신 제어용 제어 정보이다</a></li>\n<li><a href=\"#3-%EC%86%8C%EC%BC%93%EC%9D%84-%ED%98%B8%EC%B6%9C%ED%96%88%EC%9D%84-%EB%95%8C-%EB%8F%99%EC%9E%91\">3. 소켓을 호출했을 때 동작</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-story2-%EC%84%9C%EB%B2%84%EC%97%90-%EC%A0%91%EC%86%8D%ED%95%9C%EB%8B%A4\">🛺 [Story2] 서버에 접속한다.</a></p>\n<ul>\n<li><a href=\"#1-%EC%A0%91%EC%86%8D%EC%9D%98-%EC%9D%98%EB%AF%B8\">1. 접속의 의미</a></li>\n<li><a href=\"#2-%EC%86%8C%EC%BC%93-%EC%95%9E%EC%97%90-%EC%A0%9C%EC%96%B4-%EC%A0%95%EB%B3%B4%EB%A5%BC-%EA%B8%B0%EB%A1%9D%ED%95%9C-%ED%97%A4%EB%8D%94-%EB%B0%B0%EC%B9%98\">2. 소켓 앞에 제어 정보를 기록한 헤더 배치</a></li>\n<li><a href=\"#3-%EC%A0%91%EC%86%8D-%EB%8F%99%EC%9E%91%EC%9D%98-%EC%8B%A4%EC%B2%B4\">3. 접속 동작의 실체</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-story3-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A5%BC-%EC%86%A1%EC%88%98%EC%8B%A0-%ED%95%9C%EB%8B%A4\">🛺 [Story3] 데이터를 송수신 한다.</a></p>\n<ul>\n<li><a href=\"#1-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-%EC%8A%A4%ED%83%9D%EC%97%90-http-%EB%A6%AC%ED%80%98%EC%8A%A4%ED%8A%B8-%EB%A9%94%EC%84%B8%EC%A7%80%EB%A5%BC-%EB%84%98%EA%B8%B4%EB%8B%A4\">1. 프로토콜 스택에 HTTP 리퀘스트 메세지를 넘긴다</a></li>\n<li><a href=\"#2-%EB%8D%B0%EC%9D%B4%ED%84%B0%EA%B0%80-%ED%81%B4-%EB%95%8C%EB%8A%94-%EB%B6%84%ED%95%A0%ED%95%98%EC%97%AC-%EB%B3%B4%EB%82%B8%EB%8B%A4\">2. 데이터가 클 때는 분할하여 보낸다</a></li>\n<li><a href=\"#3-ack-%EB%B2%88%ED%98%B8%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EC%97%AC-%ED%8C%A8%ED%82%B7%EC%9D%B4-%EB%8F%84%EC%B0%A9%ED%96%88%EB%8A%94%EC%A7%80-%ED%99%95%EC%9D%B8%ED%95%9C%EB%8B%A4\">3. ACK 번호를 사용하여 패킷이 도착했는지 확인한다</a></li>\n<li><a href=\"#4-%ED%8C%A8%ED%82%B7-%ED%8F%89%EA%B7%A0-%EC%99%95%EB%B3%B5-%EC%8B%9C%EA%B0%84%EC%9C%BC%EB%A1%9C-ack-%EB%B2%88%ED%98%B8%EC%9D%98-%EB%8C%80%EA%B8%B0-%EC%8B%9C%EA%B0%84%EC%9D%84-%EC%A1%B0%EC%A0%95%ED%95%9C%EB%8B%A4\">4. 패킷 평균 왕복 시간으로 ACK 번호의 대기 시간을 조정한다</a></li>\n<li><a href=\"#5-%EC%9C%88%EB%8F%84%EC%9A%B0sliding-window-%EC%A0%9C%EC%96%B4-%EB%B0%A9%EC%8B%9D%EC%9C%BC%EB%A1%9C-ack-%EB%B2%88%ED%98%B8%EB%A5%BC-%EA%B4%80%EB%A6%AC%ED%95%9C%EB%8B%A4\">5. 윈도우(Sliding Window) 제어 방식으로 ACK 번호를 관리한다</a></li>\n<li><a href=\"#6-%EC%9C%88%EB%8F%84%EC%9A%B0-%EC%82%AC%EC%9D%B4%EC%A6%88--ack-%ED%95%A9%EC%8A%B9\">6. 윈도우 사이즈 + ACK 합승</a></li>\n<li><a href=\"#7-http-%EC%9D%91%EB%8B%B5-%EB%A9%94%EC%84%B8%EC%A7%80%EB%A5%BC-%EC%88%98%EC%8B%A0%ED%95%9C%EB%8B%A4\">7. HTTP 응답 메세지를 수신한다</a></li>\n</ul>\n</li>\n</ul>\n</div>","excerpt":"다음은 성공과 실패를 결정하는 1%의 네트워크 원리 를 읽고 정리한 내용입니다. 본 글은 CH2. TCP/IP의 데이터를 전기 신호로 만들어 보낸다_프로토콜 스택과 LAN 어댑터의 탐험입니다 🙌 🛺 [Story1] 소켓을 작성한다. 1. 프로토콜 스택의 내부 구성 네트워크를 제어하는 다음 두 가지가 필요하다. 소프트웨어 - (OS 내장) 프로토콜 스택 하드웨어 - LAN 어댑터 아래가 네트워크 계층 구조이다. 어플리케이션에서 데이터 송신을 시작한다. 이때 소켓 라이브러리를 사용하여 리졸버로 DNS 서버를 조회하는 등의 동작을 실행한다. OS 내부에 있는 프로토콜 스택이 그 다음 작업을 의뢰받는다. TCP 혹은 UDP로 데이터를 송수신한다. IP 프로토콜로 패킷 송수신 동작을 제어한다. ICMP(패킷운반시 오류 통지, 제어용 메세지) 혹은 ARP(IP에 대응하는 MAC주소 조사)로 동작한다. LAN 드라이버는 LAN 어댑터라는 하드웨어를 제어한다. LAN 어댑터라는 하드웨어가 실제 …","frontmatter":{"date":"September 29, 2021","title":"성공과 실패를 결정하는 1%의 네트워크 원리_3","categories":"네트워크 책","author":"코다","emoji":"⚡️"},"fields":{"slug":"/one-percent-network-3/"}},"next":{"id":"67377600-a29e-5099-ba3e-69e517ee7ca0","html":"<blockquote>\n<p>다음은 웹 개발자를 위한 대규모 서비스를 지탱하는 기술을 읽고 정리한 내용입니다 🙌</p>\n</blockquote>\n<br>\n<ul>\n<li>규모가 커지면서 트래픽이 커지면 문제가 발생한다. → 라우터의 성능 관점에서는 bps보다 패킷 단위인 pps가 더 중요하다. 사용하고 있는 라우터에서 감당하는 이상의 패킷이 송수신되면 문제가 발생한다.</li>\n<li>또한 호스트 수가 500을 넘어가면서 하나의 서브넷을 구성하면 여러 패킷 손실등이 발생하기도 한다.</li>\n<li>글로벌 서비스로 확장하면 데이터 센트럴 한군데 두었을 때 latency도 한계에 다다를 수 있다.</li>\n</ul>\n<h2 id=\"강의38-네트워크-분기점\" style=\"position:relative;\"><a href=\"#%EA%B0%95%EC%9D%9838-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EB%B6%84%EA%B8%B0%EC%A0%90\" aria-label=\"강의38 네트워크 분기점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[강의38] 네트워크 분기점</h2>\n<h2 id=\"1gbps의-한계---pc-라우터의-한계\" style=\"position:relative;\"><a href=\"#1gbps%EC%9D%98-%ED%95%9C%EA%B3%84---pc-%EB%9D%BC%EC%9A%B0%ED%84%B0%EC%9D%98-%ED%95%9C%EA%B3%84\" aria-label=\"1gbps의 한계   pc 라우터의 한계 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1Gbps의 한계 - PC 라우터의 한계</h2>\n<ul>\n<li>1Gbps 는 30만pps → 한계치이다.</li>\n<li>이것을 해결하기 위해서는 PC 라우터를 여러 대 병렬화 하던지, 고가의 라우터를 사용해야 한다.</li>\n</ul>\n<h2 id=\"500호스트의-한계---1서브넷-arp-테이블에서의-한계\" style=\"position:relative;\"><a href=\"#500%ED%98%B8%EC%8A%A4%ED%8A%B8%EC%9D%98-%ED%95%9C%EA%B3%84---1%EC%84%9C%EB%B8%8C%EB%84%B7-arp-%ED%85%8C%EC%9D%B4%EB%B8%94%EC%97%90%EC%84%9C%EC%9D%98-%ED%95%9C%EA%B3%84\" aria-label=\"500호스트의 한계   1서브넷 arp 테이블에서의 한계 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>500호스트의 한계 - 1서브넷 ARP 테이블에서의 한계</h2>\n<ul>\n<li>스위치의 ARP(Address Resolution Protocol table)에서 한계가 있다.\n<ul>\n<li>ARP는 IP주소와 MAC 주소간의 관계를 나타내는 테이블이다.</li>\n</ul>\n</li>\n<li>이 테이블의 크기에 제한이 있다. 그것을 넘어가게 되면 특정 호스트로 ping이 가지 않게 된다.</li>\n<li>서브넷 내에 호스트가 많으면 브로드캐스팅 패킷이 증가하여 트래픽이 부하를 생성한다.</li>\n</ul>\n<h2 id=\"네트워크-구조-계층화\" style=\"position:relative;\"><a href=\"#%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EA%B5%AC%EC%A1%B0-%EA%B3%84%EC%B8%B5%ED%99%94\" aria-label=\"네트워크 구조 계층화 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>네트워크 구조 계층화</h2>\n<ul>\n<li>지금까지 언급한 문제에 대한 대책\n<ul>\n<li>3단 구조로 네트워크를 계층화 하자는 것이다.</li>\n</ul>\n</li>\n<li><strong>3단 구조</strong>\n<ol>\n<li>가장 작은 것은 Access 계층</li>\n<li>그 다음이 Distribution 계층</li>\n<li>가장 위가 Core 계층 또는 OSPF 영역</li>\n</ol>\n<ul>\n<li>이렇게 가장 작은 서브넷에서 100대, 200대를 억제, 디스트리뷰션에서 1000대, 코어 전체에서 100000 단위로 다룬다.</li>\n</ul>\n</li>\n<li>Distribution 영역간 트래픽을 제어해서 너무 증가하지 않도록 하고 서브넷 내에서의 통신량을 제어한다.</li>\n</ul>\n<h2 id=\"글로벌화\" style=\"position:relative;\"><a href=\"#%EA%B8%80%EB%A1%9C%EB%B2%8C%ED%99%94\" aria-label=\"글로벌화 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>글로벌화</h2>\n<ul>\n<li>CDN을 사용해서 여러 곳에 배치된 데이터센터를 활용해 latency를 줄인다.</li>\n</ul>\n<br>\n<h2 id=\"강의39-한층-높은-단계로\" style=\"position:relative;\"><a href=\"#%EA%B0%95%EC%9D%9839-%ED%95%9C%EC%B8%B5-%EB%86%92%EC%9D%80-%EB%8B%A8%EA%B3%84%EB%A1%9C\" aria-label=\"강의39 한층 높은 단계로 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[강의39] 한층 높은 단계로</h2>\n<h2 id=\"웹-서비스-인프라의-핵심\" style=\"position:relative;\"><a href=\"#%EC%9B%B9-%EC%84%9C%EB%B9%84%EC%8A%A4-%EC%9D%B8%ED%94%84%EB%9D%BC%EC%9D%98-%ED%95%B5%EC%8B%AC\" aria-label=\"웹 서비스 인프라의 핵심 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>웹 서비스 인프라의 핵심</h2>\n<ul>\n<li>저비용, 높은 확장성</li>\n<li>적당하면서 충분히 높은 신뢰성</li>\n<li>기술 4가지\n<ul>\n<li>확장성</li>\n<li>다중화</li>\n<li>효율향상</li>\n<li>네트워크</li>\n</ul>\n</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#%EA%B0%95%EC%9D%9838-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EB%B6%84%EA%B8%B0%EC%A0%90\">[강의38] 네트워크 분기점</a></li>\n<li><a href=\"#1gbps%EC%9D%98-%ED%95%9C%EA%B3%84---pc-%EB%9D%BC%EC%9A%B0%ED%84%B0%EC%9D%98-%ED%95%9C%EA%B3%84\">1Gbps의 한계 - PC 라우터의 한계</a></li>\n<li><a href=\"#500%ED%98%B8%EC%8A%A4%ED%8A%B8%EC%9D%98-%ED%95%9C%EA%B3%84---1%EC%84%9C%EB%B8%8C%EB%84%B7-arp-%ED%85%8C%EC%9D%B4%EB%B8%94%EC%97%90%EC%84%9C%EC%9D%98-%ED%95%9C%EA%B3%84\">500호스트의 한계 - 1서브넷 ARP 테이블에서의 한계</a></li>\n<li><a href=\"#%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EA%B5%AC%EC%A1%B0-%EA%B3%84%EC%B8%B5%ED%99%94\">네트워크 구조 계층화</a></li>\n<li><a href=\"#%EA%B8%80%EB%A1%9C%EB%B2%8C%ED%99%94\">글로벌화</a></li>\n<li><a href=\"#%EA%B0%95%EC%9D%9839-%ED%95%9C%EC%B8%B5-%EB%86%92%EC%9D%80-%EB%8B%A8%EA%B3%84%EB%A1%9C\">[강의39] 한층 높은 단계로</a></li>\n<li><a href=\"#%EC%9B%B9-%EC%84%9C%EB%B9%84%EC%8A%A4-%EC%9D%B8%ED%94%84%EB%9D%BC%EC%9D%98-%ED%95%B5%EC%8B%AC\">웹 서비스 인프라의 핵심</a></li>\n</ul>\n</div>","frontmatter":{"date":"September 29, 2021","title":"대규모 서비스를 지탱하는 기술 - 웹 서비스와 네트워크","categories":"웹 인프라 책 성능테스트","author":"코다","emoji":"📚"},"fields":{"slug":"/high-traffic-service_12/"}},"prev":{"id":"8064689b-ac41-5c5d-b707-9c5fb59639e2","html":"<blockquote>\n<p>다음은 웹 개발자를 위한 대규모 서비스를 지탱하는 기술을 읽고 정리한 내용입니다 🙌</p>\n</blockquote>\n<br>\n<h2 id=\"1-작업큐job-queue-시스템\" style=\"position:relative;\"><a href=\"#1-%EC%9E%91%EC%97%85%ED%81%90job-queue-%EC%8B%9C%EC%8A%A4%ED%85%9C\" aria-label=\"1 작업큐job queue 시스템 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 작업큐(Job-Queue) 시스템</h2>\n<h2 id=\"웹-서비스와-요청\" style=\"position:relative;\"><a href=\"#%EC%9B%B9-%EC%84%9C%EB%B9%84%EC%8A%A4%EC%99%80-%EC%9A%94%EC%B2%AD\" aria-label=\"웹 서비스와 요청 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>웹 서비스와 요청</h2>\n<p>본래 웹 서비스의 요청은 동기적으로 실행이 되었는데, 데이터가 축적되어 처리가 무거워지면서 작업큐 시스템을 통해서 나중으로 미뤄도 되는 처리를 비동기로 실행하도록 한다.</p>\n<p><strong>예)</strong> 특정 url을 북마크 할 때 해당 url의 개요를 얻고 키워드를 추출하고, 카테고리를 판정하는 작업들을 비동기로 처리한다. 그렇지 않으면 북마크를 추가할 때마다 긴 시간이 소요된다.</p>\n<h2 id=\"작업큐-시스템-입문\" style=\"position:relative;\"><a href=\"#%EC%9E%91%EC%97%85%ED%81%90-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%9E%85%EB%AC%B8\" aria-label=\"작업큐 시스템 입문 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>작업큐 시스템 입문</h2>\n<ul>\n<li>비동화 하는 방법 → 해당 처리를 독립된 스크립트로 어플리케이션 내부에서 호출한다.\n<ul>\n<li>이 방법은 대량의 비동기 처리시 그 수만큼의 프로세스를 실행시키므로 성능상 단점이 될 수 있다.</li>\n<li>스크립트 시작과 초기화의 오버헤드가 커서 성능이 좋지 않다.</li>\n<li>소규모 어플리케이션에서만 진행하는 것이 좋다.</li>\n</ul>\n</li>\n<li>작업큐와 워커를 세트로 작업큐 시스템을 사용하는 것이 일반적이다.\n<ul>\n<li>작업큐에 실행하고자 하는 처리를 등록하고, 워커가 큐에서 작업을 추출해서 처리한다.</li>\n<li>작업큐를 통해 일시작인 대량의 처리 등록시 부하의 변동을 흡수한다.</li>\n<li>워커가 항상 실행하고 있으므로 처리시 초기화 오버헤드가 거의 없다.</li>\n</ul>\n<p align=\"center\"><img width=\"85%\" src=\"https://user-images.githubusercontent.com/63405904/136998712-f7065322-bc05-4c98-a135-c8e360e0f89e.png\"><br>이미지 출처: 대용량 서비스를 지탱하는 기술</p>\n</li>\n</ul>\n<br>\n<h2 id=\"2-스토리지-선택---rdbms-와-key-value-스토어\" style=\"position:relative;\"><a href=\"#2-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80-%EC%84%A0%ED%83%9D---rdbms-%EC%99%80-key-value-%EC%8A%A4%ED%86%A0%EC%96%B4\" aria-label=\"2 스토리지 선택   rdbms 와 key value 스토어 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 스토리지 선택 - RDBMS 와 key-value 스토어</h2>\n<h2 id=\"증가하는-데이터를-어떻게-저장할까-\" style=\"position:relative;\"><a href=\"#%EC%A6%9D%EA%B0%80%ED%95%98%EB%8A%94-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A5%BC-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%A0%80%EC%9E%A5%ED%95%A0%EA%B9%8C-\" aria-label=\"증가하는 데이터를 어떻게 저장할까  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>증가하는 데이터를 어떻게 저장할까 ?</h2>\n<h3 id=\"웹-어플리케이션과-스토리지\" style=\"position:relative;\"><a href=\"#%EC%9B%B9-%EC%96%B4%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%EA%B3%BC-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80\" aria-label=\"웹 어플리케이션과 스토리지 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>웹 어플리케이션과 스토리지</h3>\n<ul>\n<li><strong>스토리지란?</strong>\n<ul>\n<li>데이터를 영속적 혹은 일시적으로 저장하기 위한 기능</li>\n</ul>\n</li>\n<li>원본 데이터는 서비스의 근본적인 신뢰성과 관계되어서 매우 중요하다.</li>\n<li>캐시 데이터는 신뢰성보다는 성능을 높이고 비용을 줄일 때 사용된다.</li>\n<li>스토리지를 처음부터 잘 선택하는 것이 중요하다. 중간에 변경을 하려는 것은 굉장히 어렵다.</li>\n</ul>\n<h3 id=\"스토리지-선택의-전제조건\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80-%EC%84%A0%ED%83%9D%EC%9D%98-%EC%A0%84%EC%A0%9C%EC%A1%B0%EA%B1%B4\" aria-label=\"스토리지 선택의 전제조건 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스토리지 선택의 전제조건</h3>\n<ul>\n<li>평균크기</li>\n<li>최대크기</li>\n<li>신규추가빈도</li>\n<li>갱신빈도</li>\n<li>삭제빈도</li>\n<li>참조빈도</li>\n</ul>\n<h3 id=\"스토리지의-종류\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80%EC%9D%98-%EC%A2%85%EB%A5%98\" aria-label=\"스토리지의 종류 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스토리지의 종류</h3>\n<ul>\n<li>현재는 크기 4가지 이다.\n<ul>\n<li>RDBMS\n<ul>\n<li>SQL 언어로 데이터 조작을 수행하는 시스템</li>\n<li>대표적으로 MySQL이 있다.</li>\n<li>MySQL에서는 SQL을 해석하여 실행하는 블록(서버, 옵티마이저, 캐시버퍼)과 실제 데이터를 보관하는 기능블록(InnoDB와 같은 스토리지 엔진)이 분리되어 있다.</li>\n<li>트랜잭션이 필요하고 갱신빈도가 높다면 InnoDB 엔진을 선택하고 추가작업이나 count 등만을 사용하면 MyISAM을 사용하는 등 특징에 맞게 선택해서 사용한다.\n<ul>\n<li>그렇지만 하나의 서버에서 두가지 엔진을 사용하는 것은 효율적인 CPU, 메모리 사용이 어렵다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>분산 key-value 스토어 (ex. memcached 등등)\n<ul>\n<li>정말 심플한 스토리지 이다.</li>\n<li>RDBMS에 비해 기능을 부족하지만 성능이 10~100배이다.</li>\n<li>분산알고리즘을 사용하기도 하는데 key의 해시값을 서버대수로 나누어서 분산저장하는 방법이나 더 복잡한 방법으로 분산한다.</li>\n<li>캐시데이터를 분산 key-value 스토리지에 저장할 수 있다.</li>\n</ul>\n</li>\n<li>분산 파일 시스템\n<ul>\n<li>보통 어느 크기 상의 데이터를 저장하는데 적합하다.</li>\n</ul>\n</li>\n<li>그 밖의 스토리지</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"3-캐시-시스템\" style=\"position:relative;\"><a href=\"#3-%EC%BA%90%EC%8B%9C-%EC%8B%9C%EC%8A%A4%ED%85%9C\" aria-label=\"3 캐시 시스템 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 캐시 시스템</h2>\n<h2 id=\"웹-어플리케이션의-부하와-프록시캐시-시스템\" style=\"position:relative;\"><a href=\"#%EC%9B%B9-%EC%96%B4%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%EC%9D%98-%EB%B6%80%ED%95%98%EC%99%80-%ED%94%84%EB%A1%9D%EC%8B%9C%EC%BA%90%EC%8B%9C-%EC%8B%9C%EC%8A%A4%ED%85%9C\" aria-label=\"웹 어플리케이션의 부하와 프록시캐시 시스템 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>웹 어플리케이션의 부하와 프록시/캐시 시스템</h2>\n<ul>\n<li>\n<p>용량이 부족할 때 HTTP 레벨의 캐싱을 포워드 프록시와 리버스 프록시로 진행할 수 있다.</p>\n</li>\n<li>\n<p>프록시에서 요청에 대한 응답을 캐싱하여 같은 요청이 전달됐을 때 캐싱해둔 응답을 반환할 수 있다.</p>\n</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#1-%EC%9E%91%EC%97%85%ED%81%90job-queue-%EC%8B%9C%EC%8A%A4%ED%85%9C\">1. 작업큐(Job-Queue) 시스템</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%9B%B9-%EC%84%9C%EB%B9%84%EC%8A%A4%EC%99%80-%EC%9A%94%EC%B2%AD\">웹 서비스와 요청</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%9E%91%EC%97%85%ED%81%90-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%9E%85%EB%AC%B8\">작업큐 시스템 입문</a></p>\n</li>\n<li>\n<p><a href=\"#2-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80-%EC%84%A0%ED%83%9D---rdbms-%EC%99%80-key-value-%EC%8A%A4%ED%86%A0%EC%96%B4\">2. 스토리지 선택 - RDBMS 와 key-value 스토어</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%A6%9D%EA%B0%80%ED%95%98%EB%8A%94-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A5%BC-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%A0%80%EC%9E%A5%ED%95%A0%EA%B9%8C-\">증가하는 데이터를 어떻게 저장할까 ?</a></p>\n<ul>\n<li><a href=\"#%EC%9B%B9-%EC%96%B4%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%EA%B3%BC-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80\">웹 어플리케이션과 스토리지</a></li>\n<li><a href=\"#%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80-%EC%84%A0%ED%83%9D%EC%9D%98-%EC%A0%84%EC%A0%9C%EC%A1%B0%EA%B1%B4\">스토리지 선택의 전제조건</a></li>\n<li><a href=\"#%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80%EC%9D%98-%EC%A2%85%EB%A5%98\">스토리지의 종류</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#3-%EC%BA%90%EC%8B%9C-%EC%8B%9C%EC%8A%A4%ED%85%9C\">3. 캐시 시스템</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%9B%B9-%EC%96%B4%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%EC%9D%98-%EB%B6%80%ED%95%98%EC%99%80-%ED%94%84%EB%A1%9D%EC%8B%9C%EC%BA%90%EC%8B%9C-%EC%8B%9C%EC%8A%A4%ED%85%9C\">웹 어플리케이션의 부하와 프록시/캐시 시스템</a></p>\n</li>\n</ul>\n</div>","frontmatter":{"date":"September 29, 2021","title":"대규모 서비스를 지탱하는 기술 - 실전 기술","categories":"웹 인프라 책 성능테스트","author":"코다","emoji":"📚"},"fields":{"slug":"/high-traffic-service_13/"}},"site":{"siteMetadata":{"siteUrl":"https://yjksw.github.io","comments":{"utterances":{"repo":"yjksw/yjksw.github.io"}}}}},"pageContext":{"slug":"/one-percent-network-3/","nextSlug":"/high-traffic-service_12/","prevSlug":"/high-traffic-service_13/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}
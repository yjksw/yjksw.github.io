{"componentChunkName":"component---src-templates-blog-template-js","path":"/os-deadlock/","result":{"data":{"cur":{"id":"80eec19c-30a9-53ed-bbfd-bb60c8bcfc25","html":"<h2 id=\"-intro\" style=\"position:relative;\"><a href=\"#-intro\" aria-label=\" intro permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>💡 INTRO</h2>\n<ul>\n<li>팀과 함께 나름 큰 프로젝트를 진행했다. 또한 추후에 있을 꽤 많은 사람들(약 100명 예상)이 참여하는 데모를 준비했다. </li>\n<li>실제 사람들에게 사용되려니 고려해야할 것이 굉장히 많았다. </li>\n<li>기능이 제대로 돌아가는 것도 중요하지만 많은 사용자에게 실제로 서비스 될 수 있는지까지 고려해야했다. </li>\n<li>따라서 어플리케이션이 실제로 구동되는 OS에 대한 지식이 없이는 어플리케이션의 안정성에 대한 판단력을 가지기 어렵다고 생각했다. </li>\n<li>따라서 운영체제 관련 책을 읽고 (추후 업로드 예정) 책에 빠진 부분을 보충하여 학습한다. </li>\n</ul>\n<br>\n<h2 id=\"-keywords\" style=\"position:relative;\"><a href=\"#-keywords\" aria-label=\" keywords permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 KEYWORDS</h2>\n<ul>\n<li class=\"task-list-item\">\n<p><input type=\"checkbox\" checked disabled>  교착상태 특징</p>\n<ul>\n<li class=\"task-list-item\"><input type=\"checkbox\" checked disabled>  필요 조건들</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" checked disabled>  자원 할당 그래프 ..</li>\n</ul>\n</li>\n<li class=\"task-list-item\">\n<p><input type=\"checkbox\" checked disabled>  교착상태 처리 방법</p>\n<ul>\n<li class=\"task-list-item\">\n<p><input type=\"checkbox\" checked disabled>  교착상태 예방</p>\n<ul>\n<li class=\"task-list-item\"><input type=\"checkbox\" checked disabled>  상호 배제 Mutual Exclusion</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" checked disabled>  점유하여 대기 Hold and Wait</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" checked disabled>  비선점 No Preemption</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" checked disabled>  순환 대기 Circular Wait</li>\n</ul>\n</li>\n<li class=\"task-list-item\">\n<p><input type=\"checkbox\" checked disabled>  교착상태 회피</p>\n<ul>\n<li class=\"task-list-item\"><input type=\"checkbox\" checked disabled>  안전 상태 Safe State</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" checked disabled>  자원 할당 그래프 알고리즘 Resource-Allocation Graph Algorithm</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" checked disabled>  은행원 알고리즘 Banker’s Algorithm</li>\n</ul>\n</li>\n</ul>\n</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" checked disabled>  교착상태 탐지 Deadlock Detection</li>\n<li class=\"task-list-item\">\n<p><input type=\"checkbox\" checked disabled>  교착상태 회복</p>\n<ul>\n<li class=\"task-list-item\"><input type=\"checkbox\" checked disabled>  프로세스 종료 Process Termination</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" checked disabled>  자원 선점 Resource Preemption</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-교착상태-deadlock\" style=\"position:relative;\"><a href=\"#-%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9C-deadlock\" aria-label=\" 교착상태 deadlock permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 교착상태 Deadlock</h2>\n<ul>\n<li>둘 이상의 프로세스 혹은 스레드가 다른 프로세스/스레드가 가지고 있는 자원을 기다리면서 무한대기 루프에 빠지는 것이다.</li>\n<li>자원은 I/O 디바이스, CPU cycle, 메모리, 세마포어 등등</li>\n<li>\n<p>예를 들어 바이너리 세마포어 2개가 있는데 2개를 모두 획득해야 임계 영역에 들어갈 수 있다면 교착상태에 빠질 가능성이 생긴다.</p>\n<ul>\n<li>P0 → P(A); P(B);</li>\n<li>P1 → P(B); P(A);</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"발생조건-4가지\" style=\"position:relative;\"><a href=\"#%EB%B0%9C%EC%83%9D%EC%A1%B0%EA%B1%B4-4%EA%B0%80%EC%A7%80\" aria-label=\"발생조건 4가지 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>발생조건 4가지</h3>\n<ul>\n<li>\n<p>상호 배제</p>\n<ul>\n<li>한번에 하나의 프로세스만 자원을 사용할 수 있다. 사용하고 싶은 다른 프로세스는 해제할 때까지 기다려야 한다.</li>\n</ul>\n</li>\n<li>\n<p>점유 대기</p>\n<ul>\n<li>자원을 하나 보유하고 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재한다.</li>\n</ul>\n</li>\n<li>\n<p>비선점</p>\n<ul>\n<li>다른 프로세스에게 할당된 자원을 강제로 빼앗을 수 없다.</li>\n</ul>\n</li>\n<li>\n<p>순환 대기</p>\n<ul>\n<li>대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다. 즉, 원하는 자원을 이어서 순환 사이클이 만들어진다.</li>\n</ul>\n</li>\n<li>위 4가지를 모두 만족해야지 데드락이 발생한다.</li>\n</ul>\n<h3 id=\"자원-할당-그래프-resource-allocation-graph\" style=\"position:relative;\"><a href=\"#%EC%9E%90%EC%9B%90-%ED%95%A0%EB%8B%B9-%EA%B7%B8%EB%9E%98%ED%94%84-resource-allocation-graph\" aria-label=\"자원 할당 그래프 resource allocation graph permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>자원 할당 그래프 Resource Allocation Graph</h3>\n<ul>\n<li>프로세스의 자원 할당 상태를 표현해주는 그래프이다.</li>\n<li>각각 프로세스, 자원이 노드로 있으며 프로세스 → 자원 edge는 프로세스의 자원 요청, 자원 → 프로세스 edge는 해당 프로세스의 자원 소유를 뜻한다.</li>\n<li><strong>자원 할당 그래프에 사이클이 없으면 데드락이 아니다.</strong></li>\n<li>\n<p>사이클이 있다면 맞을 수도 아닐 수도 있다.</p>\n<ul>\n<li>각 리소스 당 하나의 프로세스만 요청을 보내고 있다면 데드락이다.</li>\n<li>\n<p>여러 인스턴스가 요청을 보내고 있다면 데드락 가능성이 있는 것이다.</p>\n<p align=\"center\"><img width=\"70%\" src=\"https://user-images.githubusercontent.com/63405904/139089988-7833eebb-8fc4-4571-8ed8-4bbe254e85cc.png\"></p>\n</li>\n<li>왼쪽은 데드락, 오른쪽은 데드락이 아니다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-교착상태-처리-방법\" style=\"position:relative;\"><a href=\"#-%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9C-%EC%B2%98%EB%A6%AC-%EB%B0%A9%EB%B2%95\" aria-label=\" 교착상태 처리 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 교착상태 처리 방법</h2>\n<ul>\n<li>\n<p>교착상태 예방</p>\n<ul>\n<li>자원 할당을 하면서 데드락 발생조건 4가지 중 하나가 일어나지 않도록 하는 것이다.</li>\n<li>자원이 소모되고, 성능이 낮아지며, 기아 현상을 겪을 수 있다.</li>\n</ul>\n</li>\n<li>\n<p>교착상태 회피</p>\n<ul>\n<li>자원 요청의 부가적인 정보를 통해 데드락 가능성이 없는 경우에만 자원을 할당한다.</li>\n<li>보수적으로 자원을 할당하여 시스템에 비효율적이다.</li>\n</ul>\n</li>\n<li>\n<p>교착상태 탐지</p>\n<ul>\n<li>데드락 발생을 허용하고 탐지가 된다면 데드락을 회복시키는 방법이다.</li>\n<li>탐지하는데 오버헤드가 존재한다.</li>\n</ul>\n</li>\n<li>\n<p>교착상태 무시</p>\n<ul>\n<li>데드락을 시스템이 책임지지 않는다.</li>\n<li>자주 발생하는 상황이 아니므로 대부분은 os는 데드락 무시를 채택한다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"교착상태-예방\" style=\"position:relative;\"><a href=\"#%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9C-%EC%98%88%EB%B0%A9\" aria-label=\"교착상태 예방 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>교착상태 예방</h3>\n<ul>\n<li>\n<p>상호 배제</p>\n<ul>\n<li>여러 프로세스가 자원을 공유할 수 있다면 데드락이 발생하지 않지만 공유할 수 없는 상황이므로 이 조건을 배제하기는 어렵다.</li>\n</ul>\n</li>\n<li>\n<p>점유하여 대기 Hold and Wait</p>\n<ul>\n<li>프로세스가 자원을 소유하면서 다른 자원을 요청할 수 없도록 한다. 애초에 필요한 모든 자원을 할당받거나 일부를 받지 못한 경우 보유 자원을 모두 반납하고 다시 자원을 요청하도록 한다.</li>\n</ul>\n</li>\n<li>\n<p>비선점 No Preemption</p>\n<ul>\n<li>만일 한 프로세스가 다른 자원을 기다리는 경우 보유된 자원은 선점되도록 한다.</li>\n<li>모든 자원을 다 얻을 수 있을 때 해당 프로세스가 시작된다.</li>\n<li>상태를 쉽게 저장하고 로딩할 수 있는 자원에서 주로 사용된다. (cpu, memory)</li>\n</ul>\n</li>\n<li>\n<p>순환대기 Circular Wait</p>\n<ul>\n<li>자원에 할당 순서를 정한다. 예를 들어 R1, R2 순서대로 자원을 할당 받도록 한다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"교착상태-회피\" style=\"position:relative;\"><a href=\"#%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9C-%ED%9A%8C%ED%94%BC\" aria-label=\"교착상태 회피 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>교착상태 회피</h3>\n<ul>\n<li>\n<p>안전 상태 Safe State</p>\n<ul>\n<li>프로세스가 시작될 때 사용할 자원의 최대 요구량을 알 수 있다.</li>\n<li>현재 가용 자원량을 판단하여 프로세스가 요구한 자원최대량 보다 많을 경우에만 프로세스에게 자원을 할당한다.</li>\n<li>시스템이 safe state에 있다면 데드락이 없고 unsafe state에 있다면 데드락 발생 가능성이 있는 것이다.</li>\n<li>따라서 시스템이 unsafe state에 들어가지 않도록 보장한다.</li>\n</ul>\n</li>\n<li>\n<p>자원 할당 그래프 알고리즘 Resource-Allocation Graph Algorithm</p>\n<ul>\n<li>자원 할당 그래프를 보고 사이클이 생기지 않는 경우에만 자원을 할당한다.</li>\n<li>사이클 생성 여부 조사시 O(n^2) 시간이 걸린다.</li>\n</ul>\n</li>\n<li>\n<p>은행원 알고리즘 Banker’s Algorithm</p>\n<ul>\n<li>Allocation -  현재 프로세스에 할당된 자원량</li>\n<li>Max - 프로세스가 요구할 수 있는 최대 자원량</li>\n<li>Available - 자원당 가용 자원량</li>\n<li>Need - 프로세스가 현재 추가로 요구할 수 있는 자원량 (Max - Allocation)</li>\n<li>\n<p>아래 그림에서 P1의 Need는 현재 가용 자원으로 할당될 수 있으나, P1의 최대 자원량보다 현재 갸용 자원량이 적으므로 보수적으로 자원을 할당하지 않는다.</p>\n<p align=\"center\"><img width=\"70%\" src=\"https://user-images.githubusercontent.com/63405904/139090079-ad692f17-888d-4acd-bc10-ef49b281df84.png\"></p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"교착상태-탐지\" style=\"position:relative;\"><a href=\"#%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9C-%ED%83%90%EC%A7%80\" aria-label=\"교착상태 탐지 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>교착상태 탐지</h3>\n<ul>\n<li>데드락이 발생했을 때 그것을 후속처리한다.</li>\n<li>\n<p>탐지하는 방법</p>\n<ul>\n<li>\n<p>만일 자원당 인스턴스가 하나인 경우 → 자원 할당 그래프의 사이클은 데드락이다.</p>\n<ul>\n<li>\n<p>wait-for graph 알고리즘 사용</p>\n<ul>\n<li>자원 할당 그래프와 비슷한 형태이지만 프로세스만 노드로 구성되어 있다.</li>\n<li>P0 → P1은 P0이 P1의 자원을 기다리는 경우이다.</li>\n<li>wait-for graph에 사이클이 존재하는지 주기적으로 조사한다. (O(n^2))</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>자원당 여러 인스턴스 인 경우 → 은행원 알고리즘과 유사한 방법을 활용한다.</p>\n<ul>\n<li>자원을 요청하고 있지 않은 프로세스들이 보유한 자원은 반환된 자원이라고 가정한다.</li>\n<li>은행원 알고리즘으로 safe state를 찾아간다. 하지만 safe state를 찾을 수 없다면 데드락이다.</li>\n<li>이때 회복을 한다.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<br>\n<h3 id=\"교착상태-회복\" style=\"position:relative;\"><a href=\"#%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9C-%ED%9A%8C%EB%B3%B5\" aria-label=\"교착상태 회복 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>교착상태 회복</h3>\n<p>데드락 회복 2가지 방법</p>\n<ul>\n<li>\n<p>Process Termination 프로세스 죽이기</p>\n<ul>\n<li>데드락이 걸린 프로세스를 모두 죽인다.</li>\n<li>데드락이 풀릴 때까지 프로세스를 하나씩 죽인다.</li>\n</ul>\n</li>\n<li>\n<p>Resource Preemption</p>\n<ul>\n<li>비용을 최소화 할 victim을 설정하여 해당 프로세스를 재시작한다.</li>\n<li>하지만 동일한 프로세스가 계속 victim으로 선정되면 기아현상이 발생할 수 있다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h3 id=\"교착상태-무시\" style=\"position:relative;\"><a href=\"#%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9C-%EB%AC%B4%EC%8B%9C\" aria-label=\"교착상태 무시 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>교착상태 무시</h3>\n<ul>\n<li>데드락은 잘 발생하지 않는다.</li>\n<li>만일 발생하면 시스템에 이상해지고 사용자가 알아서 프로세스를 죽이도록 한다.</li>\n<li>데드락을 예방하고 처리하는 것은 시스템 오버헤드가 존재한다.</li>\n</ul>\n<br>\n<br>\n<p><strong>[참고링크]</strong></p>\n<ul>\n<li><a href=\"**%5Bhttps://kpuls.tistory.com/61%5D(https://kpuls.tistory.com/61)**\">[https://kpuls.tistory.com/61](https://kpuls.tistory.com/61)**</a>**</li>\n<li><a href=\"%5Bhttps://chanhuiseok.github.io/posts/cs-2/%5D(https://chanhuiseok.github.io/posts/cs-2/)\">[https://chanhuiseok.github.io/posts/cs-2/](https://chanhuiseok.github.io/posts/cs-2/)</a></li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#-intro\">💡 INTRO</a></li>\n<li><a href=\"#-keywords\">🌩 KEYWORDS</a></li>\n<li>\n<p><a href=\"#-%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9C-deadlock\">🌩 교착상태 Deadlock</a></p>\n<ul>\n<li><a href=\"#%EB%B0%9C%EC%83%9D%EC%A1%B0%EA%B1%B4-4%EA%B0%80%EC%A7%80\">발생조건 4가지</a></li>\n<li><a href=\"#%EC%9E%90%EC%9B%90-%ED%95%A0%EB%8B%B9-%EA%B7%B8%EB%9E%98%ED%94%84-resource-allocation-graph\">자원 할당 그래프 Resource Allocation Graph</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9C-%EC%B2%98%EB%A6%AC-%EB%B0%A9%EB%B2%95\">🌩 교착상태 처리 방법</a></p>\n<ul>\n<li><a href=\"#%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9C-%EC%98%88%EB%B0%A9\">교착상태 예방</a></li>\n<li><a href=\"#%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9C-%ED%9A%8C%ED%94%BC\">교착상태 회피</a></li>\n<li><a href=\"#%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9C-%ED%83%90%EC%A7%80\">교착상태 탐지</a></li>\n<li><a href=\"#%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9C-%ED%9A%8C%EB%B3%B5\">교착상태 회복</a></li>\n<li><a href=\"#%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9C-%EB%AC%B4%EC%8B%9C\">교착상태 무시</a></li>\n</ul>\n</li>\n</ul>\n</div>","excerpt":"💡 INTRO 팀과 함께 나름 큰 프로젝트를 진행했다. 또한 추후에 있을 꽤 많은 사람들(약 100명 예상)이 참여하는 데모를 준비했다.  실제 사람들에게 사용되려니 고려해야할 것이 굉장히 많았다.  기능이 제대로 돌아가는 것도 중요하지만 많은 사용자에게 실제로 서비스 될 수 있는지까지 고려해야했다.  따라서 어플리케이션이 실제로 구동되는 OS에 대한 지식이 없이는 어플리케이션의 안정성에 대한 판단력을 가지기 어렵다고 생각했다.  따라서 운영체제 관련 책을 읽고 (추후 업로드 예정) 책에 빠진 부분을 보충하여 학습한다.  🌩 KEYWORDS  교착상태 특징  필요 조건들  자원 할당 그래프 ..  교착상태 처리 방법  교착상태 예방  상호 배제 Mutual Exclusion  점유하여 대기 Hold and Wait  비선점 No Preemption  순환 대기 Circular Wait  교착상태 회피  안전 상태 Safe State  자원 할당 그래프 알고리즘 Resource-Al…","frontmatter":{"date":"October 22, 2021","title":"내가 또 보기 위한 운영체제 Deadlock","categories":"운영체제","author":"코다","emoji":"🧁"},"fields":{"slug":"/os-deadlock/"}},"next":{"id":"6e98f82c-055a-5bde-b249-27124d358da9","html":"<h2 id=\"-intro\" style=\"position:relative;\"><a href=\"#-intro\" aria-label=\" intro permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>💡 INTRO</h2>\n<ul>\n<li>팀과 함께 나름 큰 프로젝트를 진행했다. 또한 추후에 있을 꽤 많은 사람들(약 100명 예상)이 참여하는 데모를 준비했다. </li>\n<li>실제 사람들에게 사용되려니 고려해야할 것이 굉장히 많았다. </li>\n<li>기능이 제대로 돌아가는 것도 중요하지만 많은 사용자에게 실제로 서비스 될 수 있는지까지 고려해야했다. </li>\n<li>따라서 어플리케이션이 실제로 구동되는 OS에 대한 지식이 없이는 어플리케이션의 안정성에 대한 판단력을 가지기 어렵다고 생각했다. </li>\n<li>따라서 운영체제 관련 책을 읽고 (추후 업로드 예정) 책에 빠진 부분을 보충하여 학습한다. </li>\n</ul>\n<br>\n<h2 id=\"-keyword\" style=\"position:relative;\"><a href=\"#-keyword\" aria-label=\" keyword permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 KEYWORD</h2>\n<ul>\n<li class=\"task-list-item\"><input type=\"checkbox\" checked disabled>  경쟁 상태 Race Condition</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" checked disabled>  임계 영역 문제 The Critical-Section Problem</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" checked disabled>  피터슨 해결안 Peterson’s Solution - 소프트웨어 측면</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" checked disabled>  <strong>세마포어 Semaphores &#x26; 뮤텍스 Mutex</strong></li>\n<li class=\"task-list-item\">\n<p><input type=\"checkbox\" checked disabled>  동기화 문제들</p>\n<ul>\n<li>유한 버퍼 문제</li>\n<li>Readers-writers 문제</li>\n<li>식사하는 철학자들 문제</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-경쟁-상태-race-condition\" style=\"position:relative;\"><a href=\"#-%EA%B2%BD%EC%9F%81-%EC%83%81%ED%83%9C-race-condition\" aria-label=\" 경쟁 상태 race condition permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 경쟁 상태 Race condition</h2>\n<ul>\n<li>프로세스 간은 각기 다른 메모리에 존재하기 때문에 통신을 위해서는 공유 데이터를 사용한다. 또한 커널을 공유자원으로 사용한다.</li>\n<li>이러한 공유 자원에 대해 여러 프로세스가 동시에 접근을 시도한다면 접근하는 프로세스의 순서에 따라서 결과값이 달라져 일관성을 헤친다.</li>\n<li>이러한 상황을 race condition 이라고 한다.</li>\n</ul>\n<h3 id=\"race-condition-발생하는-상황\" style=\"position:relative;\"><a href=\"#race-condition-%EB%B0%9C%EC%83%9D%ED%95%98%EB%8A%94-%EC%83%81%ED%99%A9\" aria-label=\"race condition 발생하는 상황 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Race condition 발생하는 상황</h3>\n<ol>\n<li>\n<p>커널 작업 중 인터럽트 발생 </p>\n<ul>\n<li>커널은 모든 프로세스가 공유하는 부분이기 때문에 race condition이 발생할 수 있다.</li>\n<li>인터럽트 수행 코드가 반영이 되지 않을 수 있다.</li>\n</ul>\n</li>\n<li>\n<p>프로세스의 system call로 커널모드일 때 문맥 교환 발생</p>\n<ul>\n<li>프로세스1이 커널모드에서 데이터를 조작하는 중 시간초과가 되어 문맥 교환이 일어나고 프로세스2가 실행된다.</li>\n<li>프로세스2가 모두 수행한 후 프로세스1이 다시 로드되어 중단되었던 코드를 이어서 실행한다. (이때 저장된 레지스터 값들을 다시 로드하여 이어한다)</li>\n<li>프로세스1이 저장했던 값으로 재진행 후 결과값이 저장되기 때문에 수행되었던 공유 자원에 대한 프로세스2의 수행은 반영되지 않는다.</li>\n</ul>\n</li>\n<li>\n<p>멀티 프로세서 환경에서 공유 메모리 내의 커널 데이터에 접근할 때</p>\n<ul>\n<li>멀티 프로세서는 동시에 작업을 할 수 있는 CPU 처리기가 2대 이상이다.</li>\n<li>두 코어가 동시에 커널 내부의 공유 데이터에 접근하여 조작하는 경우 race condition이 발생한다.</li>\n</ul>\n</li>\n<li>\n<p>경쟁 조건이 발생하기 쉬운 커널 자료구조</p>\n<ul>\n<li>메모리를 할당하는 자료구조</li>\n<li>프로세스 리스트를 유지하는 자료구조</li>\n<li>인터럽트 처리를 위한 자료구조</li>\n<li>열린 파일 리스트를 저장하는 자료구조 등등</li>\n</ul>\n</li>\n</ol>\n<br>\n<h2 id=\"-임계-영역-문제-the-critical-section-problem\" style=\"position:relative;\"><a href=\"#-%EC%9E%84%EA%B3%84-%EC%98%81%EC%97%AD-%EB%AC%B8%EC%A0%9C-the-critical-section-problem\" aria-label=\" 임계 영역 문제 the critical section problem permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 임계 영역 문제 The Critical-Section Problem</h2>\n<ul>\n<li><strong>여러 프로세스가 데이터를 공유할 때 각 프로세스에서 공유 데이터를 접근하는 부분의 코드</strong></li>\n<li>이 부분을 불분명한 순서나 동시에 작업하는 경우 데이터 일관성을 헤치는 중요한 구역이므로 <strong>임계 영역</strong>이라고 부른다.</li>\n<li>\n<p>기본적으로 공유 데이터를 지키기 위한 운영체제의 특징은 다음과 같다.</p>\n<ul>\n<li>한 프로세스가 자신의 임계 영역 (다른 프로세스들과 공유하는 데이터를 조작하는 부분)에서 실행 중이라면 다른 프로세스들은 자신의 임계 영역에 들어갈 수 없다.</li>\n<li>이미 한 프로세스가 공유 데이터를 조작 중이므로 다른 프로세스는 임계 영역에 접근하지 못한다.</li>\n</ul>\n</li>\n<li>\n<p>임계 영역과 관련하여 대부분의 프로세스는 다음과 같은 코드 구조를 가진다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token keyword\">do</span> <span class=\"token punctuation\">{</span>\n\t// 진입 영역\n\t\t\n\t\t// 임계 영역\n\n\t// 퇴출 영역\n\n\t\t// 나머지 영역\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>TRUE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> </code></pre></div>\n</li>\n</ul>\n<h3 id=\"임계-영역-해결안\" style=\"position:relative;\"><a href=\"#%EC%9E%84%EA%B3%84-%EC%98%81%EC%97%AD-%ED%95%B4%EA%B2%B0%EC%95%88\" aria-label=\"임계 영역 해결안 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>임계 영역 해결안</h3>\n<p>다음 3가지 조건을 충족해야 한다. </p>\n<ol>\n<li>\n<p>상호 배제 Mutual Exclusion</p>\n<ul>\n<li>하나의 프로세스가 임계 영역에서 실행 중이라면 다른 프로세스는 자신의 임계 영역에서 실행할 수 없다.</li>\n</ul>\n</li>\n<li>\n<p>진행 Process</p>\n<ul>\n<li>임계 영역이 비어있을 때 진입하고자 하는 프로세스가 있다면 그 중에서 반드시 임계 영역에 진입할 수 있어야 한다.</li>\n</ul>\n</li>\n<li>\n<p>유한 대기 Bounded Waiting</p>\n<ul>\n<li>한 프로세스가 임계 영역에 진입을 요청했다면 무한으로 기다리지 않고 반드시 들어갈 수 있어야 한다.</li>\n<li>즉, 요청 프로세스가 있다면 진입하고자 하는 다른 프로세스들에게는 제한이 있어야 한다.</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"운영체제에서-임계-영역을-다루는-2가지-접근\" style=\"position:relative;\"><a href=\"#%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%97%90%EC%84%9C-%EC%9E%84%EA%B3%84-%EC%98%81%EC%97%AD%EC%9D%84-%EB%8B%A4%EB%A3%A8%EB%8A%94-2%EA%B0%80%EC%A7%80-%EC%A0%91%EA%B7%BC\" aria-label=\"운영체제에서 임계 영역을 다루는 2가지 접근 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>운영체제에서 임계 영역을 다루는 2가지 접근</h3>\n<ol>\n<li>\n<p>선점형 커널</p>\n<ul>\n<li>프로세스가 커널 모드에서 실행되는 동안 선점하는 것을 허용한다.</li>\n<li>경쟁 조건 발생 위험이 있으므로 잘 설계해야 하지만 더 선호하는 커널이다.</li>\n<li>실시간 프로그래밍에 적합하며 민첩한 응답이 가능하다.</li>\n<li>따라서 프로세스 동기화에 대한 내용은 선점형 커널인 경우 그 문제를 해결하는 방법이라고 할 수 있다.</li>\n</ul>\n</li>\n<li>\n<p>비선점형 커널</p>\n<ul>\n<li>프로세스가 커널 모드에서 실행되는 동안 선점을 허용하지 않는다.</li>\n<li>커널 안에 실행 중인 프로세스가 하나 뿐이기 때문에 경쟁 조건을 염려할 필요가 없다.</li>\n</ul>\n</li>\n</ol>\n<br>\n<h2 id=\"-피터슨-알고리즘-petersons-algorithm\" style=\"position:relative;\"><a href=\"#-%ED%94%BC%ED%84%B0%EC%8A%A8-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-petersons-algorithm\" aria-label=\" 피터슨 알고리즘 petersons algorithm permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 피터슨 알고리즘 Peterson’s Algorithm</h2>\n<ul>\n<li>단 두개의 프로세스에 대한 임계영역의 해결 방법이다.</li>\n<li>임계 영역에 들어가고 싶다면 flag를 true로 바꾼다.</li>\n<li>다른 프로세스에게 차례를 넘긴다.</li>\n<li>\n<p><strong>임계 영역에 들어가기 전에 상대 프로세스가 임계 영역에 접근하고 싶은지 먼저 확인한다.</strong></p>\n<ul>\n<li><code class=\"language-text\">while(flag[j] &amp;&amp; turn == j);</code></li>\n</ul>\n</li>\n<li>상대가 자원을 쓰고 싶지 않거나 (⇒ <code class=\"language-text\">flag[j] == false</code>) 내 차례라면 (⇒ <code class=\"language-text\">turn ≠ j</code>) 임계 영역에 들어갈 수 있다.</li>\n<li>\n<p>상대가 자원을 쓰고 싶고 (⇒ <code class=\"language-text\">flag[j] == true</code>) 상대의 차례라면 (⇒ <code class=\"language-text\">turn == j</code>) while에 갇혀서 임계 영역에 들어가기 전에 대기한다.</p>\n<ul>\n<li>busy wait 이라고 한다.</li>\n</ul>\n</li>\n<li><code class=\"language-text\">turn</code> 이 단 하나의 변수이기 때문에 임계 영역 문제를 해결할 수 있는 경우이다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token keyword\">do</span> <span class=\"token punctuation\">{</span>\n\n  flag<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\t\t\t\n  turn <span class=\"token operator\">=</span> j<span class=\"token punctuation\">;</span>\n\t\t\t\t\n  while<span class=\"token punctuation\">(</span>flag<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">&amp;&amp;</span> turn <span class=\"token operator\">==</span> j<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  \n  // critical section\n  \n  flag<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n\n  // remainder section\n\n<span class=\"token punctuation\">}</span> while<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h3 id=\"피터슨-알고리즘-증명\" style=\"position:relative;\"><a href=\"#%ED%94%BC%ED%84%B0%EC%8A%A8-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%A6%9D%EB%AA%85\" aria-label=\"피터슨 알고리즘 증명 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>피터슨 알고리즘 증명</h3>\n<ul>\n<li>그렇다면 피터슨 알고리즘은 위 임계 영역 해결안 조건 3가지를 충족할까?</li>\n<li>\n<p>상호 배제 </p>\n<ul>\n<li>둘다 지나가고 싶어서 flag 값을 true로 지정하여도 turn인 프로세스만 임계 영역에 들어갈 수 있다.</li>\n</ul>\n</li>\n<li>\n<p>진행 </p>\n<ul>\n<li>하나의 프로세스가 빠져나올 때 해당 프로세스의 flag를 false로 진행하므로 다른 프로세스가 들어갈 수 있도록 한다.</li>\n</ul>\n</li>\n<li>\n<p>유한 대기</p>\n<ul>\n<li>j 프로세스가 들어가고 싶을 때 turn은 i로 지정하고 i가 들어가고 싶을 때 그 반대로 지정하므로 반드시 상대 프로세스가 먼저 진입하고 싶다면 할 수 있도록 한다.</li>\n<li>때문에 모든 프로세스는 유한 대기한다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-세마포어\" style=\"position:relative;\"><a href=\"#-%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4\" aria-label=\" 세마포어 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 세마포어</h2>\n<ul>\n<li>공유 자원의 접근을 제한하는 방법의 일종이며 자원의 개수 (S)를 통해서 몇개의 프로세스가 진입할 수 있는지를 판단한다.</li>\n<li>\n<p>두 가지 연산</p>\n<ul>\n<li>이 두 연산은 반드시 atomic 하게 실행이 되며 인터럽트 될 수 없다.</li>\n<li>\n<p>P: 임계 영역에 들어가기 전에 수행</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">P<span class=\"token punctuation\">(</span>S<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>S <span class=\"token operator\">&lt;=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\tS--<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>프로세스 진입 여부를 자원 개수</li>\n</ul>\n</li>\n<li>\n<p>V: 임계 영역에서 나올 때 수행</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">V<span class=\"token punctuation\">(</span>S<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\tS++<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>자원을 반납하며 대기 중인 프로세스를 깨운다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>위 두 연산을 이용해 다음과 같은 흐름으로 진행된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">P<span class=\"token punctuation\">(</span>S<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n//-- 임계 구역 -- //\n\nV<span class=\"token punctuation\">(</span>S<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n</li>\n<li>\n<p>세마포어는 두 가지로 나뉜다.</p>\n<ul>\n<li>\n<p>카운팅 세마포어</p>\n<ul>\n<li>세마포어의 값이 양의 정수값을 가지며 이 값만큼의 프로세스 혹은 스레드를 자원에 허락한다.</li>\n<li>동기화 대상이 2개 이상이다.</li>\n</ul>\n</li>\n<li>\n<p>이진 세마포어 (⇒  뮤텍스)</p>\n<ul>\n<li>세마포어 값이 1이며 0, 1 만 가능하다.</li>\n<li>동기화 대상이 2개 뿐이다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>동작 방식</p>\n<ul>\n<li>\n<p>임계 영역에 접근하고 싶은 프로세스 혹은 스레드는 P(S) 를 호출한다.</p>\n<ul>\n<li>만일 세마포어 값이 0이면 진입할 수 없는 상태이므로 대기한다. (락이 걸린다)</li>\n<li>자원이 해체되면 임계 영역에 들어갈 수 있는데 이때 세마포어 값을 하나 감소시킨다.</li>\n</ul>\n</li>\n<li>\n<p>임계 영역에서 나오는 프로세스는 V(S)를 호출한다.</p>\n<ul>\n<li>자원을 반납하므로 세마포어 값을 하나 증가시킨다.</li>\n<li>이때 대기 중이던 다른 프로세스가 while 문에서 나와 자원을 할당 받을 수 있다.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-뮤텍스\" style=\"position:relative;\"><a href=\"#-%EB%AE%A4%ED%85%8D%EC%8A%A4\" aria-label=\" 뮤텍스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 뮤텍스</h2>\n<ul>\n<li>이진 세마포어 라고도 불린다.</li>\n<li>상호 배제 Mutual Exclusion 의 앞 부분을 따서 Mutex라고 부른다.</li>\n<li>\n<p>임계 영역에 들어갈 때 Lock 을 가지고 들어간다.</p>\n<ul>\n<li>다른 프로세스는 임계 영역에 들어갈 수 없다.</li>\n<li>해당 프로세스는 Lock(뮤텍스)를 소유할 수 있다.</li>\n</ul>\n</li>\n<li>\n<p>임계 영역에서 나올 때는 lock 을 반납하고 다른 프로세스에게 넘겨준다.</p>\n<ul>\n<li>피터슨 알고리즘이 뮤텍스의 일종이다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"뮤텍스와-세마포어의-차이점\" style=\"position:relative;\"><a href=\"#%EB%AE%A4%ED%85%8D%EC%8A%A4%EC%99%80-%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90\" aria-label=\"뮤텍스와 세마포어의 차이점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>뮤텍스와 세마포어의 차이점</h3>\n<ul>\n<li>\n<p>세마포어는 뮤텍스를 포괄하는 개념이다.</p>\n<ul>\n<li>이진 세마포어가 뮤텍스다.</li>\n</ul>\n</li>\n<li>세마포어는 그 값만큼 프로세스나 쓰레드가 공유자원에 접근할 수 있지만 뮤텍스는 1개만 가능하다.</li>\n<li>뮤텍스는 소유될 수 있으므로 해당 lock 을 소유하는 프로세스가 반드시 반납해야하지만, <strong>세마포어는 소유할 수 없는 것이며 락을 걸지 않은 프로세스나 스레드도 락을 해제할 수 있다.</strong></li>\n</ul>\n<br>\n<h2 id=\"-동기화-문제들\" style=\"position:relative;\"><a href=\"#-%EB%8F%99%EA%B8%B0%ED%99%94-%EB%AC%B8%EC%A0%9C%EB%93%A4\" aria-label=\" 동기화 문제들 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 동기화 문제들</h2>\n<h3 id=\"유한-버퍼-문제\" style=\"position:relative;\"><a href=\"#%EC%9C%A0%ED%95%9C-%EB%B2%84%ED%8D%BC-%EB%AC%B8%EC%A0%9C\" aria-label=\"유한 버퍼 문제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>유한 버퍼 문제</h3>\n<ul>\n<li>유한한 버퍼에 아이템을 저장(생상)하고 빼내오는(소비) 문제를 뮤텍스와 세마포어로 해결한다.</li>\n<li>\n<p>사용 값</p>\n<ul>\n<li>Mutex : 1로 초기화 되며 버퍼풀에 접근할 수 있는 락을 의미</li>\n<li>empty : 버퍼에 남은 빈 공간의 수</li>\n<li>full : 버퍼에 채워진 공간의 수</li>\n</ul>\n</li>\n<li>세마포어를 통해 버퍼의 크기를 파악하여 생산 혹은 소비할 수 있는지 판단한다.</li>\n<li>세마포어를 통과하면 버퍼에 아이템을 넣고 빼기 위한 조작을 하기 위해 뮤텍스 락을 잠군다.</li>\n<li>\n<p>생산자 프로세스 구조</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token keyword\">do</span> <span class=\"token punctuation\">{</span>\n\t// 버퍼에 추가할 아이템 생성\n\n\twait<span class=\"token punctuation\">(</span>empty<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> // 빈 공간이 <span class=\"token number\">0</span> 이하라면 wait, 빈 공간이 생기면 통과\n\twait<span class=\"token punctuation\">(</span>mutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> // 버퍼를 조작하는 락이 <span class=\"token number\">0</span>이라면 wait, 락을 획득하면 통과\n\n\t// 버퍼에 아이템 추가 \n\n\tsignal<span class=\"token punctuation\">(</span>mutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> // 버퍼를 조작할 수 있는 락 반납\n\tsignal<span class=\"token punctuation\">(</span>full<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> // 버퍼가 한칸 채워졌음을 알림\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>true<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n</li>\n<li>\n<p>소비자 프로세스 구조</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token keyword\">do</span> <span class=\"token punctuation\">{</span>\n\twait<span class=\"token punctuation\">(</span>full<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> // 버퍼에 아무 아이템이 없어 full 이 <span class=\"token number\">0</span>이하라면 wait, 아이템이 생기면 통과\n\twait<span class=\"token punctuation\">(</span>mutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> // 버퍼 조작 락 획득\n\n\t// 버퍼에서 아이템 빼기 <span class=\"token punctuation\">(</span>소비<span class=\"token punctuation\">)</span>\n\n\tsignal<span class=\"token punctuation\">(</span>mutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> // 버퍼 조작 락 반납\n\tsignal<span class=\"token punctuation\">(</span>empty<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> // 버퍼에 아이템이 빠졌음을 알림\n\n\t// 빼낸 아이템 사용\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>true<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n</li>\n</ul>\n<h3 id=\"readers-writers-문제\" style=\"position:relative;\"><a href=\"#readers-writers-%EB%AC%B8%EC%A0%9C\" aria-label=\"readers writers 문제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Readers-Writers 문제</h3>\n<ul>\n<li>하나의 데이터베이스가 다수의 프로세스간에 공유될 때 읽는 프로세스(readers)와 읽고 쓰는 프로세스(writers)를 구분하여 접근하도록 하는 방법이다.</li>\n<li>Readers 끼리는 공유데이터에 동시 접근 해도 문제가 발생하지 않지만 writer는 다른 reader 혹은 writer와 겹치면 문제가 발생한다.</li>\n<li>따라서 writer가 실행되는 동안 공유 데이터베이스에 mutual exclusion을 보장하도록 한다.</li>\n<li>이때 reader 혹은 writer가 기아상태 되지 않도록 문제를 해결해야 한다.</li>\n<li>\n<p>사용 값</p>\n<ul>\n<li>readcount : 현재 읽기를 수행하고 있는 프로세스 개수</li>\n<li>mutex : readcount를 갱신하기 위한 락이며 1로 초기화</li>\n<li>wrt : 쓰기를 위한 락이며 1로 초기화</li>\n</ul>\n</li>\n<li>\n<p>Writer 프로세스 구조</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token keyword\">do</span> <span class=\"token punctuation\">{</span>\n\twait<span class=\"token punctuation\">(</span>wrt<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\t// 쓰기 작업\n\n\tsignal<span class=\"token punctuation\">(</span>wrt<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>true<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n</li>\n<li>\n<p>Reader 프로세스 구조</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token keyword\">do</span> <span class=\"token punctuation\">{</span>\n\twait<span class=\"token punctuation\">(</span>mutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> // readcount 갱신을 위한 락 획득\n\treadcount++<span class=\"token punctuation\">;</span> // 읽기 프로세스 개수 <span class=\"token number\">1</span> 증가\n\t\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>readcount <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> // 만일 최초 읽기 프로세스라면 \n\t\twait<span class=\"token punctuation\">(</span>wrt<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> // 쓰기가 진행 중인지 확인하고 쓰기 중이라면 대기, 아니라면 쓰기 락을 획득하고 통과\n\n\tsignal<span class=\"token punctuation\">(</span>mutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> // readcount 갱신을 위한 락 반납\n\n\t// 읽기 작업 수행\n\n\twait<span class=\"token punctuation\">(</span>mutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n\treadcount--<span class=\"token punctuation\">;</span> // 읽기 수행 완료 후 프로세스 <span class=\"token number\">1</span> 감소\n\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>readcount <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> // 만일 읽기 프로세스가 하나도 없다면\n\t\tsignal<span class=\"token punctuation\">(</span>wrt<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> // 쓰기 락 반납하여 쓰기 프로세스 진행가능하도록 함\n\n\tsignal<span class=\"token punctuation\">(</span>mutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>true<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n</li>\n</ul>\n<h3 id=\"식사하는-철학자들-문제-the-dining-philosophers-problems\" style=\"position:relative;\"><a href=\"#%EC%8B%9D%EC%82%AC%ED%95%98%EB%8A%94-%EC%B2%A0%ED%95%99%EC%9E%90%EB%93%A4-%EB%AC%B8%EC%A0%9C-the-dining-philosophers-problems\" aria-label=\"식사하는 철학자들 문제 the dining philosophers problems permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>식사하는 철학자들 문제 The Dining-Philosophers Problems</h3>\n<ul>\n<li>다섯명의 철학자들이 원탁에 있고 다섯개의 젓가락이 철학자들 사이에 하나씩 놓여있다. 가운데 공유 밥은 한 개이다.</li>\n<li>자신의 오른쪽 젓가락이나 왼쪽의 젓가락이 없다면 먹을 수 없다.</li>\n<li>교착상태나 기아를 발생시키지 않고 여러 스레드에 여러 자원을 할당해야하는 경우다.</li>\n<li>\n<p>철학자 i의 구조</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">세마포어 값은 chopstick<span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> 이다. \n\n<span class=\"token keyword\">do</span> <span class=\"token punctuation\">{</span>\n\twait<span class=\"token punctuation\">(</span>chopstick<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\twait<span class=\"token punctuation\">(</span>chopstick<span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span>i + <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> % <span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\t// 먹기\n\n\tsignal<span class=\"token punctuation\">(</span>chopstick<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\tsignal<span class=\"token punctuation\">(</span>chopstick<span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span>i + <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> % <span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\t// 생각하기\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>true<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n</li>\n<li>\n<p>동시에 두 철학자가 식사하지 않도록 보장하지만 교착상태를 야기할 가능성이 있다. 그 해결책이 몇개 있다.</p>\n<ul>\n<li>최대 4명의 철학자만 앉게 한다.</li>\n<li>한 철학자가 두개의 젓가락을 모두 집을 수 있을 때만 허용한다.</li>\n<li>홀수번 철학자는 왼쪽부터 집고, 짝수번 철학자는 오른쪽 부터 집도록 한다.</li>\n</ul>\n</li>\n<li>교착상태를 해결하면 기아상태를 주의해야한다.</li>\n</ul>\n<br>\n<br>\n<h2 id=\"-참고링크\" style=\"position:relative;\"><a href=\"#-%EC%B0%B8%EA%B3%A0%EB%A7%81%ED%81%AC\" aria-label=\" 참고링크 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 참고링크</h2>\n<ul>\n<li><a href=\"https://hibee.tistory.com/297\">https://hibee.tistory.com/297</a></li>\n<li><a href=\"https://dduddublog.tistory.com/25\">https://dduddublog.tistory.com/25</a></li>\n<li><a href=\"https://jhnyang.tistory.com/37\">https://jhnyang.tistory.com/37</a></li>\n<li>\n<p>세마포어 &#x26; 뮤테스</p>\n<ul>\n<li><a href=\"https://mangkyu.tistory.com/104\">https://mangkyu.tistory.com/104</a></li>\n<li><a href=\"https://velog.io/@conatuseus/OS-%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4%EC%99%80-%EB%AE%A4%ED%85%8D%EC%8A%A4\">https://velog.io/@conatuseus/OS-세마포어와-뮤텍스</a></li>\n<li><a href=\"https://medium.com/@kwoncharles/%EB%AE%A4%ED%85%8D%EC%8A%A4-mutex-%EC%99%80-%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4-semaphore-%EC%9D%98-%EC%B0%A8%EC%9D%B4-de6078d3c453\">https://medium.com/@kwoncharles/뮤텍스-mutex-와-세마포어-semaphore-의-차이-de6078d3c453</a></li>\n<li><a href=\"https://sycho-lego.tistory.com/11\">https://sycho-lego.tistory.com/11</a></li>\n</ul>\n</li>\n<li>공룡책</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#-intro\">💡 INTRO</a></li>\n<li><a href=\"#-keyword\">🌩 KEYWORD</a></li>\n<li>\n<p><a href=\"#-%EA%B2%BD%EC%9F%81-%EC%83%81%ED%83%9C-race-condition\">🌩 경쟁 상태 Race condition</a></p>\n<ul>\n<li><a href=\"#race-condition-%EB%B0%9C%EC%83%9D%ED%95%98%EB%8A%94-%EC%83%81%ED%99%A9\">Race condition 발생하는 상황</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-%EC%9E%84%EA%B3%84-%EC%98%81%EC%97%AD-%EB%AC%B8%EC%A0%9C-the-critical-section-problem\">🌩 임계 영역 문제 The Critical-Section Problem</a></p>\n<ul>\n<li><a href=\"#%EC%9E%84%EA%B3%84-%EC%98%81%EC%97%AD-%ED%95%B4%EA%B2%B0%EC%95%88\">임계 영역 해결안</a></li>\n<li><a href=\"#%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%97%90%EC%84%9C-%EC%9E%84%EA%B3%84-%EC%98%81%EC%97%AD%EC%9D%84-%EB%8B%A4%EB%A3%A8%EB%8A%94-2%EA%B0%80%EC%A7%80-%EC%A0%91%EA%B7%BC\">운영체제에서 임계 영역을 다루는 2가지 접근</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-%ED%94%BC%ED%84%B0%EC%8A%A8-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-petersons-algorithm\">🌩 피터슨 알고리즘 Peterson’s Algorithm</a></p>\n<ul>\n<li><a href=\"#%ED%94%BC%ED%84%B0%EC%8A%A8-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%A6%9D%EB%AA%85\">피터슨 알고리즘 증명</a></li>\n</ul>\n</li>\n<li><a href=\"#-%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4\">🌩 세마포어</a></li>\n<li>\n<p><a href=\"#-%EB%AE%A4%ED%85%8D%EC%8A%A4\">🌩 뮤텍스</a></p>\n<ul>\n<li><a href=\"#%EB%AE%A4%ED%85%8D%EC%8A%A4%EC%99%80-%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90\">뮤텍스와 세마포어의 차이점</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-%EB%8F%99%EA%B8%B0%ED%99%94-%EB%AC%B8%EC%A0%9C%EB%93%A4\">🌩 동기화 문제들</a></p>\n<ul>\n<li><a href=\"#%EC%9C%A0%ED%95%9C-%EB%B2%84%ED%8D%BC-%EB%AC%B8%EC%A0%9C\">유한 버퍼 문제</a></li>\n<li><a href=\"#readers-writers-%EB%AC%B8%EC%A0%9C\">Readers-Writers 문제</a></li>\n<li><a href=\"#%EC%8B%9D%EC%82%AC%ED%95%98%EB%8A%94-%EC%B2%A0%ED%95%99%EC%9E%90%EB%93%A4-%EB%AC%B8%EC%A0%9C-the-dining-philosophers-problems\">식사하는 철학자들 문제 The Dining-Philosophers Problems</a></li>\n</ul>\n</li>\n<li><a href=\"#-%EC%B0%B8%EA%B3%A0%EB%A7%81%ED%81%AC\">🌩 참고링크</a></li>\n</ul>\n</div>","frontmatter":{"date":"October 21, 2021","title":"내가 또 보기 위한 운영체제 프로세스 동기화","categories":"운영체제","author":"코다","emoji":"🧁"},"fields":{"slug":"/process_synchronization/"}},"prev":{"id":"dcb75ef2-3086-5644-8574-f88a14febe20","html":"<h2 id=\"-왜-혼잡제어가-필요할까\" style=\"position:relative;\"><a href=\"#-%EC%99%9C-%ED%98%BC%EC%9E%A1%EC%A0%9C%EC%96%B4%EA%B0%80-%ED%95%84%EC%9A%94%ED%95%A0%EA%B9%8C\" aria-label=\" 왜 혼잡제어가 필요할까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 왜 혼잡제어가 필요할까?</h2>\n<ul>\n<li>라우터에 패킷이 몰리면 패킷이 유실되고 패킷을 재전송 하면서 네트워크는 더 혼잡해진다.</li>\n<li>송신측에서 이러한 문제를 해결하기 위해 전송속도를 줄이는 혼잡 제어를 사용한다.</li>\n</ul>\n<br>\n<h2 id=\"-aimd\" style=\"position:relative;\"><a href=\"#-aimd\" aria-label=\" aimd permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 AIMD</h2>\n<ul>\n<li>Additive Increase, Mutiplicative Decrese</li>\n<li>패킷을 하나씩 보내고 문제없이 도착하면 window 크기를 1개씩 증가한다.</li>\n<li>패킷 전송에 실패하면 속도를 절반으로 줄인다.</li>\n<li>이 경우 나중에 네트워크에 진입한 쪽이 처음에는 불리하지만 점점 동일한 평형상태가 되기 때문에 공정하다.</li>\n<li>네트워크 혼잡을 미리 감지하지는 못하고 혼잡하면 대역폭을 줄인다.</li>\n</ul>\n<p align=\"center\"><img width=\"70%\" src=\"https://user-images.githubusercontent.com/63405904/139091747-767ffc1e-b9a7-4894-9445-17930ef59391.png\"></p>\n<br>\n<h2 id=\"-slow-start\" style=\"position:relative;\"><a href=\"#-slow-start\" aria-label=\" slow start permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 Slow Start</h2>\n<ul>\n<li>AIMD는 처음 전송속도를 올리는 것이 너무 느리다는 단점이 있다.</li>\n<li>slow start는 처음에는 문제가 없다면 윈도우 사이즈를 지수함수꼴로 증가한다.</li>\n<li>혼잡 현상이 발생하면 window사이즈를 1로 떨어뜨린다. 하지만 이때는 네트워크의 혼잡율을 어느정도 예상할 수 있다.</li>\n<li>따라서 혼잡 현상이 발생했던 window size의 크기의 반까지 지수함수 꼴로 증가시키고 이후부터 1씩 완만하게 증기시킨다. (임계점에 다다르면 지수함수는 너무 급격하므로 1씩 윈도우를 증가시킨다)</li>\n</ul>\n<p align=\"center\"><img width=\"70%\" src=\"https://user-images.githubusercontent.com/63405904/139091821-279101d0-e464-4644-a803-3ea6a7c2a678.png\"></p>\n<p align=\"center\"><img width=\"70%\" src=\"https://user-images.githubusercontent.com/63405904/139091877-c00e5fdd-d52f-4280-9f76-3ba9587b225a.png\"></p>\n<br>\n<h2 id=\"-fast-retransmit-빠른-재전송\" style=\"position:relative;\"><a href=\"#-fast-retransmit-%EB%B9%A0%EB%A5%B8-%EC%9E%AC%EC%A0%84%EC%86%A1\" aria-label=\" fast retransmit 빠른 재전송 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 Fast Retransmit 빠른 재전송</h2>\n<ul>\n<li>패킷을 받는 쪽에서 패킷이 도착하지 않고 다음 패킷이 도착하더라도 ACK를 보내는데 이때 잘 도착한 패킷의 다음 패킷을 ACK로 보낸다.</li>\n<li>그러면 중복된 ACK 패킷이 계속 도착하므로 이때는 문제가 된 순번의 패킷을 재전송 해줄수 있다.</li>\n<li>중복된 패킷을 3개 받으면 재전송을 하는데, 혼잡임을 감지하고 window size를 반으로 줄이다.</li>\n</ul>\n<p align=\"center\"><img width=\"70%\" src=\"https://user-images.githubusercontent.com/63405904/139092293-9e27653f-f3aa-44fd-867c-c2327be7b57f.png\"></p>\n<br>\n<h2 id=\"-fast-recovery-빠른-회복\" style=\"position:relative;\"><a href=\"#-fast-recovery-%EB%B9%A0%EB%A5%B8-%ED%9A%8C%EB%B3%B5\" aria-label=\" fast recovery 빠른 회복 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 Fast Recovery 빠른 회복</h2>\n<ul>\n<li>혼잡한 상태가 되면 window를 1이 아닌 반으로 줄이고 선형증가시킨다.</li>\n<li>혼잡상황을 한번 겪으면 순수 AIMD 방식으로 동작한다.</li>\n</ul>\n<br>\n<h2 id=\"-tcp-reno\" style=\"position:relative;\"><a href=\"#-tcp-reno\" aria-label=\" tcp reno permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 TCP Reno</h2>\n<ul>\n<li>위 기법들을 사용한 TCP 혼잡제어이다.</li>\n<li>먼저 slow start로 시작하고 임계점을 넘어가면 1씩 설정하여 윈도우 사이즈를 높인다.</li>\n<li>\n<p>위의 3 ACK Duplicated와 타임아웃을 구분하여 각기 다른 방식을 취한다.</p>\n<ul>\n<li>3 ACK Duplicated라면 윈도우 사이즈를 반으로 줄이고 선형적으로 증가시킨다.</li>\n<li>타임아웃이 발생하면 윈도우 크기를 1로 줄이고 slow start를 진행한다.</li>\n</ul>\n</li>\n</ul>\n<p align=\"center\"><img width=\"70%\" src=\"https://user-images.githubusercontent.com/63405904/139091995-e0f1f659-47c8-486a-b7c4-d9ddc7ee2c9a.png\"></p>\n<br>\n<br>\n<p><strong>[참고자료]</strong></p>\n<ul>\n<li><a href=\"https://evan-moon.github.io/2019/11/26/tcp-congestion-control/\">https://evan-moon.github.io/2019/11/26/tcp-congestion-control/</a></li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#-%EC%99%9C-%ED%98%BC%EC%9E%A1%EC%A0%9C%EC%96%B4%EA%B0%80-%ED%95%84%EC%9A%94%ED%95%A0%EA%B9%8C\">🌩 왜 혼잡제어가 필요할까?</a></li>\n<li><a href=\"#-aimd\">🌩 AIMD</a></li>\n<li><a href=\"#-slow-start\">🌩 Slow Start</a></li>\n<li><a href=\"#-fast-retransmit-%EB%B9%A0%EB%A5%B8-%EC%9E%AC%EC%A0%84%EC%86%A1\">🌩 Fast Retransmit 빠른 재전송</a></li>\n<li><a href=\"#-fast-recovery-%EB%B9%A0%EB%A5%B8-%ED%9A%8C%EB%B3%B5\">🌩 Fast Recovery 빠른 회복</a></li>\n<li><a href=\"#-tcp-reno\">🌩 TCP Reno</a></li>\n</ul>\n</div>","frontmatter":{"date":"October 22, 2021","title":"내가 또 보기 위한 TCP 혼잡제어","categories":"네트워크","author":"코다","emoji":"⚡️"},"fields":{"slug":"/tcp-congestion-control/"}},"site":{"siteMetadata":{"siteUrl":"https://yjksw.github.io","comments":{"utterances":{"repo":"yjksw/yjksw.github.io"}}}}},"pageContext":{"slug":"/os-deadlock/","nextSlug":"/process_synchronization/","prevSlug":"/tcp-congestion-control/"}},"staticQueryHashes":["1073350324","2938748437"]}
{"componentChunkName":"component---src-templates-blog-template-js","path":"/java-list/","result":{"data":{"cur":{"id":"e6f0d0ff-4840-58a3-a95a-131f2cc9d72d","html":"<br>\n<p>자바에서 LIST 인터페이스를 구현한 Collection 구현체 중 가장 많이 쓰고 헷갈리는 것이 ArrayList와 LinkedList의 차이이다. 알고리즘 코딩을 공부하다가 특정 답을 배열 구조에 담을 일이 있어서 찾아보다 문득 ArrayList, LinkedList 중 무엇을 쓸까 고민하는 김에 정리하게 되었다. <br></p>\n<p>인터페이스도 같고 사용하는 방식도 비슷한 부분이 많기 때문에 ArrayList를 써야할 때 LinkedList를 쓰거나 그 반대로 사용하더라도 큰 차이가 없이 느껴지기도 한다. 하지만 두 가지 자료구조가 구분되어 있는 만큼 더 적절한 부분이 있다. 간단히 한번 알아보자. <br></p>\n<p>Java에서는 변수를 저장하기 위해서 배열을 사용한다. 하지만 배열의 단점은 초기에 길이를 저장해서 미리 메모리를 확보해 놓아야 한다는 것이다. 다라서 동적으로 메모리 할당이 어려울 뿐만 아니라, 예상하지 못하는 입력크기에 대해서는 애초에 크게 배열의 크기를 잡아놓는 비효율적인 방법을 택해야 한다. 이런 문제를 해결할 수 있도록 자바 Collection에서는 ArrayList와 LinkedList 자료구조를 제공한다. <br></p>\n<h2 id=\"arraylist\" style=\"position:relative;\"><a href=\"#arraylist\" aria-label=\"arraylist permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ArrayList</h2>\n<p>ArrayList는 데이터를 배열로 관리하고 데이터를 추가, 삭제하기 위해서 임시 배열을 생성해서 데이터를 복사하여 하나씩 index를 모두 미룬다. <br></p>\n<p>다르게 말하면 많은 양의 데이터를 추가/삭제하는 경우에는 복사가 매우 많이 일어나게 되며, 그만큼의 성능저하를 일으킨다. 하지만 ArrayList가 LinkedList에 비해서 유용하게 작동하는 부분은 바로 탐색이다. 각 데이터는 각자의 인덱스를 가지고 있기 때문에 참조를 할 때 한번에 참조가 가능하며 매우 유리하게 작동하는 구현체가 된다. <br></p>\n<h2 id=\"linkedlist\" style=\"position:relative;\"><a href=\"#linkedlist\" aria-label=\"linkedlist permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>LinkedList</h2>\n<p>LinkedList는 각 노드가 자기 이전의 노드와 다음 노드를 알고 있다. 따라서 데이터를 추가하고 삭제할 시, 위에서 보이는 것처럼 그 앞과 뒤의 연결만 신경쓰면 되기 때문에 매우 유용하다. 하지만 탐색의 경우 각 노드가 정해진 인덱스에 저장되어 있는 것은 아니기 때문에 처음부터 순차적으로 노드를 방문해서 검색해야 한다는 단점을 가지고 있다. </p>\n<h2 id=\"데이터-검색삽입삭제-성능-비교\" style=\"position:relative;\"><a href=\"#%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B2%80%EC%83%89%EC%82%BD%EC%9E%85%EC%82%AD%EC%A0%9C-%EC%84%B1%EB%8A%A5-%EB%B9%84%EA%B5%90\" aria-label=\"데이터 검색삽입삭제 성능 비교 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>데이터 검색/삽입/삭제 성능 비교</h2>\n<h3 id=\"검색\" style=\"position:relative;\"><a href=\"#%EA%B2%80%EC%83%89\" aria-label=\"검색 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>검색</h3>\n<p>검색은 ArrayList가 LinkedList에 비해 훨씬 빠르다. ArrayList는 인덱스 기반으로 바로 해당 인덱스를 참조할 수 있기 때문에 O(1)의 시간 복잡도를 가진다. 그에 비해 LinkedList는 검색 시 모든 요소 탐색을 하기 때문에 최악의 경우 O(n)의 시간 복잡도를 가진다. <br></p>\n<h3 id=\"삽입삭제\" style=\"position:relative;\"><a href=\"#%EC%82%BD%EC%9E%85%EC%82%AD%EC%A0%9C\" aria-label=\"삽입삭제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>삽입/삭제</h3>\n<p>LinkedList의 삽입, 삭제는 ArrayList에 비해서 빠른데 LinkedList는 앞뒤 노드의 참조 형태만 변경하면 되기 때문에 따라서 삽입과 삭제가 일어날 때 O(1)의 시간 복잡도를 가지는 반면 ArrayList는 O(n)의 시간복잡도를 가진다. <br></p>\n<h2 id=\"코드-응용에서의-성능-비교\" style=\"position:relative;\"><a href=\"#%EC%BD%94%EB%93%9C-%EC%9D%91%EC%9A%A9%EC%97%90%EC%84%9C%EC%9D%98-%EC%84%B1%EB%8A%A5-%EB%B9%84%EA%B5%90\" aria-label=\"코드 응용에서의 성능 비교 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>코드 응용에서의 성능 비교</h2>\n<p>알고리즘 문제를 풀 때, 각 문제에 대한 정답을 배열에 저장하여 한꺼번에 출력을 해야하는 문제가 있었다. 해당 문제에서는 각 문제에 대해서 매번 그 답을 삽입해야 하기 때문에 LinkedList가 훨씬 좋은 성능을 보였다. <br></p>\n<p>예를 들어 다음과 같은 코드를 보자. </p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Character</span><span class=\"token punctuation\">></span></span> arr <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">LinkedList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Character</span><span class=\"token punctuation\">></span></span> link <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">LinkedList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">//어떠한 조건이 충족되었을 때, </span>\narr<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token string\">'-'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nlink<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token string\">'-'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">//댜른 조건이 충족되었을 때,</span>\narr<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token string\">'+'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nlink<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token string\">'+'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>크게 중요하지 않기 때문에 전체 코드를 적지는 않았다. 대충 위와 같은 코드에서 각각 ArrayList와 LinkedList로 비교해보았을 때 다음과 같은 성능 차이를 보였다. <br></p>\n<p><img src=\"https://user-images.githubusercontent.com/63405904/113716079-2d07c480-9725-11eb-99d8-f9696839f3d6.png\" alt=\"result\">{: width=80%}</p>\n<p>첫번째 나온 라인이 LinkedList을 사용했을 때 1700ms 의 시간 효율을 보였고, 동일한 코드에 ArrayList를 사용했을 때, 잦은 삽입으로 다소 낮은 2056ms의 시간 효율을 보인 것을 볼 수 있다. <br></p>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#arraylist\">ArrayList</a></li>\n<li><a href=\"#linkedlist\">LinkedList</a></li>\n<li>\n<p><a href=\"#%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B2%80%EC%83%89%EC%82%BD%EC%9E%85%EC%82%AD%EC%A0%9C-%EC%84%B1%EB%8A%A5-%EB%B9%84%EA%B5%90\">데이터 검색/삽입/삭제 성능 비교</a></p>\n<ul>\n<li><a href=\"#%EA%B2%80%EC%83%89\">검색</a></li>\n<li><a href=\"#%EC%82%BD%EC%9E%85%EC%82%AD%EC%A0%9C\">삽입/삭제</a></li>\n</ul>\n</li>\n<li><a href=\"#%EC%BD%94%EB%93%9C-%EC%9D%91%EC%9A%A9%EC%97%90%EC%84%9C%EC%9D%98-%EC%84%B1%EB%8A%A5-%EB%B9%84%EA%B5%90\">코드 응용에서의 성능 비교</a></li>\n</ul>\n</div>","excerpt":"자바에서 LIST 인터페이스를 구현한 Collection 구현체 중 가장 많이 쓰고 헷갈리는 것이 ArrayList와 LinkedList의 차이이다. 알고리즘 코딩을 공부하다가 특정 답을 배열 구조에 담을 일이 있어서 찾아보다 문득 ArrayList, LinkedList 중 무엇을 쓸까 고민하는 김에 정리하게 되었다.  인터페이스도 같고 사용하는 방식도 비슷한 부분이 많기 때문에 ArrayList를 써야할 때 LinkedList를 쓰거나 그 반대로 사용하더라도 큰 차이가 없이 느껴지기도 한다. 하지만 두 가지 자료구조가 구분되어 있는 만큼 더 적절한 부분이 있다. 간단히 한번 알아보자.  Java에서는 변수를 저장하기 위해서 배열을 사용한다. 하지만 배열의 단점은 초기에 길이를 저장해서 미리 메모리를 확보해 놓아야 한다는 것이다. 다라서 동적으로 메모리 할당이 어려울 뿐만 아니라, 예상하지 못하는 입력크기에 대해서는 애초에 크게 배열의 크기를 잡아놓는 비효율적인 방법을 택해야 한다…","frontmatter":{"date":"August 09, 2020","title":"[JAVA] ArrayList와 LinkedList 차이점","categories":"자바","author":"코다","emoji":"✊"},"fields":{"slug":"/java-list/"}},"next":{"id":"ca95173c-b23d-5aec-933f-46102018988a","html":"<p>다음은 Java에 존재하는 아주 특이한 클래스인 Wrapper class에 대한 내용이다. JAVA wrapper class에 대해서 설명한 한 <a href=https://www.baeldung.com/java-wrapper-classes>사이트</a>를 <strong>번역</strong>하는 겸 공부한 내용을 정리해 작성해놓았다.  </p>\n<br>\n<h2 id=\"1-개요\" style=\"position:relative;\"><a href=\"#1-%EA%B0%9C%EC%9A%94\" aria-label=\"1 개요 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 개요</h2>\n<p>Wrapper class(감싸는 클래스) 이름이 설명하듯이 wrapper class는 자바의 Primitive types들을 객체로 감싸는 역할을 하는 클래스이다. <br></p>\n<p>다음과 같은 자바의 primitive 타입들은 모두 각자의 wrapper 클래스가 있다. <br></p>\n<ul>\n<li>boolean, byte, short, char, int, long, float, double <br></li>\n<li>Boolean, Byte, Short, Character, Integer, Long, Float, Double<br></li>\n</ul>\n<p>이것들은 모두 java.lang 패키지에 정의되어 있으므로 따로 import 하지 않아도 사용할 수 있다. <br></p>\n<br>\n<h2 id=\"2-wrapper-classes\" style=\"position:relative;\"><a href=\"#2-wrapper-classes\" aria-label=\"2 wrapper classes permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. Wrapper Classes</h2>\n<p>“Wrapper 클래스의 목적은 무엇입니까?”는 자바 관련 인터뷰에서 흔하게 물어보는 질문 중 하나이다. <br></p>\n<p>그 목적은 간단하게 말해서, generic classes는 객체와 호환되서 작동되지 primitive 타입과는 호환이 되지 않기 때문이다. 따라서, 우리가 generic classe들을 사용하고 싶다면 우리는 primitive type들을 객체로 만들 수 있도록 하는 방법이 필요한 것이다. <br></p>\n<p>예를 들어서, 많은 유용한 기능들을 제공하는 Java Collection Framwork는 객체와만 작동하도록 되어 있다. Java 버전 5 이하, 즉 거의 15년 전 자바를 사용할때는 나중에 소개할 autoboxing 기능이 없었기 때문에 현재 사용되는 것처럼 간단히 <code class=\"language-text\">add(5)</code> 와 같이 collection of Integers를 사용할 수 없었다. <br></p>\n<p>당시에는 primitive 타입의 값들은 직접 각 wrapper classes로 변환되어 새롭게 저장되어야 사용될 수 있었다. 지금은 autoboxing이라는 기능이 추가되면서, <code class=\"language-text\">ÀrrayList.add(101)</code>와 같은 문법을 그대로 사용할 수 있다. 자바 내부적으로 primitive value들을 Integer등과 같은 wrapper class 객체로 변환해서 사용될 수 있도록 하기 때문이다. <br></p>\n<br>\n<h2 id=\"3-primitive에서-wrapper-class로-변환\" style=\"position:relative;\"><a href=\"#3-primitive%EC%97%90%EC%84%9C-wrapper-class%EB%A1%9C-%EB%B3%80%ED%99%98\" aria-label=\"3 primitive에서 wrapper class로 변환 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. Primitive에서 Wrapper Class로 변환</h2>\n<p>그럼 이 시점에 나올 만한 질문은 “어떻게 primitive value를 해당 타입 wrapper class로 변환할 수 있는가? “이다. 예를 들어, int 를 Integer로 변환하고, char를 Character로 변환하는 방법은 무엇인가 이다. <br></p>\n<p>간단히 2가지 방법이 있다. 생성자 constructor를 사용하던지, static factory method를 사용해서 primitive value를 wrapper class로 변환할 수 있다. <br></p>\n<p>하지만 Java 9에 들어서는 Integer나 Long에 대한 생성자는 중요도가 떨어지면 지원되지 않는 경우가 많기 때문에 factory method를 사용하는 것을 높이 권장한다. 다음 코드를 참고해보자. <br></p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">Integer</span> object <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//생성자 사용</span>\n\n<span class=\"token class-name\">Integer</span> another <span class=\"token class-name\">Object</span> <span class=\"token operator\">=</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//factory method 사용</span></code></pre></div>\n<p>위의 코드에 <code class=\"language-text\">valueOf()</code>메소드는 int를 Integer 객체로 변환해여 반환한다. 캐싱된 값을 반환하기 때문에 매우 효율적이고, -128 에서 127까지의 값은 항상 캐싱하며 이 범위 박의 값들도 캐싱할 수 있는 장점을 가지고 있다. <br></p>\n<p>위의 방법관 같이 boolean을 Boolean으로, byte 를 Byte, chat를 Character로, long을 Long으로, float을 Float로, double을 Double로 변환할 수 있다. 이와 다르게 String을 Integer로 변환하고 싶을 때는 String이 wrapper class가 아니기 때문에 <code class=\"language-text\">parseInt()</code> 를 사용해야 한다. <br></p>\n<p>반대로 wrapper 객체를 다시 Primitive type으로 변환하고 싶을 때는 각자에 맞는 <code class=\"language-text\">intValue()</code> 나 <code class=\"language-text\">doubleValue()</code> 와 같은 메소드를 사용해야 한다. <br></p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">int</span> val <span class=\"token operator\">=</span> object<span class=\"token punctuation\">.</span><span class=\"token function\">intValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<br>\n<h2 id=\"4-autoboxing-과-unboxing\" style=\"position:relative;\"><a href=\"#4-autoboxing-%EA%B3%BC-unboxing\" aria-label=\"4 autoboxing 과 unboxing permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. Autoboxing 과 Unboxing</h2>\n<p>이전 파트에서는 어떻게 primitive 값을 객체로 매뉴얼하게 바꿀 수 있는지에 대해서 다뤘었다. 하지만 이전에 언급했듯이 Java 5 이후에는 자동으로 변환해주는 autoboxing, unboxing이라는 속성이 등장했다.<br></p>\n<p>“Boxing”이라는 뜻이 primitive value를 해당 Wrapper class로 변환해준다는 의미이다. 자동적으로 변환되기 때문에 다음 단어에 auto를 덧붙여서 autoboxing이라고 불린다. <br></p>\n<p>비슷한 경우로 wrapper 객체가 unwrapped 되어 다시 primitive value가 되는 개념이 unboxing이다. <br></p>\n<p>즉, autoboxing과 unboxing은 실전에서 사용될 때 사용자가 primitive value를 특정 메소드에서 사용할 때 wrapper object이나 해당 primitive을 기대한 객체의 타입으로 바꾸어 준다는 뜻이다. <br></p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> list <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nlist<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//autoboxing</span>\n\n<span class=\"token class-name\">Integer</span> val <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//autoboxing</span></code></pre></div>\n<p>위의 예시에서는 자바가 자동적으로 primitive value인 int를 wrapper로 변환해주었다. 사실, 내부적으로는 valueOf() 메소드를 사용해서 변환한 것이다. 예를 들어, 다음 두 코드는 동일하게 동작하는 것이라고 여겨진다. <br></p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">Integer</span> value <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token class-name\">Integer</span> value <span class=\"token operator\">=</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>autoboxing은 코드를 한결 간결하게 만들어주고, 가독성을 높여주지만 때로는 <strong>사용하지 말아야 할 때</strong>가 있다. 예를 들어 <strong>반복문 안</strong>에서는 사용하지 않도록 한다. <br></p>\n<p>Autoboxing과 비슷하게 unboxing 또한 객체를 어떤 메소드에 전달했을 때 자동으로 기대되는 primitive로 변화해주는 역할을 한다. <br></p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">Integer</span> object <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> val1 <span class=\"token operator\">=</span> <span class=\"token function\">getSquareValue</span><span class=\"token punctuation\">(</span>object<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//unboxing</span>\n<span class=\"token keyword\">int</span> val2 <span class=\"token operator\">=</span> object<span class=\"token punctuation\">;</span> <span class=\"token comment\">//unboxing</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">getSquareValue</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> i<span class=\"token operator\">*</span>i<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>즉, 어떠한 메소드가 primitive value나 wrapper object을 기대할 때 두 가지 경우 모두를 전달할 수 있다는 것이다. 자바가 내부적으로 전달받은 변수에 대해서 맞는 primitive나 wrapper 클래스로 변환해 줄 것이기 때문이다. </p>\n<br>\n<br>\n<p><strong><small>[참고 자료]: <a href=\"https://www.baeldung.com/java-wrapper-classes\">https://www.baeldung.com/java-wrapper-classes</a>, <a href=\"https://www.geeksforgeeks.org/wrapper-classes-java/\">https://www.geeksforgeeks.org/wrapper-classes-java/</a></small></strong></p>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#1-%EA%B0%9C%EC%9A%94\">1. 개요</a></li>\n<li><a href=\"#2-wrapper-classes\">2. Wrapper Classes</a></li>\n<li><a href=\"#3-primitive%EC%97%90%EC%84%9C-wrapper-class%EB%A1%9C-%EB%B3%80%ED%99%98\">3. Primitive에서 Wrapper Class로 변환</a></li>\n<li><a href=\"#4-autoboxing-%EA%B3%BC-unboxing\">4. Autoboxing 과 Unboxing</a></li>\n</ul>\n</div>","frontmatter":{"date":"August 08, 2020","title":"[Java] Wrapper Classes in Java","categories":"자바","author":"코다","emoji":"✊"},"fields":{"slug":"/java-wrapper-class/"}},"prev":{"id":"3abdc3c5-1be2-5f00-abea-96176b99fce9","html":"<p>모 기업에서 인턴을 하면서 맡은 업무가 <mark>개인화 추천 모델 구현</mark>이었다. 맡은 업무는 딥러닝 기반의 개인화 추천 모델을 제작하는 것이지만 기존에 회사에서 가지고 있는 추천 시스템의 경우 협업 필터링 등으로 이미 구현이 되어 있었기 때문에 간단히 개인화 추천 시스템에 대한 브리핑을 해주시면서 감을 잡을 수 있도록 해주셨다. <br></p>\n<p>추천 시스템 기술을 처음 접해보면서 어떠한 것인지 공부하며 기록해보려고 한다. <br></p>\n<h2 id=\"추천이란\" style=\"position:relative;\"><a href=\"#%EC%B6%94%EC%B2%9C%EC%9D%B4%EB%9E%80\" aria-label=\"추천이란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>추천이란?</h2>\n<p>추천이란 간단히 말해서 사용자(user)에게 관심이 있을 것으로 예상이 되는 아이템(item)을 제안하는 것이다. 특정 아이템에 대한 특정 사용자의 선호도 또는 평가를 예측하는 것이 매우 중요하다. <br></p>\n<p>우리가 흔히 생각해 낼 수 있는 추천 시스템은 페이스북과 같은 것에서의 광고 추천, 넷플릭스나 왓챠와 같은 OTT 서비스에서의 영화 추천 시스템이다. <br></p>\n<h2 id=\"접근-방식\" style=\"position:relative;\"><a href=\"#%EC%A0%91%EA%B7%BC-%EB%B0%A9%EC%8B%9D\" aria-label=\"접근 방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>접근 방식</h2>\n<p>추천 시스템 기술에서의 접근 방식은 크게 다음과 같은 3가지가 있다. <br></p>\n<ul>\n<li>내용 기반 필터링 (Content-based Filtering) <br></li>\n<li>협업 필터링 (Collaborative Filtering) <br></li>\n<li>하이브리드 (Hybrid) <br></li>\n</ul>\n<h3 id=\"1-내용-기반-필터링\" style=\"position:relative;\"><a href=\"#1-%EB%82%B4%EC%9A%A9-%EA%B8%B0%EB%B0%98-%ED%95%84%ED%84%B0%EB%A7%81\" aria-label=\"1 내용 기반 필터링 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1) 내용 기반 필터링</h3>\n<p>사용자의 프로필이나 아이템의 content 정보를 이용하는 방법이다. 사용자의 선호도, 취향 등을 파악하는 방법이 핵심이다. 예를 들어, 회원가입 시 사용자에게 선호하는 아이템 또는 분야 등에 대해서 선택하도록 하여 선호도를 파악하여 해당 정보를 기반으로 추천을 한다. 또는 사용자의 과거에 평가한 아이템 분석을 통해서 선호도를 파악할 수 있다. <br></p>\n<p><img src=\"https://user-images.githubusercontent.com/63405904/110242569-0590d100-7f9a-11eb-8799-e9fe186779e6.jpeg\" alt=\"contentbased\"></p>\n<h3 id=\"2-협업-필터링\" style=\"position:relative;\"><a href=\"#2-%ED%98%91%EC%97%85-%ED%95%84%ED%84%B0%EB%A7%81\" aria-label=\"2 협업 필터링 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2) 협업 필터링</h3>\n<p>협업 필터링은 여러 사용자들의 활동, 기호 정보들을 분석하여, 각 사아요자에게 적합한 아이템을 추천하도록 한다. 예를 들어서 사용자 A와 유사하다고 판단되는 사용자 B가 최근 구매한 상품을 사용자 A에게도 추천하도록 하는 것이다. <br></p>\n<p><img src=\"https://user-images.githubusercontent.com/63405904/110242548-f14cd400-7f99-11eb-927e-2e1000c04eba.jpeg\" alt=\"collaborative\"></p>\n<h3 id=\"3-내용-기반-필터링--협업-필터링의-장단점\" style=\"position:relative;\"><a href=\"#3-%EB%82%B4%EC%9A%A9-%EA%B8%B0%EB%B0%98-%ED%95%84%ED%84%B0%EB%A7%81--%ED%98%91%EC%97%85-%ED%95%84%ED%84%B0%EB%A7%81%EC%9D%98-%EC%9E%A5%EB%8B%A8%EC%A0%90\" aria-label=\"3 내용 기반 필터링  협업 필터링의 장단점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3) 내용 기반 필터링 &#x26; 협업 필터링의 장단점</h3>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>내용 기반 필터링</th>\n<th>협업 필터링</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>장점</td>\n<td>사용자의 명시적인 기호 정보를 직접적으로 반영한다. <br>다른 사용자의 정보나 평가, 행동 등이 필요하지 않다.<br>새로 추가된 아이템에 대한 추천이 가능하다.</td>\n<td>대부분의 경우 추천 성과가 우수하다.<br>잠재적인 특징을 고려하여 다양한 범위의 추천이 가능하다.</td>\n</tr>\n<tr>\n<td>단점</td>\n<td>사용자의 명시적인 프로필 얻기 어려움이 있다.<br>명시적으로 표현된 특징만 다룰 수 있고 잠재적인 것을 캐치하기 어렵다.<br>추천하는 항목이 비슷한 장르에 머무르는 한계가 있다.</td>\n<td>초기 사용자에 대한 믿을만한 추천이 어렵다. Cold start가 존재한다.<br>한번도 평가되지 않은 아이템은 추천 대상에서 제외된다. sparsity, coverage</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"4-하이브리드\" style=\"position:relative;\"><a href=\"#4-%ED%95%98%EC%9D%B4%EB%B8%8C%EB%A6%AC%EB%93%9C\" aria-label=\"4 하이브리드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4) 하이브리드</h3>\n<p>위에서의 내용 기반 필터링과 협업 필터링을 결합하여 사용한다. 결합하는 방식을 다양하기 때문에 어떠한 하이브리드 방식을 택하는지는 매우 광범위 하다. 하지만 간단히 보아서 위의 두가지 방식을 같이 사용함으로 각자의 단점을 보완한다는 장점을 가지고 있다. 다만 시스템적으로 매우 복잡해질 수 있는 단점이 있다. </p>\n<h3 id=\"5-협업-필터링-기술-분류\" style=\"position:relative;\"><a href=\"#5-%ED%98%91%EC%97%85-%ED%95%84%ED%84%B0%EB%A7%81-%EA%B8%B0%EC%88%A0-%EB%B6%84%EB%A5%98\" aria-label=\"5 협업 필터링 기술 분류 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5) 협업 필터링 기술 분류</h3>\n<p>본 기업에서 중점적으로 사용하고 있는 협업 필터링 기술은 다음과 같이 분류된다. <br></p>\n<ul>\n<li>\n<p>메모리 기반(Memory-based) 협업 필터링 <br></p>\n<ul>\n<li>사용자 또는 아이템 간의 유사도를 계산하고 그것을 바탕을 추천 결과를 생성하는 방식으로 유사도를 계산하는 방식이 매우 중요함. <br></li>\n<li><strong>대표 알고리즘</strong>: User-based CF / Item-based CF <br></li>\n<li><strong>장점</strong>: 구현이 간단하고 이해하기 쉬움. <br></li>\n<li><strong>한계</strong>: 1) 새로운 사용자와 아이템에 대한 cold start 문제 2) Rating matrix의 sparsity 문제 3) 큰 데이터 셋에 대해 제한된 scalability <br></li>\n</ul>\n</li>\n<li>\n<p>모델 기반(Model-based) 협업 필터링 <br></p>\n<ul>\n<li>데이터(rating matrix)에 내재되어 있는 패턴이나 속성을 학습한 모델을 만들고, 이것을 바탕으로 추천 결과를 생성하는 방식. <br></li>\n<li><strong>대표 알고리즘</strong>: Slope-One EF / Matrix Facotrization <br></li>\n<li><strong>장점:</strong> sparsity, scalability 문제에 상대적으로 더 잘 대처하는 것이 가능하고 예측 성능이 향상됨. <br></li>\n<li><strong>한계:</strong> 1) 모델 구축 비용이 큼 2) 예측 성능과 scalability 사이의 trade-off 3) 차원 감소로 인한 정보손실(SVD 실행 시 발생) <br></li>\n</ul>\n</li>\n<li>\n<p>하이브리드(Hybrid) 방식 협업 필터링 <br></p>\n<ul>\n<li>메모리 기반 방식과 모델 기반 방식을 결합하여 사용하는 방식 <br></li>\n<li><strong>대표 알고리즘</strong>: 메모리 기반과 모델 기반의 조합 <br></li>\n<li><strong>장점</strong>: 각 방식의 단점을 보완하고 장점만을 취합할 수 있음 <br></li>\n<li><strong>한계:</strong> 구현이 복잡해지고 비용이 증가함. <br></li>\n</ul>\n</li>\n</ul>\n<br>\n<p><strong><small>[참고 자료]: <a href=\"https://www.samsungsemiconstory.com/2265\">https://www.samsungsemiconstory.com/2265</a>, </small></strong></p>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#%EC%B6%94%EC%B2%9C%EC%9D%B4%EB%9E%80\">추천이란?</a></li>\n<li>\n<p><a href=\"#%EC%A0%91%EA%B7%BC-%EB%B0%A9%EC%8B%9D\">접근 방식</a></p>\n<ul>\n<li><a href=\"#1-%EB%82%B4%EC%9A%A9-%EA%B8%B0%EB%B0%98-%ED%95%84%ED%84%B0%EB%A7%81\">1) 내용 기반 필터링</a></li>\n<li><a href=\"#2-%ED%98%91%EC%97%85-%ED%95%84%ED%84%B0%EB%A7%81\">2) 협업 필터링</a></li>\n<li><a href=\"#3-%EB%82%B4%EC%9A%A9-%EA%B8%B0%EB%B0%98-%ED%95%84%ED%84%B0%EB%A7%81--%ED%98%91%EC%97%85-%ED%95%84%ED%84%B0%EB%A7%81%EC%9D%98-%EC%9E%A5%EB%8B%A8%EC%A0%90\">3) 내용 기반 필터링 &#x26; 협업 필터링의 장단점</a></li>\n<li><a href=\"#4-%ED%95%98%EC%9D%B4%EB%B8%8C%EB%A6%AC%EB%93%9C\">4) 하이브리드</a></li>\n<li><a href=\"#5-%ED%98%91%EC%97%85-%ED%95%84%ED%84%B0%EB%A7%81-%EA%B8%B0%EC%88%A0-%EB%B6%84%EB%A5%98\">5) 협업 필터링 기술 분류</a></li>\n</ul>\n</li>\n</ul>\n</div>","frontmatter":{"date":"August 10, 2020","title":"[머신러닝] 추천 시스템 기술","categories":"머신러닝","author":"코다","emoji":"🪄"},"fields":{"slug":"/ml-recommendation-system/"}},"site":{"siteMetadata":{"siteUrl":"https://yjksw.github.io","comments":{"utterances":{"repo":"yjksw/yjksw.github.io"}}}}},"pageContext":{"slug":"/java-list/","nextSlug":"/java-wrapper-class/","prevSlug":"/ml-recommendation-system/"}},"staticQueryHashes":["1073350324","2938748437"]}
{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/jwt-token/",
    "result": {"data":{"cur":{"id":"38ae2cc9-d468-5d33-af6e-18533bf42cae","html":"<h2 id=\"jwtjson-web-token-배경\" style=\"position:relative;\"><a href=\"#jwtjson-web-token-%EB%B0%B0%EA%B2%BD\" aria-label=\"jwtjson web token 배경 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JWT(JSON Web Token) 배경</h2>\n<p>이전에 인증 절차를 거치려면 사용자의 해싱값을 DB에 저장하고 매번 요청이 있을 때마다 해당 해싱값을 검증해야한다. 검증시 DB에 접근하는 쿼리가 실행되어야하는데 성능면에서 좋지 않다. 따라서 JWT가 등장하게 되고 위와 같은 절차를 거치지만 DB 접근 쿼리가 필요하지 않게 된다.</p>\n<ul>\n<li>\n<p><em>JWT 정의: A string that is sent in the HTTP request (from client or server) to validate the authenticity of the client. It is saved on the client-side only.</em></p>\n<p><a href=\"%5Bhttps://medium.com/jspoint/so-what-the-heck-is-jwt-or-json-web-token-dca8bcb719a6%5D(https://medium.com/jspoint/so-what-the-heck-is-jwt-or-json-web-token-dca8bcb719a6)\">출처</a></p>\n</li>\n</ul>\n<br>\n<h2 id=\"jwt-특징\" style=\"position:relative;\"><a href=\"#jwt-%ED%8A%B9%EC%A7%95\" aria-label=\"jwt 특징 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JWT 특징</h2>\n<ul>\n<li>compact</li>\n<li>self-contained</li>\n<li>digitally signed : it is signed using a secret key(<strong>HMAC</strong> algorithm) or public/private key pair using (<strong>RSA</strong> or <strong>ECDSA</strong>)\n<ul>\n<li>sgined 토큰 이라면 claim의 무결성(integrity)를 검증할 수 있다.</li>\n<li>만일 토큰이 public/private key로 signed 되었다면, 시그니처는 private key를 들고있는 쪽이 signed 한 것이라는 것을 보장한다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"jwt-언제-사용하면-좋을까\" style=\"position:relative;\"><a href=\"#jwt-%EC%96%B8%EC%A0%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%A9%B4-%EC%A2%8B%EC%9D%84%EA%B9%8C\" aria-label=\"jwt 언제 사용하면 좋을까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JWT 언제 사용하면 좋을까</h2>\n<ul>\n<li><strong>Authorization</strong>: 유저가 로그인하여 어떠한 요청들을 보낼 때, JWT를 통해서 인증을 한다. JWT가 사용되는 가장 대표적인 시나리오다. <code class=\"language-text\">Single Sign On</code> 이라고 하는데, 이 때 JWT를 사용하면 부하도 적고 여러 다른 도메인에서 쉽게 사용될 수 있다. (cross-origin일 때 용이)</li>\n<li><strong>Information Exchange</strong>: 정보들을 안전하게 전달하려고 할 때 JWT를 사용하기도 한다. JWT를 signed 할 수 있으니 송신자가 누군지 보장할 수 있다. 또한 시그니처를 통해서 header와 payload를 계산하기 때문에 해당 컨텐츠가 무결함을 보장할 수 있다.</li>\n</ul>\n<br>\n<h2 id=\"jwt-생성\" style=\"position:relative;\"><a href=\"#jwt-%EC%83%9D%EC%84%B1\" aria-label=\"jwt 생성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JWT 생성</h2>\n<p>secret key를 사용해서 JWT를 생성하며, 해당 secret key는 private하여 외부에 공개되거나 JWT 토큰에 주입될 경우가 없다. 또한 JWT를 클라이언트에게 받았을 때 서버에 저장되어 있는 secret key를 통해서 검증한다. <br></p>\n<p>JWT 생성하기 위해서 <a href=\"%5Bhttps://jwt.io/%5D(https://jwt.io/)\">여기</a> 에서 원하는 라이브러리를 다운 받아서 사용한다.</p>\n<br>\n<h2 id=\"jwt-구조\" style=\"position:relative;\"><a href=\"#jwt-%EA%B5%AC%EC%A1%B0\" aria-label=\"jwt 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JWT 구조</h2>\n<p><code class=\"language-text\">xxxx.yyyy.zzzz</code> 으로 header, payload, signature가 (<code class=\"language-text\">.</code>)로 연결되어 있다.</p>\n<ul>\n<li>Header\n<ul>\n<li>type of token (ex. JWT)</li>\n<li>signing algorithm</li>\n<li>JSON 타입, <code class=\"language-text\">Base64Url</code>로 인코딩</li>\n</ul>\n</li>\n<li>Payload\n<ul>\n<li>claims - entity(유저) 정보나 이외의 추가 정보 등등</li>\n<li>registered - 등록되어 있는 claims로 항상 추가하기를 권장하는 유용한 claims\n<ul>\n<li>iss(issuer), exp(expiration time), sub(subject), aud(audience) 등등</li>\n<li>JWT은 compact 하기 때문에 3글자로 제한하여 정의함</li>\n</ul>\n</li>\n<li>public -  JWT 사용하는 입장에서 정의할 수 있는 claims\n<ul>\n<li>충돌을 피하기 위해서 JWT Registry에 정의된 것들만 사용하거나, 충돌방지할 수 있는 URI 형태</li>\n</ul>\n</li>\n<li>private - 커스텀 claims로 양쪽에서 합의하여 공유하기로 한 정보에 대해서 서술한 claims</li>\n<li>JSON 타입, <code class=\"language-text\">Base64Url</code>로 인코딩, 때문에 어느 누구나 디코딩하여 접근할 수 있는 정보이기 때문에 민감한 정보는 담지 않도록 한다.</li>\n</ul>\n</li>\n<li>Signature\n<ul>\n<li>인코딩 된 header, payload, secrete을 조합하여 header에 있는 알고리즘으로 시그니처를 생성</li>\n<li>이 시그니처를 통해서 담긴 정보의 무결성을 보장</li>\n<li>private key로 signed 되었을 경우 JWT sender 또한 보장 가능</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"jwt-signature\" style=\"position:relative;\"><a href=\"#jwt-signature\" aria-label=\"jwt signature permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JWT Signature</h3>\n<p>위 header와 payload는 쉽게 디코딩해 내용을 확인할 수 있다. 따라서 해당 token을 보안에 사용할 수 있도록 하는 요소는 signature이다. <br></p>\n<p>제 3자가 토큰의 header나 payload를 변경하지 않았음을 보장하기 위해서 secret key와 해당 키로 생성된 signaturer를 사용한다. <br></p>\n<p>Token 검증을 할 때, 전송된 JWT에 있는 header, payload를 가지고 서버에 저장되어 있는 secret을 통해서 test signature를 생성한다. test signature와 token에 있는 처음 token 생성시 추가된 original signature와 동일한지 비교하여 데이터 변경 여부를 체크한다. 이 방법을 통해서 token은 데이터 무결성을 보장한다. <br></p>\n<br>\n<h2 id=\"왜-jwt\" style=\"position:relative;\"><a href=\"#%EC%99%9C-jwt\" aria-label=\"왜 jwt permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>왜 JWT?</h2>\n<p>Simple Web Tokens(<strong>SWT</strong>)와 Security Assertion Markup Language Tokens(<strong>SAML</strong>) 비교했을 때 장점들이다. <br></p>\n<p>JSON은 우선 XML보다 간단(덜 장황함)하여 인코딩 했을 때, 그 사이즈가 훨씬 작고 <strong>SAML</strong>보다 compact 하다. <br></p>\n<p align=\"center\"><img width=\"85%\" src=\"https://user-images.githubusercontent.com/63405904/135121193-926e8de5-411d-49dc-873c-09cfb0a552df.png\"></p>\n<p align=\"center\"><img width=\"85%\" src=\"https://user-images.githubusercontent.com/63405904/135121388-68caa14c-464b-449e-8901-70491a30b765.png\"></p>\n<p>보안적 측면에서는 <strong>SWT</strong>는 대칭키를 활용하는 HMAC 알고리즘만 사용이 가능한데, <strong>JWT</strong>, <strong>SAML</strong>은 public/private key 페어를 사용할 수 있다. 더해서 XML signing보다 JSON signing이 훨씬 쉽다. <br></p>\n<p>또한 잘 구축되어 있는 여러 JSON 파서들을 활용할 수 있다. <br></p>\n<p>마지막으로 활용 측면에서 <strong>JWT</strong>는 인터넷 환경에서 많이 쓰인다. 그렇기 때문에 클라이언트의 입장에서 <strong>JWT</strong>를 여러 환경(특히, 모바일 환경에서도)에서 활용하기 용이하다는 장점이 있다.  <br></p>\n<br>\n<br>\n<p><strong>[참고자료]</strong></p>\n<ul>\n<li><a href=\"https://jwt.io/introduction\">https://jwt.io/introduction</a></li>\n<li><a href=\"https://stackoverflow.com/questions/31309759/what-is-secret-key-for-jwt-based-authentication-and-how-to-generate-it\">https://stackoverflow.com/questions/31309759/what-is-secret-key-for-jwt-based-authentication-and-how-to-generate-it</a></li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#jwtjson-web-token-%EB%B0%B0%EA%B2%BD\">JWT(JSON Web Token) 배경</a></p>\n</li>\n<li>\n<p><a href=\"#jwt-%ED%8A%B9%EC%A7%95\">JWT 특징</a></p>\n</li>\n<li>\n<p><a href=\"#jwt-%EC%96%B8%EC%A0%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%A9%B4-%EC%A2%8B%EC%9D%84%EA%B9%8C\">JWT 언제 사용하면 좋을까</a></p>\n</li>\n<li>\n<p><a href=\"#jwt-%EC%83%9D%EC%84%B1\">JWT 생성</a></p>\n</li>\n<li>\n<p><a href=\"#jwt-%EA%B5%AC%EC%A1%B0\">JWT 구조</a></p>\n<ul>\n<li><a href=\"#jwt-signature\">JWT Signature</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%99%9C-jwt\">왜 JWT?</a></p>\n</li>\n</ul>\n</div>","excerpt":"JWT(JSON Web Token) 배경 이전에 인증 절차를 거치려면 사용자의 해싱값을 DB에 저장하고 매번 요청이 있을 때마다 해당 해싱값을 검증해야한다. 검증시 DB에 접근하는 쿼리가 실행되어야하는데 성능면에서 좋지 않다. 따라서 JWT가 등장하게 되고 위와 같은 절차를 거치지만 DB 접근 쿼리가 필요하지 않게 된다. JWT 정의: A string that is sent in the HTTP request (from client or server) to validate the authenticity of the client. It is saved on the client-side only. 출처 JWT 특징 compact self-contained digitally signed : it is signed using a secret key(HMAC algorithm) or public/private key pair using (RSA or ECDSA) sgined 토큰 이라면 c…","frontmatter":{"date":"June 13, 2021","title":"JWT (JSON Web Token) 알아보기","categories":"웹","author":"코다","emoji":"🖥"},"fields":{"slug":"/jwt-token/"}},"next":{"id":"8bf91ec6-90fe-5ce0-86c1-d8e98765968f","html":"<p>간단한 JavaBean 규약에 대해서 알고 넘어가기</p>\n<h2 id=\"javabean\" style=\"position:relative;\"><a href=\"#javabean\" aria-label=\"javabean permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JavaBean</h2>\n<p>자바빈 규약을 따르는 Java Class를 말한다.</p>\n<h2 id=\"javabean-규약\" style=\"position:relative;\"><a href=\"#javabean-%EA%B7%9C%EC%95%BD\" aria-label=\"javabean 규약 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JavaBean 규약</h2>\n<ol>\n<li>defulat 패키지가 아닌 패키지 하위에 있는 클래스</li>\n<li>기본 생성자가 존재 (no-arg constructor)</li>\n<li>Property는 모두 private으로 선언</li>\n<li>Getter/setter를 통해서 properties를 조작</li>\n<li><code class=\"language-text\">Serializable</code>을 implement 하여 직렬화 가능</li>\n</ol>\n<h2 id=\"번외--serialization--deserialization\" style=\"position:relative;\"><a href=\"#%EB%B2%88%EC%99%B8--serialization--deserialization\" aria-label=\"번외  serialization  deserialization permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>번외 : Serialization &#x26; Deserialization</h2>\n<ul>\n<li>Serialization : converting state of an object into a byte stream</li>\n<li>Deserialization: reverse process of serialization</li>\n</ul>\n<p>해당 객체에 영속성을 부여하기 위해서 사용되는 매커니즘이다. <br></p>\n<p>Java 객체를 serialize 하게 하기 위해서는 <code class=\"language-text\">java.io.Serializable</code> 인터페이스를 구현하도록 한다. 해당 인터페이스는 멤버변수나 메소드가 존재하지 않는 marker interface(Cloneable이나 Remote와 같은) 이다. <br></p>\n<p>Serializable하면 1) 해당 객체 그대로에 영속성을 부여할 수 있으며 2) 네트워크 상에서 byte stream으로 전송이 가능하다. <br></p>\n<p><strong>Serialization 특징</strong></p>\n<ul>\n<li>\n<p>부모 클래스가 Serializable interface를 구현하면 자식 클래스는 자동으로 Serializable 하다.</p>\n</li>\n<li>\n<p>non-static 멤버 변수만 Serialization 으로 저장될 수 있다. (static 과 transient 데이터는 불가)</p>\n</li>\n<li>\n<p>비밀번호 등의 보안으로 인해 어떠한 멤버 변수가 serialize 되어 저장되지 않기를 원한다면 해당 데이터를 trasient 데이터로 지정하도록 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Member</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Serializable</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">transient</span> <span class=\"token class-name\">String</span> password<span class=\"token punctuation\">;</span>\n\t<span class=\"token class-name\">String</span> name<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n<li>\n<p>해당 객체가 deserialized 될 때 해당 객체의 생성자는 호출되지 않는다.</p>\n</li>\n<li>\n<p>Serializable 한 객체와 연관되어 있는 객체 또한 Serializable 인터페이스를 반드시 구현해야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">ObjectA</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Serializable</span> <span class=\"token punctuation\">{</span>\t\n\t<span class=\"token comment\">//ObjectB는 반드시 Serializable을 구현해야 함\t</span>\n\t<span class=\"token class-name\">ObjectB</span> oj <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ObjectB</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n</ul>\n<p><strong>SerialVersionUID</strong></p>\n<p>Serialization을 진행하면서 각 Serializable class는 <code class=\"language-text\">SerialVersionUID</code> 라는 id를 할당받는다. 해당 id를 통해서 직렬화된 객체의 sender와 receiver를 판별하는데, sender와 reciever는 동일해야한다. 만일 동일하지 않다면 <code class=\"language-text\">InvalidClassException</code>이 deserialize 할 때 발생한다.</p>\n<br>\n<br>\n<p><strong>[참고자료]</strong></p>\n<ul>\n<li><a href=\"https://dololak.tistory.com/133\">https://dololak.tistory.com/133</a></li>\n<li><a href=\"https://www.geeksforgeeks.org/javabean-class-java/#:~:text=JavaBeans%20are%20classes%20that%20encapsulate,public%20getters%20and%20setter%20methods\">https://www.geeksforgeeks.org/javabean-class-java/#:~:text=JavaBeans are classes that encapsulate,public getters and setter methods</a>.</li>\n<li><a href=\"https://www.geeksforgeeks.org/serialization-in-java/\">https://www.geeksforgeeks.org/serialization-in-java/</a></li>\n<li><a href=\"https://www.javatpoint.com/serialization-in-java#:~:text=Serialization%20in%20Java%20is%20a,is%20converted%20into%20an%20object\">https://www.javatpoint.com/serialization-in-java#:~:text=Serialization in Java is a,is converted into an object</a>.</li>\n</ul>\n<p><strong>[MORE]</strong></p>\n<ul>\n<li>non-static 만 serialization 가능한 이유</li>\n<li>SerialVersionUID</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#javabean\">JavaBean</a></li>\n<li><a href=\"#javabean-%EA%B7%9C%EC%95%BD\">JavaBean 규약</a></li>\n<li><a href=\"#%EB%B2%88%EC%99%B8--serialization--deserialization\">번외 : Serialization &#x26; Deserialization</a></li>\n</ul>\n</div>","frontmatter":{"date":"June 08, 2021","title":"자바빈 규약 (번외: Serialization)","categories":"자바","author":"코다","emoji":"✊"},"fields":{"slug":"/java-bean/"}},"prev":{"id":"2696e70c-e746-5fb0-96cc-3b651a5c3483","html":"<h2 id=\"requestbody\" style=\"position:relative;\"><a href=\"#requestbody\" aria-label=\"requestbody permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>@RequestBody</h2>\n<p>request body를 method argument로 바꿀 때 <code class=\"language-text\">HttpMessageConverter</code>를 사용한다.</p>\n<ul>\n<li><code class=\"language-text\">HttpMessageConverter</code> 는 두가지를 담당한다. 첫번째는 Http request message를 객체로 변환하는 것, 두번째는 객체를 Http response body로 변환하는 작업이다.</li>\n</ul>\n<h3 id=\"동작원리\" style=\"position:relative;\"><a href=\"#%EB%8F%99%EC%9E%91%EC%9B%90%EB%A6%AC\" aria-label=\"동작원리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>동작원리</h3>\n<p><code class=\"language-text\">DispatcherServlet</code>에 의해서 호출되는 handler의 method parameters은 스프링의 <code class=\"language-text\">HandlerMethodArgumentResolver</code>에 의해 생성이 되고, handler의 return value는 <code class=\"language-text\">HandlerMethodReturnValueHandler</code>에 의해서 처리된다. <code class=\"language-text\">@ResponseBody</code>와 <code class=\"language-text\">@RequestBody</code>를 다루는 구현체는 <code class=\"language-text\">RequestResponseBodyMethodProcess</code>이다.</p>\n<ul>\n<li>\n<p>DispatcherServlet의 handle에서부터 Argument resolve 하는 과정</p>\n<p><code class=\"language-text\">DispatcherServlet#handle()</code> → <code class=\"language-text\">AbstractHandlerMethodAdapter#handle()</code> → <code class=\"language-text\">RequestMappingHandlerAdapter#handleInternal()</code> → <code class=\"language-text\">RequestMappingHandlerAdapter#invokeHandlerMethod()</code> → <code class=\"language-text\">ServletInvocableHandlerMethod#invokeAndHandle()</code> → <code class=\"language-text\">InvocableHandlerMethod#invokeForRequest()</code> → <code class=\"language-text\">InvocableHandlerMethod #getMethodArgumentValues()</code> → <em>(Interface)</em><code class=\"language-text\">HandlerMethodArgumentResolver#resolveArgument()</code> → <em>(Imp)</em><code class=\"language-text\">RequestResponseBodyMethodProcessor#resolveArgument()</code></p>\n</li>\n<li>\n<p><code class=\"language-text\">RequestResponseBodyMethodProcessor#resolveArgument()</code> 내부에서 HttpMessageConverter를 사용해서 변환시키는 과정</p>\n<p><code class=\"language-text\">RequestResponseBodyMethodProcessor#resolveArgument()</code> → (e<em>xtends  AbstractMessageConverterMethodArgumentResolver</em>)<code class=\"language-text\">RequestResponseBodyMethodProcessor#readWithMessageConverters()</code> → (<em>Imp HandlerMethodArgumentResolver</em>)<code class=\"language-text\">AbstractMessageConverterMethodArgumentResolver#readWithMessageConverters()</code> 에서 변환 로직을 시행한다.</p>\n</li>\n</ul>\n<p>이때 HttpMessageConverter default 인스턴스들은 <code class=\"language-text\">WebMvcConfigurationSupport#addDefaultHttpMessageConverters()</code> 를 통해 등록된다.</p>\n<h3 id=\"httpmessageconverter-로직\" style=\"position:relative;\"><a href=\"#httpmessageconverter-%EB%A1%9C%EC%A7%81\" aria-label=\"httpmessageconverter 로직 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>HttpMessageConverter 로직</h3>\n<ul>\n<li>\n<p><code class=\"language-text\">@RequestBody</code> 일때</p>\n<p><code class=\"language-text\">HttpMessageConverter#canRead()</code> 로 converter가 해당 content의 인스턴스를 읽고 생성할 수 있는지 확인한다. 이후에 argument를 생성하여 반환한다.</p>\n</li>\n<li>\n<p><code class=\"language-text\">@ResponseBody</code> 일때</p>\n<p><code class=\"language-text\">HttpMessageConverter#canWrite()</code> 를 통해서 <code class=\"language-text\">HttpMessageConverter</code>가 해당 반환값을 serialize 할 수 있는지 확인하고 response content를 생성하고, <code class=\"language-text\">Accept</code> 헤더가 있다면 해당 content-type에 매칭되는지도 확인한다.</p>\n</li>\n</ul>\n<p><code class=\"language-text\">MessagConverter</code>를 사용하는 <code class=\"language-text\">@RequestBody</code>는 값을 바인딩하는 것이 아니라, 해당 내용을 Java Object로 변환한다. 그렇기 때문에 Body가 존재하지 않은 <code class=\"language-text\">GET</code> 메서드에 <code class=\"language-text\">@RequestBody</code>를 적용하려고 하면 예외가 발생한다.</p>\n<h3 id=\"4가지-default-messageconverters\" style=\"position:relative;\"><a href=\"#4%EA%B0%80%EC%A7%80-default-messageconverters\" aria-label=\"4가지 default messageconverters permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4가지 Default MessageConverters</h3>\n<ol>\n<li>\n<p><code class=\"language-text\">ByteArrayHttpMessageConverter</code></p>\n<p><code class=\"language-text\">byte[]</code> 오브젝트 타입을 지원하여 들어오는 요청을 모두 바이트 배열로 받을 수 있다. 또한 리턴 타입이 <code class=\"language-text\">byte[]</code> 일 경우 <code class=\"language-text\">Content-type</code>이 <code class=\"language-text\">applcation/octet-stream</code>으로 설정된다.</p>\n</li>\n<li>\n<p><code class=\"language-text\">StringHttpMessageConverter</code></p>\n<p><code class=\"language-text\">String</code> 오브젝트 타입을 지원하여 HTTP 본문을 그대로 <code class=\"language-text\">String</code>으로 가져오고, 그대로 리턴할 경우 <code class=\"language-text\">Content-type</code>은 <code class=\"language-text\">text/plain</code>으로 전달된다.</p>\n</li>\n<li>\n<p><code class=\"language-text\">FormHttpMessageConverter</code></p>\n<p>MultiValueMap&#x3C;String, String>을 지원하는데, 지원하는 미디어 타입은 <code class=\"language-text\">application/x-www-form-urlencoded</code>이다. 하지만 form 데이터의 경우 <code class=\"language-text\">@ModelAttribute</code>가 더 유용하다.</p>\n</li>\n<li>\n<p><code class=\"language-text\">SourceHttpMessageConverter</code></p>\n<p>XML 문서를 Source 타입 객체로 변환하고 싶을 때 사용하지만 요즘에는 잘 쓰이지 않는다.</p>\n</li>\n</ol>\n<h3 id=\"자주-쓰이는-messageconverters-3가지\" style=\"position:relative;\"><a href=\"#%EC%9E%90%EC%A3%BC-%EC%93%B0%EC%9D%B4%EB%8A%94-messageconverters-3%EA%B0%80%EC%A7%80\" aria-label=\"자주 쓰이는 messageconverters 3가지 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>자주 쓰이는 MessageConverters 3가지</h3>\n<ol>\n<li>\n<p><code class=\"language-text\">Jaxb2RootElementHttpMessageConverter</code></p>\n<p>JAXB의 @XmlRootElement와 @XmlType이 붙은 클래스로 XML과 오브젝트 사이의 변환을 해준다.</p>\n</li>\n<li>\n<p><code class=\"language-text\">MashallingHttpMessageConverter</code></p>\n<p>스프링 OXM 추상화 <code class=\"language-text\">Mashaller</code>와 <code class=\"language-text\">Unmarshaller</code>를 이용해서 <code class=\"language-text\">XML</code>과 오브젝트 사이의 변환을 해준다.</p>\n</li>\n<li>\n<p><code class=\"language-text\">MappingJacksonHttpMessageConverter</code></p>\n<p><code class=\"language-text\">Jackson</code>의 <code class=\"language-text\">ObjectMapper</code>를 사용해서 <code class=\"language-text\">JSON</code>과 오브젝트 사이의 변환을 해주고 지원하는 미디어타입은 <code class=\"language-text\">application/json</code>이다.</p>\n</li>\n</ol>\n<ul>\n<li>참고링크: <a href=\"https://joont92.github.io/spring/MessageConverter/\">https://joont92.github.io/spring/MessageConverter/</a></li>\n</ul>\n<br>\n<h2 id=\"modelattribute\" style=\"position:relative;\"><a href=\"#modelattribute\" aria-label=\"modelattribute permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>@ModelAttribute</h2>\n<p>흔히 <code class=\"language-text\">@ModelAttribute</code>를 들어온 요청에 대해서 method parameter를 매핑시키는 용도로만 알고 있는데, 이외에 return value를 지정된 model attribute로 바인딩하고 웹 뷰에 표현하는 작업도 담당한다. <br></p>\n<p>따라서 <code class=\"language-text\">@ModelAttribute</code>는 두 가지 level에서 사용되는데 <strong>1) method parameter</strong>와 <strong>2) method level</strong>이다. <br></p>\n<p>일반적으로 <code class=\"language-text\">@ModelAttribute</code>는 form data에 사용이 되는데, 이때 value 속성의 값을 함께 넘겨준다. <br></p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token namespace\">form:</span>form</span> <span class=\"token attr-name\">method</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>POST<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">action</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>/spring-mvc-basics/addEmployee<span class=\"token punctuation\">\"</span></span> \n  <span class=\"token attr-name\">modelAttribute</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>employee<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token namespace\">form:</span>label</span> <span class=\"token attr-name\">path</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>name<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>Name<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span><span class=\"token namespace\">form:</span>label</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token namespace\">form:</span>input</span> <span class=\"token attr-name\">path</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>name<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span>\n    \n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token namespace\">form:</span>label</span> <span class=\"token attr-name\">path</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>id<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>Id<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span><span class=\"token namespace\">form:</span>label</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token namespace\">form:</span>input</span> <span class=\"token attr-name\">path</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>id<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span>\n    \n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>input</span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>submit<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">value</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>Submit<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span><span class=\"token namespace\">form:</span>form</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p>하지만 만일 <code class=\"language-text\">value</code> 속성이 함께 제공되지 않았다면 default로 Method level에 적용되는 <code class=\"language-text\">@ModelAttribute</code>에게는 반환 타입이, Method-argument에는 parameter 타입이  지정된다.</p>\n<h3 id=\"at-method-level\" style=\"position:relative;\"><a href=\"#at-method-level\" aria-label=\"at method level permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>At Method Level</h3>\n<p>Method level에서 <code class=\"language-text\">@ModelAttribute</code>이 추가되어 있다면 해당 메서드는 Model에 하나 또는 여러개의 속성(attribute)을 추가한다는 것을 의미한다. <code class=\"language-text\">@RequestMapping</code> 어노테이션이 붙어있는 메서드와 마찬가지로 같은 argument(Model mode)을 제공하는것은 동일하지만, 들어오는 request에 직접적으로 매핑되지는 않는다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token comment\">//하나의 model attribute를 추가할 때</span>\n<span class=\"token annotation punctuation\">@ModelAttribute</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">addAccount</span><span class=\"token punctuation\">(</span><span class=\"token annotation punctuation\">@RequestParam</span> <span class=\"token class-name\">String</span> number<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">return</span> accountManager<span class=\"token punctuation\">.</span><span class=\"token function\">findAccount</span><span class=\"token punctuation\">(</span>number<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">//하나 이상의 model attributes를 추가할 때 </span>\n<span class=\"token annotation punctuation\">@ModelAttribute</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">addAttributes</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Model</span> model<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\tmodel<span class=\"token punctuation\">.</span><span class=\"token function\">addAttribute</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"msg\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Welcome to the Netherlands\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\tmodel<span class=\"token punctuation\">.</span><span class=\"token function\">addAttribute</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"name\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"This is name\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>일반적으로 Spring MVC는 위 메서드를 request handler를 호출하기 이전에 우선적으로 호출한다.  <br></p>\n<p><strong>!!! <code class=\"language-text\">@ModelAttribute</code> 메서드들이 controller에서 <code class=\"language-text\">@RequestMapping</code>으로 지정된 메서드들 보다 먼저 실행된다는 것이다. (같은 controller에 있는 경우)</strong> <br></p>\n<p>만일 global하게 들어오는 모든 요청에 대해서 특정 model attribute을 추가하고 싶다면, 해당 controller를 <code class=\"language-text\">@ControllerAdvice</code>을 지정하는 것이 좋다. <br></p>\n<p>일반적으로 method level의 <code class=\"language-text\">@ModelAttribute</code>의 목적은 하나 또는 하나 이상의 model attributes를 추가하기 위해서이다. Controller는 여러개의 <code class=\"language-text\">@MethodAttribute</code> 메소드들을 가지고 있을 수 있는데, 그 어떤 요청이 들어오면 같은 controller 안에 있는 그 모든 메소드들이 실행된다. 전역적으로 실행하고 싶다면 <code class=\"language-text\">@ControllerAdvice</code> 어노테이션을 추가하면 된다. <br></p>\n<h3 id=\"at-method-argument\" style=\"position:relative;\"><a href=\"#at-method-argument\" aria-label=\"at method argument permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>At Method Argument</h3>\n<p>만일 method argument 레벨에서 <code class=\"language-text\">@ModelAttribute</code>가 사용된다면 model 에서 인자가 추출되어야 한다는 것을 의미한다.</p>\n<blockquote>\n<p>“An @ModelAttribute on a method argument indicates the argument should be retrieved from the model. If not present in the model, the argument should be instantiated first and then added to the model.”</p>\n</blockquote>\n<p>즉, Method Argument 레벨에서 <code class=\"language-text\">@ModelAttribute</code>를 사용하면, 우선 model에 해당 attribute가 있는지 확인하여 반환하고, 없다면 <strong>1) arguments를 초기화</strong> <strong>2)model에 추가</strong>한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@RequestMapping</span><span class=\"token punctuation\">(</span>value<span class=\"token operator\">=</span><span class=\"token string\">\"/owners/{ownerId}/pets/{petId}/edit\"</span><span class=\"token punctuation\">,</span> method <span class=\"token operator\">=</span> <span class=\"token class-name\">RequestMethod</span><span class=\"token punctuation\">.</span>POST<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">processSubmit</span><span class=\"token punctuation\">(</span><span class=\"token annotation punctuation\">@ModelAttribute</span> <span class=\"token class-name\">Pet</span> pet<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위와 같이 Method Argument에서 <code class=\"language-text\">@ModelAttribute</code>가 사용되었을 경우 인자인 Pet instance의 출처는 다음 4가지 중 하나일 수 있다.</p>\n<ol>\n<li><code class=\"language-text\">@SessionAttributes</code> 에 의해 이미 존재하는 model attribute</li>\n<li><code class=\"language-text\">@ModelAttribute</code> 메소드에 의해 이미 존재하는 model attribute</li>\n<li>URI template와 type converter에 의해 추출된 instance</li>\n<li>default constructor에 의해 초기화된 instance</li>\n</ol>\n<br>\n<br>\n<p><strong>[참고자료]</strong></p>\n<ul>\n<li><a href=\"https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html#rest-message-conversion\">https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/remoting.html#rest-message-conversion</a></li>\n<li><a href=\"https://mangkyu.tistory.com/72\">https://mangkyu.tistory.com/72</a></li>\n<li><a href=\"https://stackoverflow.com/questions/29517613/how-exactly-works-requestbody-annotation-and-how-it-is-related-to-the-httpmessa\">https://stackoverflow.com/questions/29517613/how-exactly-works-requestbody-annotation-and-how-it-is-related-to-the-httpmessa</a></li>\n<li><a href=\"https://stackoverflow.com/questions/17362177/how-does-the-modelattribute-annotation-work-why-cant-i-got-the-value\">https://stackoverflow.com/questions/17362177/how-does-the-modelattribute-annotation-work-why-cant-i-got-the-value</a></li>\n<li><a href=\"https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html#mvc-ann-modelattrib-methods\">https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html#mvc-ann-modelattrib-methods</a></li>\n</ul>\n<br>\n<br>\n<p><strong>[MORE]</strong></p>\n<ul>\n<li>\n<p>HttpMessageConverters 내부동작원리</p>\n<p><a href=\"https://www.baeldung.com/spring-httpmessageconverter-rest\">https://www.baeldung.com/spring-httpmessageconverter-rest</a></p>\n</li>\n<li>\n<p>언제 무엇? 장단점</p>\n</li>\n<li>\n<p>URI template와 type converter에 의해 추출된 instance 동작원리</p>\n</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#requestbody\">@RequestBody</a></p>\n<ul>\n<li><a href=\"#%EB%8F%99%EC%9E%91%EC%9B%90%EB%A6%AC\">동작원리</a></li>\n<li><a href=\"#httpmessageconverter-%EB%A1%9C%EC%A7%81\">HttpMessageConverter 로직</a></li>\n<li><a href=\"#4%EA%B0%80%EC%A7%80-default-messageconverters\">4가지 Default MessageConverters</a></li>\n<li><a href=\"#%EC%9E%90%EC%A3%BC-%EC%93%B0%EC%9D%B4%EB%8A%94-messageconverters-3%EA%B0%80%EC%A7%80\">자주 쓰이는 MessageConverters 3가지</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#modelattribute\">@ModelAttribute</a></p>\n<ul>\n<li><a href=\"#at-method-level\">At Method Level</a></li>\n<li><a href=\"#at-method-argument\">At Method Argument</a></li>\n</ul>\n</li>\n</ul>\n</div>","frontmatter":{"date":"June 19, 2021","title":"@ModelAttribute vs. @RequestBody 더 깊이 파헤치기","categories":"스프링부트","author":"코다","emoji":"🖥"},"fields":{"slug":"/request-body-model-attribute-advanced/"}},"site":{"siteMetadata":{"siteUrl":"https://yjksw.github.io","comments":{"utterances":{"repo":"yjksw/yjksw.github.io"}}}}},"pageContext":{"slug":"/jwt-token/","nextSlug":"/java-bean/","prevSlug":"/request-body-model-attribute-advanced/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}
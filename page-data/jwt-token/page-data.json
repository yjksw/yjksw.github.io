{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/jwt-token/",
    "result": {"data":{"cur":{"id":"38ae2cc9-d468-5d33-af6e-18533bf42cae","html":"<h2 id=\"jwtjson-web-token-배경\" style=\"position:relative;\"><a href=\"#jwtjson-web-token-%EB%B0%B0%EA%B2%BD\" aria-label=\"jwtjson web token 배경 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JWT(JSON Web Token) 배경</h2>\n<p>이전에 인증 절차를 거치려면 사용자의 해싱값을 DB에 저장하고 매번 요청이 있을 때마다 해당 해싱값을 검증해야한다. 검증시 DB에 접근하는 쿼리가 실행되어야하는데 성능면에서 좋지 않다. 따라서 JWT가 등장하게 되고 위와 같은 절차를 거치지만 DB 접근 쿼리가 필요하지 않게 된다.</p>\n<ul>\n<li>\n<p><em>JWT 정의: A string that is sent in the HTTP request (from client or server) to validate the authenticity of the client. It is saved on the client-side only.</em></p>\n<p><a href=\"%5Bhttps://medium.com/jspoint/so-what-the-heck-is-jwt-or-json-web-token-dca8bcb719a6%5D(https://medium.com/jspoint/so-what-the-heck-is-jwt-or-json-web-token-dca8bcb719a6)\">출처</a></p>\n</li>\n</ul>\n<br>\n<h2 id=\"jwt-특징\" style=\"position:relative;\"><a href=\"#jwt-%ED%8A%B9%EC%A7%95\" aria-label=\"jwt 특징 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JWT 특징</h2>\n<ul>\n<li>compact</li>\n<li>self-contained</li>\n<li>digitally signed : it is signed using a secret key(<strong>HMAC</strong> algorithm) or public/private key pair using (<strong>RSA</strong> or <strong>ECDSA</strong>)\n<ul>\n<li>sgined 토큰 이라면 claim의 무결성(integrity)를 검증할 수 있다.</li>\n<li>만일 토큰이 public/private key로 signed 되었다면, 시그니처는 private key를 들고있는 쪽이 signed 한 것이라는 것을 보장한다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"jwt-언제-사용하면-좋을까\" style=\"position:relative;\"><a href=\"#jwt-%EC%96%B8%EC%A0%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%A9%B4-%EC%A2%8B%EC%9D%84%EA%B9%8C\" aria-label=\"jwt 언제 사용하면 좋을까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JWT 언제 사용하면 좋을까</h2>\n<ul>\n<li><strong>Authorization</strong>: 유저가 로그인하여 어떠한 요청들을 보낼 때, JWT를 통해서 인증을 한다. JWT가 사용되는 가장 대표적인 시나리오다. <code class=\"language-text\">Single Sign On</code> 이라고 하는데, 이 때 JWT를 사용하면 부하도 적고 여러 다른 도메인에서 쉽게 사용될 수 있다. (cross-origin일 때 용이)</li>\n<li><strong>Information Exchange</strong>: 정보들을 안전하게 전달하려고 할 때 JWT를 사용하기도 한다. JWT를 signed 할 수 있으니 송신자가 누군지 보장할 수 있다. 또한 시그니처를 통해서 header와 payload를 계산하기 때문에 해당 컨텐츠가 무결함을 보장할 수 있다.</li>\n</ul>\n<br>\n<h2 id=\"jwt-생성\" style=\"position:relative;\"><a href=\"#jwt-%EC%83%9D%EC%84%B1\" aria-label=\"jwt 생성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JWT 생성</h2>\n<p>secret key를 사용해서 JWT를 생성하며, 해당 secret key는 private하여 외부에 공개되거나 JWT 토큰에 주입될 경우가 없다. 또한 JWT를 클라이언트에게 받았을 때 서버에 저장되어 있는 secret key를 통해서 검증한다. <br></p>\n<p>JWT 생성하기 위해서 <a href=\"%5Bhttps://jwt.io/%5D(https://jwt.io/)\">여기</a> 에서 원하는 라이브러리를 다운 받아서 사용한다.</p>\n<br>\n<h2 id=\"jwt-구조\" style=\"position:relative;\"><a href=\"#jwt-%EA%B5%AC%EC%A1%B0\" aria-label=\"jwt 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JWT 구조</h2>\n<p><code class=\"language-text\">xxxx.yyyy.zzzz</code> 으로 header, payload, signature가 (<code class=\"language-text\">.</code>)로 연결되어 있다.</p>\n<ul>\n<li>Header\n<ul>\n<li>type of token (ex. JWT)</li>\n<li>signing algorithm</li>\n<li>JSON 타입, <code class=\"language-text\">Base64Url</code>로 인코딩</li>\n</ul>\n</li>\n<li>Payload\n<ul>\n<li>claims - entity(유저) 정보나 이외의 추가 정보 등등</li>\n<li>registered - 등록되어 있는 claims로 항상 추가하기를 권장하는 유용한 claims\n<ul>\n<li>iss(issuer), exp(expiration time), sub(subject), aud(audience) 등등</li>\n<li>JWT은 compact 하기 때문에 3글자로 제한하여 정의함</li>\n</ul>\n</li>\n<li>public -  JWT 사용하는 입장에서 정의할 수 있는 claims\n<ul>\n<li>충돌을 피하기 위해서 JWT Registry에 정의된 것들만 사용하거나, 충돌방지할 수 있는 URI 형태</li>\n</ul>\n</li>\n<li>private - 커스텀 claims로 양쪽에서 합의하여 공유하기로 한 정보에 대해서 서술한 claims</li>\n<li>JSON 타입, <code class=\"language-text\">Base64Url</code>로 인코딩, 때문에 어느 누구나 디코딩하여 접근할 수 있는 정보이기 때문에 민감한 정보는 담지 않도록 한다.</li>\n</ul>\n</li>\n<li>Signature\n<ul>\n<li>인코딩 된 header, payload, secrete을 조합하여 header에 있는 알고리즘으로 시그니처를 생성</li>\n<li>이 시그니처를 통해서 담긴 정보의 무결성을 보장</li>\n<li>private key로 signed 되었을 경우 JWT sender 또한 보장 가능</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"jwt-signature\" style=\"position:relative;\"><a href=\"#jwt-signature\" aria-label=\"jwt signature permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JWT Signature</h3>\n<p>위 header와 payload는 쉽게 디코딩해 내용을 확인할 수 있다. 따라서 해당 token을 보안에 사용할 수 있도록 하는 요소는 signature이다. <br></p>\n<p>제 3자가 토큰의 header나 payload를 변경하지 않았음을 보장하기 위해서 secret key와 해당 키로 생성된 signaturer를 사용한다. <br></p>\n<p>Token 검증을 할 때, 전송된 JWT에 있는 header, payload를 가지고 서버에 저장되어 있는 secret을 통해서 test signature를 생성한다. test signature와 token에 있는 처음 token 생성시 추가된 original signature와 동일한지 비교하여 데이터 변경 여부를 체크한다. 이 방법을 통해서 token은 데이터 무결성을 보장한다. <br></p>\n<br>\n<h2 id=\"왜-jwt\" style=\"position:relative;\"><a href=\"#%EC%99%9C-jwt\" aria-label=\"왜 jwt permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>왜 JWT?</h2>\n<p>Simple Web Tokens(<strong>SWT</strong>)와 Security Assertion Markup Language Tokens(<strong>SAML</strong>) 비교했을 때 장점들이다. <br></p>\n<p>JSON은 우선 XML보다 간단(덜 장황함)하여 인코딩 했을 때, 그 사이즈가 훨씬 작고 <strong>SAML</strong>보다 compact 하다. <br></p>\n<p align=\"center\"><img width=\"85%\" src=\"https://user-images.githubusercontent.com/63405904/135121193-926e8de5-411d-49dc-873c-09cfb0a552df.png\"></p>\n<p align=\"center\"><img width=\"85%\" src=\"https://user-images.githubusercontent.com/63405904/135121388-68caa14c-464b-449e-8901-70491a30b765.png\"></p>\n<p>보안적 측면에서는 <strong>SWT</strong>는 대칭키를 활용하는 HMAC 알고리즘만 사용이 가능한데, <strong>JWT</strong>, <strong>SAML</strong>은 public/private key 페어를 사용할 수 있다. 더해서 XML signing보다 JSON signing이 훨씬 쉽다. <br></p>\n<p>또한 잘 구축되어 있는 여러 JSON 파서들을 활용할 수 있다. <br></p>\n<p>마지막으로 활용 측면에서 <strong>JWT</strong>는 인터넷 환경에서 많이 쓰인다. 그렇기 때문에 클라이언트의 입장에서 <strong>JWT</strong>를 여러 환경(특히, 모바일 환경에서도)에서 활용하기 용이하다는 장점이 있다.  <br></p>\n<br>\n<br>\n<p><strong>[참고자료]</strong></p>\n<ul>\n<li><a href=\"https://jwt.io/introduction\">https://jwt.io/introduction</a></li>\n<li><a href=\"https://stackoverflow.com/questions/31309759/what-is-secret-key-for-jwt-based-authentication-and-how-to-generate-it\">https://stackoverflow.com/questions/31309759/what-is-secret-key-for-jwt-based-authentication-and-how-to-generate-it</a></li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#jwtjson-web-token-%EB%B0%B0%EA%B2%BD\">JWT(JSON Web Token) 배경</a></p>\n</li>\n<li>\n<p><a href=\"#jwt-%ED%8A%B9%EC%A7%95\">JWT 특징</a></p>\n</li>\n<li>\n<p><a href=\"#jwt-%EC%96%B8%EC%A0%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%A9%B4-%EC%A2%8B%EC%9D%84%EA%B9%8C\">JWT 언제 사용하면 좋을까</a></p>\n</li>\n<li>\n<p><a href=\"#jwt-%EC%83%9D%EC%84%B1\">JWT 생성</a></p>\n</li>\n<li>\n<p><a href=\"#jwt-%EA%B5%AC%EC%A1%B0\">JWT 구조</a></p>\n<ul>\n<li><a href=\"#jwt-signature\">JWT Signature</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%99%9C-jwt\">왜 JWT?</a></p>\n</li>\n</ul>\n</div>","excerpt":"JWT(JSON Web Token) 배경 이전에 인증 절차를 거치려면 사용자의 해싱값을 DB에 저장하고 매번 요청이 있을 때마다 해당 해싱값을 검증해야한다. 검증시 DB에 접근하는 쿼리가 실행되어야하는데 성능면에서 좋지 않다. 따라서 JWT가 등장하게 되고 위와 같은 절차를 거치지만 DB 접근 쿼리가 필요하지 않게 된다. JWT 정의: A string that is sent in the HTTP request (from client or server) to validate the authenticity of the client. It is saved on the client-side only. 출처 JWT 특징 compact self-contained digitally signed : it is signed using a secret key(HMAC algorithm) or public/private key pair using (RSA or ECDSA) sgined 토큰 이라면 c…","frontmatter":{"date":"June 13, 2021","title":"JWT (JSON Web Token) 알아보기","categories":"웹","author":"코다","emoji":"🖥"},"fields":{"slug":"/jwt-token/"}},"next":{"id":"8bf91ec6-90fe-5ce0-86c1-d8e98765968f","html":"<p>간단한 JavaBean 규약에 대해서 알고 넘어가기</p>\n<h2 id=\"javabean\" style=\"position:relative;\"><a href=\"#javabean\" aria-label=\"javabean permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JavaBean</h2>\n<p>자바빈 규약을 따르는 Java Class를 말한다.</p>\n<h2 id=\"javabean-규약\" style=\"position:relative;\"><a href=\"#javabean-%EA%B7%9C%EC%95%BD\" aria-label=\"javabean 규약 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JavaBean 규약</h2>\n<ol>\n<li>defulat 패키지가 아닌 패키지 하위에 있는 클래스</li>\n<li>기본 생성자가 존재 (no-arg constructor)</li>\n<li>Property는 모두 private으로 선언</li>\n<li>Getter/setter를 통해서 properties를 조작</li>\n<li><code class=\"language-text\">Serializable</code>을 implement 하여 직렬화 가능</li>\n</ol>\n<h2 id=\"번외--serialization--deserialization\" style=\"position:relative;\"><a href=\"#%EB%B2%88%EC%99%B8--serialization--deserialization\" aria-label=\"번외  serialization  deserialization permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>번외 : Serialization &#x26; Deserialization</h2>\n<ul>\n<li>Serialization : converting state of an object into a byte stream</li>\n<li>Deserialization: reverse process of serialization</li>\n</ul>\n<p>해당 객체에 영속성을 부여하기 위해서 사용되는 매커니즘이다. <br></p>\n<p>Java 객체를 serialize 하게 하기 위해서는 <code class=\"language-text\">java.io.Serializable</code> 인터페이스를 구현하도록 한다. 해당 인터페이스는 멤버변수나 메소드가 존재하지 않는 marker interface(Cloneable이나 Remote와 같은) 이다. <br></p>\n<p>Serializable하면 1) 해당 객체 그대로에 영속성을 부여할 수 있으며 2) 네트워크 상에서 byte stream으로 전송이 가능하다. <br></p>\n<p><strong>Serialization 특징</strong></p>\n<ul>\n<li>\n<p>부모 클래스가 Serializable interface를 구현하면 자식 클래스는 자동으로 Serializable 하다.</p>\n</li>\n<li>\n<p>non-static 멤버 변수만 Serialization 으로 저장될 수 있다. (static 과 transient 데이터는 불가)</p>\n</li>\n<li>\n<p>비밀번호 등의 보안으로 인해 어떠한 멤버 변수가 serialize 되어 저장되지 않기를 원한다면 해당 데이터를 trasient 데이터로 지정하도록 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Member</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Serializable</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">transient</span> <span class=\"token class-name\">String</span> password<span class=\"token punctuation\">;</span>\n\t<span class=\"token class-name\">String</span> name<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n<li>\n<p>해당 객체가 deserialized 될 때 해당 객체의 생성자는 호출되지 않는다.</p>\n</li>\n<li>\n<p>Serializable 한 객체와 연관되어 있는 객체 또한 Serializable 인터페이스를 반드시 구현해야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">ObjectA</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Serializable</span> <span class=\"token punctuation\">{</span>\t\n\t<span class=\"token comment\">//ObjectB는 반드시 Serializable을 구현해야 함\t</span>\n\t<span class=\"token class-name\">ObjectB</span> oj <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ObjectB</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n</ul>\n<p><strong>SerialVersionUID</strong></p>\n<p>Serialization을 진행하면서 각 Serializable class는 <code class=\"language-text\">SerialVersionUID</code> 라는 id를 할당받는다. 해당 id를 통해서 직렬화된 객체의 sender와 receiver를 판별하는데, sender와 reciever는 동일해야한다. 만일 동일하지 않다면 <code class=\"language-text\">InvalidClassException</code>이 deserialize 할 때 발생한다.</p>\n<br>\n<br>\n<p><strong>[참고자료]</strong></p>\n<ul>\n<li><a href=\"https://dololak.tistory.com/133\">https://dololak.tistory.com/133</a></li>\n<li><a href=\"https://www.geeksforgeeks.org/javabean-class-java/#:~:text=JavaBeans%20are%20classes%20that%20encapsulate,public%20getters%20and%20setter%20methods\">https://www.geeksforgeeks.org/javabean-class-java/#:~:text=JavaBeans are classes that encapsulate,public getters and setter methods</a>.</li>\n<li><a href=\"https://www.geeksforgeeks.org/serialization-in-java/\">https://www.geeksforgeeks.org/serialization-in-java/</a></li>\n<li><a href=\"https://www.javatpoint.com/serialization-in-java#:~:text=Serialization%20in%20Java%20is%20a,is%20converted%20into%20an%20object\">https://www.javatpoint.com/serialization-in-java#:~:text=Serialization in Java is a,is converted into an object</a>.</li>\n</ul>\n<p><strong>[MORE]</strong></p>\n<ul>\n<li>non-static 만 serialization 가능한 이유</li>\n<li>SerialVersionUID</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#javabean\">JavaBean</a></li>\n<li><a href=\"#javabean-%EA%B7%9C%EC%95%BD\">JavaBean 규약</a></li>\n<li><a href=\"#%EB%B2%88%EC%99%B8--serialization--deserialization\">번외 : Serialization &#x26; Deserialization</a></li>\n</ul>\n</div>","frontmatter":{"date":"June 08, 2021","title":"자바빈 규약 (번외: Serialization)","categories":"자바","author":"코다","emoji":"✊"},"fields":{"slug":"/java-bean/"}},"prev":{"id":"aa4dffec-9907-5cba-91ed-6988835a5453","html":"<ul>\n<li><code class=\"language-text\">@ControllerAdvice</code>를 통해서 어플리케이션 전역적으로 exception을 핸들링 할 수 있다. 다르게 표현하면 <code class=\"language-text\">@RequestMapping</code> 메서드에서 던져지는 exceptions들의 interceptor라고 할 수 있다. (shared across multiple @Controller classes)</li>\n<li>주로 <code class=\"language-text\">@ControllerAdvice</code>에서 전역적으로 처리하고 싶은 어노테이션은 <code class=\"language-text\">@ExceptionHandler</code>, <code class=\"language-text\">@InitBinder</code>, <code class=\"language-text\">@ModelAttribute</code> 등이 있다.</li>\n<li><code class=\"language-text\">ResponseEntityExceptionHandler</code> 클래스가 <code class=\"language-text\">@ControllerAdvice</code> 어노테이션에서 전역적인 exception handling 을 구현할 수 있도록 하는 base class이다. 해당 클래스에서 Spring MVC 내부에서 발생한 예외들을 처리할 수 있는 메서드들을 제공한다. (<code class=\"language-text\">DefaultHandlerExceptionResolver</code>는 <code class=\"language-text\">ModelAndView</code>를 반환하는 반면 <code class=\"language-text\">ResponseEntityExceptionHandler</code>는 <code class=\"language-text\">ResponseEntity</code>를 반환한다)</li>\n</ul>\n<h2 id=\"여러-controlleradvice-간의-우선순위\" style=\"position:relative;\"><a href=\"#%EC%97%AC%EB%9F%AC-controlleradvice-%EA%B0%84%EC%9D%98-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84\" aria-label=\"여러 controlleradvice 간의 우선순위 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>여러 @ControllerAdvice 간의 우선순위</h2>\n<p>@ControllerAdvice 클래스들은 Bean으로 등록이 되도록 하는데, 해당 빈들은 <code class=\"language-text\">Ordered</code> 인터페이스를 구현하여 orderable 한 속성을 부여하거나, <code class=\"language-text\">@Order</code>/ <code class=\"language-text\">@Priority</code>를 사용해서 우선순위를 부여할 수 있다. (여기서 <code class=\"language-text\">Ordered</code> semantic이 <code class=\"language-text\">@Order</code>/ <code class=\"language-text\">@Priority</code> 에 우선순위를 가진다)</p>\n<ul>\n<li>\n<p>예외를 처리하는 경우</p>\n<p>매칭이 되는 exception handler method가 있는 가장 처음 매칭되는 advice의 <code class=\"language-text\">@ExceptionHandler</code>가 실행된다.</p>\n</li>\n<li>\n<p>model attribute와 data binding 초기화 경우</p>\n<p><code class=\"language-text\">@ModelAttribute</code>와 <code class=\"language-text\">@InitBinder</code> 메소드가 <code class=\"language-text\">ControllerAdvice</code>의 우선순위 순서에 따라서 실행된다.</p>\n</li>\n<li>\n<p><code class=\"language-text\">@ControlerAdvice</code>의 우선순위에 따른 ExceptionHandler 선언 팁</p>\n<p align=\"center\"><img width=\"85%\" src=\"https://user-images.githubusercontent.com/63405904/135494123-1441631a-7277-4b6f-b82e-30610bcf4b5e.png\"></p>\n</li>\n</ul>\n<p>기본적으로 <code class=\"language-text\">@ControllerAdvice</code>는 모든 controller에 전역적으로 적용이 되기 때문에, 더 구체적인 controller에 적용하기 위해서는 selectors를 사용해야한다. (<code class=\"language-text\">annotations()</code> , <code class=\"language-text\">basePackageClasses()</code> , <code class=\"language-text\">basePackages()</code>)만일 여러 selectors가 있으면 OR 로 적용이되면 이 selectors 체크는 runtime에 실행이 되므로, 만일 너무 많은 selectors를 사용하면 런타임 퍼포먼스 효율이 떨어지게 된다.</p>\n<br>\n<br>\n<p><strong>[참고자료]</strong></p>\n<ul>\n<li><a href=\"https://zetcode.com/springboot/controlleradvice/\">https://zetcode.com/springboot/controlleradvice/</a></li>\n<li><a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/bind/annotation/ControllerAdvice.html\">https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/bind/annotation/ControllerAdvice.html</a></li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#%EC%97%AC%EB%9F%AC-controlleradvice-%EA%B0%84%EC%9D%98-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84\">여러 @ControllerAdvice 간의 우선순위</a></li>\n</ul>\n</div>","frontmatter":{"date":"June 19, 2021","title":"@ControllerAdvice 알아보기","categories":"스프링부트","author":"코다","emoji":"🖥"},"fields":{"slug":"/springboot-controller-advice/"}},"site":{"siteMetadata":{"siteUrl":"https://yjksw.github.io","comments":{"utterances":{"repo":"yjksw/yjksw.github.io"}}}}},"pageContext":{"slug":"/jwt-token/","nextSlug":"/java-bean/","prevSlug":"/springboot-controller-advice/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}
{"componentChunkName":"component---src-templates-blog-template-js","path":"/one-percent-network-1/","result":{"data":{"cur":{"id":"0b8de3f2-07af-5ce2-8ced-e55579a73288","html":"<blockquote>\n<p>다음은 <em>성공과 실패를 결정하는 1%의 네트워크 원리</em> 를 읽고 정리한 내용입니다. 본 글은 CH1. 웹 브라우저가 메시지를 만든다 입니다 🙌</p>\n</blockquote>\n<br>\n<h2 id=\"-개요\" style=\"position:relative;\"><a href=\"#-%EA%B0%9C%EC%9A%94\" aria-label=\" 개요 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>💡 개요</h2>\n<ol>\n<li>\n<p>HTTP 리퀘스트 메세지를 작성한다. </p>\n<ul>\n<li>URL을 해독하는 곳에서 브라우저의 동작이 시작된다.</li>\n<li>이 URL의 의미에 따라서 요청 메세지를 작성하고 요청 내용을 만든다.</li>\n<li>이때 HTTP 라는 프로토콜이 사용된다.</li>\n</ul>\n</li>\n<li>\n<p>웹 서버의 IP 주소를 DNS 서버에 조회</p>\n<ul>\n<li>OS에 의뢰해서 요청 메세지를 송신할 때 송신대상의 IP주소를 알아야한다.</li>\n<li>URL의 웹 도메인명으로 DNS 서버를 조회해서 IP 주소를 조사한다.</li>\n</ul>\n</li>\n<li>\n<p>전세계 DNS 서버 연대 </p>\n<ul>\n<li>다수의 DNS 서버가 연대하여 IP 주소를 조사한다.</li>\n</ul>\n</li>\n<li>\n<p>프로토콜 스택에 메시지 송신을 의뢰 </p>\n<ul>\n<li>OS에 메세지를 송신하는 동작을 의뢰한다.</li>\n<li>OS에서 제공하는 규칙에 따라서 의뢰를 해야한다.</li>\n<li>해당 프로그램을 직접 구현하는 것이 아니더라도 규칙의 큰 흐름을 알는 것이 중요하다.</li>\n</ul>\n</li>\n</ol>\n<br>\n<h2 id=\"🛺-story1-http-리퀘스트-메세지를-작성한다\" style=\"position:relative;\"><a href=\"#%F0%9F%9B%BA-story1-http-%EB%A6%AC%ED%80%98%EC%8A%A4%ED%8A%B8-%EB%A9%94%EC%84%B8%EC%A7%80%EB%A5%BC-%EC%9E%91%EC%84%B1%ED%95%9C%EB%8B%A4\" aria-label=\"🛺 story1 http 리퀘스트 메세지를 작성한다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🛺 [STORY1] HTTP 리퀘스트 메세지를 작성한다</h2>\n<h3 id=\"url-입력\" style=\"position:relative;\"><a href=\"#url-%EC%9E%85%EB%A0%A5\" aria-label=\"url 입력 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>URL 입력</h3>\n<ul>\n<li>\n<p>URL은 우리가 알고 있는 http 뿐 아니라 ftp, file, 등등 여러가지가 존재한다.</p>\n<ul>\n<li>\n<p>브라우저에 여러 프로토콜 존재한다</p>\n<ul>\n<li>브라우저는 여러 클라이언트 기능을 가지고 있는 복합적인 소프트웨어이기 때문</li>\n</ul>\n</li>\n<li>브라우저에서 http 요청 뿐 아니라 파일 다운로드/업로드 등의 기능도 있다.</li>\n<li>어느 기능을 사용하는지 url 에 명시된 프로토콜로 판단할 수 있다.</li>\n</ul>\n</li>\n<li>\n<p>URL에 엑세스 대상에 따라서 여러 정보를 담는다.</p>\n<ul>\n<li>웹 서버 요청일 경우 파일 경로, 포트 번호 등을 담아서 보낼 수 있다.</li>\n<li>모든 URL에는 앞에 엑세스 대상에 따라서 다른 프로토콜을 명시하고 있다. (http, ftp 등등)</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"브라우저의-url-해독\" style=\"position:relative;\"><a href=\"#%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EC%9D%98-url-%ED%95%B4%EB%8F%85\" aria-label=\"브라우저의 url 해독 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>브라우저의 URL 해독</h3>\n<p>우선 웹 서버에 엑세스 하는 경우를 기반으로 설명한다. </p>\n<ul>\n<li>URL에 파일 경로가 포함되어 있을 수 있다 → / 를 기준으로 디렉토리 구조와 파일명을 명시하여 url에 포함한다.</li>\n<li>\n<p>마지막에 파일명을 명시하지 않는 경우</p>\n<ul>\n<li>기본 파일명을 서버측에 설정하여 생략된 경우 사용한다. (index.html, default.htm 등등)</li>\n</ul>\n</li>\n<li>\n<p>마지막에 디렉토리를 생략한 경우</p>\n<ul>\n<li>루트 디렉토리의 기본 파일을 읽는 것으로 간주한다.</li>\n</ul>\n</li>\n<li>\n<p>마지막에 경로에 /가 생략된 경우 (ex. <a href=\"http://www.web.com/path\">http://www.web.com/path</a>)</p>\n<ul>\n<li>이 경우 마지막 값이 파일명인지 디렉토리인지 알 수 없다.</li>\n<li>다음과 같은 경우 우선 매칭되는 <strong>파일명</strong>이 있는지 확인하고, 없다면 매칭되는 <strong>디렉토리명</strong>이 있는지 확인한다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"http기본-개념\" style=\"position:relative;\"><a href=\"#http%EA%B8%B0%EB%B3%B8-%EA%B0%9C%EB%85%90\" aria-label=\"http기본 개념 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>HTTP기본 개념</h3>\n<ul>\n<li>URL 해독 후 액세스 해야하는 위치가 판단된다. 그때부터 명시된 프로토콜 (이 경우에는 HTTP)에 따라서 액세스를 진행한다.</li>\n<li>\n<p>HTTP 프로토콜의 요청 메세지가 담고 있는 내용</p>\n<ol>\n<li>무엇을 - URI 데이터를 저장한 경로만 쓰거나 URL을 그대로 쓸 수도 있다. </li>\n<li>어떻게 - 메소드 (GET, POST, PUT 등등) </li>\n</ol>\n</li>\n<li>\n<p>응답 메세지가 담고 있는 내용</p>\n<ol>\n<li>결과 데이터</li>\n<li>status code - 실행 결과의 상태에 대한 정보 </li>\n</ol>\n</li>\n<li>PUT 이나 DELETE를 사용하면 파일 서버 대신 웹 서버를 사용할 수도 있긴 하다. (???) p. 45</li>\n</ul>\n<h3 id=\"http-리쿼스트-메세지를-만든다\" style=\"position:relative;\"><a href=\"#http-%EB%A6%AC%EC%BF%BC%EC%8A%A4%ED%8A%B8-%EB%A9%94%EC%84%B8%EC%A7%80%EB%A5%BC-%EB%A7%8C%EB%93%A0%EB%8B%A4\" aria-label=\"http 리쿼스트 메세지를 만든다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>HTTP 리쿼스트 메세지를 만든다</h3>\n<ul>\n<li>우선 URL을 판단하여 웹 서버와 파일 경로 및 파일명을 해석한 후에 HTTP 요청 메세지를 만든다.</li>\n<li>\n<p>첫번째 행 - Request Line</p>\n<ul>\n<li>메소드 - 여러 종류의 메소드 중 웹 서버에 어떻게 전달할지 메소드에 담아서 판단한다.</li>\n<li>URI - 파일이나 경로명</li>\n<li>HTTP 버전</li>\n</ul>\n</li>\n<li>\n<p>두번째 부터 - Headers</p>\n<ul>\n<li>부가적인 자세한 정보를 헤더에 추가한다.</li>\n<li>날짜, 데이터 종류, 언어, 압축 형식 등등</li>\n</ul>\n</li>\n<li>\n<p>공백 라인 이후 - Request Body</p>\n<ul>\n<li>송신할 데이터를 메세지 본문에 기재한다.</li>\n<li>주로 POST 요청인 경우 바디에 데이터를 담아서 요청한다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"리퀘스트-메세지를-보낸-이후-응답이-돌아온다\" style=\"position:relative;\"><a href=\"#%EB%A6%AC%ED%80%98%EC%8A%A4%ED%8A%B8-%EB%A9%94%EC%84%B8%EC%A7%80%EB%A5%BC-%EB%B3%B4%EB%82%B8-%EC%9D%B4%ED%9B%84-%EC%9D%91%EB%8B%B5%EC%9D%B4-%EB%8F%8C%EC%95%84%EC%98%A8%EB%8B%A4\" aria-label=\"리퀘스트 메세지를 보낸 이후 응답이 돌아온다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>리퀘스트 메세지를 보낸 이후 응답이 돌아온다.</h3>\n<ul>\n<li>기본적으로 첫번째 행을 제외하고 요청 메세지와 비슷한 형태를 지닌다.</li>\n<li>\n<p>첫번째 행 -</p>\n<ul>\n<li>요청 실행 결과 status code</li>\n<li>status 코드의 응답 문구 (Not Found)</li>\n</ul>\n</li>\n<li>응답이 오면 메세지를 추출해서 화면에 표시한다.</li>\n<li>\n<p>문장만 이루어진 응답 데이터가 아닌 경우</p>\n<ul>\n<li>\n<p>추가적으로 이미지나 영상을 담고 있는 경우 응답 문장에 tag를 추가하여 명시한다.</p>\n<ul>\n<li>ex. <code class=\"language-text\">&lt;img src=\"{이미지경로}\" /></code></li>\n</ul>\n</li>\n<li>\n<p>tag가 존재한다면</p>\n<ul>\n<li>우선 공백으로 비워둔다.</li>\n<li>이후 추가 웹 서버 액세스하여 태그에 쓰여있는 경로로 URI를 만들어서 요청 메세지를 보낸다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>하나의 요청 메세지에는 하나의 URI 만 쓰기 때문에 여러 파일이 필요하면 매번 요청을 보내야 한다.</li>\n</ul>\n<br>\n<h2 id=\"🛺-story2-웹-서버의-ip주소를-dns-서버에-조회한다\" style=\"position:relative;\"><a href=\"#%F0%9F%9B%BA-story2-%EC%9B%B9-%EC%84%9C%EB%B2%84%EC%9D%98-ip%EC%A3%BC%EC%86%8C%EB%A5%BC-dns-%EC%84%9C%EB%B2%84%EC%97%90-%EC%A1%B0%ED%9A%8C%ED%95%9C%EB%8B%A4\" aria-label=\"🛺 story2 웹 서버의 ip주소를 dns 서버에 조회한다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🛺 [STORY2] 웹 서버의 IP주소를 DNS 서버에 조회한다.</h2>\n<h3 id=\"ip-주소의-기본\" style=\"position:relative;\"><a href=\"#ip-%EC%A3%BC%EC%86%8C%EC%9D%98-%EA%B8%B0%EB%B3%B8\" aria-label=\"ip 주소의 기본 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>IP 주소의 기본</h3>\n<ul>\n<li>브라우저가 담당하는 일 → URL 해독, HTTP 메세지 만들기</li>\n<li>\n<p>OS가 담당하는 일 → 메세지를 네트워크로 송출</p>\n<ul>\n<li>따라서 브라우저가 위 업무는 OS에 위임하여 메세지를 송신한다.</li>\n</ul>\n</li>\n<li>이때 URL에서 해석한 도메인명의 IP 주소를 조사해야 한다.</li>\n</ul>\n<h4 id=\"tcpip-기본-개념\" style=\"position:relative;\"><a href=\"#tcpip-%EA%B8%B0%EB%B3%B8-%EA%B0%9C%EB%85%90\" aria-label=\"tcpip 기본 개념 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TCP/IP 기본 개념</h4>\n<ul>\n<li>서브넷 - 여러 PC가 하나의 허브에 연결되어 있는 단위</li>\n<li>\n<p><strong>여러 서브넷을 라우터로 연결하여 네트워크 전체를 구성한다.</strong></p>\n<p align=\"center\"><img width=\"85%\" src=\"https://user-images.githubusercontent.com/63405904/141642594-d563a745-1eb7-4378-8b1e-2d94c45a4545.png\"></p>\n</li>\n<li>\n<p>네트워크 주소를 00동 00번지의 단위로 표현할 수 있다.</p>\n<ul>\n<li>00동 → 서브넷에 할당된 네트워크 번호</li>\n<li>00번지 → 호스트 번호</li>\n</ul>\n</li>\n<li><strong>네트워크 번호 + 호스트 번호</strong>가 IP 주소를 구성한다.</li>\n<li>라우터와 허브를 통해서 <strong>네트워크 주소를 계속 중계</strong>하면서 액세스 대상을 찾아간다.</li>\n<li>\n<p><strong>기본적인 흐름</strong></p>\n<ul>\n<li>송신측이 메세지를 보냄 → 가까운 허브가 운반하여 가까운 라우터에 송신 → 라우터에서 다음 라우터를 판단 → 서브넷의 허브가 해당 라우터까지 메세지를 송신함 → 반복하여 최종 도착지에 데이터가 도착</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"ip의-구조\" style=\"position:relative;\"><a href=\"#ip%EC%9D%98-%EA%B5%AC%EC%A1%B0\" aria-label=\"ip의 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>IP의 구조</h4>\n<ul>\n<li>32비트 디지털 데이터</li>\n<li>8비트씩 . 으로 구분하여 10진수로 표기 - 255.255.255.255</li>\n<li>네트워크 번호(서브넷 번호)와 호스트 번호를 판단하기 위해 넷마스크 정보를 IP에 더한다.</li>\n<li>\n<p>넷마스크 번호도 동일하게 32비트 디지털 데이터이다.</p>\n<ul>\n<li>1로 표기된 비트까지가 네트워크 번호</li>\n<li>0으로 표기된 비트를 호스트 번호로 판단한다.</li>\n<li>바이트 단위로 반드시 맞아 떨어지지는 않는다.</li>\n</ul>\n</li>\n<li>호스트 번호가 모두 0인 경우 - 서브넷 자체를 나타냄</li>\n<li>호스트 번호가 모두 1인 경우 - 서브넷 기기 전체에 대한 브로드캐스트를 나타냄</li>\n</ul>\n<h3 id=\"도메인명과-ip-주소를-구분하는-이유\" style=\"position:relative;\"><a href=\"#%EB%8F%84%EB%A9%94%EC%9D%B8%EB%AA%85%EA%B3%BC-ip-%EC%A3%BC%EC%86%8C%EB%A5%BC-%EA%B5%AC%EB%B6%84%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0\" aria-label=\"도메인명과 ip 주소를 구분하는 이유 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>도메인명과 IP 주소를 구분하는 이유</h3>\n<ul>\n<li>반드시 IP 주소가 있어야지 수신 상대와 연결될 수 있는데 번호로 구성된 IP를 기억하기는 어렵기 때문에 도메인명을 쓰도록 한다.</li>\n<li>\n<p>도메인명 만으로 네트워크 통신을 하게 된다면 주소에 대한 바이트가 균일하지 않고 지나치게 클 수 있다.</p>\n<ul>\n<li>데이터 운반 동작에 더 많은 시간이 걸려 속도가 느려진다.</li>\n</ul>\n</li>\n<li>따라서 사용자는 도메인명만 기억하면 해당 IP 주소를 알아서 찾아주는 <strong>DNS</strong>를 사용한다.</li>\n</ul>\n<h3 id=\"socket-라이브러리가-ip-주소-찾는-기능을-제공\" style=\"position:relative;\"><a href=\"#socket-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC%EA%B0%80-ip-%EC%A3%BC%EC%86%8C-%EC%B0%BE%EB%8A%94-%EA%B8%B0%EB%8A%A5%EC%9D%84-%EC%A0%9C%EA%B3%B5\" aria-label=\"socket 라이브러리가 ip 주소 찾는 기능을 제공 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Socket 라이브러리가 IP 주소 찾는 기능을 제공</h3>\n<ul>\n<li>DNS 동일하게 요청 메세지 + 응답 메세지의 구조로 데이터를 찾아내는 것이다.</li>\n<li>DNS 서버에 요청 메세지를 보내어 도메인명을 의뢰하는 DNS 클라이언트는 <strong>DNS 리졸버</strong>이다.</li>\n<li>DNS resolution → DNS 원리로 IP 주소를 조사하는 것 (DNS 리졸버가 수행함)</li>\n<li>\n<p><strong>DBS 리졸버는 Socket 라이브러리에 내장된 프로그램이다.</strong></p>\n<ul>\n<li>Socket 라이브러리에는 네트워크 기능과 관련된 프로그램이 집합해 있다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"리졸버를-이용하여-dns-서버를-조회한다\" style=\"position:relative;\"><a href=\"#%EB%A6%AC%EC%A1%B8%EB%B2%84%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-dns-%EC%84%9C%EB%B2%84%EB%A5%BC-%EC%A1%B0%ED%9A%8C%ED%95%9C%EB%8B%A4\" aria-label=\"리졸버를 이용하여 dns 서버를 조회한다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>리졸버를 이용하여 DNS 서버를 조회한다</h3>\n<ul>\n<li>Socket 라이브러리에 리졸버 메소드에 의뢰하고자 하는 도메인 명을 명시하면 IP 주소를 조회할 수 있다.</li>\n</ul>\n<h3 id=\"리졸버-내부의-작동\" style=\"position:relative;\"><a href=\"#%EB%A6%AC%EC%A1%B8%EB%B2%84-%EB%82%B4%EB%B6%80%EC%9D%98-%EC%9E%91%EB%8F%99\" aria-label=\"리졸버 내부의 작동 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>리졸버 내부의 작동</h3>\n<ul>\n<li>어플리케이션(브라우저)에서 리졸버를 호출하면서 어플리케이션은 잠시 대기한다. (리졸버로 제어가 넘어가 실행된다. 이때부터 실행주체는 Socket 라이브러리의 리졸버이다)</li>\n<li>DNS 서버에 응답 메세지를 만들어 보낸다.</li>\n<li><strong>메세지 송신 동작은 OS의 프로토콜 스택이 수행한다. LAN 어댑터를 경유하여 목표서버에 메세지가 전달된다.</strong></li>\n<li>DNS 서버가 해당 메세지를 해석하여 결과를 찾는다.</li>\n<li>응답이 오면 <code class=\"language-text\">프로토콜 스택 → 리졸버가 내용을 해독하여 IP 주소 추출 → 어플리케이션에 주소전달</code> 하는 단계를 밟는다.</li>\n<li>\n<p>DNS 서버 주소 정보는 ?</p>\n<ul>\n<li>TCP/IP 설정 항목으로 컴퓨터에 미리 설정되어 있다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<br>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[용어]\n\nURL - Uniform Resource Locater\n\nFTP - File Transfer Protocol\n\nURI - Unifor Resource Identifier\n\nCGI 프로그램 - 웹 서버 소프트웨어에서 프로그램을 호출할 때 정한 규칙(CGI)에 따라 움직이는 프로그램  \n\n라우터 - 패킷을 중계하는 장치 \n\n허브 - 패킷을 중계하는 장치 (리피터 허브 &amp; 스위칭 허브) \n\nDNS - Domain Name System 서버명과 IP주소를 대응, 메일 주소와 메일 서버를 대응 등등 \n\n프로토콜 스택 - OS 에 내장되어 있는 네트워크 제어 소프트웨어</code></pre></div>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#-%EA%B0%9C%EC%9A%94\">💡 개요</a></li>\n<li>\n<p><a href=\"#%F0%9F%9B%BA-story1-http-%EB%A6%AC%ED%80%98%EC%8A%A4%ED%8A%B8-%EB%A9%94%EC%84%B8%EC%A7%80%EB%A5%BC-%EC%9E%91%EC%84%B1%ED%95%9C%EB%8B%A4\">🛺 STORY1 HTTP 리퀘스트 메세지를 작성한다</a></p>\n<ul>\n<li><a href=\"#url-%EC%9E%85%EB%A0%A5\">URL 입력</a></li>\n<li><a href=\"#%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EC%9D%98-url-%ED%95%B4%EB%8F%85\">브라우저의 URL 해독</a></li>\n<li><a href=\"#http%EA%B8%B0%EB%B3%B8-%EA%B0%9C%EB%85%90\">HTTP기본 개념</a></li>\n<li><a href=\"#http-%EB%A6%AC%EC%BF%BC%EC%8A%A4%ED%8A%B8-%EB%A9%94%EC%84%B8%EC%A7%80%EB%A5%BC-%EB%A7%8C%EB%93%A0%EB%8B%A4\">HTTP 리쿼스트 메세지를 만든다</a></li>\n<li><a href=\"#%EB%A6%AC%ED%80%98%EC%8A%A4%ED%8A%B8-%EB%A9%94%EC%84%B8%EC%A7%80%EB%A5%BC-%EB%B3%B4%EB%82%B8-%EC%9D%B4%ED%9B%84-%EC%9D%91%EB%8B%B5%EC%9D%B4-%EB%8F%8C%EC%95%84%EC%98%A8%EB%8B%A4\">리퀘스트 메세지를 보낸 이후 응답이 돌아온다.</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%F0%9F%9B%BA-story2-%EC%9B%B9-%EC%84%9C%EB%B2%84%EC%9D%98-ip%EC%A3%BC%EC%86%8C%EB%A5%BC-dns-%EC%84%9C%EB%B2%84%EC%97%90-%EC%A1%B0%ED%9A%8C%ED%95%9C%EB%8B%A4\">🛺 STORY2 웹 서버의 IP주소를 DNS 서버에 조회한다.</a></p>\n<ul>\n<li>\n<p><a href=\"#ip-%EC%A3%BC%EC%86%8C%EC%9D%98-%EA%B8%B0%EB%B3%B8\">IP 주소의 기본</a></p>\n<ul>\n<li><a href=\"#tcpip-%EA%B8%B0%EB%B3%B8-%EA%B0%9C%EB%85%90\">TCP/IP 기본 개념</a></li>\n<li><a href=\"#ip%EC%9D%98-%EA%B5%AC%EC%A1%B0\">IP의 구조</a></li>\n</ul>\n</li>\n<li><a href=\"#%EB%8F%84%EB%A9%94%EC%9D%B8%EB%AA%85%EA%B3%BC-ip-%EC%A3%BC%EC%86%8C%EB%A5%BC-%EA%B5%AC%EB%B6%84%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0\">도메인명과 IP 주소를 구분하는 이유</a></li>\n<li><a href=\"#socket-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC%EA%B0%80-ip-%EC%A3%BC%EC%86%8C-%EC%B0%BE%EB%8A%94-%EA%B8%B0%EB%8A%A5%EC%9D%84-%EC%A0%9C%EA%B3%B5\">Socket 라이브러리가 IP 주소 찾는 기능을 제공</a></li>\n<li><a href=\"#%EB%A6%AC%EC%A1%B8%EB%B2%84%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-dns-%EC%84%9C%EB%B2%84%EB%A5%BC-%EC%A1%B0%ED%9A%8C%ED%95%9C%EB%8B%A4\">리졸버를 이용하여 DNS 서버를 조회한다</a></li>\n<li><a href=\"#%EB%A6%AC%EC%A1%B8%EB%B2%84-%EB%82%B4%EB%B6%80%EC%9D%98-%EC%9E%91%EB%8F%99\">리졸버 내부의 작동</a></li>\n</ul>\n</li>\n</ul>\n</div>","excerpt":"다음은 성공과 실패를 결정하는 1%의 네트워크 원리 를 읽고 정리한 내용입니다. 본 글은 CH1. 웹 브라우저가 메시지를 만든다 입니다 🙌 💡 개요 HTTP 리퀘스트 메세지를 작성한다.  URL을 해독하는 곳에서 브라우저의 동작이 시작된다. 이 URL의 의미에 따라서 요청 메세지를 작성하고 요청 내용을 만든다. 이때 HTTP 라는 프로토콜이 사용된다. 웹 서버의 IP 주소를 DNS 서버에 조회 OS에 의뢰해서 요청 메세지를 송신할 때 송신대상의 IP주소를 알아야한다. URL의 웹 도메인명으로 DNS 서버를 조회해서 IP 주소를 조사한다. 전세계 DNS 서버 연대  다수의 DNS 서버가 연대하여 IP 주소를 조사한다. 프로토콜 스택에 메시지 송신을 의뢰  OS에 메세지를 송신하는 동작을 의뢰한다. OS에서 제공하는 규칙에 따라서 의뢰를 해야한다. 해당 프로그램을 직접 구현하는 것이 아니더라도 규칙의 큰 흐름을 알는 것이 중요하다. 🛺 STORY1 HTTP 리퀘스트 메세지를 작성한다 …","frontmatter":{"date":"September 24, 2021","title":"성공과 실패를 결정하는 1%의 네트워크 원리_1","categories":"네트워크 책","author":"코다","emoji":"⚡️"},"fields":{"slug":"/one-percent-network-1/"}},"next":{"id":"fe08b31d-d1b9-5132-8265-561e8d82be9a","html":"<blockquote>\n<p>다음은 웹 개발자를 위한 대규모 서비스를 지탱하는 기술을 읽고 정리한 내용입니다 🙌</p>\n</blockquote>\n<br>\n<h2 id=\"강의8-os-캐시-구조\" style=\"position:relative;\"><a href=\"#%EA%B0%95%EC%9D%988-os-%EC%BA%90%EC%8B%9C-%EA%B5%AC%EC%A1%B0\" aria-label=\"강의8 os 캐시 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[강의8] OS 캐시 구조</h2>\n<h2 id=\"os의-캐시-구조를-알고-애플리케이션-작성하기---페이지-캐시\" style=\"position:relative;\"><a href=\"#os%EC%9D%98-%EC%BA%90%EC%8B%9C-%EA%B5%AC%EC%A1%B0%EB%A5%BC-%EC%95%8C%EA%B3%A0-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EC%9E%91%EC%84%B1%ED%95%98%EA%B8%B0---%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C\" aria-label=\"os의 캐시 구조를 알고 애플리케이션 작성하기   페이지 캐시 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>OS의 캐시 구조를 알고 애플리케이션 작성하기 - 페이지 캐시</h2>\n<ul>\n<li>OS는 메모리를 이용해서 캐시 구조를 갖추고 디스크 액세스를 줄인다.</li>\n</ul>\n<h3 id=\"linuxx86-페이징-구조\" style=\"position:relative;\"><a href=\"#linuxx86-%ED%8E%98%EC%9D%B4%EC%A7%95-%EA%B5%AC%EC%A1%B0\" aria-label=\"linuxx86 페이징 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Linux(x86) 페이징 구조</h3>\n<p>OS는 가장 메모리 구조를 가지고 있는데 논리적인 선형 어드레스를 물리적인 어드레스로 변환한다. </p>\n<h2 id=\"가상-메모리-구조\" style=\"position:relative;\"><a href=\"#%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0\" aria-label=\"가상 메모리 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>가상 메모리 구조</h2>\n<p>기본적인 OS 구조를 보면 OS에서 관리하고 있는 메모리 구조 있고, OS가 있으며 OS에서 돌아가는 프로세스가 존재한다. 프로세스에서 메모리가 필요한 경우 메모리에 직접 접근해서 주소를 가져오는 것이 아니라, OS를 통해서 비어있는 주소와 다른 주소를 반환한다. </p>\n<h3 id=\"왜-가상-주소를-반환할까\" style=\"position:relative;\"><a href=\"#%EC%99%9C-%EA%B0%80%EC%83%81-%EC%A3%BC%EC%86%8C%EB%A5%BC-%EB%B0%98%ED%99%98%ED%95%A0%EA%B9%8C\" aria-label=\"왜 가상 주소를 반환할까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>왜 가상 주소를 반환할까?</h3>\n<p>개별 프로세스가 실제로 메모리의 어느 부분을 사용하는지 스스로 알고 있을 필요가 없고, 특정 번지에서 통일해서 시작하는 것으로 다루면 더 쉽기 때문이다. </p>\n<ul>\n<li>예) 유닉스에서 공유 라이브러리는 프로세스 내에서 지정된 주소로 할당이 되어 있는데 프로세스 내에서 이 특정 어드레스는 예약에 되어 있음. 따라서 시작주소가 다 다르면 메모리를 확보할 주소위치를 찾기가 어려움</li>\n</ul>\n<p>어쨌든 OS 커널에서 메모리를 추상화해서 넘기고 있다 !!! </p>\n<p>또한 OS에서 메모리를 확보할 때도 단일 바이트 만큼씩 액세스 하는 것이 아니라 4KB 정도의 블록을 확보해서 프로세스에 넘긴다. <strong>블록 = 페이지 (즉, OS가 메모리를 확보하는 단위)</strong> </p>\n<p>OS는 메모리 요청을 받을 때 필요한 만큼의 페이지를 확보해서 프로세스에 넘긴다.  </p>\n<h2 id=\"linux-페이지-캐시의-원리\" style=\"position:relative;\"><a href=\"#linux-%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C%EC%9D%98-%EC%9B%90%EB%A6%AC\" aria-label=\"linux 페이지 캐시의 원리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Linux 페이지 캐시의 원리</h2>\n<p>OS는 확보한 페이지를 메모리상에 캐싱해둔다. </p>\n<h3 id=\"프로세스가-디스크에서-데이터를-읽어내는-과정\" style=\"position:relative;\"><a href=\"#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EA%B0%80-%EB%94%94%EC%8A%A4%ED%81%AC%EC%97%90%EC%84%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A5%BC-%EC%9D%BD%EC%96%B4%EB%82%B4%EB%8A%94-%EA%B3%BC%EC%A0%95\" aria-label=\"프로세스가 디스크에서 데이터를 읽어내는 과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>프로세스가 디스크에서 데이터를 읽어내는 과정</h3>\n<p>첫번째, 우선 디스크로부터 4KB 정도의 블록을 읽어냄</p>\n<p>두번째, 우선 메모리에 해당 읽어낸 데이터를 위치시킴 </p>\n<ul>\n<li>프로세스는 디스크에서 데이터를 직접 읽을 수는 없다 ! 프로세스가 액세스 할 수 있는 것은 가상 메모리 주소이기 때문이다.</li>\n</ul>\n<p>세번째, OS는 메모리에 쓰인 블록의 해당 주소를 프로세스에 가상 주소로 변환해서 알려준다. </p>\n<p>네번째, 프로세스는 해당 가상 주소로 메모리에 액세스 하게 된다. </p>\n<p align=\"center\"><img width=\"85%\" src=\"https://user-images.githubusercontent.com/63405904/136983984-be05b727-15c4-485c-8cf8-9f349a1d3fff.png\"><br>이미지 출처: 대용량 서비스를 지탱하는 기술</p>\n<p><strong>페이지 캐시 등장 -</strong> 이후에 더이상 프로세스가 데이터가 필요하지 않더라도 메모리에 쓰인 블럭을 해제하지 않고 남겨둔다. 그럼 다음 프로세스가 같은 디스크에 액세스할 때 해당 페이지를 재사용한다. </p>\n<h3 id=\"페이지-캐시의-효과\" style=\"position:relative;\"><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C%EC%9D%98-%ED%9A%A8%EA%B3%BC\" aria-label=\"페이지 캐시의 효과 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>페이지 캐시의 효과</h3>\n<p>리눅스의 페이지 캐시는 모든 I/O에 작용(예외를 제외하고)하여 디스크를 최초 읽은 이후 두번째 액세스부터 빨라진다. (OS를 계속 가동시켜두면 빨라진다. 재부팅 시 메모리에 캐시된 데이터는 없어진다.) </p>\n<h2 id=\"vfs\" style=\"position:relative;\"><a href=\"#vfs\" aria-label=\"vfs permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>VFS</h2>\n<p>리눅스의 구조는 다음과 같다. </p>\n<ul>\n<li>최하위에 하드디스크를 조작하는 디바이스 드라이버 → 위에 여러 파일 시스템 (리눅스의 경우 ext3, ext2, ext4, 등등) → vfs (virtual file system)</li>\n<li>파일시스템은 다양한 함수를 갖추고 있는데 인터페이스를 통일하기 위해 있는 것이 vfs 이다.</li>\n</ul>\n<p>VFS가 페이지 캐시 구조를 가지고 있다. → 어떤 파일 시스템을 이용하여 어떤 디스크를 읽어도 vfs를 통해서 동일한 구조로 캐싱이 된다. </p>\n<p><strong>한마디로, VFS의 역할은 파일시스템 추상화와 성능에 관여하는 페이지 캐시 부분이다.</strong> </p>\n<h2 id=\"리눅스는-페이지-단위로-디스크를-캐싱\" style=\"position:relative;\"><a href=\"#%EB%A6%AC%EB%88%85%EC%8A%A4%EB%8A%94-%ED%8E%98%EC%9D%B4%EC%A7%80-%EB%8B%A8%EC%9C%84%EB%A1%9C-%EB%94%94%EC%8A%A4%ED%81%AC%EB%A5%BC-%EC%BA%90%EC%8B%B1\" aria-label=\"리눅스는 페이지 단위로 디스크를 캐싱 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>리눅스는 페이지 단위로 디스크를 캐싱</h2>\n<h3 id=\"왜-파일-캐시가-아니라-페이지-캐시일까-\" style=\"position:relative;\"><a href=\"#%EC%99%9C-%ED%8C%8C%EC%9D%BC-%EC%BA%90%EC%8B%9C%EA%B0%80-%EC%95%84%EB%8B%88%EB%9D%BC-%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C%EC%9D%BC%EA%B9%8C-\" aria-label=\"왜 파일 캐시가 아니라 페이지 캐시일까  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>왜 파일 캐시가 아니라 페이지 캐시일까 ?</h3>\n<p>만일 메모리에 남은 여유 메모리 공간이 1.5 GB이고 필요한 파일이 4GB 일 경우 문제가 발생한다. </p>\n<p>OS는 파일(현재 4GB 단위) 기준으로 캐싱하는 것이 아니라 블록 단위(4KB 단위)만으로 캐싱한다. 특정 파일의 읽어낸 일부분만 캐싱한다. </p>\n<ul>\n<li><strong>페이지 == 가상 메모리의 최소단위</strong></li>\n</ul>\n<h3 id=\"lru\" style=\"position:relative;\"><a href=\"#lru\" aria-label=\"lru permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>LRU</h3>\n<p>만일 적은 여유분의 메모리에 4GB 파일을 모두 읽게 된다면 LRU(Least Recently Used) 방식으로 캐싱이 최신화 된다. 따라서 DB 서버도 계속 구동시키면 캐시가 최적화되어 I/O 부하가 내려간다. </p>\n<h3 id=\"어떻게-캐싱이-될까\" style=\"position:relative;\"><a href=\"#%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%BA%90%EC%8B%B1%EC%9D%B4-%EB%90%A0%EA%B9%8C\" aria-label=\"어떻게 캐싱이 될까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>어떻게 캐싱이 될까</h3>\n<p>리눅스는 파일을 i노드 번호라는 번호로 식별하고 어느 위치에서 시작하는 오프셋을 제공하여 두가지 정보를 함께 캐싱한다. 따라서 파일 전체가 아닌 일부분을 캐싱할 수 있다.</p>\n<p>이 키가 너무 많으면 파일이 클 경우 데이터 찾는 것이 어렵다고 여겨질 수 있는 데이터 구조는 <strong>Radix Tree</strong>라는 구조로 탐색 속도가 떨어지지 않는다. </p>\n<h2 id=\"메모리가-비어있으면-캐싱\" style=\"position:relative;\"><a href=\"#%EB%A9%94%EB%AA%A8%EB%A6%AC%EA%B0%80-%EB%B9%84%EC%96%B4%EC%9E%88%EC%9C%BC%EB%A9%B4-%EC%BA%90%EC%8B%B1\" aria-label=\"메모리가 비어있으면 캐싱 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>메모리가 비어있으면 캐싱</h2>\n<p>리눅스는 메모리가 비어있으면 모두 캐싱 → 프로세스에 메모리가 필요하면 오래돈 캐시를 버리고 메모리 확보</p>\n<ul>\n<li>\n<p>메모리 상황 알아보기</p>\n<p><code class=\"language-text\">sar -r</code> 명령어를 통해서 <code class=\"language-text\">kbcached</code>(kilo byte cached) 부분과 <code class=\"language-text\">%memused</code> 부분으로 확인할 수 있다. 주로 꽉찬 메모리를 확인할 수 있는데 이것은 문제가 아니다. 본래 리눅스는 가용 가능한 메모리에 조금씩 디스크를 모두 캐싱하고 추가 메모리가 필요하면 오래된 캐시를 파기한다. </p>\n</li>\n</ul>\n<h2 id=\"메모리-늘려서-io-부하-줄이기\" style=\"position:relative;\"><a href=\"#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%8A%98%EB%A0%A4%EC%84%9C-io-%EB%B6%80%ED%95%98-%EC%A4%84%EC%9D%B4%EA%B8%B0\" aria-label=\"메모리 늘려서 io 부하 줄이기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>메모리 늘려서 I/O 부하 줄이기</h2>\n<p>메모리보다 디스크에 저장된 용량이 적으면 디스크의 모든 파일이 메모리에 캐싱되어 디스크 액세스가 일어나지 않게 된다. 따라서 메모리가 늘어날 수록 I/O 부하가 줄어든다. </p>\n<h2 id=\"페이지-캐시는-투과적으로-작용\" style=\"position:relative;\"><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C%EB%8A%94-%ED%88%AC%EA%B3%BC%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%9E%91%EC%9A%A9\" aria-label=\"페이지 캐시는 투과적으로 작용 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>페이지 캐시는 투과적으로 작용</h2>\n<p>부팅 직후 파일을 그렇게 많이 읽지 않았을 때 그 이후 갑자기 큰 파일을 읽으면 해당 파일이 캐싱이 되기 때문에 갑자기 메모리 사용 용량이 높아진다. </p>\n<h2 id=\"code-classlanguage-textsarcode-명령어로-os-지표-확인하기\" style=\"position:relative;\"><a href=\"#code-classlanguage-textsarcode-%EB%AA%85%EB%A0%B9%EC%96%B4%EB%A1%9C-os-%EC%A7%80%ED%91%9C-%ED%99%95%EC%9D%B8%ED%95%98%EA%B8%B0\" aria-label=\"code classlanguage textsarcode 명령어로 os 지표 확인하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"language-text\">sar</code> 명령어로 os 지표 확인하기</h2>\n<ol>\n<li>\n<p>과거 OS 데이터 확인하기  - <code class=\"language-text\">sar -f {/var/log/sa/sa04} | head</code> 명령어로 과거 데이터의 로그 파일을 확인하여 장애 발생 원인을 확인 할 수 있다.  </p>\n<ul>\n<li>프로그램 교체 후 전후 비교를 위해서 위 sar 데이터를 활용할 수 있음</li>\n</ul>\n</li>\n<li>\n<p>현재 데이터 확인하기 - <code class=\"language-text\">sar 1 3</code> </p>\n<ul>\n<li>1초 간격으로 3회 동안 OS 데이터를 확인</li>\n<li>지금 이 순간 시스템에서 일어나고 있는지 확인할 수 있음</li>\n</ul>\n</li>\n<li>멀티 코어일 경우 <code class=\"language-text\">sar -p</code> 옵션으로 CPU 별 데이터 확인 가능 </li>\n<li>\n<p>디폴트 <code class=\"language-text\">sar</code> (<code class=\"language-text\">sar -u</code>에 해당함) - </p>\n<p align=\"center\"><img width=\"85%\" src=\"https://user-images.githubusercontent.com/63405904/136984234-20945113-1236-42e4-b23b-3a9289e74d83.png\"><br>이미지 출처: 대용량 서비스를 지탱하는 기술</p>\n<ul>\n<li>user → 사용자 모드에서 CPU가 소비된 시간 비율</li>\n<li>nice → nice로 스캐줄링의 우선도 변경한 프로세스가 사용자모드에서 CPU를 소비한 비율</li>\n<li>system → 시스템 모드에서 CPU가 소비된 시간 비율</li>\n<li>iowait → CPU가 디스크 I/O대기 위해 Idle 상태로 소비한 시간 비율</li>\n<li>steal → OS 가상화 이용시 다른 가상 CPU 계산으로 대기된 시간 비율</li>\n<li>idle → CPU가 디스크 I/O 등으로 대기되지 않고 Idle 상대로 소비한 시간 비율 (프로세스가 실행하고 있지 않은 상태)</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">sar -q</code> - Load Average 확인   </p>\n<ul>\n<li>실행큐에 쌓여있는 프로세스 수, 시스템상의 프로세스 사이즈, load average 참조 가능</li>\n<li>시간 흐름에 따른 값의 추이를 추척 가능</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">sar -r</code> - 메모리 사용 현황 확인 </p>\n<ul>\n<li>시간 추이에 따른 메모리 정도, 용도 확인 가능</li>\n<li><code class=\"language-text\">sar -W</code>와 조합해 스왑 발생 시간대의 메모리 사용 상황 확인 가능</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">sar -W</code>- 스왑 발생상황 확인 </p>\n<ul>\n<li>pswpin/s → 1초 동안 스왑인 되고 있는 페이지 수</li>\n<li>pswpout/s → 1초 동안 스왑아웃 되고 있는 페이지 수</li>\n<li>스왑이 발생하면 서버 전송량이 떨어진다. 만일 메모리 부족으로 잦은 스왑이 발생하고 있는지 확인할 수 있다.</li>\n</ul>\n</li>\n</ol>\n<br>\n<h2 id=\"강의9-io-부하를-줄이는-방법\" style=\"position:relative;\"><a href=\"#%EA%B0%95%EC%9D%989-io-%EB%B6%80%ED%95%98%EB%A5%BC-%EC%A4%84%EC%9D%B4%EB%8A%94-%EB%B0%A9%EB%B2%95\" aria-label=\"강의9 io 부하를 줄이는 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[강의9] I/O 부하를 줄이는 방법</h2>\n<h2 id=\"캐시를-전제로-한-io-줄이는-방법\" style=\"position:relative;\"><a href=\"#%EC%BA%90%EC%8B%9C%EB%A5%BC-%EC%A0%84%EC%A0%9C%EB%A1%9C-%ED%95%9C-io-%EC%A4%84%EC%9D%B4%EB%8A%94-%EB%B0%A9%EB%B2%95\" aria-label=\"캐시를 전제로 한 io 줄이는 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>캐시를 전제로 한 I/O 줄이는 방법</h2>\n<p>I/O 대책의 기본은 캐시이다 !! </p>\n<ul>\n<li>첫번째 접근법 → 데이터 크기보다 물리 메모리 사이즈가 크다면 모두 캐싱할 수 있다.</li>\n</ul>\n<p>대규모 데이터에 데이터 압축이 중요하다. 압축해서 저장할 경우 디스크 전부를 메모리에 캐싱해둘 수도 있다. </p>\n<ul>\n<li>두번째 접근법 → 경제적 비용과 밸런스 고려</li>\n</ul>\n<p>점점 서버와 높은 용량의 메모리 가격이 내려가면서 압축 알고리즘에 지나친 에너지를 쏟을 필요가 없는 경우도 많다. 밸런스를 고려하는 것이 중요하다. </p>\n<h2 id=\"복수-서버로-확장---캐시로-해결-안되는-규모인-경우\" style=\"position:relative;\"><a href=\"#%EB%B3%B5%EC%88%98-%EC%84%9C%EB%B2%84%EB%A1%9C-%ED%99%95%EC%9E%A5---%EC%BA%90%EC%8B%9C%EB%A1%9C-%ED%95%B4%EA%B2%B0-%EC%95%88%EB%90%98%EB%8A%94-%EA%B7%9C%EB%AA%A8%EC%9D%B8-%EA%B2%BD%EC%9A%B0\" aria-label=\"복수 서버로 확장   캐시로 해결 안되는 규모인 경우 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>복수 서버로 확장 - 캐시로 해결 안되는 규모인 경우</h2>\n<p>현재 인프라의 구조가 프록시 ↔ WAS ↔ DB 인 경우에 다음과 같이 서버를 확장할 수 있다. </p>\n<ol>\n<li>\n<p>WAS 서버를 늘린다.</p>\n<ul>\n<li>CPU 부하를 낮추고 분산시키기 위해서이다.</li>\n<li>단순히 늘리면 된다.</li>\n</ul>\n</li>\n<li>\n<p>DB 서버를 늘린다.</p>\n<ul>\n<li>캐싱 용량을 늘리거나 효율을 높이고자 할 때 늘린다.</li>\n<li>하지만 I/O 분산에는 국소성을 고려해야하며 마냥 늘려서 좋은 것은 아니다.</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"대수만-늘려서-확정성-확보할-수-없다\" style=\"position:relative;\"><a href=\"#%EB%8C%80%EC%88%98%EB%A7%8C-%EB%8A%98%EB%A0%A4%EC%84%9C-%ED%99%95%EC%A0%95%EC%84%B1-%ED%99%95%EB%B3%B4%ED%95%A0-%EC%88%98-%EC%97%86%EB%8B%A4\" aria-label=\"대수만 늘려서 확정성 확보할 수 없다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>대수만 늘려서 확정성 확보할 수 없다.</h2>\n<ul>\n<li>\n<p>캐시 용량이 부족해서 DB 서버 대수를 확보했지만 부족한 캐싱 용량의 상황까지 그대로 복제될 수 있다.</p>\n<ul>\n<li>A 서버에서 조회하며 캐싱했는데 부족한 것이 B 서버에서도 동일하게 일어남</li>\n<li>어느정도 빨라질 수는 있겠지만 증설비용대비 성능향상은 좋지 않다.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"-io-부하-줄이기와-페이지-캐시\" style=\"position:relative;\"><a href=\"#-io-%EB%B6%80%ED%95%98-%EC%A4%84%EC%9D%B4%EA%B8%B0%EC%99%80-%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C\" aria-label=\" io 부하 줄이기와 페이지 캐시 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>+ I/O 부하 줄이기와 페이지 캐시</h2>\n<p>리눅스에서 sar 명령어로 메모리 상황을 확인했을 때 항상 메모리가 부족해보일수도 있다. 하지만 리눅스의 페이지 캐시 원리는 <code class=\"language-text\">리눅스는 가능한 남아있는 메모리를 페이지 캐시로 활용한다</code> 라는 것이다. 따라서 부팅 후 시간이 지날수록 sar의 <code class=\"language-text\">kbmemfree</code> 는 줄어들 수밖에 없다. </p>\n<h3 id=\"페이지-캐시에-의한-io-부하-경감-효과\" style=\"position:relative;\"><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C%EC%97%90-%EC%9D%98%ED%95%9C-io-%EB%B6%80%ED%95%98-%EA%B2%BD%EA%B0%90-%ED%9A%A8%EA%B3%BC\" aria-label=\"페이지 캐시에 의한 io 부하 경감 효과 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>페이지 캐시에 의한 I/O 부하 경감 효과</h3>\n<ul>\n<li>많은 데이터가 있는 상황에서 메모리를 증설하고 <code class=\"language-text\">sar -P</code> 로 확인해보면 <code class=\"language-text\">%iowait</code> 의 확연한 차이를 볼 수 있다.</li>\n<li>\n<p><code class=\"language-text\">sar -r</code> 를 사용하면 커널이 캐시를 확보하고 있는 정도를 확인할 수 있다. 커널이 확보하고 있는 캐시용량과 어플리케이션에서 다루는 데이터의 용량을 비교하여 데이터량이 더 많을 경우 메모리 증설을 검토하여 디스크 액세스를 줄인다.</p>\n<p><code class=\"language-text\">vmstat</code>을 사용하면 디스크 액세스 정도를 확인할 수 있다.   </p>\n</li>\n<li>메모리 증설이 어려운 경우 데이터 분할하여 각각 서버에 위치한다. → 캐시 올릴 데이터 비율이 올라가고 I/O 횟수가 줄어든다.</li>\n</ul>\n<h3 id=\"페이지-캐시는-한번의-read에서-시작된다\" style=\"position:relative;\"><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C%EB%8A%94-%ED%95%9C%EB%B2%88%EC%9D%98-read%EC%97%90%EC%84%9C-%EC%8B%9C%EC%9E%91%EB%90%9C%EB%8B%A4\" aria-label=\"페이지 캐시는 한번의 read에서 시작된다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>페이지 캐시는 한번의 read에서 시작된다.</h3>\n<ul>\n<li>캐싱하지 못한 데이터는 직접 디스크에서 읽는다. 서버를 재부팅한 경우 메모리의 캐시는 초기화 되므로 모든 액세스에 I/O를 발생시킨다.</li>\n<li>대규모 DB 서버인 경우 모든 DB 액세스마다 디스크 I/O가 발생해서 DB가 lock에 걸리는 경우도 많다.</li>\n<li>따라서 필요한 경우 필요데이터를 전체 한번 전체적으로 읽어 다시 캐싱하는 방법도 필요하다.</li>\n<li>I/O 바운드가 높은 서버인 경우 페이지 캐시가 최적화 되었는지 확인한다.</li>\n</ul>\n<br>\n<h2 id=\"강의10-국소성을-살리는-분산\" style=\"position:relative;\"><a href=\"#%EA%B0%95%EC%9D%9810-%EA%B5%AD%EC%86%8C%EC%84%B1%EC%9D%84-%EC%82%B4%EB%A6%AC%EB%8A%94-%EB%B6%84%EC%82%B0\" aria-label=\"강의10 국소성을 살리는 분산 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[강의10] 국소성을 살리는 분산</h2>\n<h2 id=\"국소성을-고려한-분산이란\" style=\"position:relative;\"><a href=\"#%EA%B5%AD%EC%86%8C%EC%84%B1%EC%9D%84-%EA%B3%A0%EB%A0%A4%ED%95%9C-%EB%B6%84%EC%82%B0%EC%9D%B4%EB%9E%80\" aria-label=\"국소성을 고려한 분산이란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>국소성을 고려한 분산이란</h2>\n<p>서버를 여러대 확장해서 캐시 용량을 늘리기 위해서는 국소성(locality)을 고려해서 분산시켜야한다. </p>\n<ul>\n<li>\n<p>DB의 경우 서비스 패턴과 처리방식에 따라 데이터 액세스 경향이 한쪽으로 치우친다.</p>\n<ul>\n<li>어떤 서비스 패턴이 엔트리 A에 많이 접근하고 다른 서비스는 테이블B에 많이 접근한다면 1, 2를 분산하여 한쪽에만 액세스 하도록 할 수 있다.</li>\n<li>이것을 고려하지 않으면 여전히 서버 1에서 두 패턴이 모두 일어나게 되므로 캐시를 위한 메모리 용량이 부족하게 된다.</li>\n<li>즉, 액세스 패턴을 고려하여 국소성을 적용한 분산을 하라!!</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"파티셔닝---국소성-분산1\" style=\"position:relative;\"><a href=\"#%ED%8C%8C%ED%8B%B0%EC%85%94%EB%8B%9D---%EA%B5%AD%EC%86%8C%EC%84%B1-%EB%B6%84%EC%82%B01\" aria-label=\"파티셔닝   국소성 분산1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>파티셔닝 - 국소성 분산1</h2>\n<p>한 대였던 DB를 여러대의 서버로 분할하는 방법이다. → 제일 간단한 분할 방법은 테이블 단위 분할</p>\n<ul>\n<li><strong>테이블 단위 분할</strong> - 같이 액세스 하는 경우가 많은 테이블을 같은 서버에 위치시키고 그 밖의 것들을 다른 서버에 위치</li>\n<li>\n<p><strong>테이블 데이터 분할 -</strong> 하나의 테이블을 여러 테이블로 분할</p>\n<ul>\n<li>예를 들어 책에 나온 예시로는 하나의 테이블을 앞 알파벳에 따라서 데이터를 분할함</li>\n<li>국소성이 올라가 캐싱이 잘됨</li>\n<li>단점: 분할이 너무 작게 된다면 데이터를 한번 병합해야 함</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"요청-패턴을-섬으로-분할---국소성-분산2\" style=\"position:relative;\"><a href=\"#%EC%9A%94%EC%B2%AD-%ED%8C%A8%ED%84%B4%EC%9D%84-%EC%84%AC%EC%9C%BC%EB%A1%9C-%EB%B6%84%ED%95%A0---%EA%B5%AD%EC%86%8C%EC%84%B1-%EB%B6%84%EC%82%B02\" aria-label=\"요청 패턴을 섬으로 분할   국소성 분산2 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>요청 패턴을 ‘섬’으로 분할 - 국소성 분산2</h2>\n<p>요청의 종류에 따라서 요청을 보내는 서버를 나누는 것이다. - 특이한 경우이기는 함</p>\n<p align=\"center\"><img width=\"85%\" src=\"https://user-images.githubusercontent.com/63405904/136984334-66cc4ba2-bb5a-4b92-aacd-1067c92f5765.png\"><br>이미지 출처: 대용량 서비스를 지탱하는 기술</p>\n<ul>\n<li>캐싱하기 쉬운 요청, 캐싱하기 어려운 요청을 처리하는 섬을 나눔 → 전자는 국소성으로 높은 캐시 적중률을 냄</li>\n</ul>\n<h2 id=\"페이지-캐시를-고려한-운용의-기본-원칙\" style=\"position:relative;\"><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C%EB%A5%BC-%EA%B3%A0%EB%A0%A4%ED%95%9C-%EC%9A%B4%EC%9A%A9%EC%9D%98-%EA%B8%B0%EB%B3%B8-%EC%9B%90%EC%B9%99\" aria-label=\"페이지 캐시를 고려한 운용의 기본 원칙 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>페이지 캐시를 고려한 운용의 기본 원칙</h2>\n<ol>\n<li>\n<p>OS를 가동한 직후에 서버를 투입하지 않는다 → 캐시가 쌓여있지 않기 때문이다. </p>\n<ul>\n<li>OS를 기동하고 자주 사용하는 DB의 파일을 한번 cat 하여 메모리에 올린다. 이후 로드밸런서에 편입한다.</li>\n</ul>\n</li>\n<li>성능 테스트를 할 경우 초기값은 버려야한다. → 최초 캐시가 최적화 되어 있지 않은 단계이므로 속도가 확연히 차이가 나게 된다. </li>\n</ol>\n<h2 id=\"-부하분산과-os의-동작원리\" style=\"position:relative;\"><a href=\"#-%EB%B6%80%ED%95%98%EB%B6%84%EC%82%B0%EA%B3%BC-os%EC%9D%98-%EB%8F%99%EC%9E%91%EC%9B%90%EB%A6%AC\" aria-label=\" 부하분산과 os의 동작원리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>+ 부하분산과 OS의 동작원리</h2>\n<ul>\n<li>OS 캐시, 멀티스레드나 멀티프로세스, 가상 메모리구조, 파일시스템 등과 같은 OS 지식이 있어야 부하분산을 잘 할 수 있음.</li>\n<li>요청 분배에는 LVS 사용법, MySQL 아파치와 같은 미들웨어 사용법 등이 있다.</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#%EA%B0%95%EC%9D%988-os-%EC%BA%90%EC%8B%9C-%EA%B5%AC%EC%A1%B0\">강의8 OS 캐시 구조</a></li>\n<li>\n<p><a href=\"#os%EC%9D%98-%EC%BA%90%EC%8B%9C-%EA%B5%AC%EC%A1%B0%EB%A5%BC-%EC%95%8C%EA%B3%A0-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EC%9E%91%EC%84%B1%ED%95%98%EA%B8%B0---%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C\">OS의 캐시 구조를 알고 애플리케이션 작성하기 - 페이지 캐시</a></p>\n<ul>\n<li><a href=\"#linuxx86-%ED%8E%98%EC%9D%B4%EC%A7%95-%EA%B5%AC%EC%A1%B0\">Linux(x86) 페이징 구조</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0\">가상 메모리 구조</a></p>\n<ul>\n<li><a href=\"#%EC%99%9C-%EA%B0%80%EC%83%81-%EC%A3%BC%EC%86%8C%EB%A5%BC-%EB%B0%98%ED%99%98%ED%95%A0%EA%B9%8C\">왜 가상 주소를 반환할까?</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#linux-%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C%EC%9D%98-%EC%9B%90%EB%A6%AC\">Linux 페이지 캐시의 원리</a></p>\n<ul>\n<li><a href=\"#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EA%B0%80-%EB%94%94%EC%8A%A4%ED%81%AC%EC%97%90%EC%84%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A5%BC-%EC%9D%BD%EC%96%B4%EB%82%B4%EB%8A%94-%EA%B3%BC%EC%A0%95\">프로세스가 디스크에서 데이터를 읽어내는 과정</a></li>\n<li><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C%EC%9D%98-%ED%9A%A8%EA%B3%BC\">페이지 캐시의 효과</a></li>\n</ul>\n</li>\n<li><a href=\"#vfs\">VFS</a></li>\n<li>\n<p><a href=\"#%EB%A6%AC%EB%88%85%EC%8A%A4%EB%8A%94-%ED%8E%98%EC%9D%B4%EC%A7%80-%EB%8B%A8%EC%9C%84%EB%A1%9C-%EB%94%94%EC%8A%A4%ED%81%AC%EB%A5%BC-%EC%BA%90%EC%8B%B1\">리눅스는 페이지 단위로 디스크를 캐싱</a></p>\n<ul>\n<li><a href=\"#%EC%99%9C-%ED%8C%8C%EC%9D%BC-%EC%BA%90%EC%8B%9C%EA%B0%80-%EC%95%84%EB%8B%88%EB%9D%BC-%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C%EC%9D%BC%EA%B9%8C-\">왜 파일 캐시가 아니라 페이지 캐시일까 ?</a></li>\n<li><a href=\"#lru\">LRU</a></li>\n<li><a href=\"#%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%BA%90%EC%8B%B1%EC%9D%B4-%EB%90%A0%EA%B9%8C\">어떻게 캐싱이 될까</a></li>\n</ul>\n</li>\n<li><a href=\"#%EB%A9%94%EB%AA%A8%EB%A6%AC%EA%B0%80-%EB%B9%84%EC%96%B4%EC%9E%88%EC%9C%BC%EB%A9%B4-%EC%BA%90%EC%8B%B1\">메모리가 비어있으면 캐싱</a></li>\n<li><a href=\"#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%8A%98%EB%A0%A4%EC%84%9C-io-%EB%B6%80%ED%95%98-%EC%A4%84%EC%9D%B4%EA%B8%B0\">메모리 늘려서 I/O 부하 줄이기</a></li>\n<li><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C%EB%8A%94-%ED%88%AC%EA%B3%BC%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%9E%91%EC%9A%A9\">페이지 캐시는 투과적으로 작용</a></li>\n<li><a href=\"#sar-%EB%AA%85%EB%A0%B9%EC%96%B4%EB%A1%9C-os-%EC%A7%80%ED%91%9C-%ED%99%95%EC%9D%B8%ED%95%98%EA%B8%B0\"><code class=\"language-text\">sar</code> 명령어로 os 지표 확인하기</a></li>\n<li><a href=\"#%EA%B0%95%EC%9D%989-io-%EB%B6%80%ED%95%98%EB%A5%BC-%EC%A4%84%EC%9D%B4%EB%8A%94-%EB%B0%A9%EB%B2%95\">강의9 I/O 부하를 줄이는 방법</a></li>\n<li><a href=\"#%EC%BA%90%EC%8B%9C%EB%A5%BC-%EC%A0%84%EC%A0%9C%EB%A1%9C-%ED%95%9C-io-%EC%A4%84%EC%9D%B4%EB%8A%94-%EB%B0%A9%EB%B2%95\">캐시를 전제로 한 I/O 줄이는 방법</a></li>\n<li><a href=\"#%EB%B3%B5%EC%88%98-%EC%84%9C%EB%B2%84%EB%A1%9C-%ED%99%95%EC%9E%A5---%EC%BA%90%EC%8B%9C%EB%A1%9C-%ED%95%B4%EA%B2%B0-%EC%95%88%EB%90%98%EB%8A%94-%EA%B7%9C%EB%AA%A8%EC%9D%B8-%EA%B2%BD%EC%9A%B0\">복수 서버로 확장 - 캐시로 해결 안되는 규모인 경우</a></li>\n<li><a href=\"#%EB%8C%80%EC%88%98%EB%A7%8C-%EB%8A%98%EB%A0%A4%EC%84%9C-%ED%99%95%EC%A0%95%EC%84%B1-%ED%99%95%EB%B3%B4%ED%95%A0-%EC%88%98-%EC%97%86%EB%8B%A4\">대수만 늘려서 확정성 확보할 수 없다.</a></li>\n<li>\n<p><a href=\"#-io-%EB%B6%80%ED%95%98-%EC%A4%84%EC%9D%B4%EA%B8%B0%EC%99%80-%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C\">+ I/O 부하 줄이기와 페이지 캐시</a></p>\n<ul>\n<li><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C%EC%97%90-%EC%9D%98%ED%95%9C-io-%EB%B6%80%ED%95%98-%EA%B2%BD%EA%B0%90-%ED%9A%A8%EA%B3%BC\">페이지 캐시에 의한 I/O 부하 경감 효과</a></li>\n<li><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C%EB%8A%94-%ED%95%9C%EB%B2%88%EC%9D%98-read%EC%97%90%EC%84%9C-%EC%8B%9C%EC%9E%91%EB%90%9C%EB%8B%A4\">페이지 캐시는 한번의 read에서 시작된다.</a></li>\n</ul>\n</li>\n<li><a href=\"#%EA%B0%95%EC%9D%9810-%EA%B5%AD%EC%86%8C%EC%84%B1%EC%9D%84-%EC%82%B4%EB%A6%AC%EB%8A%94-%EB%B6%84%EC%82%B0\">강의10 국소성을 살리는 분산</a></li>\n<li><a href=\"#%EA%B5%AD%EC%86%8C%EC%84%B1%EC%9D%84-%EA%B3%A0%EB%A0%A4%ED%95%9C-%EB%B6%84%EC%82%B0%EC%9D%B4%EB%9E%80\">국소성을 고려한 분산이란</a></li>\n<li><a href=\"#%ED%8C%8C%ED%8B%B0%EC%85%94%EB%8B%9D---%EA%B5%AD%EC%86%8C%EC%84%B1-%EB%B6%84%EC%82%B01\">파티셔닝 - 국소성 분산1</a></li>\n<li><a href=\"#%EC%9A%94%EC%B2%AD-%ED%8C%A8%ED%84%B4%EC%9D%84-%EC%84%AC%EC%9C%BC%EB%A1%9C-%EB%B6%84%ED%95%A0---%EA%B5%AD%EC%86%8C%EC%84%B1-%EB%B6%84%EC%82%B02\">요청 패턴을 ‘섬’으로 분할 - 국소성 분산2</a></li>\n<li><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C%EB%A5%BC-%EA%B3%A0%EB%A0%A4%ED%95%9C-%EC%9A%B4%EC%9A%A9%EC%9D%98-%EA%B8%B0%EB%B3%B8-%EC%9B%90%EC%B9%99\">페이지 캐시를 고려한 운용의 기본 원칙</a></li>\n<li><a href=\"#-%EB%B6%80%ED%95%98%EB%B6%84%EC%82%B0%EA%B3%BC-os%EC%9D%98-%EB%8F%99%EC%9E%91%EC%9B%90%EB%A6%AC\">+ 부하분산과 OS의 동작원리</a></li>\n</ul>\n</div>","frontmatter":{"date":"September 24, 2021","title":"대규모 서비스를 지탱하는 기술 - OS 캐시와 분산","categories":"웹 인프라 책 성능테스트","author":"코다","emoji":"📚"},"fields":{"slug":"/high-traffic-service_3/"}},"prev":{"id":"3144633b-9fb5-54a7-9f11-f6a48517333b","html":"<h2 id=\"intro\" style=\"position:relative;\"><a href=\"#intro\" aria-label=\"intro permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>INTRO</h2>\n<ul>\n<li>\n<p>현재 진행중인 <a href=\"https://github.com/woowacourse-teams/2021-pick-git\">프로젝트</a>에서 DB Replication을 적용했었다. </p>\n<ul>\n<li><a href=\"https://yjksw.github.io/db-replication/\">Replication 알아보기</a></li>\n</ul>\n</li>\n<li>DB replication 적용 이후 Master DB를 업그레이드 해야하는 상황에서 replicas와의 연동에 문제가 생긴적이 있었다. 이때 Master와 replicas 간의 데이터 연동 방법을 이해하고 해결한 (매우 간단한) 방법을 기록한다. </li>\n</ul>\n<h2 id=\"master-db와-replicas-동기화\" style=\"position:relative;\"><a href=\"#master-db%EC%99%80-replicas-%EB%8F%99%EA%B8%B0%ED%99%94\" aria-label=\"master db와 replicas 동기화 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Master DB와 replicas 동기화</h2>\n<ul>\n<li>Master DB에 데이터를 쓰기 위해서는 replicas에서 master db 의 데이터와 연결되어 있어야 한다. 그러기 위해서 replication을 설정할 때 <code class=\"language-text\">show master status</code> 라는 명령어를 통해서 나온 <code class=\"language-text\">File</code>값과 <code class=\"language-text\">Position</code> 값을 replica db 설정시 적용해 주었다. </li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"mysql\"><pre class=\"language-mysql\"><code class=\"language-mysql\">MariaDB [pickgit]&gt; show master status;\n+--------------------+----------+--------------+------------------+\n| File               | Position | Binlog_Do_DB | Binlog_Ignore_DB |\n+--------------------+----------+--------------+------------------+\n| mariadb-bin.000008 | 68143505 |              |                  |\n+--------------------+----------+--------------+------------------+\n1 row in set (0.000 sec)</code></pre></div>\n<ul>\n<li>여기서 File은 master db의 binary 로그 파일이고 Position 값은 해당 파일의 현재 위치이다. </li>\n<li>\n<p>위 log 파일에는 어떤 내용이 담겨 있을까?</p>\n<blockquote>\n<p>The MariaDB binary log is a series of files that contain events. An event is a description of a modification to the contents of our database. <br>출처: Big Data and Business Intelligence</p>\n</blockquote>\n</li>\n<li>로그 파일에는 데이터베이스에서 일어난 <code class=\"language-text\">event</code>에 대해서 적혀 있는데, 여기서 <code class=\"language-text\">event</code>라고 하는 것은 데이터베이스의 컨텐츠에 대해 일어난 변경사항을 말한다. </li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"mysql\"><pre class=\"language-mysql\"><code class=\"language-mysql\">MariaDB [pickgit]&gt; show master status;\n+--------------------+----------+--------------+------------------+\n| File               | Position | Binlog_Do_DB | Binlog_Ignore_DB |\n+--------------------+----------+--------------+------------------+\n| mariadb-bin.000008 | 68143656 |              |                  |\n+--------------------+----------+--------------+------------------+\n1 row in set (0.000 sec)</code></pre></div>\n<ul>\n<li>실제로 테이블을 추가하는 쿼리를 날린 후 다시 확인해보니 Position값이 증가한 것을 확인할 수 있다. </li>\n<li>Replicas 설정시 위 값을 지정한다는 것은 replicas에 데이터를 업데이트하는 file과 해당 file에서의 위치를 지정하는 것이다. </li>\n<li>번외로 만일 binary loggin이 비활성되어 있는 상태에서 master 데이터베이스가 실행중이었다면 <code class=\"language-text\">show master status;</code> 명령어에 나오는 값이 비어있을 것이다. 그 경우 replicas에 master의 로그파일과 position을 지정할 때 빈 스트링 (”)과 4를 지정하면 된다. </li>\n</ul>\n<h2 id=\"문제상황-및-해결\" style=\"position:relative;\"><a href=\"#%EB%AC%B8%EC%A0%9C%EC%83%81%ED%99%A9-%EB%B0%8F-%ED%95%B4%EA%B2%B0\" aria-label=\"문제상황 및 해결 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>문제상황 및 해결</h2>\n<ul>\n<li>본래 사용한 MariaDB 버전은 10.1이었다. 하지만 Flyway를 적용한 이후 MariaDB를 10.4로 업그레이드 하지 않으면 적용할 수 없다는 오류가 생겼다. MariaDB 버전을 업그레이드 할 수 있는 방법을 찾아보았지만 현재 사용 중인 DB 데이터를 백업하고 삭제 후 10.4 버전을 새로 설치하여 데이터를 복원하라는 내용밖에 나오지 않았다. </li>\n<li>현재 Master 1개 slave 2개를 사용중이었기 때문에 DB 3개를 모두 삭제하고 재설치하는 것은 지나치게 많은 작업이라고 생각했다. (replication 설정, 유저 생성 및 권한 부여 등등 자잘한 설정이 많음) 따라서 Flyway가 직접 적용되는 Master DB만 수정하고 Slave DB는 기존의 것을 유지하기로 했다. </li>\n<li>\n<p>Master DB를 새로 구성하는 와중에 다음과 같은 문제 상황이 발생했다. </p>\n<ul>\n<li>문제 상황</li>\n<li>Master DB의 설정을 마치고 Slave에 Master를 지정하여 연결을 완료함 </li>\n<li>Master DB의 <code class=\"language-text\">replication</code> 유저에게 외부에서 쓰기 권한을 부여하지 않은 것을 깨달음 </li>\n<li>Master DB의 <code class=\"language-text\">replication</code> 유저에게 권한을 부여함</li>\n<li>Slave DB에 Master DB의 데이터가 반영이 되지 않음  </li>\n</ul>\n</li>\n<li>\n<p>Master에서 연결된 slave hosts를 확인해 보면 잘 연결되어 있는 것을 확인할 수 있다. </p>\n<div class=\"gatsby-highlight\" data-language=\"mysql\"><pre class=\"language-mysql\"><code class=\"language-mysql\">MariaDB [pickgit]&gt; show slave hosts;\n+-----------+------+------+-----------+\n| Server_id | Host | Port | Master_id |\n+-----------+------+------+-----------+\n|         3 |      | 9000 |         1 |\n|         2 |      | 9000 |         1 |\n+-----------+------+------+-----------+\n2 rows in set (0.000 sec)</code></pre></div>\n</li>\n<li>Slave 의 상태를 확인해보면 <code class=\"language-text\">Slave_IO_State: Waiting for master to sent event</code> 라고 나와있는 것을 확인할 수 있다. </li>\n</ul>\n<p align=\"center\"><img width=\"90%\" src=\"https://user-images.githubusercontent.com/63405904/134805936-9f3469e3-aa3e-496f-91b3-ae5b7f6e881d.png\"></p>\n<ul>\n<li>위 상태의 더 아래에 <code class=\"language-text\">Last_Error</code> 와 <code class=\"language-text\">Last_SQL_Error</code>를 확인해보면 특정 쿼리에 에러가 발생했다는 로그가 출력되어 있다. 즉, <code class=\"language-text\">replication</code> 이라는 유저가 Master에서는 잘 적용이 되었지만 Slave DB에는 존재하지 않기 때문에 에러가 발생한 것이다. 해당 로그 이후에 추가 및 변경된 데이터에 대해서는 slave db에 더 이상 반영이 되지 않았다. </li>\n<li>위 문제를 해결하기 위해서는 Slave DB가 Master의 로그 파일을 읽는 Position을 위 쿼리가 실행된 이후로 옮겨서 해당 쿼리를 건너뛰어야 한다. 따라서 <code class=\"language-text\">show master status</code>를 다시 실행하여 나온 최신 position을 slave DB 설정에 넣어주어 문제를 해결했다. 여기서 주의할 점은 만일 이전에 변경된 데이터가 있다면 해당 변경 로그도 모두 건너뛰게 되니 다시 적용해주어야 한다. </li>\n</ul>\n<p><strong>[참고자료]</strong></p>\n<ul>\n<li><a href=\"https://dev.mysql.com/doc/refman/8.0/en/replication-setup-replicas.html#replication-howto-newservers\">https://dev.mysql.com/doc/refman/8.0/en/replication-setup-replicas.html#replication-howto-newservers</a></li>\n<li><a href=\"https://dev.mysql.com/doc/refman/8.0/en/replication-howto-masterstatus.html\">https://dev.mysql.com/doc/refman/8.0/en/replication-howto-masterstatus.html</a></li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#intro\">INTRO</a></li>\n<li><a href=\"#master-db%EC%99%80-replicas-%EB%8F%99%EA%B8%B0%ED%99%94\">Master DB와 replicas 동기화</a></li>\n<li><a href=\"#%EB%AC%B8%EC%A0%9C%EC%83%81%ED%99%A9-%EB%B0%8F-%ED%95%B4%EA%B2%B0\">문제상황 및 해결</a></li>\n</ul>\n</div>","frontmatter":{"date":"September 26, 2021","title":"DB 리플리케이션 적용시 Binary 로그 에러 해결방법","categories":"데이터베이스 인프라","author":"코다","emoji":"🚊"},"fields":{"slug":"/db-replication-binary-log/"}},"site":{"siteMetadata":{"siteUrl":"https://yjksw.github.io","comments":{"utterances":{"repo":"yjksw/yjksw.github.io"}}}}},"pageContext":{"slug":"/one-percent-network-1/","nextSlug":"/high-traffic-service_3/","prevSlug":"/db-replication-binary-log/"}},"staticQueryHashes":["1073350324","2938748437"]}
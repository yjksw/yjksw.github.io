{"componentChunkName":"component---src-templates-blog-template-js","path":"/operating-system-4/","result":{"data":{"cur":{"id":"729d1153-237f-5fde-a73b-e4781e4d31d3","html":"<blockquote>\n<p>다음은 반효경 교수님의 ‘운영체제와 정보기술의 원리’ <em>CH5. 프로세스 관리</em>를 읽고 정리한 내용입니다 🙌</p>\n</blockquote>\n<br>\n<br>\n<h2 id=\"-1-프로세스의-개념\" style=\"position:relative;\"><a href=\"#-1-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%9D%98-%EA%B0%9C%EB%85%90\" aria-label=\" 1 프로세스의 개념 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 1. 프로세스의 개념</h2>\n<ul>\n<li><strong>프로세스란 실행 중인 프로그램</strong>이다.</li>\n<li>프로세스는 CPU를 획득해서 코드를 수행하고 CPU를 반환하고 입출력 작업을 수행하기도 한다.</li>\n<li>\n<p>프로세스 문맥 (context) - 프로세스가 현재 어떤 상태에서 수행되고 있는 규명하기 위해 필요한 정보</p>\n<ul>\n<li>여러 프로세스가 CPU를 사용하면서 중간에 CPU를 다른 프로세스에게 넘겨야 한다.</li>\n<li>이때 다시 이어서하기 위한 필요 정보가 있는데 그것을 <strong>프로세스 문맥</strong>이라고 한다.</li>\n<li>프로세스의 주소 공간, 레지스터의 값, 시스템 콜을 통해 커널에서 수행한 일의 상태, 프로세스에 대해 커널이 관리하고 있는 여러 정보들을 포함한다.</li>\n</ul>\n</li>\n<li>\n<p>프로세스 문맥은 3가지로 나뉜다.</p>\n<ol>\n<li>\n<p>하드웨어 문맥</p>\n<ol>\n<li>CPU의 수행 상태를 나타낸다. </li>\n<li>프로그램 카운터 값, 각종 레지스터에 저장하고 있는 값들이다. </li>\n</ol>\n</li>\n<li>\n<p>프로세스의 주소 공간</p>\n<ol>\n<li>코드, 데이터, 스택으로 이루어진 프로세스의 독자적인 주소 공간이다. </li>\n</ol>\n</li>\n<li>\n<p>커널상의 문맥 </p>\n<ol>\n<li>PCB 와 커널스택이 프로세스에 대한 커널에 위치하는 자료구조이다. </li>\n</ol>\n</li>\n</ol>\n</li>\n</ul>\n<br>\n<h2 id=\"-2-프로세스의-상태\" style=\"position:relative;\"><a href=\"#-2-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%9D%98-%EC%83%81%ED%83%9C\" aria-label=\" 2 프로세스의 상태 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 2. 프로세스의 상태</h2>\n<ul>\n<li><strong>실행(running), 준비(ready), 봉쇄(blocked, wait, sleep)</strong></li>\n<li>\n<p>실행 - 프로세스가 CPU를 봉하고 기계어 명령을 실행하고 있는 상태</p>\n<ul>\n<li>실제로 실행 상태에 있는 프로세스는 매 시점 하나이다.</li>\n</ul>\n</li>\n<li>준비 - 프로세스가 CPU만 보유하면 명령을 실행할 수 있지만 CPU를 획득하지 못한 상태</li>\n<li>\n<p>봉쇄 - CPU를 할당 받더라도 명령을 실행할 수 없는 프로세스의 상태</p>\n<ul>\n<li>입출력 작업이 진행 중인 경우</li>\n</ul>\n</li>\n<li>프로세스의 상태를 나누는 이유는 컴퓨터의 자원을 효율적으로 관리하기 위해서다.</li>\n<li>\n<p>이외에도 <strong>시작과 종료</strong> 상태가 있다.</p>\n<ul>\n<li>시작 - 프로세스에 대한 자료구조는 생성 되었지만 메모리 획득을 승인받지 못한 상태</li>\n<li>종료 - 프로세스가 종료되었으나 운영체제가 관련된 자료구조를 완전히 정리하지 못한 상태</li>\n</ul>\n</li>\n<li>프로세스는 앞의 상태 중 하나에 머물러 있으며, 시간의 흐름에 따라서 변한다.</li>\n</ul>\n<h3 id=\"프로세스의-상태-흐름\" style=\"position:relative;\"><a href=\"#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%9D%98-%EC%83%81%ED%83%9C-%ED%9D%90%EB%A6%84\" aria-label=\"프로세스의 상태 흐름 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>프로세스의 상태 흐름</h3>\n<ul>\n<li>\n<p>프로세스의 문맥이 교환되는 것을 Context switching이라고 한다.</p>\n<ul>\n<li>한 프로세스가 진행 중일 때 타이머 인터럽트가 발생한다.</li>\n<li>타이머 인터럽트 처리루틴에 따라서 현재 진행중이던 프로세스의 문맥을 저장하고 준비 상태의 프로세스 중 하나를 선택한다.</li>\n<li>본래 수행 중이던 프로세스를 준비 상태로 내리고 새로운 프로세스가 실행 상태가 된다.</li>\n<li>실행할 프로세스에 대한 문맥을 세팅한다.</li>\n</ul>\n</li>\n<li><strong>CPU 디스패치(dispatch)</strong> - 준비 상태에 있는 프로세스 중 CPU를 할당받을 프로세스를 선택하고 제어권을 넘겨받는 과정</li>\n</ul>\n<h3 id=\"입출력을-요청한-프로세스의-상태변화\" style=\"position:relative;\"><a href=\"#%EC%9E%85%EC%B6%9C%EB%A0%A5%EC%9D%84-%EC%9A%94%EC%B2%AD%ED%95%9C-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%9D%98-%EC%83%81%ED%83%9C%EB%B3%80%ED%99%94\" aria-label=\"입출력을 요청한 프로세스의 상태변화 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>입출력을 요청한 프로세스의 상태변화</h3>\n<ul>\n<li>디스크 입출력은 오랜 시간이 걸리기 때문에 이 시간동안 해당 프로세스는 봉쇄 상태가 된다.</li>\n<li>그 동안 준비 상태의 프로세스 들을 CPU 스캐줄러가 선정해 CPU를 할당하고 해당 프로세스는 실행 상태로 변경이 된다.</li>\n<li>입출력 요청 프로세스는 디스크 입출력 큐에 대기하다가 디스크 컨트롤러부터 서비스를 받는다.</li>\n<li>완료 후 디스크 컨트롤러가 CPU에게 인터럽트로 입출력 완료를 알린다.</li>\n<li>\n<p>CPU는 인터럽에 대한 루틴을 수행한다.</p>\n<ul>\n<li>이때 당시에 CPU에서 진행중이던 프로세스가 사용자모드에서 커널 모드로 바뀐다.</li>\n<li>관련이 없는 프로세스지만 해당 프로세스 중 인터럽트가 발생했기 때문에 해당 프로세스가 커널 모드로 진입했다고 판단하도록 한다.</li>\n</ul>\n</li>\n<li>봉쇄 상태의 프로세스는 준비 상태로 바뀌고, 로컬버퍼에 있는 내용을 메모리로 이동시키는 업무를 수행한다.</li>\n<li>인터럽트 처리 루틴이 완료되면 직전 프로세스가 다시 수행되거나 입출력 완료 프로세스의 우선순위가 높다면 해당 프로세스가 수행된다.</li>\n</ul>\n<br>\n<h2 id=\"-3-프로세스-제어블록\" style=\"position:relative;\"><a href=\"#-3-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%A0%9C%EC%96%B4%EB%B8%94%EB%A1%9D\" aria-label=\" 3 프로세스 제어블록 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 3. 프로세스 제어블록</h2>\n<ul>\n<li>\n<p>Process Control Block - 운영체제가 시스템 내의 프로세스들을 관리하기 위해 프로세스마다 유지하는 정보들을 담는 <strong>커널 내 자료구조</strong></p>\n<ul>\n<li>커널 메모리의 데이터 영역에 위치한다.</li>\n</ul>\n</li>\n<li>\n<p>다음 요소들로 구성되어 있다.</p>\n<ul>\n<li>\n<p>프로세스의 상태</p>\n<ul>\n<li>CPU를 할당해도 되는지 여부를 결정</li>\n</ul>\n</li>\n<li>\n<p>프로세스 카운터 값</p>\n<ul>\n<li>다음 수행할 명령어 위치 가리킴</li>\n</ul>\n</li>\n<li>\n<p>CPU 레지스터 값</p>\n<ul>\n<li>CPU 연산을 위해서 현 시점에서 레지스터에 특정 값을 저장</li>\n</ul>\n</li>\n<li>\n<p>CPU 스캐줄링 정보</p>\n<ul>\n<li>스캐줄링에 필요한 정보</li>\n</ul>\n</li>\n<li>\n<p>메모리 관리 정보</p>\n<ul>\n<li>메모리 할당에 필요한 정보</li>\n</ul>\n</li>\n<li>\n<p>자원 사용 정보</p>\n<ul>\n<li>사용자에게 자원 사용 요금을 계산하여 청구</li>\n</ul>\n</li>\n<li>\n<p>입출력 상태 정보</p>\n<ul>\n<li>프로세스가 오픈한 파일 정보 등 프로세스의 입출력 관련 상태 정보</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-4-문맥교환\" style=\"position:relative;\"><a href=\"#-4-%EB%AC%B8%EB%A7%A5%EA%B5%90%ED%99%98\" aria-label=\" 4 문맥교환 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 4. 문맥교환</h2>\n<ul>\n<li>\n<p>Context Switch - 하나의 사용자 프로세스로부터 다른 사용자 프로세스로 CPU의 제어권이 이양되는 과정</p>\n<ul>\n<li>타이머 인터럽트가 발생하면 직전 수행 프로세스의 문맥을 저장하고 새로운 프로세스에게 CPU를 이양한다.</li>\n</ul>\n</li>\n<li>\n<p>기존에 보유하고 있던 프로세스의 문맥 저장</p>\n<ul>\n<li>PC 값 등을 자신의 PCB에 저장</li>\n</ul>\n</li>\n<li>\n<p>새로 할당받은 프로세스</p>\n<ul>\n<li>저장했던 문맥을 PCB에서 하드웨어로 복원</li>\n</ul>\n</li>\n<li>타이머 인터럽트 외에도 실행 중이던 프로세스가 입출력 요청이나 다른 조건을 충족하지 못해서 CPU를 뺏기고 봉쇄상태가 될 때도 문맥교환이 발생한다.</li>\n<li>\n<p><strong>프로세스 실행 상태 중 인터럽트나 시스템 콜로 인해 CPU의 제어권이 운영체제로 넘어가면 실행 중이던 프로세스의 문맥을 일부 PCB에 저장하지만 이 과정은 문맥교환이라고 하지 않는다.</strong></p>\n<ul>\n<li>단순히 해당 프로세스의 모드가 사용자모드에서 커널모드로 바뀌는 것 뿐이다.</li>\n</ul>\n</li>\n<li>\n<p>모드변경보다 문맥교환이 훨씬 많은 오버헤드가 발생한다. 따라서 타이머의 단위가 작아 문맥교환이 지나치게 자주 일어나면 오버헤드가 커진다.</p>\n<ul>\n<li>하지만 단위가 너무 크면 시분할 시스템의 의미가 퇴색되므로 적절한 시간 할당이 중요하다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-5-프로세스를-스케줄링하기-위한-큐\" style=\"position:relative;\"><a href=\"#-5-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EB%A5%BC-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81%ED%95%98%EA%B8%B0-%EC%9C%84%ED%95%9C-%ED%81%90\" aria-label=\" 5 프로세스를 스케줄링하기 위한 큐 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 5. 프로세스를 스케줄링하기 위한 큐</h2>\n<ul>\n<li>\n<p>운영체제는 준비상태에 있는 프로세스들을 ready queue에 두고 줄 앞에 프로세스에게 CPU를 할당한다.</p>\n<ul>\n<li>줄을 세우는 방식은 CPU 스캐줄링 방식에 따라서 달라진다.</li>\n</ul>\n</li>\n<li>\n<p>운영체제 하드웨어 자원을 기다리는 프로세스를 위한 자원별 장치 큐 device queue가 있다.</p>\n<ul>\n<li>ex. 디스크 입출력 큐 disk I/O queue, 키보드 입출력 큐 등등</li>\n</ul>\n</li>\n<li>\n<p>소프트웨어 자원을 기다리기 위한 자원 큐도 있다.</p>\n<ul>\n<li>어떤 공유 데이터에 대한 접근 권한 등등</li>\n<li>일관성을 위해 해당 공유 데이터에 접근 중인 프로세스가 다 사용하고 반납할 때까지 접근 권한을 주면 안된다.</li>\n<li>이 관리를 자원 큐를 통해서 한다.</li>\n</ul>\n</li>\n<li>\n<p>이 모든 큐들은 커널의 데이터 영역에 둔다.</p>\n<ul>\n<li>프로세스의 CPU 대기, 입출력 대기 등의 정보를 커널이 총체적으로 관리한다.</li>\n</ul>\n</li>\n<li>\n<p>작업 큐 (job queue) - 시스템 내의 모든 프로세스를 관리하기 위한 큐로 프로세스의 상태와 무관하게 현재 시스템 내에 있는 모든 프로세스가 작업 큐에 속한다.</p>\n<ul>\n<li>작업 큐에 있다고 반드시 메모리가 있는 것은 아니다.</li>\n<li>작업 큐가 가장 넓은 개념이고 준비 큐와 장치큐이 있는 프로세스는 모두 작업 큐에 속해있다.</li>\n</ul>\n</li>\n<li>큐는 각 프로세스의 PCB를 연결 리스크 형태로 관리하고 포인터로 순서를 정한다.</li>\n</ul>\n<br>\n<h2 id=\"-6-스케줄러\" style=\"position:relative;\"><a href=\"#-6-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%9F%AC\" aria-label=\" 6 스케줄러 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 6. 스케줄러</h2>\n<ul>\n<li>\n<p>스캐줄러 - 어떤 프로세스에게 자원을 할당할지 결정하는 운영체제 커널의 코드</p>\n<ul>\n<li>장기 스캐줄러와 단기 스케줄러</li>\n</ul>\n</li>\n<li>\n<p>장기 스캐줄러 (long term scheduler) - 작업 스캐줄러 (job scheduler) 이며 어떤 프로세스를 준비 큐에 진입시킬지 결정</p>\n<ul>\n<li>CPU에 실행되기 위해서는 프로세스가 메모리를 보유해야하므로 장기 스캐줄러는 프로세스에 메모리 보유 문제에 관여한다.</li>\n<li>수십 초 내지 수 분 단위로 가끔 호출되므로 상대적으로 느린 것이 허용된다.</li>\n<li>메모리에 동시에 올라가 있는 프로세스의 수 (degree of multiprogramming)을 조절한다.</li>\n<li>하지만 현대의 시분할 시스템은 메모리가 훨씬 커서 장기 스케줄러 없어 바로 프로세스에 메모리를 할당해 준비큐에 넣어준다.</li>\n</ul>\n</li>\n<li>\n<p>단기 스캐줄러 (short term scheduler) - 준비 프로세스 중 어떤 프로세스를 다음에 실행상태로 만들지 결정</p>\n<ul>\n<li>준비 큐에 있는 것들 중 어떤 프로세스에게 CPU를 할당할지 결정하는 것</li>\n<li>타이머 인터럽트 발생시 단기 스캐줄러가 호출된다.</li>\n<li>밀리초 단위로 빈번하게 호출이 되므로 수행 속도가 빨라야 한다.</li>\n</ul>\n</li>\n<li>\n<p>중기 스캐줄러 (medium term scheduling) - 메모리에 적재된 프로세스의 수를 동적으로 조절</p>\n<ul>\n<li>너무 많은 프로세스가 메모리에 적재되어 시스템 효율이 떨어지는 것을 관리한다.</li>\n<li>메모리에 당장 필요한 프로세스의 주소 공간도 모자라면 디스크 입출력이 수시로 발생하여 시스템의 성능이 저하된다.</li>\n<li>중기 스캐줄러는 이 경우 메모리의 프로세스 중 일부를 선정 해 메모리를 뺏고 해당 내용을 스왑 영역에 저장한다 ⇒ swap out</li>\n<li>프로세스당 보유 메모리가 지나치게 적다면 일부 프로세스를 메모리에게 디스크로 스왑 아웃시키는 역할을 수행한다.</li>\n<li>\n<p>봉쇄 상태에 있는 프로세스들이 가장 먼저 스왑 아웃된다. 그럼에도 부족하다면 타이머 인터럽트 발생 후 준비 큐로 이동하는 프로세스들을 추가적으로 스왑 아웃한다.</p>\n<ul>\n<li>다시 CPU를 할당 받을 때까지 시간이 걸리기 때문이다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>프로세스의 중지(suspended, stopped) 상태</p>\n<ul>\n<li>외부적인 이유로 프로세스의 수행이 정지된 상태</li>\n<li>디스크로 스왑 아웃된 프로세스의 상태이다.</li>\n<li>중지준비 상태 - 준비 상태의 프로세스가 디스크로 스왑 아웃된 것</li>\n<li>\n<p>중지봉쇄 상태 - 봉쇄 상태의 프로세스가 디스크로 스왑 아웃된 것</p>\n<ul>\n<li>중지봉쇄 상태에서 해당 작업이 끝나면 중지준비 상태로 변경된다.</li>\n</ul>\n</li>\n<li>이 경우들은 프로세스가 메모리를 보유하지 않고 통째로 디스크로 스왑 아웃 된 상태이다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-7-프로세스의-생성\" style=\"position:relative;\"><a href=\"#-7-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%9D%98-%EC%83%9D%EC%84%B1\" aria-label=\" 7 프로세스의 생성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 7. 프로세스의 생성</h2>\n<ul>\n<li>시스템 부팅된 후 최초 프로세스는 운영체제가 직접 생성한다.</li>\n<li>\n<p>이후부터는 이미 존재하는 프로세스가 다른 프로세스를 복제 생성한다.</p>\n<ul>\n<li>생성하는 프로세스를 부모 프로세스, 생성되는 프로세스를 자식 프로세스라고 한다.</li>\n</ul>\n</li>\n<li>\n<p>자식 프로세스가 먼저 죽고 부모 프로세스가 이에 대한 처리를 한다.</p>\n<ul>\n<li>부모 프로세스가 종료되기 위해서는 생성된 자식 프로세스가 모두 종료된 후에야 종료될 수 있다.</li>\n</ul>\n</li>\n<li>\n<p>프로세스의 자원</p>\n<ul>\n<li>\n<p>운영체제와 자원의 종료에 따라 획득하는 방식이 다르다.</p>\n<ul>\n<li>운영체제로 직접 자원 할당</li>\n<li>부모 프로세스와 자원을 공유하여 사용</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>프로세스 수행 모델</p>\n<ul>\n<li>\n<p>부모와 자식이 공존하며 수행</p>\n<ul>\n<li>부모와 자식이 CPU를 획득하기 위해 경쟁함</li>\n</ul>\n</li>\n<li>\n<p>자식이 종료(terminated) 될 때까지 부모가 기다리는(wait) 모델</p>\n<ul>\n<li>자식이 종료될 때까지 부모 프로세스는 봉쇄 상태에 머물다가 자식 종료 후 부모 프로세스가 준비 상태가 되어 CPU를 획득할 수 있음</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>프로세스가 생성될 때 독자적인 주소 공간을 갖는다.</p>\n<ul>\n<li>\n<p>자식 프로세스가 생성될 때 부모 프로세스의 주소 공간을 복사하여 별도의 주소 공간을 생성하고 새로운 프로그램 내용을 덮어씌워 실행한다.</p>\n<ul>\n<li>유닉스에서 <code class=\"language-text\">fork()</code> 시 자식 프로세스가 생성되고 부모와 똑같은 커널 내 정보와 주소 공간 정보를 가진 상태로 복사된다. (프로세스 id는 다르다)</li>\n<li>이후 <code class=\"language-text\">exec()</code> 시 새로운 주소 공간을 덮어씌운다.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"프로세스의-종료\" style=\"position:relative;\"><a href=\"#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%9D%98-%EC%A2%85%EB%A3%8C\" aria-label=\"프로세스의 종료 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>프로세스의 종료</h3>\n<ul>\n<li>\n<p>자발적 종료</p>\n<ul>\n<li>코드의 마지막에 <code class=\"language-text\">exit()</code>라는 시스템 콜을 통해 (없다면 컴파일러가 자동으로 삽입) 종료하고 운영체제는 해당 프로세스로부터 자원을 회수한다.</li>\n</ul>\n</li>\n<li>\n<p>비자발적 종료</p>\n<ul>\n<li>부모 프로세스가 자식 프로세스의 수행을 강제로 종료하며 <code class=\"language-text\">abort()</code>로 이루어진다.</li>\n<li>자식 프로세스가 할당 자원의 한계 이상의 자원을 요구할 때 </li>\n<li>자식 프로세스에게 할당된 작업이 필요하지 않을 때 </li>\n<li>부모 프로세스가 종료(exit) 되는 경우에 발생한다. </li>\n</ul>\n</li>\n<li>종료되는 프로세스는 자식 프로세스를 계속 실행하기 위해서 종료되지 않을 다른 프로세스의 양자로 보내어 계속 수행할 수 있도록 할 수 있다.</li>\n</ul>\n<h3 id=\"자식-프로세스-생성\" style=\"position:relative;\"><a href=\"#%EC%9E%90%EC%8B%9D-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%83%9D%EC%84%B1\" aria-label=\"자식 프로세스 생성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>자식 프로세스 생성</h3>\n<ul>\n<li>\n<p><code class=\"language-text\">fork()</code> 시스템 콜로 CPU제어권을 커널로 넘겨 fork() 호출 프로세스를 복제해 자식 프로세스를 생성</p>\n<ul>\n<li>\n<p>부모와 모든 문맥(주소 공간, PC, 레지스터 상태, PCB, 커널스택 등)을 동일하게 가진 자식 프로세스 생성한다.</p>\n<ul>\n<li>따라서 자식 프로세스는 부모 프로세스의 현재 수행 시점부터 수행하게 된다. (PC 등의 값을 그대로 복제하므로)</li>\n</ul>\n</li>\n<li>식별자는 부모 프로세스와 다르다.</li>\n<li>함수의 결과값은 자식은 0, 부모는 양수이다. 이 값으로 자식과 부모 프로세스를 분기할 수 있다. 하지만 여전히 분기문을 가진 코드 또한 동일한 것을 지닌 상태이다.</li>\n</ul>\n</li>\n<li>자식에게 독자적인 프로그램 수행이 가능하도록 유닉스에서 새로운 주소 공간에 새로운 프로그램을 <code class=\"language-text\">exec()</code> 를 통해 덮어씌울 수 있도록 한다.</li>\n<li>\n<p><code class=\"language-text\">fork()</code>, <code class=\"language-text\">exec()</code>, <code class=\"language-text\">exit()</code> , <code class=\"language-text\">wait()</code>는 모두 특권명령이다.</p>\n<ul>\n<li><code class=\"language-text\">wait()</code>은 자식 프로세스가 종료될 때까지 부모 프로세스를 봉쇄 상태에 머무르게 하는 것이다.</li>\n<li>이것으로 자식과 부모의 동기화 (synchronization)이 가능하다.</li>\n<li>자식 프로세스가 종료되면 다시 준비 큐에 삽입되어 CPU 할당 받을 수 있다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-8-프로세스-간의-협력\" style=\"position:relative;\"><a href=\"#-8-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EA%B0%84%EC%9D%98-%ED%98%91%EB%A0%A5\" aria-label=\" 8 프로세스 간의 협력 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 8. 프로세스 간의 협력</h2>\n<ul>\n<li>부모 프로세스와 자식 프로세스는 독자적인 메모리 구조를 가지므로 독립적인 관계가 된다.</li>\n<li>프로세스간 협력할 때 서로 주소 공간을 참조하지 않으면서 정보를 주고받을 수 있는 매커니즘이 필요하다.</li>\n<li>\n<p>IPC(Inter-Process Communication) - 운영체제가 제공하는 하나의 컴퓨터 안에서 실행 중인 프로세스 간 협력 매커니즘</p>\n<ul>\n<li>프로세스간의 통신(communication)과 함께 공유 데이터의 일관성을 위한 동기화를 보장해주어야 한다.</li>\n<li>\n<p>메세지 전달(message passing)과 공유메모리(shared memory) 방식이 있다.</p>\n<ul>\n<li>차이는 shared data가 있는 것과 없는 것이다.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"메세지-전달\" style=\"position:relative;\"><a href=\"#%EB%A9%94%EC%84%B8%EC%A7%80-%EC%A0%84%EB%8B%AC\" aria-label=\"메세지 전달 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>메세지 전달</h3>\n<ul>\n<li>프로세스간 공유 데이터가 없이 메세지를 주고받으며 통신한다. 메세지 전달은 직접하지 못하고 커널이 전달한다.</li>\n<li>커널이 제공하는 send(), receive() 연산으로 시스템 콜 방식으로 요청해 메세지를 전달한다.</li>\n<li>메세지를 전달하는 연산은 특권명령이다.</li>\n<li>\n<p>통신하기 원하는 두 프로세스는 communication link를 생성하고 send(), receive()를 통해 메세지를 주고 받는다.</p>\n<ul>\n<li>communication link는 물리적인 방법, 논리적인 방법 두 가지로 구현할 수 있다.</li>\n</ul>\n</li>\n<li>\n<p>직접 프로세스에게 전달하는 방식과 메일 박스를 통해 간접적으로 전달하는 방식으로 나뉜다.</p>\n<ol>\n<li>\n<p>직접 통신 (direct communication)</p>\n<ol>\n<li>통신하려는 프로세스를 직접 명시하고 받는 프로세스도 직접 명시한다. </li>\n<li>커뮤니케이션 링크는 자동으로 생성되고 하나의 링크는 한 쌍의 프로세스에게 할당된다. </li>\n<li>대부분의 링크는 양방향이며 단 하나의 링크만 서로 존재한다. </li>\n</ol>\n</li>\n<li>\n<p>간접 통신 (indirect communication)</p>\n<ol>\n<li>메일박스 또는 포트로 메시지를 전달받는다. 메일박스는 고유의 id가 있어서 해당 메일박스를 공유하는 프로세스들끼리만 통신을 할 수 있다. </li>\n<li>커뮤니케이션 링크는 메일박스를 공유하는 경우에만 생성된다. </li>\n<li>하나의 링크가 여러 프로세스에게 할당될 수 있고, 각 프로세스 쌍은 여러 링크를 공유할 수 있다. </li>\n<li>링크는 단방향, 양방향일 수 있다. </li>\n<li>새로운 메일박스를 생성하는 연산, 메세지 send(), receive() 연산, 메일박스 삭제 연산을 할 수 있다. </li>\n<li>간접통신에서 메세지 대상 및 수신자는 A라는 메일박스로 통일된다. </li>\n<li>\n<p>메일박스 공유로 수신 대상의 혼란을 제어하기 위해 2개의 프로세스에게만 링크를 할당할 수 있다. </p>\n<ul>\n<li>또는 링크의 receive() 연산을 매 시점 하나의 프로세스만 수행할 수 있도록 한다.</li>\n<li>시스템이 메세지 수신자를 임의로 결정해 누가 받았는지 송신자에게 통신해준다.</li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"공유메모리-shared-memory\" style=\"position:relative;\"><a href=\"#%EA%B3%B5%EC%9C%A0%EB%A9%94%EB%AA%A8%EB%A6%AC-shared-memory\" aria-label=\"공유메모리 shared memory permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>공유메모리 shared memory</h3>\n<ul>\n<li>프로세스들의 메모리 주소 공간 일부를 공유한다.</li>\n<li>각 프로세스는 독립된 주소 공간을 가지고 있다. 이 주소 공간(가상 메모리)가 물리 메모리로 매핑될 때 공유메모리 주소 영역은 동일한 물리 메모리 영역으로 매핑된다.</li>\n<li>통신이 쉬운 인터페이스이지만 데이터 일관성 문제가 발생할 수 있다. 이 문제는 커널이 책임지지 않으며 프로세스들끼리 직접 동기화 문제를 해결해야 한다.</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#-1-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%9D%98-%EA%B0%9C%EB%85%90\">🌩 1. 프로세스의 개념</a></li>\n<li>\n<p><a href=\"#-2-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%9D%98-%EC%83%81%ED%83%9C\">🌩 2. 프로세스의 상태</a></p>\n<ul>\n<li><a href=\"#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%9D%98-%EC%83%81%ED%83%9C-%ED%9D%90%EB%A6%84\">프로세스의 상태 흐름</a></li>\n<li><a href=\"#%EC%9E%85%EC%B6%9C%EB%A0%A5%EC%9D%84-%EC%9A%94%EC%B2%AD%ED%95%9C-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%9D%98-%EC%83%81%ED%83%9C%EB%B3%80%ED%99%94\">입출력을 요청한 프로세스의 상태변화</a></li>\n</ul>\n</li>\n<li><a href=\"#-3-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%A0%9C%EC%96%B4%EB%B8%94%EB%A1%9D\">🌩 3. 프로세스 제어블록</a></li>\n<li><a href=\"#-4-%EB%AC%B8%EB%A7%A5%EA%B5%90%ED%99%98\">🌩 4. 문맥교환</a></li>\n<li><a href=\"#-5-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EB%A5%BC-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81%ED%95%98%EA%B8%B0-%EC%9C%84%ED%95%9C-%ED%81%90\">🌩 5. 프로세스를 스케줄링하기 위한 큐</a></li>\n<li><a href=\"#-6-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%9F%AC\">🌩 6. 스케줄러</a></li>\n<li>\n<p><a href=\"#-7-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%9D%98-%EC%83%9D%EC%84%B1\">🌩 7. 프로세스의 생성</a></p>\n<ul>\n<li><a href=\"#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%9D%98-%EC%A2%85%EB%A3%8C\">프로세스의 종료</a></li>\n<li><a href=\"#%EC%9E%90%EC%8B%9D-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%83%9D%EC%84%B1\">자식 프로세스 생성</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-8-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EA%B0%84%EC%9D%98-%ED%98%91%EB%A0%A5\">🌩 8. 프로세스 간의 협력</a></p>\n<ul>\n<li><a href=\"#%EB%A9%94%EC%84%B8%EC%A7%80-%EC%A0%84%EB%8B%AC\">메세지 전달</a></li>\n<li><a href=\"#%EA%B3%B5%EC%9C%A0%EB%A9%94%EB%AA%A8%EB%A6%AC-shared-memory\">공유메모리 shared memory</a></li>\n</ul>\n</li>\n</ul>\n</div>","excerpt":"다음은 반효경 교수님의 ‘운영체제와 정보기술의 원리’ CH5. 프로세스 관리를 읽고 정리한 내용입니다 🙌 🌩 1. 프로세스의 개념 프로세스란 실행 중인 프로그램이다. 프로세스는 CPU를 획득해서 코드를 수행하고 CPU를 반환하고 입출력 작업을 수행하기도 한다. 프로세스 문맥 (context) - 프로세스가 현재 어떤 상태에서 수행되고 있는 규명하기 위해 필요한 정보 여러 프로세스가 CPU를 사용하면서 중간에 CPU를 다른 프로세스에게 넘겨야 한다. 이때 다시 이어서하기 위한 필요 정보가 있는데 그것을 프로세스 문맥이라고 한다. 프로세스의 주소 공간, 레지스터의 값, 시스템 콜을 통해 커널에서 수행한 일의 상태, 프로세스에 대해 커널이 관리하고 있는 여러 정보들을 포함한다. 프로세스 문맥은 3가지로 나뉜다. 하드웨어 문맥 CPU의 수행 상태를 나타낸다.  프로그램 카운터 값, 각종 레지스터에 저장하고 있는 값들이다.  프로세스의 주소 공간 코드, 데이터, 스택으로 이루어진 프로세스의…","frontmatter":{"date":"October 13, 2021","title":"운영체제와 정보기술의 원리 - CH5. 프로세스 관리","categories":"운영체제 책","author":"코다","emoji":"🧁"},"fields":{"slug":"/operating-system-4/"}},"next":{"id":"c8678391-1095-5db1-99f3-e36da5f03ed2","html":"<blockquote>\n<p>다음은 반효경 교수님의 ‘운영체제와 정보기술의 원리’ <em>CH4. 프로그램의 구조와 실행</em>를 읽고 정리한 내용입니다 🙌</p>\n</blockquote>\n<br>\n<br>\n<h2 id=\"-1-프로그램의-구조와-인터럽트\" style=\"position:relative;\"><a href=\"#-1-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EC%9D%98-%EA%B5%AC%EC%A1%B0%EC%99%80-%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8\" aria-label=\" 1 프로그램의 구조와 인터럽트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 1. 프로그램의 구조와 인터럽트</h2>\n<ul>\n<li>\n<p>CPU에서 프로그램 명령을 실행하기 위해서는 프로그램 명령을 담은 주소 영역이 메모리에 올라가야한다.</p>\n<ul>\n<li>주소 영역은 code(프로그램 함수들이 기계어로 변환되어 저장), data(전역 변수 등 프로그램이 사용하는 데이터 저장), stack(함수 복귀 주소 및 데이터 임시 저장)으로 구분된다.</li>\n<li>함수를 호출하여 새로운 함수 위치로 점프할 때 다시 돌아올 주소를 스택 영역에 저장한다.</li>\n</ul>\n</li>\n<li>\n<p>인터럽트 동작 원리도 함수의 호출과 비슷하다.</p>\n<ul>\n<li>인터럽트 발생시 실행중이던 명령어의 위치를 저장한다. 처리루틴 후 해당 주소로 돌아와서 수행을 이어간다.</li>\n<li>이 주소는 운영체제가 관리하는 PCB에 저장된다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-2-컴퓨터-시스템의-작동-개요\" style=\"position:relative;\"><a href=\"#-2-%EC%BB%B4%ED%93%A8%ED%84%B0-%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98-%EC%9E%91%EB%8F%99-%EA%B0%9C%EC%9A%94\" aria-label=\" 2 컴퓨터 시스템의 작동 개요 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 2. 컴퓨터 시스템의 작동 개요</h2>\n<ul>\n<li>CPU는 매 시점 특정 주소에 존재하는 명령을 읽어서 그대로 실행한다.</li>\n<li>\n<p>CPU가 실행해야할 명령의 메모리 위치는 Program Counter라는 레지스터에 저장된다. 주로 PC는 바로 다음 주소를 가리켜 코드가 순차적으로 실행되도록 한다.</p>\n<ul>\n<li>반복문이나 함수호출 등의 주소이동이 있는 경우는 해당 주소를 가리키게 된다.</li>\n</ul>\n</li>\n<li>프로그램 실행 중 입출력 등의 다른 연산이 이루어지면 각 장치의 컨트롤러와 로컬버퍼가 함게 동작하여 연산을 처리한다.</li>\n<li>만일 PC가 메모리의 운영체제 부분을 가리키고 있다면 CPU는 커널 모드에서 수행중이라고 한다.</li>\n<li>\n<p>CPU가 실행하는 명령은 일반명령과 특권명령을 나뉜다.</p>\n<ul>\n<li>일반명령은 모든 프로그램에서 수행하는 명령이다. 메모리 자료를 읽어서 CPU 연산 후 결과를 메모리에 쓴다.</li>\n<li>특권명령은 보안이 필요한 명령으로 각종 장치에 접근한다. 운영체제만 수행하며 모드비트로 구분된다.</li>\n</ul>\n</li>\n<li>\n<p>특권명령은 디스크파일접근, 화면출력 등을 수행할 수 있다. 사용자는 운영체제에 이 명령을 요청하여 대행하도록 system call을 한다.</p>\n<ul>\n<li>system call이 호출되면 CPU는 해당 장치의 컨트롤러에 요청을 하고 데이터가 해당 장치의 로컬 버퍼에 담기면 컨트롤러가 CPU에 인터럽트를 발생시켜 작업 완료를 알린다.</li>\n</ul>\n</li>\n<li>\n<p>CPU는 매 명령 수행 후 인터럽트 라인을 체크해 인터럽트가 일어났는지 확인한다.</p>\n<ul>\n<li>인터럽트 라인은 종류마다 다르다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-3-프로그램의-실행\" style=\"position:relative;\"><a href=\"#-3-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EC%9D%98-%EC%8B%A4%ED%96%89\" aria-label=\" 3 프로그램의 실행 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 3. 프로그램의 실행</h2>\n<ul>\n<li>\n<p>프로그램이 실행된다는 것은</p>\n<ol>\n<li>실행파일이 메모리에 적재된다. </li>\n<li>프로그램이 CPU를 할당받고 명령을 수행하고 있다. </li>\n</ol>\n<p>라는 두가지 의미를 가진다. </p>\n</li>\n<li>1번째 의미로 여러가지 프로그램이 메모리에 올라가 있을 수 있으니 <strong>여러 프로그램이 동시에 실행된다</strong>라고 할 수 있다.</li>\n<li>프로그램이 메모리에 적재될 때 일부분만 메모리에 나머지는 디스크에 내려가 있다.</li>\n<li>\n<p><strong>프로그램마다 독자적</strong>으로 주소공간을 가져 코드, 데이터, 스택 영역등으로 나뉜다.</p>\n<ul>\n<li>해당 공간을 가상메모리 virtual memory, 논리적 메모리 logical memory 라고 부른다.</li>\n</ul>\n</li>\n<li>\n<p>운영체제의 경우도 하나의 프로그램이다.</p>\n<ul>\n<li>각각의 코드, 데이터 스택주소 공간을 가지고 있다.</li>\n<li>하드웨어와 사용자의 중간이기 때문에 1) CPU, 메모리 자원을 관리하는 부분과 2) 사용자에게 편리한 인터페이스 제공하기위한 부분이 나뉜다.</li>\n<li>시스템 콜, 인터럽트 처리 부분도 포함된다.</li>\n</ul>\n</li>\n<li>\n<p>커널의 데이터 영역 - 각종 자원을 관리하는 자료구조가 저장</p>\n<ul>\n<li>CPU, 메모리 하드웨어 자원 관리</li>\n<li>\n<p>수행 중인 프로그램(소프트웨어) 관리 ⇒ 수행중인 프로그램을 프로세스라고 부른다.</p>\n<ul>\n<li>각 프로세스의 상태, CPU 사용 정보, 메모리 사용 정보 등을 담은 PCB를 둔다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>커널의 스택 영역 - 함수호출 시 복귀 주소를 저장</p>\n<ul>\n<li>\n<p>현재 수행 중인 프로세스마다 별도의 스택을 두어 관리</p>\n<ul>\n<li>프로세스마다 특권명령을 수행하려고 system call을 하고 system call 안에서 다른 함수를 호출할 경우 복귀 주소가 커널 내 주소가 되기 때문</li>\n<li>커널은 공유 코드이므로 각 사용자 프로그램이 커널 함수에 접근할 수 있으므로 일관성 유지를 위해 각 프로세스마다 스택을 따로 둠.</li>\n</ul>\n</li>\n<li>\n<p>요약</p>\n<ul>\n<li>사용자 프로그램 내에서 함수호출 시 해당 프로그램의 스택에 복귀 주소를 저장</li>\n<li>시스템 콜이나 인터럽트 발생으로 운영체제가 제어하면 프로그램 복귀 정보를 PCB에 저장</li>\n<li>\n<p>커널 내에서 이루어지는 함수호출은 각 프로세스의 커널스택에 복귀 정보를 저장</p>\n<ul>\n<li>직전에 수행중이던 프로세스의 커널스택에 저장</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-4-사용자-프로그램이-사용하는-함수\" style=\"position:relative;\"><a href=\"#-4-%EC%82%AC%EC%9A%A9%EC%9E%90-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EC%9D%B4-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%ED%95%A8%EC%88%98\" aria-label=\" 4 사용자 프로그램이 사용하는 함수 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 4. 사용자 프로그램이 사용하는 함수</h2>\n<ol>\n<li>\n<p>사용자정의 함수 - 프로그래머 본인이 작성</p>\n<ol>\n<li>코드 영역에 기계어 형태 </li>\n</ol>\n</li>\n<li>\n<p>라이브러리 함수 - 다른 누군가 미리 작성</p>\n<ol>\n<li>코드 영역에 기계어 형태 </li>\n</ol>\n</li>\n<li>\n<p>커널 함수 - 운영체제 커널의 코드에 정의된 함수 </p>\n<ul>\n<li>system call 함수, 인터럽트 처리 함수</li>\n<li>printf()와 같은 함수는 라이브러리 함수고 내부에서 system call을 한다.</li>\n<li>system call은 사용자가 운영체제 CPU를 넘겨서 실행하는 것이다.</li>\n<li>system call 또한 인터럽트 라인을 세팅하는 방법을 사용한다.</li>\n</ul>\n</li>\n</ol>\n<br>\n<h2 id=\"-5-인터럽트\" style=\"position:relative;\"><a href=\"#-5-%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8\" aria-label=\" 5 인터럽트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 5. 인터럽트</h2>\n<ul>\n<li>CPU는 대부분 명령을 순차적으로 진행한다. 매 명령마다 인터럽트 라인을 체크하고 발생했다면 제어권을 운영체제에게 넘겨 인터럽트 처리루틴에 따라 처리하고 다시 돌아온다.</li>\n<li>\n<p>인터럽트 처리 중 다른 인터럽트가 발생 한 경우</p>\n<ul>\n<li>원칙적으로 위 경우는 데이터 일관성을 위해 허용하지 않는다.</li>\n<li>예외적인 경우는 인터럽트 처리루틴 중 더 시급하거나 CPU가 당장 필요한 일이 발생한 경우이다.</li>\n</ul>\n</li>\n<li>인터럽트마다 중요도가 다르므로 중요도가 더 높은 인터럽트는 발생을 허용해 우선순위가 높은 인터럽트부터 처리하도록 한다.</li>\n</ul>\n<br>\n<h2 id=\"-6-시스템-콜\" style=\"position:relative;\"><a href=\"#-6-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%BD%9C\" aria-label=\" 6 시스템 콜 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 6. 시스템 콜</h2>\n<ul>\n<li>\n<p>시스템 콜은 프로세스가 가지고 있는 자신의 주소 공간 내의 호출이 아닌 커널 (다른 프로그램 주소 공간) 함수를 호출하는 것이다.</p>\n<ul>\n<li>이 경우 프로그램 자신이 스스로 인터럽트 라인을 세팅한다.</li>\n</ul>\n</li>\n<li>입출력 시스템 콜인 경우 CPU 명령 수행보다 많은 시간이 소요되므로 CPU가 그 시간동안 대기하고 있는 것은 자원의 낭비이다.</li>\n<li>또한 입출력을 요청한 프로그램에게 CPU를 다시 넘겨주는 것은 필요한 데이터가 없으므로 옳지 않다.</li>\n<li>따라서 한 프로그램이 입출력을 요청한다면 다른 프로그램에게 제어권을 넘겨주어 실행되도록 한다.</li>\n<li>\n<p>입출력 작업이 완료되었을 경우 인터럽트 처리루틴</p>\n<ul>\n<li>해당 인터럽트는 하드웨어 인터럽트이다.</li>\n<li>로컬버퍼의 내용을 메모리로 복사하고 해당 프로세스가 다시 CPU를 획득할 수 있는 권한을 준다.</li>\n<li>해당 프로세스가 작업 큐에 삽입되어 제어권이 돌아오게 한다.</li>\n</ul>\n</li>\n<li>\n<p>정리 - 프로세스가 CPU를 빼앗기는 경우 2가지</p>\n<ol>\n<li>타이머에 의한 인터럽트 발생 → 한 프로세스의 독점을 방지</li>\n<li>시스템 콜에 의한 인터럽트 발생 → 운영체제 함수 호출이 필요한 경우 실행 </li>\n</ol>\n</li>\n</ul>\n<br>\n<h2 id=\"-7-프로세스의-두-가지-실행-상태\" style=\"position:relative;\"><a href=\"#-7-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%9D%98-%EB%91%90-%EA%B0%80%EC%A7%80-%EC%8B%A4%ED%96%89-%EC%83%81%ED%83%9C\" aria-label=\" 7 프로세스의 두 가지 실행 상태 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 7. 프로세스의 두 가지 실행 상태</h2>\n<ul>\n<li>사용자 모드에서 실행상태 (user mode running) - 자신의 주소 공간의 코드 실행</li>\n<li>\n<p>커널 모드에서 실행상태 (kernel mode running) - 커널의 시스템 콜 함수 실행</p>\n<ul>\n<li>이 경우에도 커널이 실행 상태에 있다고 하는 것이 아니라 해당 프로세스가 실행상태에 있다고 한다.</li>\n<li>해당 프로세스가 필요한 일을 처리하는 것이기 때문이다.</li>\n<li><em>프로세스 A가 커널모드에 실행 중</em> 이라고 표현한다.</li>\n</ul>\n</li>\n<li>프로그램 실행이 끝날 때는 커널 모드로 프로그램을 종료한다.</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#-1-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EC%9D%98-%EA%B5%AC%EC%A1%B0%EC%99%80-%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8\">🌩 1. 프로그램의 구조와 인터럽트</a></li>\n<li><a href=\"#-2-%EC%BB%B4%ED%93%A8%ED%84%B0-%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98-%EC%9E%91%EB%8F%99-%EA%B0%9C%EC%9A%94\">🌩 2. 컴퓨터 시스템의 작동 개요</a></li>\n<li><a href=\"#-3-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EC%9D%98-%EC%8B%A4%ED%96%89\">🌩 3. 프로그램의 실행</a></li>\n<li><a href=\"#-4-%EC%82%AC%EC%9A%A9%EC%9E%90-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EC%9D%B4-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%ED%95%A8%EC%88%98\">🌩 4. 사용자 프로그램이 사용하는 함수</a></li>\n<li><a href=\"#-5-%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8\">🌩 5. 인터럽트</a></li>\n<li><a href=\"#-6-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%BD%9C\">🌩 6. 시스템 콜</a></li>\n<li><a href=\"#-7-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%9D%98-%EB%91%90-%EA%B0%80%EC%A7%80-%EC%8B%A4%ED%96%89-%EC%83%81%ED%83%9C\">🌩 7. 프로세스의 두 가지 실행 상태</a></li>\n</ul>\n</div>","frontmatter":{"date":"October 12, 2021","title":"운영체제와 정보기술의 원리 - CH4. 프로그램의 구조와 실행","categories":"운영체제 책","author":"코다","emoji":"🧁"},"fields":{"slug":"/operating-system-3/"}},"prev":{"id":"5c1b47d1-8778-57cd-9be5-9beb636f6354","html":"<h2 id=\"-intro\" style=\"position:relative;\"><a href=\"#-intro\" aria-label=\" intro permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>💡 Intro</h2>\n<ul>\n<li>진행 중인 <a href=\"https://github.com/woowacourse-teams/2021-pick-git\">프로젝트</a>에서 구현한 웹 어플리케이션이 어느 정도의 부하를 견딜 수 있는지에 대한 성능테스트를 진행했다. </li>\n<li>프로젝트는 개발자를 타켓으로 한 깃헙 레포지토리를 연동한 게시물을 업로드하여 개발자들이 자신의 작업을 공유하고 다른 이들의 프로젝트를 캐줄얼하게 엿볼 수 있는 SNS형 웹 어플리케이션이다. </li>\n<li>웹 어플리케이션에 들어가자마자 최신순으로 정렬된 게시물 피드를 볼 수 있다. (비로그인/로그인 모두 가능)</li>\n<li>홈피드 게시물 조회 성능테스트를 진행, 병목 지점을 분석하고 개선하는 과정을 따라가보자. </li>\n</ul>\n<br>\n<br>\n<h2 id=\"-사전-작업\" style=\"position:relative;\"><a href=\"#-%EC%82%AC%EC%A0%84-%EC%9E%91%EC%97%85\" aria-label=\" 사전 작업 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 사전 작업</h2>\n<h3 id=\"테스트-더미-데이터-입력\" style=\"position:relative;\"><a href=\"#%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%8D%94%EB%AF%B8-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%9E%85%EB%A0%A5\" aria-label=\"테스트 더미 데이터 입력 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>테스트 더미 데이터 입력</h3>\n<ul>\n<li>테스트를 진행하기 위해서는 실제 운영환경과 최대한 유사한 환경에서 테스트하는 것이 중요하다. </li>\n<li>운영환경과 유사한 환경이라고 하면 크게 1) 인프라 구조 2) 데이터 두 가지가 있다. </li>\n<li>먼저 대량의 더미 데이터를 입력하도록 한다. (팀원 케빈이 수고해주었다 !! 👍)</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"> * 테스트 데이터 : 게시물 100만 / 유저 20만\n *                 태그 10만 (1개당 게시물 10개)\n *                 댓글 100만 (게시물당 1개)\n *\n * 테스트 용이성을 위해 유저 1명 이름은 tester로 명명해 저장\n * 테스트 용이성을 위해 태그 3개 이름은 java, javascript, spring로 명명해 저장</code></pre></div>\n<h3 id=\"mariadb-쿼리-캐시-끄기\" style=\"position:relative;\"><a href=\"#mariadb-%EC%BF%BC%EB%A6%AC-%EC%BA%90%EC%8B%9C-%EB%81%84%EA%B8%B0\" aria-label=\"mariadb 쿼리 캐시 끄기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>MariaDB 쿼리 캐시 끄기</h3>\n<ul>\n<li>\n<p>왜 쿼리 캐시를 껐을까?</p>\n<ul>\n<li>실제 어플리케이션에서는 query cache 설정이 켜져있음에도 불구하고 cache 설정을 끈 이유는 실제 환경에서는 많은 유저들이 여러 태그를 검색하여 매번 다양한 쿼리가 실행되지만 테스트 환경에서는 3개의 태그를 랜덤으로 실행하기 때문에 캐시 적중률이 실제 환경보다 높다. 따라서 db 쿼리캐시를 꺼서 최대한 실제 환경과 맞춰주도록 한다. </li>\n<li>참고로 MySQL 8.0 부터는 쿼리 캐시 기능이 꺼져있다고 한다. </li>\n<li>또한 여전히 os 측에서 하는 memory 캐시 영향이 있지만 제어하기 어려운 부분이므로 우선 넘어가도록 한다. </li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>쿼리 캐시 확인</p>\n</blockquote>\n<p align=\"center\"><img width=\"85%\" src=\"https://user-images.githubusercontent.com/63405904/137438052-8604eb7d-a892-4a2b-9ca2-064ef832743b.png\"></p>\n<p align=\"center\"><img width=\"85%\" src=\"https://user-images.githubusercontent.com/63405904/137438572-2c20b02c-9cfb-4556-a9b8-ae362209423b.png\"></p>\n<ul>\n<li>MariaDB config 파일에서 cache size를 0으로 설정한다. </li>\n<li>이후 <code class=\"language-text\">sudo service mysqld restart</code> 로 DB를 재구동시킨다. </li>\n</ul>\n<blockquote>\n<p>변경 후 적용 확인</p>\n</blockquote>\n<p align=\"center\"><img width=\"85%\" src=\"https://user-images.githubusercontent.com/63405904/137438718-ba0973ee-3037-4729-b1cb-ef2d2fe43354.png\"></p>\n<h3 id=\"mariadb-slow-query-로그-설정하기\" style=\"position:relative;\"><a href=\"#mariadb-slow-query-%EB%A1%9C%EA%B7%B8-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0\" aria-label=\"mariadb slow query 로그 설정하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>MariaDB slow query 로그 설정하기</h3>\n<ul>\n<li>오래 걸리는 쿼리에 대한 로그를 남겨 특정 쿼리로 인한 병목이 있는지 확인할 수 있도록 설정한다. </li>\n<li>단위는 1초 이상 걸리는 쿼리에 대한 로그를 남기는 것으로 했다. </li>\n</ul>\n<blockquote>\n<p>Slow query 적용 중인지 확인</p>\n</blockquote>\n<p align=\"center\"><img width=\"85%\" src=\"https://user-images.githubusercontent.com/63405904/137438832-c3b085d0-8143-4974-8045-829455f6fbe7.png\"></p>\n<ul>\n<li>\n<p>Slow 쿼리 설정 적용 하기</p>\n<ul>\n<li>slow<em>query</em>log = 1 부터 long<em>query</em>time 까지 적용</li>\n<li>\n<p>적용 후 <code class=\"language-text\">sudo service mysqld restart</code> 로 재시작</p>\n<p align=\"center\"><img width=\"85%\" src=\"https://user-images.githubusercontent.com/63405904/137438852-19161fd9-ac7b-4948-bdb3-0df7991bbf6f.png\"></p>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>Slow query 설정 후 확인</p>\n</blockquote>\n<p align=\"center\"><img width=\"85%\" src=\"https://user-images.githubusercontent.com/63405904/137439074-ff7ed9e9-0ff8-454b-b471-1634454ca3bf.png\"></p>\n<ul>\n<li>\n<p>제대로 적용되었는지 확인하기 위해서 5초 이상 걸리는 쿼리를 실행하고 로그파일 경로의 <code class=\"language-text\">mariadb-slow.log</code>에 대항 쿼리에 대한 로그가 남았는지 확인해보자. </p>\n<p align=\"center\"><img width=\"85%\" src=\"https://user-images.githubusercontent.com/63405904/137439218-aa74256f-24e3-40c8-9351-03f83fda8a6b.png\"></p>\n<p align=\"center\"><img width=\"85%\" src=\"https://user-images.githubusercontent.com/63405904/137439229-266c8c68-1626-43b6-a481-c99b245c6b20.png\"></p>\n<p align=\"center\"><img width=\"85%\" src=\"https://user-images.githubusercontent.com/63405904/137439238-f496e3bf-41fc-4c2a-afdc-5008d843c634.png\"></p>\n</li>\n</ul>\n<br>\n<br>\n<h2 id=\"-테스트-진행하기\" style=\"position:relative;\"><a href=\"#-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%A7%84%ED%96%89%ED%95%98%EA%B8%B0\" aria-label=\" 테스트 진행하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 테스트 진행하기</h2>\n<h3 id=\"테스트-환경\" style=\"position:relative;\"><a href=\"#%ED%85%8C%EC%8A%A4%ED%8A%B8-%ED%99%98%EA%B2%BD\" aria-label=\"테스트 환경 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>테스트 환경</h3>\n<p>테스트를 위해 구축한 테스트 환경은 다음과 같다. </p>\n<ul>\n<li>WAS 2대가 각각 AWS EC2 Medium 사양으로 실행중이다. </li>\n<li>AWS EC2 Medium 사양으로 Reverse Proxy가 있으며 Load balancer 역할을 하면 ssl 적용이 되어 있다. </li>\n<li>\n<p>데이터 베이스는 AWS EC2 Medium에 MariaDB로 3대가 연결되어 있다. </p>\n<ul>\n<li>Master DB 1개, Slave DB 2대로 replication이 적용되어 있다. </li>\n</ul>\n</li>\n</ul>\n<p>테스트 툴은 K6로 진행한다. </p>\n<ul>\n<li>AWS EC2 Medium 에 K6 테스트 서버를 구축했다. </li>\n<li>\n<p>왜 K6일까?</p>\n<ul>\n<li>사실 팀 차원에서 하는 테스트 툴은 <a href=\"https://naver.github.io/ngrinder/#:~:text=nGrinder%20is%20a%20platform%20for,inconveniences%20and%20providing%20integrated%20environments\">Ngrinder</a> 이다. </li>\n<li>하지만 AWS 권한 제한으로 인해 controller와 agent를 별도의 EC2로 분리하지 못했다. (그것 때문인지는 모르겠지만 간혹 랜덤하게 K6와 동일한 테스트를 돌렸을 때 결과가 매우 다르게 나올때도 있었다…) ngrinder는 반드시 분리하도록 권장하기 때문에 혹시 모를 영향을 최소화 하기 위해서 나는 K6에서 진행하였다. </li>\n<li>또한 K6는 문서가 굉장히 깔끔하게 잘 되어 있어 스크립트를 짜거나 테스트 설정을 하는 것이 입문자에게 편하다는 장점이 있었다. </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"테스트-스크립트-및-설정\" style=\"position:relative;\"><a href=\"#%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EB%B0%8F-%EC%84%A4%EC%A0%95\" aria-label=\"테스트 스크립트 및 설정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>테스트 스크립트 및 설정</h3>\n<ul>\n<li>K6는 자바스크립트로 테스트 스크립트를 짠다. </li>\n<li>\n<p>부하 테스트는 약 10분간 148 명의 vuser로 진행했다. </p>\n<ul>\n<li>본래 30분 이상을 하기를 권장하지만 시간 관계상 10분만 진행하고 빠르게 결과를 분석하기로 했다. </li>\n</ul>\n</li>\n<li>\n<p>스크립트 </p>\n<ul>\n<li>비회원으로 홈 피드 조회 API 요청을 보낸다. 우선 pagination은 0 - 20 고정이다. (추후 랜덤 페이지 테스트를 진행해야한다.)</li>\n<li>응답코드가 200 인지 확인한다. </li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">import</span> http <span class=\"token keyword\">from</span> <span class=\"token string\">'k6/http'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> <span class=\"token constant\">URL</span> <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'https://jslib.k6.io/url/1.0.0/index.js'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> check <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'k6'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> randomIntBetween <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"https://jslib.k6.io/k6-utils/1.1.0/index.js\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">let</span> options <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\nvus<span class=\"token operator\">:</span> <span class=\"token number\">148</span><span class=\"token punctuation\">,</span>\nduration<span class=\"token operator\">:</span> <span class=\"token string\">'600s'</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n<span class=\"token keyword\">const</span> url <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">URL</span><span class=\"token punctuation\">(</span><span class=\"token string\">'https://test-pick-git.o-r.kr/api/posts'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nurl<span class=\"token punctuation\">.</span>searchParams<span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span><span class=\"token string\">'page'</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nurl<span class=\"token punctuation\">.</span>searchParams<span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span><span class=\"token string\">'limit'</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> res <span class=\"token operator\">=</span> http<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">check</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token string\">'is status 200'</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">r</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> r<span class=\"token punctuation\">.</span>status <span class=\"token operator\">===</span> <span class=\"token number\">200</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n<li>성능 테스트를 진행하면서 서버의 상태를 관리하기 위해 각각 WAS 2대, DB 2대에 대한 상태를 출력하고 모니터링 했다. </li>\n<li><code class=\"language-text\">vmstat 1 -Sm</code> 와 <code class=\"language-text\">top</code> 명령어를 통해 프로세스의 상태, CPU 상태, 스왑 발생 여부, load average 등을 확인했다.  </li>\n</ul>\n<br>\n<br>\n<h2 id=\"-테스트-진행하기-1\" style=\"position:relative;\"><a href=\"#-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%A7%84%ED%96%89%ED%95%98%EA%B8%B0-1\" aria-label=\" 테스트 진행하기 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 테스트 진행하기</h2>\n<h3 id=\"첫번째-테스트---was-오류\" style=\"position:relative;\"><a href=\"#%EC%B2%AB%EB%B2%88%EC%A7%B8-%ED%85%8C%EC%8A%A4%ED%8A%B8---was-%EC%98%A4%EB%A5%98\" aria-label=\"첫번째 테스트   was 오류 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>첫번째 테스트 - WAS 오류</h3>\n<ul>\n<li>\n<p>WAS 및 DB 모니터링: 왼쪽 위 부터 시계 방향으로 <code class=\"language-text\">was1</code> → <code class=\"language-text\">was2</code> → <code class=\"language-text\">slaveDB2</code> → <code class=\"language-text\">slaveDB1</code></p>\n<p align=\"center\"><img width=\"85%\" src=\"https://user-images.githubusercontent.com/63405904/137442374-21e53603-b1d6-4505-9290-9bc65dfc1d38.png\"></p>\n<ul>\n<li>WAS2에 대한 CPU idle 비율이 100% 이므로 해당 WAS가 동작하지 않은 것을 알아내었다. 확인해보니 어플리케이션이 종료되어 있었다. 테스트 진행시간이 5분정도 경과되었을 때 was2에 어플리케이션을 띄웠고 테스트는 그대로 계속 진행했다. </li>\n</ul>\n</li>\n<li>\n<p>테스트 결과 </p>\n<p align=\"center\"><img width=\"85%\" src=\"https://user-images.githubusercontent.com/63405904/137442922-2b3148e4-d243-480e-b442-3ea3a5168eb4.png\"></p>\n</li>\n<li>DB의 경우 OS메모리 캐싱이 되므로 DISK I/O는 발생하지 않았다. </li>\n<li>\n<p>다만 비효율적인 쿼리에 의해 CPU 과부하가 걸리는 것을 확인할 수 있었다.</p>\n<ul>\n<li>맨 왼쪽 칼럼 <strong>r</strong>(실행 대기 프로세스 수) 수치가 10 정도로 매우 높다.</li>\n<li>본래 r은 CPU 코어 갯수여야 서버가 잘 돌아가고 있다고 판단한다. (현재 ec2 CPU 코어 개수 2개)</li>\n</ul>\n</li>\n<li>요청 당 실행 시간(http<em>req</em>duration) <strong>13.33 초</strong>로 매우 긴 시간이 소요되기에 개선해야 할 점이 명확히 보였다. </li>\n</ul>\n<br>\n<h3 id=\"두번째-테스트\" style=\"position:relative;\"><a href=\"#%EB%91%90%EB%B2%88%EC%A7%B8-%ED%85%8C%EC%8A%A4%ED%8A%B8\" aria-label=\"두번째 테스트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>두번째 테스트</h3>\n<ul>\n<li>\n<p>WAS 및 DB 모니터링: 왼쪽 위 부터 시계 방향으로 <code class=\"language-text\">was1</code> → <code class=\"language-text\">was2</code> → <code class=\"language-text\">slaveDB2</code> → <code class=\"language-text\">slaveDB1</code></p>\n<p align=\"center\"><img width=\"85%\" src=\"https://user-images.githubusercontent.com/63405904/137443197-e4a921d2-f0b5-45b8-a8f1-84ce23bf5c94.png\"></p>\n<p align=\"center\"><img width=\"85%\" src=\"https://user-images.githubusercontent.com/63405904/137443204-86fd6f1b-1f46-4613-bb31-00dc4091bb68.png\"></p>\n<ul>\n<li>앞 테스트와 동일하게 WAS의 CPU나 I/O 상황은 대체적으로 양호하고 DB 서버에 CPU 과부하가 걸리는 것을 확인할 수 있다. </li>\n</ul>\n</li>\n<li>\n<p>테스트 결과 </p>\n<p align=\"center\"><img width=\"85%\" src=\"https://user-images.githubusercontent.com/63405904/137443363-66ab8e2e-33a6-4cd5-9e59-72354e93c3fc.png\"></p>\n</li>\n<li>\n<p>WAS가 2대였음에도 불구하고 error rate이 줄어든 것 밖에 나아진 부분은 없었다. </p>\n<ul>\n<li>요청 실행 시간이나 테스트 갯수 tps 등의 수치가 위와 동일했다. </li>\n</ul>\n</li>\n<li>이것을 통해 알 수 있는 것은 WAS의 성능이 아니라 DB에 의한 성능저하라는 것이다. </li>\n</ul>\n<br>\n<ul>\n<li>\n<p>더 명확하게 알아보기 위해 slow query 로그를 확인해 보았다. </p>\n<ul>\n<li>로그를 확인해보니 태그를 검색하고 검색 결과인 게시물을 조회하는 쿼리가 1.5 초 정도 소요되는 것을 확인할 수 있었다. </li>\n</ul>\n<p align=\"center\"><img width=\"85%\" src=\"https://user-images.githubusercontent.com/63405904/137443674-1307b8ca-3cfa-41c8-ba80-c0e1adf39e12.png\"></p>\n</li>\n</ul>\n<br>\n<blockquote>\n<p>다음 포스트에서 병목이 생기는 DB 쿼리를 진단하고 개선한 후 결과에 대해서 다룬다. </p>\n</blockquote>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#-intro\">💡 Intro</a></li>\n<li>\n<p><a href=\"#-%EC%82%AC%EC%A0%84-%EC%9E%91%EC%97%85\">🌩 사전 작업</a></p>\n<ul>\n<li><a href=\"#%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%8D%94%EB%AF%B8-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%9E%85%EB%A0%A5\">테스트 더미 데이터 입력</a></li>\n<li><a href=\"#mariadb-%EC%BF%BC%EB%A6%AC-%EC%BA%90%EC%8B%9C-%EB%81%84%EA%B8%B0\">MariaDB 쿼리 캐시 끄기</a></li>\n<li><a href=\"#mariadb-slow-query-%EB%A1%9C%EA%B7%B8-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0\">MariaDB slow query 로그 설정하기</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%A7%84%ED%96%89%ED%95%98%EA%B8%B0\">🌩 테스트 진행하기</a></p>\n<ul>\n<li><a href=\"#%ED%85%8C%EC%8A%A4%ED%8A%B8-%ED%99%98%EA%B2%BD\">테스트 환경</a></li>\n<li><a href=\"#%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EB%B0%8F-%EC%84%A4%EC%A0%95\">테스트 스크립트 및 설정</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%A7%84%ED%96%89%ED%95%98%EA%B8%B0-1\">🌩 테스트 진행하기</a></p>\n<ul>\n<li><a href=\"#%EC%B2%AB%EB%B2%88%EC%A7%B8-%ED%85%8C%EC%8A%A4%ED%8A%B8---was-%EC%98%A4%EB%A5%98\">첫번째 테스트 - WAS 오류</a></li>\n<li><a href=\"#%EB%91%90%EB%B2%88%EC%A7%B8-%ED%85%8C%EC%8A%A4%ED%8A%B8\">두번째 테스트</a></li>\n</ul>\n</li>\n</ul>\n</div>","frontmatter":{"date":"October 15, 2021","title":"K6를 활용한 성능테스트 경험기 1 - 홈피드 조회 기능 향상","categories":"웹 프로젝트 성능테스트 데이터베이스","author":"코다","emoji":"📈"},"fields":{"slug":"/project-pickgit-homefeed-performance-test-1/"}},"site":{"siteMetadata":{"siteUrl":"https://yjksw.github.io","comments":{"utterances":{"repo":"yjksw/yjksw.github.io"}}}}},"pageContext":{"slug":"/operating-system-4/","nextSlug":"/operating-system-3/","prevSlug":"/project-pickgit-homefeed-performance-test-1/"}},"staticQueryHashes":["1073350324","2938748437"]}
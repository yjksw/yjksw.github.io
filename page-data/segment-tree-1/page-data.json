{"componentChunkName":"component---src-templates-blog-template-js","path":"/segment-tree-1/","result":{"data":{"cur":{"id":"e2eeb2c3-459a-5343-b311-e5d107abbb71","html":"<p>히스토그램에서 가장 큰 직사각형의 크기를 찾는 알고리즘을 풀다가, 관련 문제의 풀이법을 간단히 찾아서 금방 해결할 줄 알았으니 구현에서 의도치 않은 오랜 시간이 걸렸다. </p>\n<p>먼저 <a href=\"https://www.acmicpc.net/problem/6549\">문제</a>의 해결 방법을 요약하면 다음과 같다. </p>\n<blockquote>\n<ol>\n<li>히스토그램 중, 높이가 가장 낮은 min 값과 해당 너비값을 곱하여 넓이를 구함. </li>\n<li>해당 최소값을 기준으로 히스토램을 나누어서 1번을 반복함. </li>\n<li>더 이상 나눌 수 없을 때까지 반복하며 매번 넓이의 max 값을 업데이트 함. </li>\n</ol>\n</blockquote>\n<p>다음은 <a href=\"https://www.acmicpc.net/blog/view/12\">백준 블로그</a>에 있는 문제 해설에서 가져온 그림이다. 위의 해결 방법을 이해하는데 도움이 된다. </p>\n<p><img src=\"https://user-images.githubusercontent.com/63405904/109445062-10bb9c80-7a82-11eb-9887-9047f1485785.png\" alt=\"histogram\">{: width=“80%“}</p>\n<p>처음에 단순히 이 풀이방법을 배열과 재귀를 사용해서 구현하는 방법으로 시도를 했었다. 사이트에 나와있는 테스트 케이스가 통과하길래 바로 채점을 했더니 결과는 <em>시간초과</em> 였다.. 개인적으로 알고리즘을 할 때 가장 어려운 부분이 답을 출력이 되지만 시간초과가 나올 때 인 것 같다. 문제설명 밑에 해당 문제를 세그먼트 트리를 사용한 분할정복으로 풀 수 있다고 하길래 세그먼트 트리에 대해서 공부하면서 정리한 내용과 처음에 접근했던 방식에 대해서 쓰려고 한다. </p>\n<ol>\n<li>배열/재귀를 사용해서 풀었던 방법: <mark> 시간초과 </mark></li>\n<li>세그먼트 트리/분할정복을 사용해서 푼 방법: <mark>통과</mark></li>\n</ol>\n<h3 id=\"배열과-재귀를-사용한-첫번째-접근-방법\" style=\"position:relative;\"><a href=\"#%EB%B0%B0%EC%97%B4%EA%B3%BC-%EC%9E%AC%EA%B7%80%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%9C-%EC%B2%AB%EB%B2%88%EC%A7%B8-%EC%A0%91%EA%B7%BC-%EB%B0%A9%EB%B2%95\" aria-label=\"배열과 재귀를 사용한 첫번째 접근 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>배열과 재귀를 사용한 첫번째 접근 방법</h3>\n<p>배열과 재귀를 사용한 접근 방법은 간단하지만 번거롭다. 매번 나뉘어진 구간 사이에서의 <strong>최솟값</strong>을 찾는 과정을 반복해야 하기 때문이다.  </p>\n<h4 id=\"접근-방법-1-arraylist\" style=\"position:relative;\"><a href=\"#%EC%A0%91%EA%B7%BC-%EB%B0%A9%EB%B2%95-1-arraylist\" aria-label=\"접근 방법 1 arraylist permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>접근 방법 1: ArrayList</h4>\n<p>ArrayList를 사용해서 탐색 API를 사용해서 최솟값 구하기</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">1. ArrayList의 일부 구간을 subList를 사용하여 List에 저장한다.\n2. Collections.min() 메소드를 사용하여 최솟값을 추출하여 넓이를 구한다. \n3. indexOf() 메소드를 사용하여 최솟값의 index를 구한다. \n4. 다음과 같은 재귀로 반복한다.\n\t* 맨 첫번째 요소가 최소값일 경우: 두번째 요소부터 마지막 요소까지 재귀\n\t* 맨 마지막 요소가 최소값일 경우: 첫본째 요소부터 마지막 이전 요소까지 재귀\n\t* 중간의 어느 값이 최소값일 경우: (시작 요소, 최소값 위치 -1)과 (최소값 위치 +1, 마지막 요소)로 나누어서 재귀</code></pre></div>\n<p>위의 방식은 조금만 큰 값이 들어가도 바로 <em>시간 초과</em>가 결렸다. 이유는 ArrayList의 경우 일반 배열과 달리 초반에 메모리 할당이 되지 않기 때문에 추가/삭제 시 메모리 할당을 매번 해줘야 한다. 따라서 일반적으로 일반 배열이 더욱 빠르다. 그래서 두번째 접근 방식으로 일반 배열을 사용하는 것을 택했다. 일반 배열을 사용하면 최소값을 찾는 등의 메소드를 사용하기는 어렵지만 최소값을 찾는 구현은 어렵지 않고, 시간 복잡도도 비슷하기 때문에 시도해 보았다. </p>\n<p><strong>코드:</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> startIndex<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> lastIndex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">long</span> area <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>startIndex <span class=\"token operator\">==</span> lastIndex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    area <span class=\"token operator\">=</span> value<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>startIndex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>area<span class=\"token operator\">></span>max<span class=\"token punctuation\">)</span>\n    \tmax <span class=\"token operator\">=</span> area<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  \n  <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> list <span class=\"token operator\">=</span> value<span class=\"token punctuation\">.</span><span class=\"token function\">subList</span><span class=\"token punctuation\">(</span>startIndex<span class=\"token punctuation\">,</span> lastIndex<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">long</span> min <span class=\"token operator\">=</span> <span class=\"token class-name\">Collections</span><span class=\"token punctuation\">.</span><span class=\"token function\">min</span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  area <span class=\"token operator\">=</span> min<span class=\"token operator\">*</span><span class=\"token punctuation\">(</span>lastIndex<span class=\"token operator\">-</span>startIndex<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">int</span> index <span class=\"token operator\">=</span> startIndex <span class=\"token operator\">+</span> list<span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span>min<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>area <span class=\"token operator\">></span> max<span class=\"token punctuation\">)</span>\n    max <span class=\"token operator\">=</span> area<span class=\"token punctuation\">;</span>\n  \n  <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>index <span class=\"token operator\">==</span> startIndex<span class=\"token punctuation\">)</span>\n    <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span>index<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> lastIndex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>index <span class=\"token operator\">==</span> lastIndex<span class=\"token punctuation\">)</span>\n    <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span>startIndex<span class=\"token punctuation\">,</span> index<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">else</span><span class=\"token punctuation\">{</span>\n    <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span>startIndex<span class=\"token punctuation\">,</span> index<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span>index<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> lastIndex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h4 id=\"접근-방법-2-arrays\" style=\"position:relative;\"><a href=\"#%EC%A0%91%EA%B7%BC-%EB%B0%A9%EB%B2%95-2-arrays\" aria-label=\"접근 방법 2 arrays permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>접근 방법 2: Arrays</h4>\n<p>Array를 사용해서 최소값을 구하기</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">1. for-loop를 사용해서 최소값 구하기\n2. 최소값 사용하여 넓이 구하기 \n3. 접근 방법 1에서와 같이 재귀하기</code></pre></div>\n<p>ArrayList를 사용했을 때보다는 빨랐기 때문에 더 많은 test case를 통과할 수 있었다. 하지만 여전히 시간초과에 걸렸다. </p>\n<p>문제에서 나온 직사각형의 갯수 제한은 100,000이고 재귀 초기함수가 <code class=\"language-text\">(startIndex==lastIndex)</code> 일 때이기 때문에 각각하나씩 모두 접근한다. 이때마다 해당 구간의 최소값을 찾기위해 O(n)만큼 탐색을 하니 시간 초과가 걸릴만 하다. 때문에 문제의 태그에서 나온 세그먼트 트리에 대해서 공부하고 활용해보기로 했다. </p>\n<p><strong>코드:</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> startIndex<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> lastIndex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">long</span> area <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">long</span> min <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">long</span> index <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>startIndex<span class=\"token operator\">==</span>lastIndex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    area <span class=\"token operator\">=</span> value<span class=\"token punctuation\">[</span>startIndex<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>area<span class=\"token operator\">></span>max<span class=\"token punctuation\">)</span>\n      max<span class=\"token operator\">=</span>area<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  \n  <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> temp<span class=\"token operator\">=</span>startIndex<span class=\"token punctuation\">;</span>temp<span class=\"token operator\">&lt;=</span>lastIndex<span class=\"token punctuation\">;</span>temp<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>min<span class=\"token operator\">&lt;</span><span class=\"token number\">0</span> <span class=\"token operator\">||</span> value<span class=\"token punctuation\">[</span>temp<span class=\"token punctuation\">]</span><span class=\"token operator\">&lt;</span>min<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n      min <span class=\"token operator\">=</span> value<span class=\"token punctuation\">[</span>temp<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n      index <span class=\"token operator\">=</span> temp<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  \n  area <span class=\"token operator\">=</span> min<span class=\"token operator\">*</span><span class=\"token punctuation\">(</span>lastIndex<span class=\"token operator\">-</span>startIndex<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  \n  <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>area<span class=\"token operator\">></span>max<span class=\"token punctuation\">)</span>\n    max <span class=\"token operator\">=</span> area<span class=\"token punctuation\">;</span>\n  \n  <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>index <span class=\"token operator\">==</span> startIndex<span class=\"token punctuation\">)</span>\n    <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span>index<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> lastIndex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>index <span class=\"token operator\">==</span> lastIndex<span class=\"token punctuation\">)</span>\n    <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span>startIndex<span class=\"token punctuation\">,</span> index<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">else</span><span class=\"token punctuation\">{</span>\n    <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span>startIndex<span class=\"token punctuation\">,</span> index<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span>index<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> lastIndex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h4 id=\"접근-방법-3-segment-tree\" style=\"position:relative;\"><a href=\"#%EC%A0%91%EA%B7%BC-%EB%B0%A9%EB%B2%95-3-segment-tree\" aria-label=\"접근 방법 3 segment tree permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>접근 방법 3: Segment Tree</h4>\n<p>세그먼트 트리는 <mark>주어진 쿼리에 빠르게 응답하기 위해 만들어진 자료구조</mark>이고, 그 사용법은 쿼리마다 상이하다. 가장 대표적으로 세그먼트 트리를 사용할 때 내는 예시는 구간 합을 구하는 문제이다. 하지만 이 글에서는 <em>히스토그램에서 가장 큰 직사각형</em> 푸는 문제에 적용된 세그먼트를 설명할 것이다. </p>\n<p>풀이에 세그먼트 트리를 활용할 수 있는 상황은 다음 두가지와 같다. <strong>1. 쿼리 형식으로 문제가 주어진 경우 2. 시간 복잡도를 log로 만들고 싶을 경우</strong>. <small>개인적으로 구간에 관련한 문제가 나올 경우, 시간 복잡도를 줄이기 위해 세그먼트 트리 사용을 하는 것이 좋은 것 같다.</small></p>\n<p>세그먼트 트리는 주로 이진트리를 이용하며, 주로 완전 이진 트리 Full Binary Tree에 가깝다. 그렇기 대문에 세그먼트 트리를 사용하면 다음과 같은 성능을 지닌다. </p>\n<ol>\n<li>쿼리의 결과값 구하기: O(lgN)</li>\n<li>값 업데이트 하기: O(lgN)</li>\n</ol>\n<p>히스토그램 문제에서는 쿼리의 결과값 구하는 과정의 시간 복잡도가 O(lgN)이 되면서 성능이 매우 좋아지게 된다. </p>\n<h6 id=\"segment-tree-란\" style=\"position:relative;\"><a href=\"#segment-tree-%EB%9E%80\" aria-label=\"segment tree 란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Segment Tree 란?</h6>\n<img src=\"https://user-images.githubusercontent.com/63405904/109445201-6e4fe900-7a82-11eb-8e6c-09edb7e236a4.png\" alt=\"histogram\" style=\"zoom:70%;\">\n<p>히스토그램 문제에서는 위에서 말했듯 다음 두가지 풀이를 반복한다. </p>\n<ol>\n<li>최소값 기준으로 구간 나누기</li>\n<li>나뉘어진 구간에서 재귀로 1) 반복하기</li>\n</ol>\n<p>히스토그램에서 중요 요소는 최소값이기 때문에 각 구간의 최소값의 위치를 저장하도록 한다. 따라서 이후에 특정 구간의 최소값을 찾을 때 <mark>O(lgN)</mark>만큼의 시간복잡도로 최소값을 찾을 수 있다. 위의 이진 세그먼트 트리는 10개의 원소가 있다고 가정했을 때 각 구간이 나뉜 것을 보여준다. <strong>세그먼트 트리에서 모든 leaf node는 원래 배열의 자기자신 element</strong>이다. </p>\n<p>요약하자면 segment tree의 구성요소는 다음과 같다. </p>\n<ul>\n<li>Leaf node :  원래 배열의 그 수의 위치. <small>(이 값은 응용 문제에 따라서 달라진다.)</small></li>\n<li>다른 node:  왼쪽 자식과 오른쪽 자식 중 더 최소값의 위치.</li>\n</ul>\n<p>히스토그램 문제에서 Segment tree 구현을 요약하면 다음과 같다. </p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">1. 초기화 함수: 구간이 자기 자신일 경우, leaf node이므로 해당 위치를 기록함. \n2. 재귀 함수: 구간을 반으로 나누어서 재귀함.\n3. 일반 함수: 자신의 왼쪽 자식 노드와, 오른쪽 자식 노드 위치의 값을 비교하여 더 작은 값의 위치를 트리의 해당 노트에 입력함. </code></pre></div>\n<p>전체 구간 <code class=\"language-text\">0 ~ n-1</code>까지부터 시작해 재귀를 하면 각 구간마다의 <mark>최솟값의 위치</mark>를 기록한 <em>lgN</em> 높이 만큼의 segment tree가 생성된다. 이 세그먼트 트리를 사용해서 더 빠른 방법으로 최소값을 탐색하고 제일 앞에서 설명한 방법을 통해서 정답을 도출하면 된다. </p>\n<hr>\n<p>다음 글에서 구체적으로 세그먼트 트리를 구현하는 방법과 히스토그램에서 응용된 방법에 대해서 다루도록 하겠다. </p>\n<p><strong><small>[참고 자료]: <a href=\"https://www.acmicpc.net/blog/view/12\">https://www.acmicpc.net/blog/view/12</a>, <a href=\"https://www.crocus.co.kr/648\">https://www.crocus.co.kr/648</a>, <a href=\"https://www.acmicpc.net/blog/view/9\">https://www.acmicpc.net/blog/view/9</a> </small></strong></p>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#%EB%B0%B0%EC%97%B4%EA%B3%BC-%EC%9E%AC%EA%B7%80%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%9C-%EC%B2%AB%EB%B2%88%EC%A7%B8-%EC%A0%91%EA%B7%BC-%EB%B0%A9%EB%B2%95\">배열과 재귀를 사용한 첫번째 접근 방법</a></p>\n<ul>\n<li><a href=\"#%EC%A0%91%EA%B7%BC-%EB%B0%A9%EB%B2%95-1-arraylist\">접근 방법 1: ArrayList</a></li>\n<li><a href=\"#%EC%A0%91%EA%B7%BC-%EB%B0%A9%EB%B2%95-2-arrays\">접근 방법 2: Arrays</a></li>\n<li>\n<p><a href=\"#%EC%A0%91%EA%B7%BC-%EB%B0%A9%EB%B2%95-3-segment-tree\">접근 방법 3: Segment Tree</a></p>\n<ul>\n<li>\n<ul>\n<li><a href=\"#segment-tree-%EB%9E%80\">Segment Tree 란?</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</div>","excerpt":"히스토그램에서 가장 큰 직사각형의 크기를 찾는 알고리즘을 풀다가, 관련 문제의 풀이법을 간단히 찾아서 금방 해결할 줄 알았으니 구현에서 의도치 않은 오랜 시간이 걸렸다.  먼저 문제의 해결 방법을 요약하면 다음과 같다.  히스토그램 중, 높이가 가장 낮은 min 값과 해당 너비값을 곱하여 넓이를 구함.  해당 최소값을 기준으로 히스토램을 나누어서 1번을 반복함.  더 이상 나눌 수 없을 때까지 반복하며 매번 넓이의 max 값을 업데이트 함.  다음은 백준 블로그에 있는 문제 해설에서 가져온 그림이다. 위의 해결 방법을 이해하는데 도움이 된다.  histogram{: width=“80%“} 처음에 단순히 이 풀이방법을 배열과 재귀를 사용해서 구현하는 방법으로 시도를 했었다. 사이트에 나와있는 테스트 케이스가 통과하길래 바로 채점을 했더니 결과는 시간초과 였다.. 개인적으로 알고리즘을 할 때 가장 어려운 부분이 답을 출력이 되지만 시간초과가 나올 때 인 것 같다. 문제설명 밑에 해당 …","frontmatter":{"date":"September 09, 2020","title":"세그먼트 트리를 활용한 히스토그램 문제 풀이_1","categories":"알고리즘","author":"코다","emoji":"🤹‍♀️"},"fields":{"slug":"/segment-tree-1/"}},"next":{"id":"1cfe8a3b-ad8f-5ccf-ae4a-4383087005d8","html":"<p>알고리즘에 대해서 배울 때 가장 먼저 다루는 부분이 바로 <strong>Time Complexity</strong> 이다. 기술이 발전하면서 메모리에 대한 부분은 상당 부분 해결이 되고 걱정하지 않아도 되는 부분이 되었다. 하지만 시간 복잡도 측면에서는 아무리 발전해도 부족한 부분이다. 왜냐하면 짧으면 짧을수록 더 좋기 때문이다. 따라서 알고리즘 강의를 들을 때에는 항상 Time Complexity에 대한 강의를 시작으로 배운다. 어떠한 문제에 대해서 여러가지 알고리즘을 사용하여 해결할 수 있을 때 무엇이 최적의 알고리즘인지를 판단하는 잣대는 해당 알고리즘으로 문제를 해결하는데 걸리는 시간이기 때문이다. 거기서 핵심적인 역할을 하는 두 theory에 대해서 <a href=\"https://www.geeksforgeeks.org/lower-and-upper-bound-theory/\">다음 글</a>의 내용을 번역 및 정리하면서 알아보자. <br></p>\n<p>Lower Bound와 upper Bound Theory는 어떠한 문제에 대한 가장 적은 복잡도를 가진 알고리즘을 선택하는데 핵심적인 역할을 한다. 구체적으로 이 이론들을 다루기 이전에 각각 Lower Bound와 Upper Bound가 무엇을 의미하는지 살펴보자. <br></p>\n<ul>\n<li>\n<p><strong>Lower Bound</strong> - <br></p>\n<p>L(n)이 알고리즘 A에 대한 수행 시간일 때, <span class=\"mjx-chtml\"><span class=\"mjx-math\" aria-label=\"L(n) >= C*g(n)\"><span class=\"mjx-mrow\" aria-hidden=\"true\"><span class=\"mjx-mi\"><span class=\"mjx-char MJXc-TeX-math-I\" style=\"padding-top: 0.446em; padding-bottom: 0.298em;\">L</span></span><span class=\"mjx-mo\"><span class=\"mjx-char MJXc-TeX-main-R\" style=\"padding-top: 0.446em; padding-bottom: 0.593em;\">(</span></span><span class=\"mjx-mi\"><span class=\"mjx-char MJXc-TeX-math-I\" style=\"padding-top: 0.225em; padding-bottom: 0.298em;\">n</span></span><span class=\"mjx-mo\"><span class=\"mjx-char MJXc-TeX-main-R\" style=\"padding-top: 0.446em; padding-bottom: 0.593em;\">)</span></span><span class=\"mjx-mo MJXc-space3\"><span class=\"mjx-char MJXc-TeX-main-R\" style=\"padding-top: 0.077em; padding-bottom: 0.372em;\">&gt;<span class=\"mjx-charbox MJXc-TeX-main-R\" style=\"padding-bottom: 0.314em;\">=</span></span></span><span class=\"mjx-mi MJXc-space3\"><span class=\"mjx-char MJXc-TeX-math-I\" style=\"padding-top: 0.519em; padding-bottom: 0.298em; padding-right: 0.045em;\">C</span></span><span class=\"mjx-mo MJXc-space2\"><span class=\"mjx-char MJXc-TeX-main-R\" style=\"padding-top: 0.151em; padding-bottom: 0.298em;\">∗</span></span><span class=\"mjx-mi MJXc-space2\"><span class=\"mjx-char MJXc-TeX-math-I\" style=\"padding-top: 0.225em; padding-bottom: 0.519em; padding-right: 0.003em;\">g</span></span><span class=\"mjx-mo\"><span class=\"mjx-char MJXc-TeX-main-R\" style=\"padding-top: 0.446em; padding-bottom: 0.593em;\">(</span></span><span class=\"mjx-mi\"><span class=\"mjx-char MJXc-TeX-math-I\" style=\"padding-top: 0.225em; padding-bottom: 0.298em;\">n</span></span><span class=\"mjx-mo\"><span class=\"mjx-char MJXc-TeX-main-R\" style=\"padding-top: 0.446em; padding-bottom: 0.593em;\">)</span></span></span></span></span>을 성립하는 <span class=\"mjx-chtml\"><span class=\"mjx-math\" aria-label=\"C\"><span class=\"mjx-mrow\" aria-hidden=\"true\"><span class=\"mjx-mi\"><span class=\"mjx-char MJXc-TeX-math-I\" style=\"padding-top: 0.519em; padding-bottom: 0.298em; padding-right: 0.045em;\">C</span></span></span></span></span>가 있는 경우 <span class=\"mjx-chtml\"><span class=\"mjx-math\" aria-label=\"g(n)\"><span class=\"mjx-mrow\" aria-hidden=\"true\"><span class=\"mjx-mi\"><span class=\"mjx-char MJXc-TeX-math-I\" style=\"padding-top: 0.225em; padding-bottom: 0.519em; padding-right: 0.003em;\">g</span></span><span class=\"mjx-mo\"><span class=\"mjx-char MJXc-TeX-main-R\" style=\"padding-top: 0.446em; padding-bottom: 0.593em;\">(</span></span><span class=\"mjx-mi\"><span class=\"mjx-char MJXc-TeX-math-I\" style=\"padding-top: 0.225em; padding-bottom: 0.298em;\">n</span></span><span class=\"mjx-mo\"><span class=\"mjx-char MJXc-TeX-main-R\" style=\"padding-top: 0.446em; padding-bottom: 0.593em;\">)</span></span></span></span></span>은 A의 lower bound이다. 어떠한 알고리즘의 lower bound는 Big Omega 로 나타낸다. <br></p>\n</li>\n<li>\n<p><strong>Upper Bound</strong> - <br></p>\n<p>U(n)이 알고리즘 A에 대한 수행 시간일 때, <span class=\"mjx-chtml\"><span class=\"mjx-math\" aria-label=\"L(n) <= C*g(n)\"><span class=\"mjx-mrow\" aria-hidden=\"true\"><span class=\"mjx-mi\"><span class=\"mjx-char MJXc-TeX-math-I\" style=\"padding-top: 0.446em; padding-bottom: 0.298em;\">L</span></span><span class=\"mjx-mo\"><span class=\"mjx-char MJXc-TeX-main-R\" style=\"padding-top: 0.446em; padding-bottom: 0.593em;\">(</span></span><span class=\"mjx-mi\"><span class=\"mjx-char MJXc-TeX-math-I\" style=\"padding-top: 0.225em; padding-bottom: 0.298em;\">n</span></span><span class=\"mjx-mo\"><span class=\"mjx-char MJXc-TeX-main-R\" style=\"padding-top: 0.446em; padding-bottom: 0.593em;\">)</span></span><span class=\"mjx-mo MJXc-space3\"><span class=\"mjx-char MJXc-TeX-main-R\" style=\"padding-top: 0.077em; padding-bottom: 0.372em;\">&lt;<span class=\"mjx-charbox MJXc-TeX-main-R\" style=\"padding-bottom: 0.314em;\">=</span></span></span><span class=\"mjx-mi MJXc-space3\"><span class=\"mjx-char MJXc-TeX-math-I\" style=\"padding-top: 0.519em; padding-bottom: 0.298em; padding-right: 0.045em;\">C</span></span><span class=\"mjx-mo MJXc-space2\"><span class=\"mjx-char MJXc-TeX-main-R\" style=\"padding-top: 0.151em; padding-bottom: 0.298em;\">∗</span></span><span class=\"mjx-mi MJXc-space2\"><span class=\"mjx-char MJXc-TeX-math-I\" style=\"padding-top: 0.225em; padding-bottom: 0.519em; padding-right: 0.003em;\">g</span></span><span class=\"mjx-mo\"><span class=\"mjx-char MJXc-TeX-main-R\" style=\"padding-top: 0.446em; padding-bottom: 0.593em;\">(</span></span><span class=\"mjx-mi\"><span class=\"mjx-char MJXc-TeX-math-I\" style=\"padding-top: 0.225em; padding-bottom: 0.298em;\">n</span></span><span class=\"mjx-mo\"><span class=\"mjx-char MJXc-TeX-main-R\" style=\"padding-top: 0.446em; padding-bottom: 0.593em;\">)</span></span></span></span></span>을 성립하는 <span class=\"mjx-chtml\"><span class=\"mjx-math\" aria-label=\"C\"><span class=\"mjx-mrow\" aria-hidden=\"true\"><span class=\"mjx-mi\"><span class=\"mjx-char MJXc-TeX-math-I\" style=\"padding-top: 0.519em; padding-bottom: 0.298em; padding-right: 0.045em;\">C</span></span></span></span></span>가 있는 경우 <span class=\"mjx-chtml\"><span class=\"mjx-math\" aria-label=\"g(n)\"><span class=\"mjx-mrow\" aria-hidden=\"true\"><span class=\"mjx-mi\"><span class=\"mjx-char MJXc-TeX-math-I\" style=\"padding-top: 0.225em; padding-bottom: 0.519em; padding-right: 0.003em;\">g</span></span><span class=\"mjx-mo\"><span class=\"mjx-char MJXc-TeX-main-R\" style=\"padding-top: 0.446em; padding-bottom: 0.593em;\">(</span></span><span class=\"mjx-mi\"><span class=\"mjx-char MJXc-TeX-math-I\" style=\"padding-top: 0.225em; padding-bottom: 0.298em;\">n</span></span><span class=\"mjx-mo\"><span class=\"mjx-char MJXc-TeX-main-R\" style=\"padding-top: 0.446em; padding-bottom: 0.593em;\">)</span></span></span></span></span>은 A의 lower bound이다. 어떠한 알고리즘의 lower bound는 Big Oh(O) 로 나타낸다. <br></p>\n</li>\n</ul>\n<h2 id=\"1-lower-bound-theory\" style=\"position:relative;\"><a href=\"#1-lower-bound-theory\" aria-label=\"1 lower bound theory permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. Lower Bound Theory:</h2>\n<p>Lower Bound Theory에 의하면 어떠한 알고리즘의 lower bound에 대하여 다른 어떠한 알고리즘도 랜덤한 input에 대하여 L(n)보다 적은 시간 복잡도를 가질 수 없다. 또한 다르게 말하면 모든 알고리즘들이 <strong>적어도 L(n)</strong> 만큼의 시간을 가질 수 밖에 없다. <br></p>\n<p><em>주의할 점: L(n)은 모든 알고리즘 중 최소의 복잡도를 나타낸다.</em><br></p>\n<p>Lower Bound 는 그 어던 알고리즘에 있어서도 매우 중요하다. Lower Bound를 계산한 후에, 특정 알고리즘의 복잡도를 계산하여 L(n)과 같다면 해당 알고리즘이 최적의 알고리즘이라는 것을 알 수 있다. 이 글에서 우리는 어떠한 알고리즘의 lower bound를 찾는 방법들에 대해서 다루어 볼 것이다. <br></p>\n<p>명심해야 하는 것은 언제나 우리의 가장 중요한 목적이 <strong>최적의 알고리즘</strong>을 구하는 것이라는 것이다. 여기서 최적의 알고리즘이라고 함은 해당 알고리즘의 Upper Bound 가 해당 문제의 Lower Bound와 같은(U(n)=L(n)) 경우이다. <em>Merge sort</em>를 통해서 optimal algorithm을 살펴보자. <br></p>\n<h3 id=\"trivial-lower-bound--\" style=\"position:relative;\"><a href=\"#trivial-lower-bound--\" aria-label=\"trivial lower bound   permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Trivial Lower Bound -</h3>\n<p>Lower bound를 찾는 가장 쉬운 방법이다. 이 방법은 Lower bound가 문제의 input의 개수와 output의 개수로 쉽게 알 수 있다고 하는 Trivial Lower Bound 방법이다. <br></p>\n<h4 id=\"예시-multiplication-of-nn-matrix\" style=\"position:relative;\"><a href=\"#%EC%98%88%EC%8B%9C-multiplication-of-nn-matrix\" aria-label=\"예시 multiplication of nn matrix permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>예시: Multiplication of n*n matrix</h4>\n<ul>\n<li>Input: 2개의 행렬에 대해 <span class=\"mjx-chtml\"><span class=\"mjx-math\" aria-label=\"2n^2\"><span class=\"mjx-mrow\" aria-hidden=\"true\"><span class=\"mjx-mn\"><span class=\"mjx-char MJXc-TeX-main-R\" style=\"padding-top: 0.372em; padding-bottom: 0.372em;\">2</span></span><span class=\"mjx-msubsup\"><span class=\"mjx-base\"><span class=\"mjx-mi\"><span class=\"mjx-char MJXc-TeX-math-I\" style=\"padding-top: 0.225em; padding-bottom: 0.298em;\">n</span></span></span><span class=\"mjx-sup\" style=\"font-size: 70.7%; vertical-align: 0.513em; padding-left: 0px; padding-right: 0.071em;\"><span class=\"mjx-mn\" style=\"\"><span class=\"mjx-char MJXc-TeX-main-R\" style=\"padding-top: 0.372em; padding-bottom: 0.372em;\">2</span></span></span></span></span></span></span>개</li>\n<li>Output: 1 개의 n*n 행렬, <span class=\"mjx-chtml\"><span class=\"mjx-math\" aria-label=\"n^2\"><span class=\"mjx-mrow\" aria-hidden=\"true\"><span class=\"mjx-msubsup\"><span class=\"mjx-base\"><span class=\"mjx-mi\"><span class=\"mjx-char MJXc-TeX-math-I\" style=\"padding-top: 0.225em; padding-bottom: 0.298em;\">n</span></span></span><span class=\"mjx-sup\" style=\"font-size: 70.7%; vertical-align: 0.513em; padding-left: 0px; padding-right: 0.071em;\"><span class=\"mjx-mn\" style=\"\"><span class=\"mjx-char MJXc-TeX-main-R\" style=\"padding-top: 0.372em; padding-bottom: 0.372em;\">2</span></span></span></span></span></span></span> 개</li>\n</ul>\n<p>위의 input/output의 숫자를 보면 쉽게 lower bound가 <span class=\"mjx-chtml\"><span class=\"mjx-math\" aria-label=\"O(n^2)\"><span class=\"mjx-mrow\" aria-hidden=\"true\"><span class=\"mjx-mi\"><span class=\"mjx-char MJXc-TeX-math-I\" style=\"padding-top: 0.519em; padding-bottom: 0.298em;\">O</span></span><span class=\"mjx-mo\"><span class=\"mjx-char MJXc-TeX-main-R\" style=\"padding-top: 0.446em; padding-bottom: 0.593em;\">(</span></span><span class=\"mjx-msubsup\"><span class=\"mjx-base\"><span class=\"mjx-mi\"><span class=\"mjx-char MJXc-TeX-math-I\" style=\"padding-top: 0.225em; padding-bottom: 0.298em;\">n</span></span></span><span class=\"mjx-sup\" style=\"font-size: 70.7%; vertical-align: 0.513em; padding-left: 0px; padding-right: 0.071em;\"><span class=\"mjx-mn\" style=\"\"><span class=\"mjx-char MJXc-TeX-main-R\" style=\"padding-top: 0.372em; padding-bottom: 0.372em;\">2</span></span></span></span><span class=\"mjx-mo\"><span class=\"mjx-char MJXc-TeX-main-R\" style=\"padding-top: 0.446em; padding-bottom: 0.593em;\">)</span></span></span></span></span>라는 것을 알 수 있다. <br></p>\n<h3 id=\"computational-model--\" style=\"position:relative;\"><a href=\"#computational-model--\" aria-label=\"computational model   permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Computational Model -</h3>\n<p>이 방법을 비교를 하는 모든 알고리즘에 대해서 사용할 수 있다. 예를 들어, sorting 문제의 경우 각 원소들을 비교하고 배열을 해야한다. 탐색하는 문제 또한 비슷하다. 예시를 통해서 해당 문제들의 lower bound를 구하는 법에 대해서 살펴보자. <br></p>\n<h3 id=\"ordered-searching--\" style=\"position:relative;\"><a href=\"#ordered-searching--\" aria-label=\"ordered searching   permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Ordered Searching -</h3>\n<p>이미 정렬이 되어 있는 리스트에 대해서 탐색을 하는 경우이다. <br></p>\n<h3 id=\"example-1-linear-search\" style=\"position:relative;\"><a href=\"#example-1-linear-search\" aria-label=\"example 1 linear search permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Example 1: Linear Search</h3>\n<p>처음부터 시작하여 차례로 각 element를 순회하며 해당 원소가 찾던 원소인지 확인한다. </p>\n<h3 id=\"example-2-binary-search\" style=\"position:relative;\"><a href=\"#example-2-binary-search\" aria-label=\"example 2 binary search permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Example 2: Binary Search</h3>\n<p>중간에 있는 것과 비교하여 찾고자 하는 숫자가 클 경우, 반의 오른쪽 부분을, 작을 경우 반의 왼쪽 부분을 나누어서 탐색한다. </p>\n<h3 id=\"calculation-the-lower-bound\" style=\"position:relative;\"><a href=\"#calculation-the-lower-bound\" aria-label=\"calculation the lower bound permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Calculation the lower bound:</h3>\n<p>비교하는 최대 횟수는 n이고, 리스트의 tree에 총 k levels이 있다고 한다면..</p>\n<ol>\n<li>Node의 갯수는 <span class=\"mjx-chtml\"><span class=\"mjx-math\" aria-label=\"2^k-1\"><span class=\"mjx-mrow\" aria-hidden=\"true\"><span class=\"mjx-msubsup\"><span class=\"mjx-base\"><span class=\"mjx-mn\"><span class=\"mjx-char MJXc-TeX-main-R\" style=\"padding-top: 0.372em; padding-bottom: 0.372em;\">2</span></span></span><span class=\"mjx-sup\" style=\"font-size: 70.7%; vertical-align: 0.591em; padding-left: 0px; padding-right: 0.071em;\"><span class=\"mjx-mi\" style=\"\"><span class=\"mjx-char MJXc-TeX-math-I\" style=\"padding-top: 0.446em; padding-bottom: 0.298em;\">k</span></span></span></span><span class=\"mjx-mo MJXc-space2\"><span class=\"mjx-char MJXc-TeX-main-R\" style=\"padding-top: 0.298em; padding-bottom: 0.446em;\">−</span></span><span class=\"mjx-mn MJXc-space2\"><span class=\"mjx-char MJXc-TeX-main-R\" style=\"padding-top: 0.372em; padding-bottom: 0.372em;\">1</span></span></span></span></span></li>\n<li><span class=\"mjx-chtml\"><span class=\"mjx-math\" aria-label=\"2^k -1\"><span class=\"mjx-mrow\" aria-hidden=\"true\"><span class=\"mjx-msubsup\"><span class=\"mjx-base\"><span class=\"mjx-mn\"><span class=\"mjx-char MJXc-TeX-main-R\" style=\"padding-top: 0.372em; padding-bottom: 0.372em;\">2</span></span></span><span class=\"mjx-sup\" style=\"font-size: 70.7%; vertical-align: 0.591em; padding-left: 0px; padding-right: 0.071em;\"><span class=\"mjx-mi\" style=\"\"><span class=\"mjx-char MJXc-TeX-math-I\" style=\"padding-top: 0.446em; padding-bottom: 0.298em;\">k</span></span></span></span><span class=\"mjx-mo MJXc-space2\"><span class=\"mjx-char MJXc-TeX-main-R\" style=\"padding-top: 0.298em; padding-bottom: 0.446em;\">−</span></span><span class=\"mjx-mn MJXc-space2\"><span class=\"mjx-char MJXc-TeX-main-R\" style=\"padding-top: 0.372em; padding-bottom: 0.372em;\">1</span></span></span></span></span>에 대하여 worst case의 경우 upper bound 개수인 n </li>\n<li>각 레밸에서 1번 비교를 하니, 비교하는 횟수는 <span class=\"mjx-chtml\"><span class=\"mjx-math\" aria-label=\"k>=|log2n|\"><span class=\"mjx-mrow\" aria-hidden=\"true\"><span class=\"mjx-mi\"><span class=\"mjx-char MJXc-TeX-math-I\" style=\"padding-top: 0.446em; padding-bottom: 0.298em;\">k</span></span><span class=\"mjx-mo MJXc-space3\"><span class=\"mjx-char MJXc-TeX-main-R\" style=\"padding-top: 0.077em; padding-bottom: 0.372em;\">&gt;<span class=\"mjx-charbox MJXc-TeX-main-R\" style=\"padding-bottom: 0.314em;\">=</span></span></span><span class=\"mjx-texatom MJXc-space3\"><span class=\"mjx-mrow\"><span class=\"mjx-mo\"><span class=\"mjx-char MJXc-TeX-main-R\" style=\"padding-top: 0.446em; padding-bottom: 0.593em;\">|</span></span></span></span><span class=\"mjx-mi\"><span class=\"mjx-char MJXc-TeX-math-I\" style=\"padding-top: 0.446em; padding-bottom: 0.298em;\">l</span></span><span class=\"mjx-mi\"><span class=\"mjx-char MJXc-TeX-math-I\" style=\"padding-top: 0.225em; padding-bottom: 0.298em;\">o</span></span><span class=\"mjx-mi\"><span class=\"mjx-char MJXc-TeX-math-I\" style=\"padding-top: 0.225em; padding-bottom: 0.519em; padding-right: 0.003em;\">g</span></span><span class=\"mjx-mn\"><span class=\"mjx-char MJXc-TeX-main-R\" style=\"padding-top: 0.372em; padding-bottom: 0.372em;\">2</span></span><span class=\"mjx-mi\"><span class=\"mjx-char MJXc-TeX-math-I\" style=\"padding-top: 0.225em; padding-bottom: 0.298em;\">n</span></span><span class=\"mjx-texatom\"><span class=\"mjx-mrow\"><span class=\"mjx-mo\"><span class=\"mjx-char MJXc-TeX-main-R\" style=\"padding-top: 0.446em; padding-bottom: 0.593em;\">|</span></span></span></span></span></span></span></li>\n</ol>\n<p>따라서 비교 문제에 있어서 n개의 원소를 가질 경우 복잡도는 log(n) 보다 작을 수 없다. 따라서 시간복잡도를 (log n)을 가진 binary serach가 최적화된 알고리즘이라고 판단할 수 있다. </p>\n<h2 id=\"2-upper-bound-theory\" style=\"position:relative;\"><a href=\"#2-upper-bound-theory\" aria-label=\"2 upper bound theory permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. Upper Bound Theory</h2>\n<p>Upper Bound Theory는 해당 문제를 푸는데 최대 U(n)만큼이 시간이 뜬다는 것이다. 주로 worst case input인 경우 Upper Bound를 알 수 있다. <br></p>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#1-lower-bound-theory\">1. Lower Bound Theory:</a></p>\n<ul>\n<li>\n<p><a href=\"#trivial-lower-bound--\">Trivial Lower Bound -</a></p>\n<ul>\n<li><a href=\"#%EC%98%88%EC%8B%9C-multiplication-of-nn-matrix\">예시: Multiplication of n*n matrix</a></li>\n</ul>\n</li>\n<li><a href=\"#computational-model--\">Computational Model -</a></li>\n<li><a href=\"#ordered-searching--\">Ordered Searching -</a></li>\n<li><a href=\"#example-1-linear-search\">Example 1: Linear Search</a></li>\n<li><a href=\"#example-2-binary-search\">Example 2: Binary Search</a></li>\n<li><a href=\"#calculation-the-lower-bound\">Calculation the lower bound:</a></li>\n</ul>\n</li>\n<li><a href=\"#2-upper-bound-theory\">2. Upper Bound Theory</a></li>\n</ul>\n</div>","frontmatter":{"date":"September 04, 2020","title":"[번역] Lower and Upper Bound Theory","categories":"알고리즘","author":"코다","emoji":"🤹‍♀️"},"fields":{"slug":"/low-upper-bound/"}},"prev":{"id":"434d77fc-ebc7-5228-996f-38867e14fc32","html":"<p>앞서 <a href=\"https://www.acmicpc.net/problem/6549\">히스토그램 문제</a>에 대한 접근 방법을 간단하게 설명하고 세그먼트 트리를 히스토그램에 맞추어서 설명했다. 이번 글에서는 구체적으로 어떻게 세그먼트 트리를 구현하여 히스토그램 문제를 푸는데까지 이어지는지 다루어 보도록 하겠다. </p>\n<p>이 문제는 레벨이 높은 문제이긴 하지만 아이디어 자체가 굉장히 어렵거나 하진 않다. 다만 시간 복잡도 측면에서 효율적으로 접근하기 위해 세그먼트 트리를 활용하는게 좀 낯설어서 어려웠던 것 같다. </p>\n<h3 id=\"segment-tree-구현\" style=\"position:relative;\"><a href=\"#segment-tree-%EA%B5%AC%ED%98%84\" aria-label=\"segment tree 구현 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Segment Tree 구현</h3>\n<p>Segment Tree를 구현할 때 배열을 사용해서 구현하도록 할텐데 segment tree는 다음과 같은 성질을 가지고 있다. </p>\n<ul>\n<li>세그먼트 트리는 거의 Full Binary Tree(비슷한 형태를 지님)의 모습을 하고 있다. </li>\n<li>왼쪽 자식: 부모노트 * 2</li>\n<li>오른쪽 자식: 부모노드 * 2 + 1 </li>\n<li>높이: lgN</li>\n</ul>\n<p>배열을 통해서 tree를 구현하려면 사전에 tree의 노드 갯수를 파악해서 배열의 크기를 지정해야한다. 위의 성질들을 이용하면 해당 tree의 크기를 계산할 수 있다. 예를 들어 기존 배열의 개수가 <strong>2의 제곱인 경우</strong>에는 높기가 lgN 이므로 필요한 노드의 갯수는 <code class=\"language-text\">2*N-1</code> 이다. <strong>2의 제곱이 아닌 경우</strong>에는 N보다 큰지만 가장 가까운 2의 제곱을 찾으면 된다. 따라서 그 경우 노드의 갯수는 <code class=\"language-text\">2*2^(lgN+2)-1</code>이 된다. </p>\n<p>이렇게 크기를 지정해서 배열을 생성한 이후에 재귀 함수를 사용해서 이전 포스트에서 이야기 했던 부분을 구현하면 된다. 재귀를 잘 이해했다면 segment tree 생성은 크게 어렵지 않다. </p>\n<p><strong>코드:</strong></p>\n<p>먼저 segment tree를 저장할 배열 공간을 할당한다.  다음은 구현할 때 유용한 몇가지 JAVA 함수를 소개해준다. </p>\n<ul>\n<li>Ceil: 올림 숫자</li>\n<li>Math.log10(n)/Math.log10(2) = log2n</li>\n</ul>\n<p>Segment Tree의 index는 1부터 시작해야 한다. 그래야지 <code class=\"language-text\">2*i, 2*i+1</code>로 왼쪽 자식노드와 오른쪽 자식노드를 구별할 수 있다. </p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n  <span class=\"token keyword\">int</span> height <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token class-name\">Math</span><span class=\"token punctuation\">.</span><span class=\"token function\">ceil</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Math</span><span class=\"token punctuation\">.</span><span class=\"token function\">log10</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token operator\">/</span><span class=\"token class-name\">Math</span><span class=\"token punctuation\">.</span><span class=\"token function\">log10</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">int</span> size <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token class-name\">Math</span><span class=\"token punctuation\">.</span><span class=\"token function\">pow</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> height<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  \n  <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> binTree <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span>size<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">init</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>다음은 segment tree에 값을 할당하는 부분이다. </p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">init</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> start<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> end<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> index<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>start<span class=\"token operator\">==</span>end<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    binTree<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> start<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">init</span><span class=\"token punctuation\">(</span>start<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>start<span class=\"token operator\">+</span>end<span class=\"token punctuation\">)</span><span class=\"token operator\">/</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> index<span class=\"token operator\">*</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">init</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>start<span class=\"token operator\">+</span>end<span class=\"token punctuation\">)</span><span class=\"token operator\">/</span><span class=\"token number\">2</span><span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> end<span class=\"token punctuation\">,</span> index<span class=\"token operator\">*</span><span class=\"token number\">2</span><span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">[</span>binTree<span class=\"token punctuation\">[</span>index<span class=\"token operator\">*</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token operator\">&lt;=</span>value<span class=\"token punctuation\">[</span>binTree<span class=\"token punctuation\">[</span>index<span class=\"token operator\">*</span><span class=\"token number\">2</span><span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    binTree<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> binTree<span class=\"token punctuation\">[</span>index<span class=\"token operator\">*</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">else</span>\n    binTree<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> binTree<span class=\"token punctuation\">[</span>index<span class=\"token operator\">*</span><span class=\"token number\">2</span><span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3 id=\"segment-tree-탐색\" style=\"position:relative;\"><a href=\"#segment-tree-%ED%83%90%EC%83%89\" aria-label=\"segment tree 탐색 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Segment Tree 탐색</h3>\n<p>Segment Tree를 생성했으면 이제 각 구간을 순회하며 해당 구간의 최소값을 구해야 한다. 일반적인 세그먼트 트리의 예시에서 구간합을 구할 경우 각 segment tree에 있는 값의 합을 구하면 되지만, 히스토그램 문제에서는 최소값을 찾아야 하니, 한번 더 참조해야 하는 부분이 있다. </p>\n<p>이 부분은 세그먼트 트리에 대해서 설명해놓은 <a href=\"https://www.acmicpc.net/blog/view/9\">백준 블로그</a>를 참조하면서 이해 했는데 매우 잘 설명이 되어 있다. 세그먼트의 해당 노드가 담당하고 있는 구간을 [start, end]로, 합을 구하는 목적 구간을 [left, right]로 놓았을 때 다음 4가지 경우가 있다. </p>\n<ol>\n<li>합을 구해야하는 [left, right]와 현재 노드가 담당하고 있는 [start, end]가 겹치지 않는 경우</li>\n<li>합을 구해야하는 [left, right]가 현재 노드가 담당하고 있는 [start, end]를 완전히 포함하는 경우</li>\n<li>현재 노드가 담당하고 있는 [start, end]가 [left, right]를 완전히 포함하는 경우</li>\n<li>[left, right]와 [start, end]가 겹쳐져 있는 경우 (1, 2, 3을 제외한 나머지)</li>\n</ol>\n<p>위의 4가지 경우에 대해서 다음과 같이 처리한다. </p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">1번 경우: if(left > end || right &lt; start) \n\t- 겹치지 않으므로 탐색할 필요 없음\n2번 경우: if(left &lt;= start &amp;&amp; end &lt;= right)\n\t- 해당 노드의 값을 리턴함\n3,4번 경우:\n\t- 각각 왼쪽, 오른쪽 자식 노드에서 탐색함. </code></pre></div>\n<p>히스토그램 문제에서는 최소값을 찾아야 하는 것이기 때문에 왼쪽과 오른쪽 자식 노드로 나누어서 들어갈 때, 배열을 한번 더 참조해서 구간에서 최종 최소값이 있는 위치를 찾아야 한다. </p>\n<p><strong>코드:</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">findMin</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> start<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> last<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> left<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> right<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> index<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>left<span class=\"token operator\">></span>last <span class=\"token operator\">||</span> right<span class=\"token operator\">&lt;</span>start<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>left<span class=\"token operator\">&lt;=</span>start <span class=\"token operator\">&amp;&amp;</span> right<span class=\"token operator\">>=</span>last<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> binTree<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> temp1 <span class=\"token operator\">=</span> <span class=\"token function\">findMin</span><span class=\"token punctuation\">(</span>start<span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span>start<span class=\"token operator\">+</span>last<span class=\"token punctuation\">)</span><span class=\"token operator\">/</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> left<span class=\"token punctuation\">,</span> right<span class=\"token punctuation\">,</span> index<span class=\"token operator\">*</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> temp2 <span class=\"token operator\">=</span> <span class=\"token function\">findMin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>start<span class=\"token operator\">+</span>last<span class=\"token operator\">/</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> last<span class=\"token punctuation\">,</span> left<span class=\"token punctuation\">,</span> right<span class=\"token punctuation\">,</span> index<span class=\"token operator\">*</span><span class=\"token number\">2</span><span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>temp1 <span class=\"token operator\">==</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">return</span> temp2<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>temp2 <span class=\"token operator\">==</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">return</span> temp1<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">[</span>temp1<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;=</span> value<span class=\"token punctuation\">[</span>temp2<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> temp1<span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">return</span> temp2<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3 id=\"히스토그램-풀이\" style=\"position:relative;\"><a href=\"#%ED%9E%88%EC%8A%A4%ED%86%A0%EA%B7%B8%EB%9E%A8-%ED%92%80%EC%9D%B4\" aria-label=\"히스토그램 풀이 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>히스토그램 풀이</h3>\n<p>위의 세그먼트 트리 생성과 탐색 방법을 사용해서 최소값을 찾는 부분을 구현했다면 이제 답을 구현하도록 해보자. 앞의 포스트에서 언급했던 방법은 아래이다. </p>\n<blockquote>\n<p>먼저 <a href=\"https://www.acmicpc.net/problem/6549\">문제</a>의 해결 방법을 요약하면 다음과 같다. </p>\n<blockquote>\n<ol>\n<li>히스토그램 중, 높이가 가장 낮은 min 값과 해당 너비값을 곱하여 넓이를 구함. </li>\n<li>해당 최소값을 기준으로 히스토램을 나누어서 1번을 반복함. </li>\n<li>더 이상 나눌 수 없을 때까지 반복하며 매번 넓이의 max 값을 업데이트 함. </li>\n</ol>\n</blockquote>\n</blockquote>\n<p>위의 방법이 분할정복인 이유는 반복적으로 나뉘어지는 구간에서의 직사각형을 계속 비교하면서 최대 크기를 찾기 때문이다. 세그먼트 트리에 저장된 최소값의 위치를 활용해서 해당 기준으로 나누고, 나눈 구간에서의 직사각형 넓이 구할 때 사용하도록 한다. </p>\n<p><strong>코드:</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> startIndex<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> lastIndex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">long</span> area <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>startIndex <span class=\"token operator\">==</span> lastIndex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    area <span class=\"token operator\">=</span> value<span class=\"token punctuation\">[</span>startIndex<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>area<span class=\"token operator\">></span>max<span class=\"token punctuation\">)</span>\n      max <span class=\"token operator\">=</span> area<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">int</span> minIndex <span class=\"token operator\">=</span> <span class=\"token function\">findMin</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> startIndex<span class=\"token punctuation\">,</span> lastIndex<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">long</span> min <span class=\"token operator\">=</span> value<span class=\"token punctuation\">[</span>minIndex<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  \n  <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>area<span class=\"token operator\">></span>max<span class=\"token punctuation\">)</span>\n    max <span class=\"token operator\">=</span> area<span class=\"token punctuation\">;</span>\n  \n  <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>minIndex <span class=\"token operator\">==</span> startIndex<span class=\"token punctuation\">)</span>\n    <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span>minIndex<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> lastIndex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>minIndex <span class=\"token operator\">>=</span> lastIndex<span class=\"token punctuation\">)</span>\n    <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span>startIndex<span class=\"token punctuation\">,</span> minIndex<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span>startIndex<span class=\"token punctuation\">,</span> minIndex<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">solve</span><span class=\"token punctuation\">(</span>minIndex<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> lastIndex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><strong><small>[참고 자료]: <a href=\"https://www.acmicpc.net/blog/view/12\">https://www.acmicpc.net/blog/view/12</a>, <a href=\"https://www.crocus.co.kr/648\">https://www.crocus.co.kr/648</a>, <a href=\"https://www.acmicpc.net/blog/view/9\">https://www.acmicpc.net/blog/view/9</a> </small></strong></p>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#segment-tree-%EA%B5%AC%ED%98%84\">Segment Tree 구현</a></li>\n<li><a href=\"#segment-tree-%ED%83%90%EC%83%89\">Segment Tree 탐색</a></li>\n<li><a href=\"#%ED%9E%88%EC%8A%A4%ED%86%A0%EA%B7%B8%EB%9E%A8-%ED%92%80%EC%9D%B4\">히스토그램 풀이</a></li>\n</ul>\n</div>","frontmatter":{"date":"September 10, 2020","title":"세그먼트 트리를 활용한 히스토그램 문제 풀이_2","categories":"알고리즘","author":"코다","emoji":"🤹‍♀️"},"fields":{"slug":"/segment-tree-2/"}},"site":{"siteMetadata":{"siteUrl":"https://yjksw.github.io","comments":{"utterances":{"repo":"yjksw/yjksw.github.io"}}}}},"pageContext":{"slug":"/segment-tree-1/","nextSlug":"/low-upper-bound/","prevSlug":"/segment-tree-2/"}},"staticQueryHashes":["1073350324","2938748437"]}
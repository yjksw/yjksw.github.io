{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/jpa-fetch-join-nickname/",
    "result": {"data":{"cur":{"id":"f536d063-bb0a-5d8a-89be-12abd97a0c4e","html":"<h2 id=\"intro\" style=\"position:relative;\"><a href=\"#intro\" aria-label=\"intro permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Intro</h2>\n<ul>\n<li>JPA의 <code class=\"language-text\">fetch join</code> 사용시 별칭을 쓰면 안되는 이유가 무엇인지 알아본다.</li>\n<li><a href=\"https://github.com/woowacourse-teams/2021-pick-git\">프로젝트</a>애서 fetch join 시 별칭 사용에 대해서 고민해본다.</li>\n</ul>\n<br>\n<h2 id=\"fetch-join-별칭은-왜-안될까-\" style=\"position:relative;\"><a href=\"#fetch-join-%EB%B3%84%EC%B9%AD%EC%9D%80-%EC%99%9C-%EC%95%88%EB%90%A0%EA%B9%8C-\" aria-label=\"fetch join 별칭은 왜 안될까  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>fetch join 별칭은 왜 안될까 ?</h2>\n<ul>\n<li>\n<p>fetch join에서 별칭이 안되는 이유는 데이터의 일관성이 깨지기 때문이다.</p>\n</li>\n<li>\n<p>예를 들어서 다음과 같은 코드는 fetch join 대상에 조건문이 들어가서 일관성이 깨진 경우이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@DisplayName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"fetch join 대상에 조건문을 걸었을 때 데이터가 불일치하다.\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token annotation punctuation\">@Test</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">findTeamWithSpecificNameMember</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// given</span>\n\n    <span class=\"token comment\">// 데이터 삽입</span>\n    <span class=\"token class-name\">Team</span> teamA <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Team</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"teamA\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token class-name\">Member</span> memberA1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Member</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"memberA1\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">Member</span> memberA2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Member</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"memberA2\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">Member</span> memberA3 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Member</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"memberA3\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Member</span><span class=\"token punctuation\">></span></span> teamAMembers <span class=\"token operator\">=</span> <span class=\"token class-name\">List</span><span class=\"token punctuation\">.</span><span class=\"token function\">of</span><span class=\"token punctuation\">(</span>memberA1<span class=\"token punctuation\">,</span> memberA2<span class=\"token punctuation\">,</span> memberA3<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    teamA<span class=\"token punctuation\">.</span><span class=\"token function\">setMembers</span><span class=\"token punctuation\">(</span>teamAMembers<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    teamRepository<span class=\"token punctuation\">.</span><span class=\"token function\">save</span><span class=\"token punctuation\">(</span>teamA<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    testEntityManager<span class=\"token punctuation\">.</span><span class=\"token function\">flush</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    testEntityManager<span class=\"token punctuation\">.</span><span class=\"token function\">clear</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 데이터 조회</span>\n    <span class=\"token class-name\">Team</span> teamA <span class=\"token operator\">=</span> teamRepository<span class=\"token punctuation\">.</span><span class=\"token function\">findById</span><span class=\"token punctuation\">(</span><span class=\"token number\">1L</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">orElseThrow</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> teamAMemberSize <span class=\"token operator\">=</span> teamA<span class=\"token punctuation\">.</span><span class=\"token function\">getMembers</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    testEntityManager<span class=\"token punctuation\">.</span><span class=\"token function\">clear</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// when</span>\n    <span class=\"token class-name\">Team</span> teamAWithMemberName <span class=\"token operator\">=</span> teamRepository<span class=\"token punctuation\">.</span><span class=\"token function\">findTeamWithSomeMemberByName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"memberA1\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// then</span>\n    <span class=\"token comment\">/* 본래 teamA에 3명의 멤버가 들어가있지만 fetch join 대상에 where문이 들어가면서 데이터 불일치가 일어났다.\n    * collection 에는 관련 데이터가 모두 들어가있기를 기대하는데 그렇지 않다.\n    * 따라서 fetch join 대상에 필터링 조건을 거는 것을 지양한다. \n    */</span>\n    <span class=\"token function\">assertThat</span><span class=\"token punctuation\">(</span>teamA<span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">isEqualTo</span><span class=\"token punctuation\">(</span>teamAWithMemberName<span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">assertThat</span><span class=\"token punctuation\">(</span>teamAMemberSize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">isNotEqualTo</span><span class=\"token punctuation\">(</span>teamAWithMemberName<span class=\"token punctuation\">.</span><span class=\"token function\">getMembers</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n<li>\n<p>TeamA에 대한 member collection 은 본래 3개이다. 그리고 fetch join을 하면 연관된 데이터가 모두 들어올 것이라고 가정한다.</p>\n</li>\n<li>\n<p>하지만 위와 같이 fetch join 대상에 별칭을 주어 where 필터링 조건을 사용하면 실제로 TeamA에 연관된 멤버는 3명이지만 <code class=\"language-text\">memberA1</code>만 연관 데이터로 들어온다.</p>\n</li>\n<li>\n<p>DB의 상태에 대한 일관성이 깨진다.</p>\n</li>\n</ul>\n<h3 id=\"하지만-예외는-있다\" style=\"position:relative;\"><a href=\"#%ED%95%98%EC%A7%80%EB%A7%8C-%EC%98%88%EC%99%B8%EB%8A%94-%EC%9E%88%EB%8B%A4\" aria-label=\"하지만 예외는 있다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>하지만 예외는 있다</h3>\n<ul>\n<li>\n<p>일관성을 해치지지 않는 한에서 성능에 도움이 된다면 예외적으로 사용해도 된다. (아마도 하이버네이트가 별칭을 허용하는 이유…)</p>\n</li>\n<li>\n<p>예를 들어 다음과 같은 쿼리는 일관성을 해치지 않는다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">select</span> m <span class=\"token keyword\">from</span> Member m <span class=\"token keyword\">join</span> <span class=\"token keyword\">fetch</span> m<span class=\"token punctuation\">.</span>team <span class=\"token keyword\">where</span> t<span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> :teamName</code></pre></div>\n</li>\n<li>\n<p>하지만 위의 쿼리가 left join fetch로 되면 일관성이 깨진다. (Team이 null이 아닌 Member에 대해서 null 값이 들어가기 때문이다.)</p>\n</li>\n<li>\n<p>때문에 매우 조심스럽게 사용해야한다.</p>\n</li>\n</ul>\n<br>\n<h2 id=\"우리-프로젝트에-있는-별칭은\" style=\"position:relative;\"><a href=\"#%EC%9A%B0%EB%A6%AC-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EC%97%90-%EC%9E%88%EB%8A%94-%EB%B3%84%EC%B9%AD%EC%9D%80\" aria-label=\"우리 프로젝트에 있는 별칭은 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>우리 프로젝트에 있는 별칭은?!</h2>\n<ul>\n<li>\n<p>깃들다 프로젝트에도 fetch join 대상에 별칭을 사용하는 부분이 있다. 다음 <a href=\"http://tech.pick-git.com/jpa-proxy-equals-bug/\">포스트</a>에 어떤 상황이었는지 배경 설명이 자세하게 되어있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Query</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"select distinct p from Post p left join fetch p.likes.likes l left join fetch l.user where p.id = :postId\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token class-name\">Optional</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Post</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">findPostWithLikeUsers</span><span class=\"token punctuation\">(</span><span class=\"token annotation punctuation\">@Param</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"postId\"</span><span class=\"token punctuation\">)</span> <span class=\"token class-name\">Long</span> postId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n</li>\n<li>\n<p>Post 안에는 해당 게시물을 좋아요한 유저들 정보를 담은 <code class=\"language-text\">Like</code> 리스트가 담겨있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Entity</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Post</span> <span class=\"token punctuation\">{</span>\n\n  <span class=\"token comment\">//....</span>\n\n   <span class=\"token annotation punctuation\">@OneToMany</span><span class=\"token punctuation\">(</span>\n      mappedBy <span class=\"token operator\">=</span> <span class=\"token string\">\"post\"</span><span class=\"token punctuation\">,</span>\n      fetch <span class=\"token operator\">=</span> <span class=\"token class-name\">FetchType</span><span class=\"token punctuation\">.</span>LAZY<span class=\"token punctuation\">,</span>\n      cascade <span class=\"token operator\">=</span> <span class=\"token class-name\">CascadeType</span><span class=\"token punctuation\">.</span>PERSIST<span class=\"token punctuation\">,</span>\n      orphanRemoval <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n  <span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">private</span> <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Like</span><span class=\"token punctuation\">></span></span> likes<span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">//...</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Like</span> <span class=\"token punctuation\">{</span>\n\n  <span class=\"token annotation punctuation\">@Id</span> <span class=\"token annotation punctuation\">@GeneratedValue</span><span class=\"token punctuation\">(</span>strategy <span class=\"token operator\">=</span> <span class=\"token class-name\">GenerationType</span><span class=\"token punctuation\">.</span>IDENTITY<span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">private</span> <span class=\"token class-name\">Long</span> id<span class=\"token punctuation\">;</span>\n\n  <span class=\"token annotation punctuation\">@ManyToOne</span><span class=\"token punctuation\">(</span>fetch <span class=\"token operator\">=</span> <span class=\"token class-name\">FetchType</span><span class=\"token punctuation\">.</span>LAZY<span class=\"token punctuation\">)</span>\n  <span class=\"token annotation punctuation\">@JoinColumn</span><span class=\"token punctuation\">(</span>name <span class=\"token operator\">=</span> <span class=\"token string\">\"post_id\"</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">private</span> <span class=\"token class-name\">Post</span> post<span class=\"token punctuation\">;</span>\n\n  <span class=\"token annotation punctuation\">@ManyToOne</span><span class=\"token punctuation\">(</span>fetch <span class=\"token operator\">=</span> <span class=\"token class-name\">FetchType</span><span class=\"token punctuation\">.</span>LAZY<span class=\"token punctuation\">)</span>\n  <span class=\"token annotation punctuation\">@JoinColumn</span><span class=\"token punctuation\">(</span>name <span class=\"token operator\">=</span> <span class=\"token string\">\"user_id\"</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">private</span> <span class=\"token class-name\">User</span> user<span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">//...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n<li>\n<p>위 쿼리를 살펴보면</p>\n<ul>\n<li>별칭이 <code class=\"language-text\">p.likes.likes l</code>에 사용된다.</li>\n<li>where 조건문에는 fetch join 대상을 필터링 하지 않는다.</li>\n<li>따라서 데이터 일관성을 헤치지 않는다.</li>\n</ul>\n</li>\n<li>\n<p>fetch join을 할 때 주의해야하는 부분은 collection을 여러개 fetch join 할 경우이다.</p>\n</li>\n<li>\n<p>위 같은 경우는 <code class=\"language-text\">post -> like</code> 관계는 OneToMany라서 한번까지 fetch join 할 수 있다.</p>\n</li>\n<li>\n<p><code class=\"language-text\">like -> user</code>는 ManyToOne 관계 이므로 추가 fetch join을 할 수 있었다.</p>\n</li>\n</ul>\n<br>\n<h2 id=\"마무리\" style=\"position:relative;\"><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-label=\"마무리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>마무리</h2>\n<ul>\n<li>처음에 버그를 마주하고 fetch join 대상에 별칭을 두는 것이 찝찝했지만 왜 안되는지 모르는 상태로 (나만) 넘어갔다.</li>\n<li>검토해보니 fetch join 대상이 아니었으며 여러 collection을 fetch join 하는 상황도 아니었다.</li>\n<li>하지만 이런 예외적인 경우는 자세히 알아보고 주의해서 사용해야 할 것 같다. 또 왜인지 모르고 그냥 안쓰지는 말자.</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#intro\">Intro</a></p>\n</li>\n<li>\n<p><a href=\"#fetch-join-%EB%B3%84%EC%B9%AD%EC%9D%80-%EC%99%9C-%EC%95%88%EB%90%A0%EA%B9%8C-\">fetch join 별칭은 왜 안될까 ?</a></p>\n<ul>\n<li><a href=\"#%ED%95%98%EC%A7%80%EB%A7%8C-%EC%98%88%EC%99%B8%EB%8A%94-%EC%9E%88%EB%8B%A4\">하지만 예외는 있다</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%9A%B0%EB%A6%AC-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EC%97%90-%EC%9E%88%EB%8A%94-%EB%B3%84%EC%B9%AD%EC%9D%80\">우리 프로젝트에 있는 별칭은?!</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\">마무리</a></p>\n</li>\n</ul>\n</div>","excerpt":"Intro JPA의  사용시 별칭을 쓰면 안되는 이유가 무엇인지 알아본다. 프로젝트애서 fetch join 시 별칭 사용에 대해서 고민해본다. fetch join 별칭은 왜 안될까 ? fetch join에서 별칭이 안되는 이유는 데이터의 일관성이 깨지기 때문이다. 예를 들어서 다음과 같은 코드는 fetch join 대상에 조건문이 들어가서 일관성이 깨진 경우이다. TeamA에 대한 member collection 은 본래 3개이다. 그리고 fetch join을 하면 연관된 데이터가 모두 들어올 것이라고 가정한다. 하지만 위와 같이 fetch join 대상에 별칭을 주어 where 필터링 조건을 사용하면 실제로 TeamA에 연관된 멤버는 3명이지만 만 연관 데이터로 들어온다. DB의 상태에 대한 일관성이 깨진다. 하지만 예외는 있다 일관성을 해치지지 않는 한에서 성능에 도움이 된다면 예외적으로 사용해도 된다. (아마도 하이버네이트가 별칭을 허용하는 이유…) 예를 들어 다음과 같은 쿼…","frontmatter":{"date":"October 06, 2021","title":"JPA 에서 별칭을 쓰지 않는 이유 (하지만 쓴 이유)","categories":"JPA 프로젝트","author":"코다","emoji":"🚀"},"fields":{"slug":"/jpa-fetch-join-nickname/"}},"next":{"id":"4ffde1a9-559f-5ac3-96ef-467e77c4740e","html":"<blockquote>\n<p>다음은 <em>성공과 실패를 결정하는 1%의 네트워크 원리</em> 를 읽고 정리한 내용입니다. 본 글은 CH5. 서버측의 LAN에는 무엇이 있는가?_방화벽과 캐시 서버의 탐험입니다 🙌</p>\n</blockquote>\n<br>\n<br>\n<h2 id=\"-story4-캐시-서버를-이용한-서버의-부하-분산\" style=\"position:relative;\"><a href=\"#-story4-%EC%BA%90%EC%8B%9C-%EC%84%9C%EB%B2%84%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%84%9C%EB%B2%84%EC%9D%98-%EB%B6%80%ED%95%98-%EB%B6%84%EC%82%B0\" aria-label=\" story4 캐시 서버를 이용한 서버의 부하 분산 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🛺 [Story4] 캐시 서버를 이용한 서버의 부하 분산</h2>\n<h3 id=\"1-캐시-서버의-이용\" style=\"position:relative;\"><a href=\"#1-%EC%BA%90%EC%8B%9C-%EC%84%9C%EB%B2%84%EC%9D%98-%EC%9D%B4%EC%9A%A9\" aria-label=\"1 캐시 서버의 이용 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 캐시 서버의 이용</h3>\n<ul>\n<li>프록시 구조를 사용하여 데이터를 캐시에 저장한다.</li>\n<li>프록시는 웹 서버와 클라이언트 사이에 들어가서 웹 서버에 대한 액세스 동작을 중개한다.\n<ul>\n<li>중개하는 과정에서 웹 서버에서 받은 데이터를 저장해두고 가능하면 해당 데이터를 대신하여 응답한다.</li>\n<li>웹 서버가 처리해야할 일을 실행하기 위해서 오랜 시간이 걸리는 반면 캐시 서버는 받은 데이터를 곧바로 송신만 하면 되기 때문에 매우 빠르다.</li>\n</ul>\n</li>\n<li>데이터가 자주 바뀌는 부분은 캐시 서버를 활용하기 어렵다. 하지만 캐시 서버에서 처리할 수 있는 얼마를 담당하면 웹 서버에 가는 부하도 줄어들어 처리속도도 향상된다.</li>\n</ul>\n<h3 id=\"2-캐시-서버는-갱신일로-콘텐츠를-관리한다\" style=\"position:relative;\"><a href=\"#2-%EC%BA%90%EC%8B%9C-%EC%84%9C%EB%B2%84%EB%8A%94-%EA%B0%B1%EC%8B%A0%EC%9D%BC%EB%A1%9C-%EC%BD%98%ED%85%90%EC%B8%A0%EB%A5%BC-%EA%B4%80%EB%A6%AC%ED%95%9C%EB%8B%A4\" aria-label=\"2 캐시 서버는 갱신일로 콘텐츠를 관리한다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 캐시 서버는 갱신일로 콘텐츠를 관리한다</h3>\n<ul>\n<li>캐시 서버가 동작할 때 캐시 서버를 웹 서버 대신 DNS에 등록한다. 따라서 요청이 오면 캐시 서버가 대신해서 데이터를 받는다.\n<ul>\n<li>메세지를 받을 때 웹 서버의 수신 동작과 동일한 절차를 거쳐서 받는다.</li>\n<li>패킷을 만들고, 접속 동작을 실행하고 요청 메세지를 받는다.</li>\n</ul>\n</li>\n<li>이후 해당 요청에 대한 데이터가 저장되어 있는지 조사한다.</li>\n<li>저장된 데이터가 없는 경우\n<ul>\n<li><code class=\"language-text\">Via</code> 라는 필드 값을 헤더에 추가하여 캐시 서버를 경유했다는 것을 나타낸다.\n<ul>\n<li>중요한 값은 아니며 캐시 서버의 설정에 따라서 추가되지 않는 경우도 있다.</li>\n</ul>\n</li>\n<li>만일 여러대의 서버가 캐시 서버에 연결이 되어 있다면 요청의 URI에 따라서 웹 서버로 요청을 전송한다.\n<ul>\n<li>이때 클라이언트는 캐시 서버로 변경된다.</li>\n</ul>\n</li>\n<li>웹 서버에서 캐시 서버로 응답을 보내고 캐시 서버는 <code class=\"language-text\">Via</code> 헤더를 추가하여 클라이언트에게 응답을 한다.</li>\n<li>그리고 응답에 대한 메시지를 캐시 서버에 저장하고 저장한 일시를 기록한다.</li>\n</ul>\n</li>\n<li>데이터가 저장되어 있는 경우\n<ul>\n<li>만일 캐시 데이터가 저장되어 있다면 해당 데이터가 변경 되지는 않았는지 확인하는 <code class=\"language-text\">If-Modified-Since</code> 헤더를 덧붙여서 웹 서버에 전송한다.\n<ul>\n<li>만일 데이터가 없었다면 위 헤더는 추가되지 않는다.</li>\n</ul>\n</li>\n<li>이때 웹 서버는 변경이 없다면 <code class=\"language-text\">304 Not Modified</code> 상태코드를 응답한다. 변경이 있다면 데이터가 없던 것과 마찬가지로 동작한다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-프록시의-원점은-포워드-프록시이다\" style=\"position:relative;\"><a href=\"#3-%ED%94%84%EB%A1%9D%EC%8B%9C%EC%9D%98-%EC%9B%90%EC%A0%90%EC%9D%80-%ED%8F%AC%EC%9B%8C%EB%93%9C-%ED%94%84%EB%A1%9D%EC%8B%9C%EC%9D%B4%EB%8B%A4\" aria-label=\"3 프록시의 원점은 포워드 프록시이다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 프록시의 원점은 포워드 프록시이다</h3>\n<ul>\n<li>클라이언트측에 캐시 서버를 두는 경우이다. → 포워드 프록시</li>\n<li>웹 서버에 대한 캐시 서버와 동일하게 동작하지만 추가로 방화벽을 실현하는 목적이 있었다.</li>\n<li>방화벽은 인터넷에서의 부정침입을 막는 것이기 때문에 프록시에서 요청 메세지를 받아 인터넷으로 필요한 것을 통과시키는 역할을 한다.</li>\n<li>프록시의 캐시를 이용하면 사내 LAN에서 더 빨리 데이터를 얻을 수 있다.</li>\n<li>프록시를 사용하면 요청의 내용을 조사하기 때문에 더 자세한 조건을 설정해서 특정 사이나에 대한 액세스를 금지하는 등의 제한을 걸 수 있다.</li>\n</ul>\n<h4 id=\"포워드-프록시-사용시-데이터-송신\" style=\"position:relative;\"><a href=\"#%ED%8F%AC%EC%9B%8C%EB%93%9C-%ED%94%84%EB%A1%9D%EC%8B%9C-%EC%82%AC%EC%9A%A9%EC%8B%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%86%A1%EC%8B%A0\" aria-label=\"포워드 프록시 사용시 데이터 송신 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>포워드 프록시 사용시 데이터 송신</h4>\n<ul>\n<li>요청 메세지의 URL과 관계없이 모든 요청을 포워드 프록시에 우선 송신한다.</li>\n<li>요청 메세지의 내용도 변경된다.\n<ul>\n<li>본래 웹 서버의 이름을 제외하고 URI에 데이터 경로를 적었는데, 포워드 프록시를 사용하는 경우 이름까지 그대로 요청 URL에 기록한다.</li>\n</ul>\n</li>\n<li>URL에 적힌 그대로가 전송 대상이므로 서버측 캐시 서버와 같이 정해진 서버로 전송하는 것이 아니라 모든 서버에 전송할 수 있다.</li>\n</ul>\n<h3 id=\"4-포워드-프록시를-개량한-리버스-프록시\" style=\"position:relative;\"><a href=\"#4-%ED%8F%AC%EC%9B%8C%EB%93%9C-%ED%94%84%EB%A1%9D%EC%8B%9C%EB%A5%BC-%EA%B0%9C%EB%9F%89%ED%95%9C-%EB%A6%AC%EB%B2%84%EC%8A%A4-%ED%94%84%EB%A1%9D%EC%8B%9C\" aria-label=\"4 포워드 프록시를 개량한 리버스 프록시 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. 포워드 프록시를 개량한 리버스 프록시</h3>\n<ul>\n<li>포워드 프록시는 브라우저의 설정이 필요해 장애의 원인이 되기도 한다.</li>\n<li>따라서 요청 메세지에 전체 URL이 아닌 URI 에 쓰여있는 디렉토리를 웹 서버에 대응시켜 전송할 수 있도록 했다 → 서버측에 설치하는 캐시 서버에서 채택한 방법으로 <strong>리버스 프록시</strong>라고 한다.</li>\n</ul>\n<h3 id=\"5-트랜스패어런트-프록시\" style=\"position:relative;\"><a href=\"#5-%ED%8A%B8%EB%9E%9C%EC%8A%A4%ED%8C%A8%EC%96%B4%EB%9F%B0%ED%8A%B8-%ED%94%84%EB%A1%9D%EC%8B%9C\" aria-label=\"5 트랜스패어런트 프록시 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5. 트랜스패어런트 프록시</h3>\n<ul>\n<li>캐시 서버에서 전송 대상을 판단하는 방법이다.\n<ul>\n<li>IP 헤더의 수신처 IP 주소로 액세스 대상 웹 서버를 찾는 방법을 <strong>트랜스패어런트 프록시</strong>라고 한다.</li>\n</ul>\n</li>\n<li>포워드 프록시에서 처럼 브라우저에 설정할 필요도 없고 리버스 프록시처럼 전송 대상을 리버스 프록시로 설정하고 DNS에 등록할 필요도 없다.\n<ul>\n<li>만일 트랜스패어런트 프록시에 DNS에 등록된다면 수신처 IP가 해당 프록시가 되므로 수신처 IP를 조사해서 패킷을 중개하는 구조를 사용할 수 있다.</li>\n</ul>\n</li>\n<li>그래서 트랜스 패어런트 프록시를 브라우저에서 웹 서버로 요청 메세지가 흘러가는 길목에 설치하거나 한 길로 수렴하는 네트워크의 길목에 설치하여 사용한다. (길마다 프록시를 설치해야할 수도 있다)</li>\n</ul>\n<br>\n<h2 id=\"-story5-콘텐츠-배포-서비스\" style=\"position:relative;\"><a href=\"#-story5-%EC%BD%98%ED%85%90%EC%B8%A0-%EB%B0%B0%ED%8F%AC-%EC%84%9C%EB%B9%84%EC%8A%A4\" aria-label=\" story5 콘텐츠 배포 서비스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🛺 [Story5] 콘텐츠 배포 서비스</h2>\n<h3 id=\"1-cdn을-이용한-부하-분산\" style=\"position:relative;\"><a href=\"#1-cdn%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%B6%80%ED%95%98-%EB%B6%84%EC%82%B0\" aria-label=\"1 cdn을 이용한 부하 분산 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. CDN을 이용한 부하 분산</h3>\n<ul>\n<li>서버 측 캐시와 클라이언트 측 캐시의 부하 경감 효과가 각각 다르다.\n<ul>\n<li>서버 측 캐시는 웹 서버에 들어오는 요청에 대한 부하를 분산시킨다.</li>\n<li>클라이언트 측 캐시는 인터넷에 들어오는 패킷 수를 줄여 인터넷 트래픽을 억제한다.</li>\n</ul>\n</li>\n<li>인터넷 트래픽을 억제하기 위해서는 (특히나 대용량 이미지나 영상 데이터에 대해) 클라이언트 측에 캐시 서버를 두는 것이 더 좋다. 하지만 그것은 웹 서버 개발자가 제어할 수 있는 부분이 아니다. (브라우저를 통한 설정이 필요하기 때문이다.)</li>\n<li>따라서 해결책으로 프로바이더와 계약하여 웹 서버 개발자가 제어할 수 있는 클라이언트 가까이 있는 캐시 서버를 이용하는 것이다. → CDN</li>\n</ul>\n<p align=\"center\"><img width=\"70%\" src=\"https://user-images.githubusercontent.com/63405904/139086526-535450f9-f459-4d2d-bc6c-748046ff5174.png\"><br>출처: 상위 1% 네트워크</p>\n<ul>\n<li>모든 프로바이더에 캐시 서버를 설치하는 것은 어려우니 우선 중요한 프로바이더마다 캐시 서버를 설치한다.</li>\n<li>서버 운영자가 직접 설치하고 프로바이더와 계약하는 것이 어려우므로 그것을 대신 하고 캐시 서버를 대출하는 CDN 서비스가 등장했다.\n<ul>\n<li>CDN 서버는 여러 웹 서버의 데이터를 캐싱할 수 있으므로 여러 웹 서버 개발자들이 공동으로 이용하여 이용 비용을 절감할 수 있다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-가장-가까운-캐시-서버의-관점\" style=\"position:relative;\"><a href=\"#2-%EA%B0%80%EC%9E%A5-%EA%B0%80%EA%B9%8C%EC%9A%B4-%EC%BA%90%EC%8B%9C-%EC%84%9C%EB%B2%84%EC%9D%98-%EA%B4%80%EC%A0%90\" aria-label=\"2 가장 가까운 캐시 서버의 관점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 가장 가까운 캐시 서버의 관점</h3>\n<ul>\n<li>CDN을 사용하기 위해서는 클라이언트가 가장 가까운 캐시 서버를 찾을 수 있어야한다.</li>\n</ul>\n<h4 id=\"최초-방법\" style=\"position:relative;\"><a href=\"#%EC%B5%9C%EC%B4%88-%EB%B0%A9%EB%B2%95\" aria-label=\"최초 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>최초 방법</h4>\n<ul>\n<li>DNS 서버가 IP주소를 응답할 때 가장 가까운 캐시 서버의 IP 주소를 응답하도록 설정한다.\n<ul>\n<li>DNS 서버에서 복수의 IP가 등록된 경우 RR로 응답하는 것을 변경한다.</li>\n<li>응답할 때 RR 방식이 아니라 클라이언트와 캐시 서버의 거리를 판단하여 가장 가까운 캐시 서버 IP를 반환하도록 한다.</li>\n</ul>\n</li>\n<li>가장 가까운 거리를 측정하는 방법\n<ul>\n<li>캐시 서버의 설치 장소에 있는 라우터에서 경로 정보를 모은다. (캐시 서버 갯수만큼의 경로표가 모인다)</li>\n<li>웹 서버 측 DNS 서버에서 해당 경로표를 입수하여 클라이언트의 DNS 요청 패킷의 송신처 IP주소와의 경로 및 거리를 측정한다.\n<ul>\n<li>이때 클라이언트 측 DNS 서버와의 거리를 측정하기 때문에 대략적인 거리이다.</li>\n<li>인터넷 경로 정보에 지나는 프로바이더와 대략적인 거리 정보가 있다.</li>\n</ul>\n</li>\n<li>클라이언트 DNS 서버와 가장 가까운 캐시의 라우터를 알 수 있다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-리피터용-서버로-액세스-대상을-분배한다\" style=\"position:relative;\"><a href=\"#3-%EB%A6%AC%ED%94%BC%ED%84%B0%EC%9A%A9-%EC%84%9C%EB%B2%84%EB%A1%9C-%EC%95%A1%EC%84%B8%EC%8A%A4-%EB%8C%80%EC%83%81%EC%9D%84-%EB%B6%84%EB%B0%B0%ED%95%9C%EB%8B%A4\" aria-label=\"3 리피터용 서버로 액세스 대상을 분배한다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 리피터용 서버로 액세스 대상을 분배한다</h3>\n<h4 id=\"두번째-방법\" style=\"position:relative;\"><a href=\"#%EB%91%90%EB%B2%88%EC%A7%B8-%EB%B0%A9%EB%B2%95\" aria-label=\"두번째 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>두번째 방법</h4>\n<ul>\n<li>리다이렉트를 나타내는 <code class=\"language-text\">Location</code> 필드를 사용하여 액세스 대상을 가장 가까운 캐시 서버로 돌리는 방법이다.</li>\n<li>먼저 DNS 서버에서 웹 서버의 IP주소를 회답하고 클라이언트가 해당 IP 주소(리다이렉트용 서버)로 요청을 보낸다. 리다이렉트용 서버는 경로표를 가지고 있어 가장 가까운 캐시 서버로 리다이렉트 하도록 <code class=\"language-text\">Location</code> 필드를 설정하여 응답한다.</li>\n<li>HTTP 요청이 많아지므로 어느정도 오버헤드가 있다. 하지만 클라이언트 DNS 서버와의 거리가 아닌 클라이언트 간의 거리를 조사하므로 더 정확하다.</li>\n<li>더 정확하게 하기 위해 최적의 캐시 서버에 액세스하는 스크립트 프로그램을 내장한 페이지를 반송할 수도 있다.</li>\n</ul>\n<h3 id=\"4-캐시-내용의-갱신-방법에서-성능의-차이가-난다\" style=\"position:relative;\"><a href=\"#4-%EC%BA%90%EC%8B%9C-%EB%82%B4%EC%9A%A9%EC%9D%98-%EA%B0%B1%EC%8B%A0-%EB%B0%A9%EB%B2%95%EC%97%90%EC%84%9C-%EC%84%B1%EB%8A%A5%EC%9D%98-%EC%B0%A8%EC%9D%B4%EA%B0%80-%EB%82%9C%EB%8B%A4\" aria-label=\"4 캐시 내용의 갱신 방법에서 성능의 차이가 난다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. 캐시 내용의 갱신 방법에서 성능의 차이가 난다</h3>\n<ul>\n<li>캐시서버를 이용할 때 갱신 내용 유무를 확인하느라 네트워크가 혼잡해질 수도 있다.</li>\n<li>이 점을 개선하기 위해 확인을 하지 않고 데이터가 업데이트 된다면 즉시 갱신할 수 있다.\n<ul>\n<li>CDN 캐시 서버에는 이러한 기능이 내장되어 있다.</li>\n</ul>\n</li>\n<li>캐시에는 변하지 않는 부분만 캐싱하는 것이 효율적이다.</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#-story4-%EC%BA%90%EC%8B%9C-%EC%84%9C%EB%B2%84%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%84%9C%EB%B2%84%EC%9D%98-%EB%B6%80%ED%95%98-%EB%B6%84%EC%82%B0\">🛺 [Story4] 캐시 서버를 이용한 서버의 부하 분산</a></p>\n<ul>\n<li>\n<p><a href=\"#1-%EC%BA%90%EC%8B%9C-%EC%84%9C%EB%B2%84%EC%9D%98-%EC%9D%B4%EC%9A%A9\">1. 캐시 서버의 이용</a></p>\n</li>\n<li>\n<p><a href=\"#2-%EC%BA%90%EC%8B%9C-%EC%84%9C%EB%B2%84%EB%8A%94-%EA%B0%B1%EC%8B%A0%EC%9D%BC%EB%A1%9C-%EC%BD%98%ED%85%90%EC%B8%A0%EB%A5%BC-%EA%B4%80%EB%A6%AC%ED%95%9C%EB%8B%A4\">2. 캐시 서버는 갱신일로 콘텐츠를 관리한다</a></p>\n</li>\n<li>\n<p><a href=\"#3-%ED%94%84%EB%A1%9D%EC%8B%9C%EC%9D%98-%EC%9B%90%EC%A0%90%EC%9D%80-%ED%8F%AC%EC%9B%8C%EB%93%9C-%ED%94%84%EB%A1%9D%EC%8B%9C%EC%9D%B4%EB%8B%A4\">3. 프록시의 원점은 포워드 프록시이다</a></p>\n<ul>\n<li><a href=\"#%ED%8F%AC%EC%9B%8C%EB%93%9C-%ED%94%84%EB%A1%9D%EC%8B%9C-%EC%82%AC%EC%9A%A9%EC%8B%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%86%A1%EC%8B%A0\">포워드 프록시 사용시 데이터 송신</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#4-%ED%8F%AC%EC%9B%8C%EB%93%9C-%ED%94%84%EB%A1%9D%EC%8B%9C%EB%A5%BC-%EA%B0%9C%EB%9F%89%ED%95%9C-%EB%A6%AC%EB%B2%84%EC%8A%A4-%ED%94%84%EB%A1%9D%EC%8B%9C\">4. 포워드 프록시를 개량한 리버스 프록시</a></p>\n</li>\n<li>\n<p><a href=\"#5-%ED%8A%B8%EB%9E%9C%EC%8A%A4%ED%8C%A8%EC%96%B4%EB%9F%B0%ED%8A%B8-%ED%94%84%EB%A1%9D%EC%8B%9C\">5. 트랜스패어런트 프록시</a></p>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-story5-%EC%BD%98%ED%85%90%EC%B8%A0-%EB%B0%B0%ED%8F%AC-%EC%84%9C%EB%B9%84%EC%8A%A4\">🛺 [Story5] 콘텐츠 배포 서비스</a></p>\n<ul>\n<li>\n<p><a href=\"#1-cdn%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%B6%80%ED%95%98-%EB%B6%84%EC%82%B0\">1. CDN을 이용한 부하 분산</a></p>\n</li>\n<li>\n<p><a href=\"#2-%EA%B0%80%EC%9E%A5-%EA%B0%80%EA%B9%8C%EC%9A%B4-%EC%BA%90%EC%8B%9C-%EC%84%9C%EB%B2%84%EC%9D%98-%EA%B4%80%EC%A0%90\">2. 가장 가까운 캐시 서버의 관점</a></p>\n<ul>\n<li><a href=\"#%EC%B5%9C%EC%B4%88-%EB%B0%A9%EB%B2%95\">최초 방법</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#3-%EB%A6%AC%ED%94%BC%ED%84%B0%EC%9A%A9-%EC%84%9C%EB%B2%84%EB%A1%9C-%EC%95%A1%EC%84%B8%EC%8A%A4-%EB%8C%80%EC%83%81%EC%9D%84-%EB%B6%84%EB%B0%B0%ED%95%9C%EB%8B%A4\">3. 리피터용 서버로 액세스 대상을 분배한다</a></p>\n<ul>\n<li><a href=\"#%EB%91%90%EB%B2%88%EC%A7%B8-%EB%B0%A9%EB%B2%95\">두번째 방법</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#4-%EC%BA%90%EC%8B%9C-%EB%82%B4%EC%9A%A9%EC%9D%98-%EA%B0%B1%EC%8B%A0-%EB%B0%A9%EB%B2%95%EC%97%90%EC%84%9C-%EC%84%B1%EB%8A%A5%EC%9D%98-%EC%B0%A8%EC%9D%B4%EA%B0%80-%EB%82%9C%EB%8B%A4\">4. 캐시 내용의 갱신 방법에서 성능의 차이가 난다</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</div>","frontmatter":{"date":"October 06, 2021","title":"성공과 실패를 결정하는 1%의 네트워크 원리_8","categories":"네트워크 책","author":"코다","emoji":"⚡️"},"fields":{"slug":"/one-percent-network-8/"}},"prev":{"id":"6e17ee34-1cf3-539f-a77c-ab519e24df3c","html":"<blockquote>\n<p>다음은 <em>성공과 실패를 결정하는 1%의 네트워크 원리</em> 를 읽고 정리한 내용입니다. 본 글은 CH6. 웹 서버에 도착하여 응답 데이터가 웹 브라우저로 돌아간다 입니다 🙌</p>\n</blockquote>\n<br>\n<br>\n<h2 id=\"-story1-서버의-개요\" style=\"position:relative;\"><a href=\"#-story1-%EC%84%9C%EB%B2%84%EC%9D%98-%EA%B0%9C%EC%9A%94\" aria-label=\" story1 서버의 개요 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🛺 [Story1] 서버의 개요</h2>\n<h3 id=\"1-클라이언트와-서버의-차이점\" style=\"position:relative;\"><a href=\"#1-%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8%EC%99%80-%EC%84%9C%EB%B2%84%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90\" aria-label=\"1 클라이언트와 서버의 차이점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 클라이언트와 서버의 차이점</h3>\n<ul>\n<li>서버도 클라이언트로부터 전송된 패킷을 받기 위해서 준비 단계를 거쳐야한다.</li>\n</ul>\n<h4 id=\"서버와-클라이언트의-차이점\" style=\"position:relative;\"><a href=\"#%EC%84%9C%EB%B2%84%EC%99%80-%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90\" aria-label=\"서버와 클라이언트의 차이점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>서버와 클라이언트의 차이점</h4>\n<ul>\n<li>네트워크와 관련된 전체적인 구조는 비슷한 형태를 지니고 있다.</li>\n<li>하지만 서버는 소켓을 미리 열고 클라이언트의 연결을 기다린다는 점, 여러 클라이언트와 소통해야 한다는 점에서 클라이언트와 차이점을 가지고 있다.</li>\n</ul>\n<h3 id=\"2-서버-어플리케이션의-구조\" style=\"position:relative;\"><a href=\"#2-%EC%84%9C%EB%B2%84-%EC%96%B4%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%EC%9D%98-%EA%B5%AC%EC%A1%B0\" aria-label=\"2 서버 어플리케이션의 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 서버 어플리케이션의 구조</h3>\n<p>서버 프로그램에서 다수의 클라이언트와 소켓 통신을 하기 위해서 다음과 같은 구조로 진행한다.</p>\n<ul>\n<li>서버 프로그램에서 클라이언트의 접속을 기다리는 부분과</li>\n<li>클라이언트와 대화를 하는 부분을 나눈다.</li>\n</ul>\n<p>클라이언트와 대화를 하는 부분은 각 클라이언트와 1대1로 대화를 한다. 따라서 대화가 섞이지 않는다.</p>\n<ul>\n<li>서버 OS의 멀티태스크, 멀티스레드 기능을 사용한 기법이다.</li>\n<li>이때 접속할 때마다 새로운 연결을 맺는것이 부담이 되면 클라이언트와의 연결 동작을 미리 해놓고 비어있는 소켓에 연결하기도 한다.</li>\n</ul>\n<h3 id=\"3-서버측의-소켓과-포트-번호\" style=\"position:relative;\"><a href=\"#3-%EC%84%9C%EB%B2%84%EC%B8%A1%EC%9D%98-%EC%86%8C%EC%BC%93%EA%B3%BC-%ED%8F%AC%ED%8A%B8-%EB%B2%88%ED%98%B8\" aria-label=\"3 서버측의 소켓과 포트 번호 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 서버측의 소켓과 포트 번호</h3>\n<ul>\n<li>서버와 클라이언트의 역할이 고정되어 있는 것이 아니라 여러 형태로 변경되면서 데이터를 송수신 할 수 있기 때문에 좌우대칭으로 실행될 수 있도록 하는 것이 중요하다.</li>\n<li>하지만 TCP 접속 동작은 좌우 대칭으로 만들기 어렵다. 한쪽이 소켓을 열고 기다리며 다른 한쪽이 연결을 해야하기 때문이다.\n<ul>\n<li>여기서 접속하는 측이 클라이언트, 접속을 기다리는 측이 서버라고 할 수 있다.</li>\n</ul>\n</li>\n<li>클라이언트의 데이터 송수신 동작\n<ol>\n<li>소켓 작성 - 소켓 생성</li>\n<li>서버측의 소켓과 파이프로 연결 - 소켓 접속</li>\n<li>데이터 송수신</li>\n<li>파이프 분리 후 소켓 말소</li>\n</ol>\n</li>\n<li>서버의 데이터 송수신 동작\n<ol>\n<li>소켓 작성 - 소켓 생성</li>\n<li>소켓을 접속 대기 생태로 만듬</li>\n<li>접속을 접수</li>\n<li>데이터 송수신</li>\n<li>파이프 분리 후 소켓 말소</li>\n</ol>\n<ul>\n<li>서버의 접속 준비 단계에서는 서버 어플리케이션의 포트 번호를 소켓에 기록한다. (웹 서버의 경우에는 80)</li>\n</ul>\n</li>\n<li>서버에서 <code class=\"language-text\">accept</code> 를 통해서 클라이언트로부터 소켓을 접수한다.</li>\n<li>클라이언트와의 접속이 되면 접속 대기 소켓을 복사하여 새로운 소켓을 생성한다.\n<ul>\n<li>접속 상대에 대한 제어 정보를 새로운 소켓에 기록한다.</li>\n</ul>\n</li>\n<li>기존의 접속 대기 소켓은 계속 접속 대기인 상태로 존재하여 다른 클라이언트와의 접속을 기다린다.</li>\n</ul>\n<h4 id=\"웹-소켓의-포트번호\" style=\"position:relative;\"><a href=\"#%EC%9B%B9-%EC%86%8C%EC%BC%93%EC%9D%98-%ED%8F%AC%ED%8A%B8%EB%B2%88%ED%98%B8\" aria-label=\"웹 소켓의 포트번호 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>웹 소켓의 포트번호</h4>\n<ul>\n<li>본래 클라이언트는 80이라는 포트의 소켓과 통신을 시작한다. 하지만 접속 한 후 응답에 다른 포트 번호가 들어올 수 없으므로 그대로 80 포트를 사용해야 한다.\n<ul>\n<li>이때 같은 포트 번호를 지닌 여러 소켓이 있게되는 문제가 발생한다.</li>\n<li>다음 패킷이 왔을 때 헤더의 포트번호로 통신 중인 소켓을 식별할 수 없기 때문이다.</li>\n</ul>\n</li>\n<li>해결방법\n<ul>\n<li>소켓을 지정할 때 다음 4가지 정보를 모두 조합하여 소켓을 식별한다.\n<ol>\n<li>클라이언트 IP주소</li>\n<li>클라이언트 포트 번호</li>\n<li>서버 IP주소</li>\n<li>서버 포트 번호</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>그렇다면 왜 디스크립터가 필요할까 ? (위 4가지 정보로 소켓을 식별할 수 있는데)\n<ul>\n<li>접속을 대기할 때는 아직 클라이언트 소켓이 지정되지 않았으므로 정보가 없다.</li>\n<li>또한 디스크립터 하나로 소켓을 식별하는 것이 더 간단하다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-story2-서버의-수신동작\" style=\"position:relative;\"><a href=\"#-story2-%EC%84%9C%EB%B2%84%EC%9D%98-%EC%88%98%EC%8B%A0%EB%8F%99%EC%9E%91\" aria-label=\" story2 서버의 수신동작 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🛺 [Story2] 서버의 수신동작</h2>\n<h3 id=\"1-lan-어댑터에서-수신-신호를-디지털-데이터로-변환한다\" style=\"position:relative;\"><a href=\"#1-lan-%EC%96%B4%EB%8C%91%ED%84%B0%EC%97%90%EC%84%9C-%EC%88%98%EC%8B%A0-%EC%8B%A0%ED%98%B8%EB%A5%BC-%EB%94%94%EC%A7%80%ED%84%B8-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A1%9C-%EB%B3%80%ED%99%98%ED%95%9C%EB%8B%A4\" aria-label=\"1 lan 어댑터에서 수신 신호를 디지털 데이터로 변환한다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. LAN 어댑터에서 수신 신호를 디지털 데이터로 변환한다</h3>\n<ul>\n<li>LAN 어댑터에서 수신하여 디지털 데이터로 바꾼다. (클록 신호를 추출하여 데이터를 0101의 형태로 바꾼다)</li>\n<li>FCS를 통해 패킷의 오류 유무를 검사한다. 오류가 있다면 패킷을 폐기한다.</li>\n<li>MAC헤더의 수신처가 본인인지 확인한다.\n<ul>\n<li>이더넷은 LAN 전체에 신호를 흘리고 상대를 찾는 형태이기 때문에 올바른 패킷이 아니더라도 도착할 수 있기 때문이다.</li>\n</ul>\n</li>\n<li>변환된 디지털 데이터를 LAN 어댑터 내부의 버퍼 메모리에 저장한다. (여기까지 LAN의 MAC 부분이 담당한다)</li>\n<li>LAN 어댑터에서 CPU에게 인터럽트로 패킷이 도착했다는 사실을 알린다.</li>\n<li>LAN 드라이버는 LAN 어댑터의 버퍼 메모리에서 수신한 패킷을 추출하여 프로토콜을 판별하고 적합한 프로토콜 처리 소프트웨어를 호출한다. (TCP/IP 면 해당 프로토콜을 호출하여 패킷을 건낸다)</li>\n</ul>\n<h3 id=\"2-ip-담당-부분의-수신-동작\" style=\"position:relative;\"><a href=\"#2-ip-%EB%8B%B4%EB%8B%B9-%EB%B6%80%EB%B6%84%EC%9D%98-%EC%88%98%EC%8B%A0-%EB%8F%99%EC%9E%91\" aria-label=\"2 ip 담당 부분의 수신 동작 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. IP 담당 부분의 수신 동작</h3>\n<ul>\n<li>IP 담당은 IP 헤더를 점검하고 수신처가 본인 IP인지 확인한다.\n<ul>\n<li>서버가 라우터와 같이 패킷을 중개하는 역할일 수 있으므로 본인에게 온 패킷이 아닐수도 있다. 이 경우에는 패킷에 쓰인 수신처 IP 주소로 패킷을 중개해야한다.</li>\n</ul>\n</li>\n<li>IP 담당에서는 fragmentation을 통해서 패킷이 분할되었는지 조사하고 그렇다면 패킷을 일시적으로 메모리에 저장하고 패킷이 모두 모이면 복원한다.</li>\n<li>IP 헤더의 프로토콜 번호를 조사하여 해당 부분에 패킷을 건내준다.\n<ul>\n<li>06이면 TCP 담당, 11이면 UDP 담당 등등</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-tcp-담당-부분이-접속-패킷을-수신했을-때의-동작\" style=\"position:relative;\"><a href=\"#3-tcp-%EB%8B%B4%EB%8B%B9-%EB%B6%80%EB%B6%84%EC%9D%B4-%EC%A0%91%EC%86%8D-%ED%8C%A8%ED%82%B7%EC%9D%84-%EC%88%98%EC%8B%A0%ED%96%88%EC%9D%84-%EB%95%8C%EC%9D%98-%EB%8F%99%EC%9E%91\" aria-label=\"3 tcp 담당 부분이 접속 패킷을 수신했을 때의 동작 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. TCP 담당 부분이 접속 패킷을 수신했을 때의 동작</h3>\n<ul>\n<li>만일 도착한 패킷의 SYN 컨트롤비트가 1이라면 접속 동작의 패킷이다.\n<ul>\n<li>접속을 접수하는 동작을 실행한다.</li>\n<li>포트 번호를 조사하여 해당 포트 번호와 일치하는 접속 대기 소켓이 있는지 확인한다.\n<ul>\n<li>만일 없다면 오류이므로 오류 패킷을 클라이언트에게 반환한다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>접속 대기 소켓을 찾으면 소켓을 복사하여 새로운 소켓을 만들고 송신처IP주소, 포트번호, 시퀀스 초기값, 윈도우 값등 필수 정보를 기록한다.</li>\n<li>패킷을 받았다는 ACK 번호, 서버의 시퀀스 초기값, 수신 버퍼 빈 용량인 윈도우 값 등을 기록한 TCP 헤더를 만들고 IP 담당에 의뢰하여 반송한다.</li>\n<li>패킷이 잘 도착하면 ACK 번호가 돌아와 접속이 완료된다.</li>\n</ul>\n<h3 id=\"4-tcp-담당-부분이-데이터-패킷을-수신했을-때의-동작\" style=\"position:relative;\"><a href=\"#4-tcp-%EB%8B%B4%EB%8B%B9-%EB%B6%80%EB%B6%84%EC%9D%B4-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%8C%A8%ED%82%B7%EC%9D%84-%EC%88%98%EC%8B%A0%ED%96%88%EC%9D%84-%EB%95%8C%EC%9D%98-%EB%8F%99%EC%9E%91\" aria-label=\"4 tcp 담당 부분이 데이터 패킷을 수신했을 때의 동작 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. TCP 담당 부분이 데이터 패킷을 수신했을 때의 동작</h3>\n<ul>\n<li>서버측에 같은 포트 번호를 가진 소켓이 많으므로 앞에서 말한 4가지 정보로 적절한 소켓을 찾는다.</li>\n<li>해당 소켓에 기록된 정보들을 통해 올바르게 데이터 송수신이 이루어지고 있는지 확인한다.\n<ul>\n<li>시퀀스 번호, 데이터 조각의 길이 등등을 확인한다.</li>\n</ul>\n</li>\n<li>패킷에서 추출된 데이터를 수신 버퍼에 저장한다.</li>\n<li>데이터를 수신하면 수신 응답용 TCP 헤더를 만들고 수신 패킷에 시퀀스 번호와 데이터 길이로 얻은 ACK 번호를 기록하고 IP 담당에 넘겨 클라이언트에게 반송한다.</li>\n<li>수신 버퍼에 기록된 데이터들은 소켓 라이브러리의 <code class=\"language-text\">read</code> 함수 호출을 통해 어플리케이션에 넘겨진다.</li>\n<li>어플리케이션에서 http 리퀘스트 메시지 내용을 조사하고 브라우저에서 데이터를 반송한다.</li>\n</ul>\n<h3 id=\"5-tcp-담당-부분의-연결-끊기-동작\" style=\"position:relative;\"><a href=\"#5-tcp-%EB%8B%B4%EB%8B%B9-%EB%B6%80%EB%B6%84%EC%9D%98-%EC%97%B0%EA%B2%B0-%EB%81%8A%EA%B8%B0-%EB%8F%99%EC%9E%91\" aria-label=\"5 tcp 담당 부분의 연결 끊기 동작 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5. TCP 담당 부분의 연결 끊기 동작</h3>\n<ul>\n<li>어느 쪽(클라이언트 or 서버) 에서든 연결 끊기 동작에 들어가도 상관없다.\n<ul>\n<li>HTTP 1.0 이라면 서버에서 연결 끊기 동작을 시작한다.</li>\n</ul>\n</li>\n<li>서버에서 <code class=\"language-text\">close</code> 함수를 호출하고 FIN 1로 설정한 TCP 헤더를 클라이언트에게 보낸다.</li>\n<li>클라이언트도  <code class=\"language-text\">close</code> 를 호출하고 FIN 1로 설정하여 반송하고 ACK도 보낸다.</li>\n<li>잠시 기다렸다가 소켓을 말소한다.</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#-story1-%EC%84%9C%EB%B2%84%EC%9D%98-%EA%B0%9C%EC%9A%94\">🛺 [Story1] 서버의 개요</a></p>\n<ul>\n<li>\n<p><a href=\"#1-%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8%EC%99%80-%EC%84%9C%EB%B2%84%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90\">1. 클라이언트와 서버의 차이점</a></p>\n<ul>\n<li><a href=\"#%EC%84%9C%EB%B2%84%EC%99%80-%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90\">서버와 클라이언트의 차이점</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#2-%EC%84%9C%EB%B2%84-%EC%96%B4%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%EC%9D%98-%EA%B5%AC%EC%A1%B0\">2. 서버 어플리케이션의 구조</a></p>\n</li>\n<li>\n<p><a href=\"#3-%EC%84%9C%EB%B2%84%EC%B8%A1%EC%9D%98-%EC%86%8C%EC%BC%93%EA%B3%BC-%ED%8F%AC%ED%8A%B8-%EB%B2%88%ED%98%B8\">3. 서버측의 소켓과 포트 번호</a></p>\n<ul>\n<li><a href=\"#%EC%9B%B9-%EC%86%8C%EC%BC%93%EC%9D%98-%ED%8F%AC%ED%8A%B8%EB%B2%88%ED%98%B8\">웹 소켓의 포트번호</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-story2-%EC%84%9C%EB%B2%84%EC%9D%98-%EC%88%98%EC%8B%A0%EB%8F%99%EC%9E%91\">🛺 [Story2] 서버의 수신동작</a></p>\n<ul>\n<li><a href=\"#1-lan-%EC%96%B4%EB%8C%91%ED%84%B0%EC%97%90%EC%84%9C-%EC%88%98%EC%8B%A0-%EC%8B%A0%ED%98%B8%EB%A5%BC-%EB%94%94%EC%A7%80%ED%84%B8-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A1%9C-%EB%B3%80%ED%99%98%ED%95%9C%EB%8B%A4\">1. LAN 어댑터에서 수신 신호를 디지털 데이터로 변환한다</a></li>\n<li><a href=\"#2-ip-%EB%8B%B4%EB%8B%B9-%EB%B6%80%EB%B6%84%EC%9D%98-%EC%88%98%EC%8B%A0-%EB%8F%99%EC%9E%91\">2. IP 담당 부분의 수신 동작</a></li>\n<li><a href=\"#3-tcp-%EB%8B%B4%EB%8B%B9-%EB%B6%80%EB%B6%84%EC%9D%B4-%EC%A0%91%EC%86%8D-%ED%8C%A8%ED%82%B7%EC%9D%84-%EC%88%98%EC%8B%A0%ED%96%88%EC%9D%84-%EB%95%8C%EC%9D%98-%EB%8F%99%EC%9E%91\">3. TCP 담당 부분이 접속 패킷을 수신했을 때의 동작</a></li>\n<li><a href=\"#4-tcp-%EB%8B%B4%EB%8B%B9-%EB%B6%80%EB%B6%84%EC%9D%B4-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%8C%A8%ED%82%B7%EC%9D%84-%EC%88%98%EC%8B%A0%ED%96%88%EC%9D%84-%EB%95%8C%EC%9D%98-%EB%8F%99%EC%9E%91\">4. TCP 담당 부분이 데이터 패킷을 수신했을 때의 동작</a></li>\n<li><a href=\"#5-tcp-%EB%8B%B4%EB%8B%B9-%EB%B6%80%EB%B6%84%EC%9D%98-%EC%97%B0%EA%B2%B0-%EB%81%8A%EA%B8%B0-%EB%8F%99%EC%9E%91\">5. TCP 담당 부분의 연결 끊기 동작</a></li>\n</ul>\n</li>\n</ul>\n</div>","frontmatter":{"date":"October 07, 2021","title":"성공과 실패를 결정하는 1%의 네트워크 원리_9","categories":"네트워크 책","author":"코다","emoji":"⚡️"},"fields":{"slug":"/one-percent-network-9/"}},"site":{"siteMetadata":{"siteUrl":"https://yjksw.github.io","comments":{"utterances":{"repo":"yjksw/yjksw.github.io"}}}}},"pageContext":{"slug":"/jpa-fetch-join-nickname/","nextSlug":"/one-percent-network-8/","prevSlug":"/one-percent-network-9/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}
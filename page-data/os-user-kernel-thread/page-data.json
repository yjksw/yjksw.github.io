{"componentChunkName":"component---src-templates-blog-template-js","path":"/os-user-kernel-thread/","result":{"data":{"cur":{"id":"1549b4b9-74b3-5275-b573-eb2609ad7eff","html":"<h2 id=\"-intro\" style=\"position:relative;\"><a href=\"#-intro\" aria-label=\" intro permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>💡 Intro</h2>\n<ul>\n<li>효율적인 프로그래밍을 위해 멀티 스레드 환경에서 구동을 할 때가 많다.</li>\n<li>멀티 스레드의 간단한 장점과 항상 헷갈렸던 사용자 레벨 스레드 vs. 커널 레벨 스레드에 대해서 알아보자.</li>\n</ul>\n<br>\n<h2 id=\"-multi-thread-장점\" style=\"position:relative;\"><a href=\"#-multi-thread-%EC%9E%A5%EC%A0%90\" aria-label=\" multi thread 장점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 Multi-thread 장점</h2>\n<h3 id=\"1-응답성\" style=\"position:relative;\"><a href=\"#1-%EC%9D%91%EB%8B%B5%EC%84%B1\" aria-label=\"1 응답성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 응답성</h3>\n<ul>\n<li>어플리케이션의 일부분이 봉쇄되거나 긴 작업을 실행하더라도 다른 부분의 프로그램이 계속 실행되는 것을 허용하기 때문에 사용자의 입장에서 응답성이 증가한다.</li>\n<li>예를 들어 다운로드가 오래 걸리는 파일을 다운로드 하면서 사용자와의 상호작용이 가능하다.</li>\n</ul>\n<h3 id=\"2-자원-공유-resource-sharing\" style=\"position:relative;\"><a href=\"#2-%EC%9E%90%EC%9B%90-%EA%B3%B5%EC%9C%A0-resource-sharing\" aria-label=\"2 자원 공유 resource sharing permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 자원 공유 resource sharing</h3>\n<ul>\n<li>프로세스는 완전히 별도의 메모리 공간을 할당받기 때문에 (code, data, heap) 서로 통신하기 위해서는 공유 메모리를 사용하거나 메세지 전달 기법 (IPC)를 사용해야한다.</li>\n<li>스레드는 속한 프로세스의 자원을 공유하기 때문에 한 프로그램이 <strong>같은 주소 내에서 여러개의 다른 작업을 하는 단위</strong>로 나뉘어질 수 있다는 이점이 있다.</li>\n</ul>\n<h3 id=\"3-경제성-economy\" style=\"position:relative;\"><a href=\"#3-%EA%B2%BD%EC%A0%9C%EC%84%B1-economy\" aria-label=\"3 경제성 economy permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 경제성 economy</h3>\n<ul>\n<li>프로세스의 자원을 공유하므로 메모리 측면과 문맥교환 오버헤드 측면에서 경제적이다.</li>\n</ul>\n<h3 id=\"4-규모-가변성-scalability\" style=\"position:relative;\"><a href=\"#4-%EA%B7%9C%EB%AA%A8-%EA%B0%80%EB%B3%80%EC%84%B1-scalability\" aria-label=\"4 규모 가변성 scalability permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. 규모 가변성 scalability</h3>\n<ul>\n<li>멀티코어 환경에서 각각의 스레드가 다른 코어에서 병렬로 실행될 수 있기 때문에 이점이 증가한다.</li>\n<li>단일 스레드라면 코어의 개수와 상관없이 한번에 한 개의 처리기에서만 실행되지만 멀티코어에 멀티스레드라면 병렬성을 증가시킨다.</li>\n</ul>\n<br>\n<h2 id=\"-multi-thread-모델\" style=\"position:relative;\"><a href=\"#-multi-thread-%EB%AA%A8%EB%8D%B8\" aria-label=\" multi thread 모델 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 Multi-thread 모델</h2>\n<ul>\n<li>\n<p>스레드는 사용자 스레드와 커널 스레드로 나뉜다.</p>\n<ul>\n<li>사용자 스레드는 사용자 수준에서 관리되며 os가 관여하지 않는다.</li>\n<li>사용자 수준의 라이브러리를 사용하여 생성되고 커널의 개입을 받지 않는다.</li>\n<li>커널 스레드는 os에 의해 직접 지원되고 관리된다.</li>\n</ul>\n</li>\n<li>다양한 Mutli-thread 모델이 있는 이유는 스레드가 작업을 처리하기 위해서는 CPU를 점유해야하기 때문에 궁극적으로는 사용자 스레드와 커널 스레드간의 어떠한 연관관계가 존재해야 하기 때문이다.</li>\n</ul>\n<h3 id=\"모델-3가지\" style=\"position:relative;\"><a href=\"#%EB%AA%A8%EB%8D%B8-3%EA%B0%80%EC%A7%80\" aria-label=\"모델 3가지 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>모델 3가지</h3>\n<ul>\n<li>\n<p>다대일 모델</p>\n<ul>\n<li>여러 사용자 스레드를 하나의 커널 스레드에 사상하며 스레드 관리는 사용자 레벨의 스레드 라이브러리가 수행한다.</li>\n<li>한 스레드가 봉쇄 상태에 들어가면 커널 스레드가 함께 봉쇄 상태에 들어가게 되므로 모두 봉쇄된다.</li>\n<li>한번에 하나의 스레드만 커널에 접근이 가능하기 때문에 멀티코어 환경에서 병렬로 실행될 수 없다.</li>\n</ul>\n</li>\n<li>\n<p>일대일 모델</p>\n<ul>\n<li>하나의 사용자 스레드를 각각 하나의 커널 스레드로 사상한다.</li>\n<li>하나의 스레드가 봉쇄상태에 들어가더라도 다른 스레드가 커널 스레드와 매핑되어 작업을 처리할 수 있으므로 멀티코어 환경에서 더 병렬성을 제공한다.</li>\n<li>사용자 레벨에서 스레드를 하나 생성할 때 커널의 스레도 생성해야 하기 대문에 오버헤드가 발생한다. 따라서 이 모델을 사용할 경우 대부분 시스템에 의해 지원되는 스레드 개수를 제한한다.</li>\n<li>Linux가 대표적인 일대일 모델을 사용하는 os이다.</li>\n</ul>\n</li>\n<li>\n<p>다대다 모델</p>\n<ul>\n<li>여러 사용자 스레드를 여러 커널 스레드에 사상한다. (사용자 스레드 ≤ 커널 스레드 숫자로 사상한다)</li>\n<li>\n<p>다대일 모델과 일대일 모델의 단점을 극복한다.</p>\n<ul>\n<li>진정한 동시성을 지원하지 못하는 단점과, 스레드 개수에 제한이 있는 단점을 커버한다.</li>\n</ul>\n</li>\n<li>개발자는 원하는 만큼 스레드를 생성하고 여러개의 커널 스레드에 의해 병렬성을 보장한다. 따라서 하나의 스레드가 봉쇄상태에 들어가더라도 다른 커널 스레드에 의해 실행을 스케줄 할 수 있다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-thread-스케줄링\" style=\"position:relative;\"><a href=\"#-thread-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81\" aria-label=\" thread 스케줄링 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 Thread 스케줄링</h2>\n<ul>\n<li>사용자 스레드와 커널 스레드가 나뉘지만 os에서 스캐줄링 되는 대상은 커널 스레드이다.</li>\n<li>사용자 스레드는 스레드 라이브러리에 의해서 관리되고 커널은 사용자 스레드의 존재에 대해서 알지 못하기 때문에 궁극적으로 사용자 스레드는 커널 스레드에 사상되어야 한다.</li>\n<li>따라서 사용자 수준과 커널 수준의 스레드 스케줄링에 대해서 간략히 다루어보자.</li>\n</ul>\n<h3 id=\"경쟁-범위-contention-scope\" style=\"position:relative;\"><a href=\"#%EA%B2%BD%EC%9F%81-%EB%B2%94%EC%9C%84-contention-scope\" aria-label=\"경쟁 범위 contention scope permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>경쟁 범위 Contention scope</h3>\n<ul>\n<li>\n<p><strong>Process-Contention scope(PCS)</strong></p>\n<ul>\n<li>다대일, 다대다 모델에서는 스레드 라이브러리가 사용자 스레드를 가용한 커널 스레드에 스케줄링한다.</li>\n<li>동일한 프로세스의 스레드들끼리 CPU를 경쟁하는 형태</li>\n<li>스레드 라이브러리가사용자 스레드를 ‘가용한 LWP(Light Weight Process) 상에서 스케줄한다’ 라고 하더라도 그것이 CPU 점유를 의미하지 않는다. CPU 점유는 커널 스레드의 스캐줄링이 필요하다.</li>\n<li>주로 우선순위에 따라서 행해지며 가장 높은 우선순위를 선점하여 스캐줄링한다.</li>\n</ul>\n</li>\n<li>\n<p><strong>System-Contention scope(SCS)</strong></p>\n<ul>\n<li>실제 CPU에서 실행되기 위해서 os가 커널 스레드를 물리적 CPU로 스캐줄링 해야한다.</li>\n<li>어느 커널 스레드가 CPU를 점유할 것인지 결정하는 형태</li>\n<li>SCS 스캐줄링은 시스템 상의 모든 스레드 사이에서 일어난다.</li>\n<li>일대일 모델 같은 경우 오직 SCS만 사용한다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-느낀-점\" style=\"position:relative;\"><a href=\"#-%EB%8A%90%EB%82%80-%EC%A0%90\" aria-label=\" 느낀 점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🛋 느낀 점</h2>\n<ul>\n<li>한번도 제대로 이해하지 못했는데 os를 처음부터 차근차근 공부하며 ‘커널’에 대한 이해도를 쌓은 후 공부하니 조금 더 감이 잡히는 듯 하다.</li>\n<li>사용자 스레드의 이점이 아직 그렇게 잘 와닿지 않는다. 우선 하나의 프로세스 내에서 여러 작업 단위를 나눈다는 점만 이해하고 넘어가야겠다.</li>\n<li>자바의 Thread와 스레드 라이브러리에 대해서 더 깊이 공부해 봐야겠다 🙌</li>\n</ul>\n<br>\n<p>[참고자료]</p>\n<ul>\n<li>Operating System 공룡책 </li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#-intro\">💡 Intro</a></li>\n<li>\n<p><a href=\"#-multi-thread-%EC%9E%A5%EC%A0%90\">🌩 Multi-thread 장점</a></p>\n<ul>\n<li><a href=\"#1-%EC%9D%91%EB%8B%B5%EC%84%B1\">1. 응답성</a></li>\n<li><a href=\"#2-%EC%9E%90%EC%9B%90-%EA%B3%B5%EC%9C%A0-resource-sharing\">2. 자원 공유 resource sharing</a></li>\n<li><a href=\"#3-%EA%B2%BD%EC%A0%9C%EC%84%B1-economy\">3. 경제성 economy</a></li>\n<li><a href=\"#4-%EA%B7%9C%EB%AA%A8-%EA%B0%80%EB%B3%80%EC%84%B1-scalability\">4. 규모 가변성 scalability</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-multi-thread-%EB%AA%A8%EB%8D%B8\">🌩 Multi-thread 모델</a></p>\n<ul>\n<li><a href=\"#%EB%AA%A8%EB%8D%B8-3%EA%B0%80%EC%A7%80\">모델 3가지</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-thread-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81\">🌩 Thread 스케줄링</a></p>\n<ul>\n<li><a href=\"#%EA%B2%BD%EC%9F%81-%EB%B2%94%EC%9C%84-contention-scope\">경쟁 범위 Contention scope</a></li>\n</ul>\n</li>\n<li><a href=\"#-%EB%8A%90%EB%82%80-%EC%A0%90\">🛋 느낀 점</a></li>\n</ul>\n</div>","excerpt":"💡 Intro 효율적인 프로그래밍을 위해 멀티 스레드 환경에서 구동을 할 때가 많다. 멀티 스레드의 간단한 장점과 항상 헷갈렸던 사용자 레벨 스레드 vs. 커널 레벨 스레드에 대해서 알아보자. 🌩 Multi-thread 장점 1. 응답성 어플리케이션의 일부분이 봉쇄되거나 긴 작업을 실행하더라도 다른 부분의 프로그램이 계속 실행되는 것을 허용하기 때문에 사용자의 입장에서 응답성이 증가한다. 예를 들어 다운로드가 오래 걸리는 파일을 다운로드 하면서 사용자와의 상호작용이 가능하다. 2. 자원 공유 resource sharing 프로세스는 완전히 별도의 메모리 공간을 할당받기 때문에 (code, data, heap) 서로 통신하기 위해서는 공유 메모리를 사용하거나 메세지 전달 기법 (IPC)를 사용해야한다. 스레드는 속한 프로세스의 자원을 공유하기 때문에 한 프로그램이 같은 주소 내에서 여러개의 다른 작업을 하는 단위로 나뉘어질 수 있다는 이점이 있다. 3. 경제성 economy 프로세스…","frontmatter":{"date":"November 10, 2021","title":"사용자 레벨 스레드 vs. 커널 레벨 스레드","categories":"운영체제","author":"코다","emoji":"🧁"},"fields":{"slug":"/os-user-kernel-thread/"}},"next":{"id":"6956dfc0-9e9b-5f82-936b-ebe795f54046","html":"<h2 id=\"-intro\" style=\"position:relative;\"><a href=\"#-intro\" aria-label=\" intro permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>💡 Intro</h2>\n<ul>\n<li>왜 하필 스프링 인가? 라는 질문을 던지게 되면서 스프링이 가지고 있느 장점에 대해서 고민해보았다.</li>\n<li>그 중 기존의 싱글톤 패턴의 한계를 뛰어넘은 스프링 싱글톤 레지스트리를 알게 되었다. 이전에 단순히 스프링이 싱글톤 scope으로 객체를 관리하여 여러 요청이 동시에 들어오는 환경에서 안정적으로 서비스할 수 있다는 장점을 들었지만 싱글톤 패턴과 어떻게 다른지 알지 못했다.</li>\n<li>그래서 알아보자 🙌</li>\n</ul>\n<br>\n<h2 id=\"-싱글톤-패턴이란\" style=\"position:relative;\"><a href=\"#-%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4%EC%9D%B4%EB%9E%80\" aria-label=\" 싱글톤 패턴이란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 싱글톤 패턴이란?</h2>\n<h3 id=\"왜-싱글톤-패턴이어야-할까\" style=\"position:relative;\"><a href=\"#%EC%99%9C-%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4%EC%9D%B4%EC%96%B4%EC%95%BC-%ED%95%A0%EA%B9%8C\" aria-label=\"왜 싱글톤 패턴이어야 할까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>왜 싱글톤 패턴이어야 할까</h3>\n<ul>\n<li>\n<p>하나의 서버에 초당 수많은 요청이 도착하고 처리되어야 한다. 요청이 올 때마다 서버에서 관련 객체를 생성하는 것은 굉장히 큰 오버헤드이다.</p>\n<ul>\n<li>\n<p>어떤 오버헤드가 발생할 수 있을까 ?</p>\n<p>주로 서버는 여러 계층의 레이어를 지나고 여러 비지니스 오브젝트들이 협력하여 요청을 처리한다. </p>\n<p>요청 하나당 대충 5개 정도의 오브젝트가 생성되고, 초딩 300개의 요청, 1분에 18000개의 요청이 발생한다면 18000 * 5 만큼의 새로운 오브젝트가 생성된다. </p>\n<p>오브젝트 생성도 비용이지만 생성된 오브젝트를 처리하여 메모리를 관리하는 GC도 오버헤드다. (GC의 동작원리를 살펴보자 🙌) </p>\n</li>\n</ul>\n</li>\n<li>따라서 스프링은 요청을 서비스 해주는 객체를 하나만 만들고 그것을 공유할 수 있도록 한다.</li>\n<li>하나의 객체만 생성하여 공유할 수 있는 것이 싱글톤 패턴이다.</li>\n</ul>\n<h3 id=\"싱글톤-패턴이-가지고-있는-단점\" style=\"position:relative;\"><a href=\"#%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4%EC%9D%B4-%EA%B0%80%EC%A7%80%EA%B3%A0-%EC%9E%88%EB%8A%94-%EB%8B%A8%EC%A0%90\" aria-label=\"싱글톤 패턴이 가지고 있는 단점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>싱글톤 패턴이 가지고 있는 단점</h3>\n<ul>\n<li>private 생성자 이므로 상속이 불가능하여 객체지향의 특징을 활용할 수 없다.</li>\n<li>\n<p>싱글톤은 테스트하기 어려우며 서버환경에서 동시에 여러 요청이 들어오기 때문에 하나만 만들어지는 것을 보장할 수 없다.</p>\n<ul>\n<li>싱글톤 객체는 만들어지는 방식이 제한적이므로 Mock 객체로 대체하는 것이 어렵다. 또한 생성자로 다이나믹하게 의존 객체를 주입하기 어렵기 때문에 일부 대체하려는 경우 해당 오브젝트를 테스트용으로 아예 만들어서 사용할 수밖에 없다.</li>\n</ul>\n</li>\n<li>\n<p>싱글톤은 전역상태를 만들기 때문에 객체지향적으로 보았을 때 바람직하지 못하다.</p>\n<ul>\n<li>static 필드와 메서드를 사용하며 싱글톤을 static 메서드를 통해 어느 곳에서든 접근할 수 있다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-싱글톤-레지스트리\" style=\"position:relative;\"><a href=\"#-%EC%8B%B1%EA%B8%80%ED%86%A4-%EB%A0%88%EC%A7%80%EC%8A%A4%ED%8A%B8%EB%A6%AC\" aria-label=\" 싱글톤 레지스트리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 싱글톤 레지스트리</h2>\n<ul>\n<li>스프링은 위에서 언급한 이유로 특정 서비스 객체들(빈)을 싱글톤으로 만든다. 하지만 위에서 나온 싱글톤 패턴을 그대로 사용하기보다 단점을 보완한 상태를 사용한다.</li>\n<li>\n<p>싱글톤 패턴의 단점을 보완하기 위해 나온 것이 스프링의 <strong>싱글톤 레지스트리</strong>이다. 스프링 컨테이너가 싱글톤 레지스트리의 역할을 하여 빈을 싱글톤으로 관리한다.</p>\n<ul>\n<li>private 생성자로 객체의 생성을 막는 방법이 아니라 일반 자바 클래스를 싱글톤으로 활용할 수 있도록 지원한다.</li>\n<li>생성, 관계설정, 사용에 대한 제어권이 컨테이너에게 있기 때문에 일반 자바 클래스도 싱글톤으로 관리될 수 있다.</li>\n</ul>\n</li>\n<li>public 생성자를 사용할 수 있기 때문에 필요하다면 새로운 오브젝트를 생성하고 Mock 오브젝트로 대체하는 등의 작업을 할 수 있다.</li>\n<li>객체지향적 설계와 디자인 패턴 적용이 가능하다.</li>\n</ul>\n<br>\n<h2 id=\"--싱글톤이기-때문에-주의할-점-️\" style=\"position:relative;\"><a href=\"#--%EC%8B%B1%EA%B8%80%ED%86%A4%EC%9D%B4%EA%B8%B0-%EB%95%8C%EB%AC%B8%EC%97%90-%EC%A3%BC%EC%9D%98%ED%95%A0-%EC%A0%90-%EF%B8%8F\" aria-label=\"  싱글톤이기 때문에 주의할 점 ️ permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩  싱글톤이기 때문에 주의할 점 ‼️</h2>\n<ul>\n<li>\n<p>멀티 스레드 환경에서 여러 스레드가 싱글톤에 동시접근 할 수 있기 때문에 상태 관리를 주의해야한다.</p>\n<ul>\n<li>대부분은 stateless하게 만들어져야 한다. 내부 상태값의 동시수정이 이루어지는 경우 매우 위험하기 때문이다.(읽기 전용은 제외)</li>\n</ul>\n</li>\n<li>\n<p>싱글톤에서 필요한 정보는 상태없이 어떻게 관리할까?</p>\n<ul>\n<li>파라미터, 로컬 변수, 리턴 값 등을 이용한다.</li>\n<li>위 변수들은 스택 영역에 독립적으로 저장이 되기 때문에 스레드마다 분리되어 있다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-스프링의-빈의-scope는-모두-싱글톤일까\" style=\"position:relative;\"><a href=\"#-%EC%8A%A4%ED%94%84%EB%A7%81%EC%9D%98-%EB%B9%88%EC%9D%98-scope%EB%8A%94-%EB%AA%A8%EB%91%90-%EC%8B%B1%EA%B8%80%ED%86%A4%EC%9D%BC%EA%B9%8C\" aria-label=\" 스프링의 빈의 scope는 모두 싱글톤일까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 스프링의 빈의 scope는 모두 싱글톤일까</h2>\n<ul>\n<li>\n<p>우선, scope 란?</p>\n<ul>\n<li>scope는 범위라는 뜻의 용어이고 여기서는 스프링의 빈이 <strong>1) 언제 생성되고 2) 언제까지 존재하며 3) 어디까지 적용되는지</strong>를 말한다.</li>\n<li>기본적인 스프링 빈의 scope는 싱글톤이며 빈의 생명주기는 스프링 컨테이너와 함께한다.</li>\n</ul>\n</li>\n<li>\n<p>이외의 scope도 존재한다!</p>\n<ul>\n<li>\n<p>프로토타입 Prototype scope</p>\n<ul>\n<li>컨테이너에 빈을 요청할 때마다 매번 새로운 오브젝트를 생성</li>\n</ul>\n</li>\n<li>\n<p>요청 Request scope</p>\n<ul>\n<li>새로운 HTTP 요청이 생길 때마다 생성</li>\n</ul>\n</li>\n<li>\n<p>세션 Session scope</p>\n<ul>\n<li>웹의 세션과 유사하게 생성</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-느낀-점\" style=\"position:relative;\"><a href=\"#-%EB%8A%90%EB%82%80-%EC%A0%90\" aria-label=\" 느낀 점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🛋 느낀 점</h2>\n<ul>\n<li><a href=\"https://github.com/yjksw/jwp-dashboard-mvc\">Spring MVC를 직접 구현해보는 미션</a>에서 component scanning으로 빈을 등록했던 것을 떠올리며 위 개념을 학습했더니 더 와닿았다.</li>\n<li>기존의 싱글톤 패턴이 안티패턴인데 멀티 스레드 환경에서는 싱글톤을 사용해야하는 것을 스프링 컨테이너로 해결한 것이 신선했다.</li>\n<li>스프링은 프레임워크이고 프레임워크에 종속적일수록 자바의 이점을 활용하기 어렵다고 생각했는데 이제야 조금씩 <em>토비의 스프링</em>에서 스프링 프레임워크가 자바의 객체지향적인 장점을 잘 살릴 수 있는 프레임워크라고 한 것이 이해되는 것 같다.</li>\n</ul>\n<br>\n<br>\n<p><strong>[참고자료]</strong></p>\n<ul>\n<li>토비의 스프링</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#-intro\">💡 Intro</a></li>\n<li>\n<p><a href=\"#-%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4%EC%9D%B4%EB%9E%80\">🌩 싱글톤 패턴이란?</a></p>\n<ul>\n<li><a href=\"#%EC%99%9C-%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4%EC%9D%B4%EC%96%B4%EC%95%BC-%ED%95%A0%EA%B9%8C\">왜 싱글톤 패턴이어야 할까</a></li>\n<li><a href=\"#%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4%EC%9D%B4-%EA%B0%80%EC%A7%80%EA%B3%A0-%EC%9E%88%EB%8A%94-%EB%8B%A8%EC%A0%90\">싱글톤 패턴이 가지고 있는 단점</a></li>\n</ul>\n</li>\n<li><a href=\"#-%EC%8B%B1%EA%B8%80%ED%86%A4-%EB%A0%88%EC%A7%80%EC%8A%A4%ED%8A%B8%EB%A6%AC\">🌩 싱글톤 레지스트리</a></li>\n<li><a href=\"#--%EC%8B%B1%EA%B8%80%ED%86%A4%EC%9D%B4%EA%B8%B0-%EB%95%8C%EB%AC%B8%EC%97%90-%EC%A3%BC%EC%9D%98%ED%95%A0-%EC%A0%90-%EF%B8%8F\">🌩  싱글톤이기 때문에 주의할 점 ‼️</a></li>\n<li><a href=\"#-%EC%8A%A4%ED%94%84%EB%A7%81%EC%9D%98-%EB%B9%88%EC%9D%98-scope%EB%8A%94-%EB%AA%A8%EB%91%90-%EC%8B%B1%EA%B8%80%ED%86%A4%EC%9D%BC%EA%B9%8C\">🌩 스프링의 빈의 scope는 모두 싱글톤일까</a></li>\n<li><a href=\"#-%EB%8A%90%EB%82%80-%EC%A0%90\">🛋 느낀 점</a></li>\n</ul>\n</div>","frontmatter":{"date":"November 10, 2021","title":"스프링의 싱글톤 레지스트리","categories":"스프링 웹","author":"코다","emoji":"🍀"},"fields":{"slug":"/spring-singleton-registry/"}},"prev":{"id":"0f7262a6-8cc3-5ad6-a8f8-5c468e91c6c6","html":"<h2 id=\"-intro\" style=\"position:relative;\"><a href=\"#-intro\" aria-label=\" intro permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>💡 Intro</h2>\n<ul>\n<li>인터페이스와 추상클래스의 차이를 명확하게 구분해보자.</li>\n<li>언제 무엇을 쓰는 것이 좋은지 나름의 정의를 내려본다.</li>\n<li>상속의 위험성에 대해서 고민해본다.</li>\n</ul>\n<br>\n<h2 id=\"-추상클래스\" style=\"position:relative;\"><a href=\"#-%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4\" aria-label=\" 추상클래스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 추상클래스</h2>\n<ul>\n<li>추상 클래스는 “미완성 설계도” 이다.</li>\n<li>\n<p>공통부분을 우선 정의한 미완성 설계도를 만들고 각기 다른 상황에 대해서 추가로 구현할 수 있다.</p>\n<ul>\n<li>완성되지 않은 abstract 메소드를 포함하고 있다.</li>\n</ul>\n</li>\n<li>추상클래스는 abstract 메소드가 있다는 것을 제외하고는 일반클래스와 동일하다.</li>\n<li><strong>상속은 자손 클래스를 만드는데 조상 클래스를 사용하는 것</strong></li>\n<li><strong>추상화는 자손 클래스의 공통부분을 뽑아내서 조상 클래스를 만드는 것</strong></li>\n</ul>\n<h3 id=\"상속\" style=\"position:relative;\"><a href=\"#%EC%83%81%EC%86%8D\" aria-label=\"상속 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>상속</h3>\n<ul>\n<li>추상클래스를 <code class=\"language-text\">extends</code> 하는 명령어가 상속에서 사용되기 때문에 두 개념이 혼용되어서 사용되기도 한다. 엄밀히 말하면 두 개념이 겹칠수도 있지만 완전히 동일한 것은 아니다.</li>\n<li>\n<p>상속이란 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것</p>\n<ul>\n<li>적은 양의 코드로 새로운 클래스를 작성할 수 있고 공통부분을 관리할 수 있다는 장점이 있다.</li>\n</ul>\n</li>\n<li><strong>상속은 is-a 관계로 표현될 수 있다.</strong></li>\n<li><code class=\"language-text\">**final</code>로 정의된 클래스가 아니라면 모두 상속이 가능하다. 추상클래스는 그 일부분이다.**</li>\n<li>\n<p>상속을 할 때 주의할 점 ‼️</p>\n<ul>\n<li>상속은 조상 클래스의 캡슐화가 깨지는 위험이 있다.</li>\n<li>또한 조상 클래스와 자손 클래스간의 강한 결합이기 때문에 조상 클래스 메서드에 변화가 생기면 자손 클래스에 아무런 변화가 없음에도 다르게 동작할 수 있다.</li>\n<li>따라서 상속보다는 <strong>조합</strong>을 사용하도록 추천한다. (Deck는 Card를 가지고 있다 와 같은 경우에 조합 사용 has-a 관계)</li>\n<li>\n<p>일반 클래스는 <code class=\"language-text\">final</code>을 추가하여 상속을 막거나 미완성 설계도인 abstract 클래스를 정의하도록 추천한다.</p>\n<ul>\n<li>또한 추상클래스의 부모 메소드를 수정하지 않는 것이 좋다.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"왜-자바는-단일-상속일까-single-inheritance\" style=\"position:relative;\"><a href=\"#%EC%99%9C-%EC%9E%90%EB%B0%94%EB%8A%94-%EB%8B%A8%EC%9D%BC-%EC%83%81%EC%86%8D%EC%9D%BC%EA%B9%8C-single-inheritance\" aria-label=\"왜 자바는 단일 상속일까 single inheritance permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>왜 자바는 단일 상속일까? (single inheritance)</h3>\n<ul>\n<li>다중상속을 하게 되면 복합적인 기능을 가진 클래스를 손쉽게 구현할 수 있지만 클래스 간 관계가 굉장히 복잡해진다.</li>\n<li>여러 다른 클래스로 상속받은 멤버의 이름이나 메서드가 같은 경우 구별도 어렵다.</li>\n</ul>\n<br>\n<h2 id=\"-인터페이스\" style=\"position:relative;\"><a href=\"#-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4\" aria-label=\" 인터페이스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 인터페이스</h2>\n<ul>\n<li>인터페이스는 “기본 설계도”이다. (추상클래스는 “미완성 설계도”)</li>\n<li>인터페이스는 면대면이 만나는 부분이라는 뜻을 가지고 있으며 2개의 구성요소가 상호작용할 수 있도록 접속 경계를 연결하는 부분이다. (플러그와 같은 역할)</li>\n<li>인터페이스끼리 상속받을 수 있으며 다중상속이 가능하다.</li>\n<li>인터페이스는 <code class=\"language-text\">implements</code> 를 사용해서 구현하며 다중구현이 가능하다.</li>\n<li>\n<p>인터페이스는 구현 메서드나 멤버 필드가 없다.</p>\n<ul>\n<li>default 메서드가 가능하도록 jdk1.8부터 추가가 되었고, static 변수만 가능하다.</li>\n</ul>\n</li>\n<li>인터페이스는 해당 인터페이스를 구현하는 모든 클래스가 특정 메소드를 반드시 구현하도록 강제하는 역할을 한다 → 따라서 명세의 역할을 한다고도 한다.</li>\n</ul>\n<h3 id=\"추상클래스와의-차이점\" style=\"position:relative;\"><a href=\"#%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90\" aria-label=\"추상클래스와의 차이점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>추상클래스와의 차이점</h3>\n<ul>\n<li>우선 구현메서드 존재 여부, 필드 존재 여부, 다중 상속 및 구현에 대한 차이점이 존재한다</li>\n<li>추상클래스는 공통기능에 대한 재사용과 정제의 역할을 한다. (정제란 불완전한 행동을 완전하게 만드는 것을 의미)</li>\n<li>인터페이스는 구현체가 특정 메소드가 반드시 존재하도록 하는 역할을 하여 특정 기능을 반드시 제공한다는 것을 보장하는 역할을 한다.</li>\n</ul>\n<h3 id=\"동일-메서드를-가진-인터페이스\" style=\"position:relative;\"><a href=\"#%EB%8F%99%EC%9D%BC-%EB%A9%94%EC%84%9C%EB%93%9C%EB%A5%BC-%EA%B0%80%EC%A7%84-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4\" aria-label=\"동일 메서드를 가진 인터페이스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>동일 메서드를 가진 인터페이스</h3>\n<ul>\n<li>\n<p>동일한 메서드 명과 시그니처를 가진 메서드가 두 개의 인터페이스에 있을때는 어떻게 할까?</p>\n<ul>\n<li>이때는 컴파일 오류로 충돌을 해결해야만 컴파일이 가능하다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-느낀-점\" style=\"position:relative;\"><a href=\"#-%EB%8A%90%EB%82%80-%EC%A0%90\" aria-label=\" 느낀 점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🛋 느낀 점</h2>\n<ul>\n<li>\n<p>추상클래스와 인터페이스는 역할 자체가 다르다.</p>\n<ul>\n<li>추상 클래스는 정제의 역할을 인터페이스는 기능 구현 강제의 역할을 한다.</li>\n<li>인터페이스를 통해서는 중복을 해결할 수 없다. 어떤 두 요소가 연결되기 위해 사전에 정의한 기능들이 모두 구현이 된다는 것을 보장할 뿐이다.</li>\n<li>상속은 부모 클래스의 캡슐화가 깨지기 때문에 조합을 이용하는 것이 더 적절하다.</li>\n</ul>\n</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#-intro\">💡 Intro</a></li>\n<li>\n<p><a href=\"#-%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4\">🌩 추상클래스</a></p>\n<ul>\n<li><a href=\"#%EC%83%81%EC%86%8D\">상속</a></li>\n<li><a href=\"#%EC%99%9C-%EC%9E%90%EB%B0%94%EB%8A%94-%EB%8B%A8%EC%9D%BC-%EC%83%81%EC%86%8D%EC%9D%BC%EA%B9%8C-single-inheritance\">왜 자바는 단일 상속일까? (single inheritance)</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4\">🌩 인터페이스</a></p>\n<ul>\n<li><a href=\"#%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90\">추상클래스와의 차이점</a></li>\n<li><a href=\"#%EB%8F%99%EC%9D%BC-%EB%A9%94%EC%84%9C%EB%93%9C%EB%A5%BC-%EA%B0%80%EC%A7%84-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4\">동일 메서드를 가진 인터페이스</a></li>\n</ul>\n</li>\n<li><a href=\"#-%EB%8A%90%EB%82%80-%EC%A0%90\">🛋 느낀 점</a></li>\n</ul>\n</div>","frontmatter":{"date":"November 15, 2021","title":"추상클래스와 인터페이스 더 이상 헷갈리지 않기","categories":"자바","author":"코다","emoji":"✊"},"fields":{"slug":"/java-abstract-vs-interface/"}},"site":{"siteMetadata":{"siteUrl":"https://yjksw.github.io","comments":{"utterances":{"repo":"yjksw/yjksw.github.io"}}}}},"pageContext":{"slug":"/os-user-kernel-thread/","nextSlug":"/spring-singleton-registry/","prevSlug":"/java-abstract-vs-interface/"}},"staticQueryHashes":["1073350324","2938748437"]}
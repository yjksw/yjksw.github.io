{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/os-user-kernel-thread/",
    "result": {"data":{"cur":{"id":"1549b4b9-74b3-5275-b573-eb2609ad7eff","html":"<h2 id=\"-intro\" style=\"position:relative;\"><a href=\"#-intro\" aria-label=\" intro permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>💡 Intro</h2>\n<ul>\n<li>효율적인 프로그래밍을 위해 멀티 스레드 환경에서 구동을 할 때가 많다.</li>\n<li>멀티 스레드의 간단한 장점과 항상 헷갈렸던 사용자 레벨 스레드 vs. 커널 레벨 스레드에 대해서 알아보자.</li>\n</ul>\n<br>\n<h2 id=\"-multi-thread-장점\" style=\"position:relative;\"><a href=\"#-multi-thread-%EC%9E%A5%EC%A0%90\" aria-label=\" multi thread 장점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 Multi-thread 장점</h2>\n<h3 id=\"1-응답성\" style=\"position:relative;\"><a href=\"#1-%EC%9D%91%EB%8B%B5%EC%84%B1\" aria-label=\"1 응답성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 응답성</h3>\n<ul>\n<li>어플리케이션의 일부분이 봉쇄되거나 긴 작업을 실행하더라도 다른 부분의 프로그램이 계속 실행되는 것을 허용하기 때문에 사용자의 입장에서 응답성이 증가한다.</li>\n<li>예를 들어 다운로드가 오래 걸리는 파일을 다운로드 하면서 사용자와의 상호작용이 가능하다.</li>\n</ul>\n<h3 id=\"2-자원-공유-resource-sharing\" style=\"position:relative;\"><a href=\"#2-%EC%9E%90%EC%9B%90-%EA%B3%B5%EC%9C%A0-resource-sharing\" aria-label=\"2 자원 공유 resource sharing permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 자원 공유 resource sharing</h3>\n<ul>\n<li>프로세스는 완전히 별도의 메모리 공간을 할당받기 때문에 (code, data, heap) 서로 통신하기 위해서는 공유 메모리를 사용하거나 메세지 전달 기법 (IPC)를 사용해야한다.</li>\n<li>스레드는 속한 프로세스의 자원을 공유하기 때문에 한 프로그램이 <strong>같은 주소 내에서 여러개의 다른 작업을 하는 단위</strong>로 나뉘어질 수 있다는 이점이 있다.</li>\n</ul>\n<h3 id=\"3-경제성-economy\" style=\"position:relative;\"><a href=\"#3-%EA%B2%BD%EC%A0%9C%EC%84%B1-economy\" aria-label=\"3 경제성 economy permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 경제성 economy</h3>\n<ul>\n<li>프로세스의 자원을 공유하므로 메모리 측면과 문맥교환 오버헤드 측면에서 경제적이다.</li>\n</ul>\n<h3 id=\"4-규모-가변성-scalability\" style=\"position:relative;\"><a href=\"#4-%EA%B7%9C%EB%AA%A8-%EA%B0%80%EB%B3%80%EC%84%B1-scalability\" aria-label=\"4 규모 가변성 scalability permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. 규모 가변성 scalability</h3>\n<ul>\n<li>멀티코어 환경에서 각각의 스레드가 다른 코어에서 병렬로 실행될 수 있기 때문에 이점이 증가한다.</li>\n<li>단일 스레드라면 코어의 개수와 상관없이 한번에 한 개의 처리기에서만 실행되지만 멀티코어에 멀티스레드라면 병렬성을 증가시킨다.</li>\n</ul>\n<br>\n<h2 id=\"-multi-thread-모델\" style=\"position:relative;\"><a href=\"#-multi-thread-%EB%AA%A8%EB%8D%B8\" aria-label=\" multi thread 모델 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 Multi-thread 모델</h2>\n<ul>\n<li>스레드는 사용자 스레드와 커널 스레드로 나뉜다.\n<ul>\n<li>사용자 스레드는 사용자 수준에서 관리되며 os가 관여하지 않는다.</li>\n<li>사용자 수준의 라이브러리를 사용하여 생성되고 커널의 개입을 받지 않는다.</li>\n<li>커널 스레드는 os에 의해 직접 지원되고 관리된다.</li>\n</ul>\n</li>\n<li>다양한 Mutli-thread 모델이 있는 이유는 스레드가 작업을 처리하기 위해서는 CPU를 점유해야하기 때문에 궁극적으로는 사용자 스레드와 커널 스레드간의 어떠한 연관관계가 존재해야 하기 때문이다.</li>\n</ul>\n<h3 id=\"모델-3가지\" style=\"position:relative;\"><a href=\"#%EB%AA%A8%EB%8D%B8-3%EA%B0%80%EC%A7%80\" aria-label=\"모델 3가지 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>모델 3가지</h3>\n<ul>\n<li>다대일 모델\n<ul>\n<li>여러 사용자 스레드를 하나의 커널 스레드에 사상하며 스레드 관리는 사용자 레벨의 스레드 라이브러리가 수행한다.</li>\n<li>한 스레드가 봉쇄 상태에 들어가면 커널 스레드가 함께 봉쇄 상태에 들어가게 되므로 모두 봉쇄된다.</li>\n<li>한번에 하나의 스레드만 커널에 접근이 가능하기 때문에 멀티코어 환경에서 병렬로 실행될 수 없다.</li>\n</ul>\n</li>\n<li>일대일 모델\n<ul>\n<li>하나의 사용자 스레드를 각각 하나의 커널 스레드로 사상한다.</li>\n<li>하나의 스레드가 봉쇄상태에 들어가더라도 다른 스레드가 커널 스레드와 매핑되어 작업을 처리할 수 있으므로 멀티코어 환경에서 더 병렬성을 제공한다.</li>\n<li>사용자 레벨에서 스레드를 하나 생성할 때 커널의 스레도 생성해야 하기 대문에 오버헤드가 발생한다. 따라서 이 모델을 사용할 경우 대부분 시스템에 의해 지원되는 스레드 개수를 제한한다.</li>\n<li>Linux가 대표적인 일대일 모델을 사용하는 os이다.</li>\n</ul>\n</li>\n<li>다대다 모델\n<ul>\n<li>여러 사용자 스레드를 여러 커널 스레드에 사상한다. (사용자 스레드 ≤ 커널 스레드 숫자로 사상한다)</li>\n<li>다대일 모델과 일대일 모델의 단점을 극복한다.\n<ul>\n<li>진정한 동시성을 지원하지 못하는 단점과, 스레드 개수에 제한이 있는 단점을 커버한다.</li>\n</ul>\n</li>\n<li>개발자는 원하는 만큼 스레드를 생성하고 여러개의 커널 스레드에 의해 병렬성을 보장한다. 따라서 하나의 스레드가 봉쇄상태에 들어가더라도 다른 커널 스레드에 의해 실행을 스케줄 할 수 있다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-thread-스케줄링\" style=\"position:relative;\"><a href=\"#-thread-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81\" aria-label=\" thread 스케줄링 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 Thread 스케줄링</h2>\n<ul>\n<li>사용자 스레드와 커널 스레드가 나뉘지만 os에서 스캐줄링 되는 대상은 커널 스레드이다.</li>\n<li>사용자 스레드는 스레드 라이브러리에 의해서 관리되고 커널은 사용자 스레드의 존재에 대해서 알지 못하기 때문에 궁극적으로 사용자 스레드는 커널 스레드에 사상되어야 한다.</li>\n<li>따라서 사용자 수준과 커널 수준의 스레드 스케줄링에 대해서 간략히 다루어보자.</li>\n</ul>\n<h3 id=\"경쟁-범위-contention-scope\" style=\"position:relative;\"><a href=\"#%EA%B2%BD%EC%9F%81-%EB%B2%94%EC%9C%84-contention-scope\" aria-label=\"경쟁 범위 contention scope permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>경쟁 범위 Contention scope</h3>\n<ul>\n<li><strong>Process-Contention scope(PCS)</strong>\n<ul>\n<li>다대일, 다대다 모델에서는 스레드 라이브러리가 사용자 스레드를 가용한 커널 스레드에 스케줄링한다.</li>\n<li>동일한 프로세스의 스레드들끼리 CPU를 경쟁하는 형태</li>\n<li>스레드 라이브러리가사용자 스레드를 ‘가용한 LWP(Light Weight Process) 상에서 스케줄한다’ 라고 하더라도 그것이 CPU 점유를 의미하지 않는다. CPU 점유는 커널 스레드의 스캐줄링이 필요하다.</li>\n<li>주로 우선순위에 따라서 행해지며 가장 높은 우선순위를 선점하여 스캐줄링한다.</li>\n</ul>\n</li>\n<li><strong>System-Contention scope(SCS)</strong>\n<ul>\n<li>실제 CPU에서 실행되기 위해서 os가 커널 스레드를 물리적 CPU로 스캐줄링 해야한다.</li>\n<li>어느 커널 스레드가 CPU를 점유할 것인지 결정하는 형태</li>\n<li>SCS 스캐줄링은 시스템 상의 모든 스레드 사이에서 일어난다.</li>\n<li>일대일 모델 같은 경우 오직 SCS만 사용한다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-느낀-점\" style=\"position:relative;\"><a href=\"#-%EB%8A%90%EB%82%80-%EC%A0%90\" aria-label=\" 느낀 점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🛋 느낀 점</h2>\n<ul>\n<li>한번도 제대로 이해하지 못했는데 os를 처음부터 차근차근 공부하며 ‘커널’에 대한 이해도를 쌓은 후 공부하니 조금 더 감이 잡히는 듯 하다.</li>\n<li>사용자 스레드의 이점이 아직 그렇게 잘 와닿지 않는다. 우선 하나의 프로세스 내에서 여러 작업 단위를 나눈다는 점만 이해하고 넘어가야겠다.</li>\n<li>자바의 Thread와 스레드 라이브러리에 대해서 더 깊이 공부해 봐야겠다 🙌</li>\n</ul>\n<br>\n<p>[참고자료]</p>\n<ul>\n<li>Operating System 공룡책</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#-intro\">💡 Intro</a></p>\n</li>\n<li>\n<p><a href=\"#-multi-thread-%EC%9E%A5%EC%A0%90\">🌩 Multi-thread 장점</a></p>\n<ul>\n<li><a href=\"#1-%EC%9D%91%EB%8B%B5%EC%84%B1\">1. 응답성</a></li>\n<li><a href=\"#2-%EC%9E%90%EC%9B%90-%EA%B3%B5%EC%9C%A0-resource-sharing\">2. 자원 공유 resource sharing</a></li>\n<li><a href=\"#3-%EA%B2%BD%EC%A0%9C%EC%84%B1-economy\">3. 경제성 economy</a></li>\n<li><a href=\"#4-%EA%B7%9C%EB%AA%A8-%EA%B0%80%EB%B3%80%EC%84%B1-scalability\">4. 규모 가변성 scalability</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-multi-thread-%EB%AA%A8%EB%8D%B8\">🌩 Multi-thread 모델</a></p>\n<ul>\n<li><a href=\"#%EB%AA%A8%EB%8D%B8-3%EA%B0%80%EC%A7%80\">모델 3가지</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-thread-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81\">🌩 Thread 스케줄링</a></p>\n<ul>\n<li><a href=\"#%EA%B2%BD%EC%9F%81-%EB%B2%94%EC%9C%84-contention-scope\">경쟁 범위 Contention scope</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-%EB%8A%90%EB%82%80-%EC%A0%90\">🛋 느낀 점</a></p>\n</li>\n</ul>\n</div>","excerpt":"💡 Intro 효율적인 프로그래밍을 위해 멀티 스레드 환경에서 구동을 할 때가 많다. 멀티 스레드의 간단한 장점과 항상 헷갈렸던 사용자 레벨 스레드 vs. 커널 레벨 스레드에 대해서 알아보자. 🌩 Multi-thread 장점 1. 응답성 어플리케이션의 일부분이 봉쇄되거나 긴 작업을 실행하더라도 다른 부분의 프로그램이 계속 실행되는 것을 허용하기 때문에 사용자의 입장에서 응답성이 증가한다. 예를 들어 다운로드가 오래 걸리는 파일을 다운로드 하면서 사용자와의 상호작용이 가능하다. 2. 자원 공유 resource sharing 프로세스는 완전히 별도의 메모리 공간을 할당받기 때문에 (code, data, heap) 서로 통신하기 위해서는 공유 메모리를 사용하거나 메세지 전달 기법 (IPC)를 사용해야한다. 스레드는 속한 프로세스의 자원을 공유하기 때문에 한 프로그램이 같은 주소 내에서 여러개의 다른 작업을 하는 단위로 나뉘어질 수 있다는 이점이 있다. 3. 경제성 economy 프로세스…","frontmatter":{"date":"November 10, 2021","title":"사용자 레벨 스레드 vs. 커널 레벨 스레드","categories":"운영체제","author":"코다","emoji":"🧁"},"fields":{"slug":"/os-user-kernel-thread/"}},"next":{"id":"6956dfc0-9e9b-5f82-936b-ebe795f54046","html":"<h2 id=\"-intro\" style=\"position:relative;\"><a href=\"#-intro\" aria-label=\" intro permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>💡 Intro</h2>\n<ul>\n<li>왜 하필 스프링 인가? 라는 질문을 던지게 되면서 스프링이 가지고 있느 장점에 대해서 고민해보았다.</li>\n<li>그 중 기존의 싱글톤 패턴의 한계를 뛰어넘은 스프링 싱글톤 레지스트리를 알게 되었다. 이전에 단순히 스프링이 싱글톤 scope으로 객체를 관리하여 여러 요청이 동시에 들어오는 환경에서 안정적으로 서비스할 수 있다는 장점을 들었지만 싱글톤 패턴과 어떻게 다른지 알지 못했다.</li>\n<li>그래서 알아보자 🙌</li>\n</ul>\n<br>\n<h2 id=\"-싱글톤-패턴이란\" style=\"position:relative;\"><a href=\"#-%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4%EC%9D%B4%EB%9E%80\" aria-label=\" 싱글톤 패턴이란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 싱글톤 패턴이란?</h2>\n<h3 id=\"왜-싱글톤-패턴이어야-할까\" style=\"position:relative;\"><a href=\"#%EC%99%9C-%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4%EC%9D%B4%EC%96%B4%EC%95%BC-%ED%95%A0%EA%B9%8C\" aria-label=\"왜 싱글톤 패턴이어야 할까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>왜 싱글톤 패턴이어야 할까</h3>\n<ul>\n<li>하나의 서버에 초당 수많은 요청이 도착하고 처리되어야 한다. 요청이 올 때마다 서버에서 관련 객체를 생성하는 것은 굉장히 큰 오버헤드이다.\n<ul>\n<li>\n<p>어떤 오버헤드가 발생할 수 있을까 ?</p>\n<p>주로 서버는 여러 계층의 레이어를 지나고 여러 비지니스 오브젝트들이 협력하여 요청을 처리한다.</p>\n<p>요청 하나당 대충 5개 정도의 오브젝트가 생성되고, 초딩 300개의 요청, 1분에 18000개의 요청이 발생한다면 18000 * 5 만큼의 새로운 오브젝트가 생성된다.</p>\n<p>오브젝트 생성도 비용이지만 생성된 오브젝트를 처리하여 메모리를 관리하는 GC도 오버헤드다. (GC의 동작원리를 살펴보자 🙌)</p>\n</li>\n</ul>\n</li>\n<li>따라서 스프링은 요청을 서비스 해주는 객체를 하나만 만들고 그것을 공유할 수 있도록 한다.</li>\n<li>하나의 객체만 생성하여 공유할 수 있는 것이 싱글톤 패턴이다.</li>\n</ul>\n<h3 id=\"싱글톤-패턴이-가지고-있는-단점\" style=\"position:relative;\"><a href=\"#%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4%EC%9D%B4-%EA%B0%80%EC%A7%80%EA%B3%A0-%EC%9E%88%EB%8A%94-%EB%8B%A8%EC%A0%90\" aria-label=\"싱글톤 패턴이 가지고 있는 단점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>싱글톤 패턴이 가지고 있는 단점</h3>\n<ul>\n<li>private 생성자 이므로 상속이 불가능하여 객체지향의 특징을 활용할 수 없다.</li>\n<li>싱글톤은 테스트하기 어려우며 서버환경에서 동시에 여러 요청이 들어오기 때문에 하나만 만들어지는 것을 보장할 수 없다.\n<ul>\n<li>싱글톤 객체는 만들어지는 방식이 제한적이므로 Mock 객체로 대체하는 것이 어렵다. 또한 생성자로 다이나믹하게 의존 객체를 주입하기 어렵기 때문에 일부 대체하려는 경우 해당 오브젝트를 테스트용으로 아예 만들어서 사용할 수밖에 없다.</li>\n</ul>\n</li>\n<li>싱글톤은 전역상태를 만들기 때문에 객체지향적으로 보았을 때 바람직하지 못하다.\n<ul>\n<li>static 필드와 메서드를 사용하며 싱글톤을 static 메서드를 통해 어느 곳에서든 접근할 수 있다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-싱글톤-레지스트리\" style=\"position:relative;\"><a href=\"#-%EC%8B%B1%EA%B8%80%ED%86%A4-%EB%A0%88%EC%A7%80%EC%8A%A4%ED%8A%B8%EB%A6%AC\" aria-label=\" 싱글톤 레지스트리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 싱글톤 레지스트리</h2>\n<ul>\n<li>스프링은 위에서 언급한 이유로 특정 서비스 객체들(빈)을 싱글톤으로 만든다. 하지만 위에서 나온 싱글톤 패턴을 그대로 사용하기보다 단점을 보완한 상태를 사용한다.</li>\n<li>싱글톤 패턴의 단점을 보완하기 위해 나온 것이 스프링의 <strong>싱글톤 레지스트리</strong>이다. 스프링 컨테이너가 싱글톤 레지스트리의 역할을 하여 빈을 싱글톤으로 관리한다.\n<ul>\n<li>private 생성자로 객체의 생성을 막는 방법이 아니라 일반 자바 클래스를 싱글톤으로 활용할 수 있도록 지원한다.</li>\n<li>생성, 관계설정, 사용에 대한 제어권이 컨테이너에게 있기 때문에 일반 자바 클래스도 싱글톤으로 관리될 수 있다.</li>\n</ul>\n</li>\n<li>public 생성자를 사용할 수 있기 때문에 필요하다면 새로운 오브젝트를 생성하고 Mock 오브젝트로 대체하는 등의 작업을 할 수 있다.</li>\n<li>객체지향적 설계와 디자인 패턴 적용이 가능하다.</li>\n</ul>\n<br>\n<h2 id=\"--싱글톤이기-때문에-주의할-점-️\" style=\"position:relative;\"><a href=\"#--%EC%8B%B1%EA%B8%80%ED%86%A4%EC%9D%B4%EA%B8%B0-%EB%95%8C%EB%AC%B8%EC%97%90-%EC%A3%BC%EC%9D%98%ED%95%A0-%EC%A0%90-%EF%B8%8F\" aria-label=\"  싱글톤이기 때문에 주의할 점 ️ permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩  싱글톤이기 때문에 주의할 점 ‼️</h2>\n<ul>\n<li>멀티 스레드 환경에서 여러 스레드가 싱글톤에 동시접근 할 수 있기 때문에 상태 관리를 주의해야한다.\n<ul>\n<li>대부분은 stateless하게 만들어져야 한다. 내부 상태값의 동시수정이 이루어지는 경우 매우 위험하기 때문이다.(읽기 전용은 제외)</li>\n</ul>\n</li>\n<li>싱글톤에서 필요한 정보는 상태없이 어떻게 관리할까?\n<ul>\n<li>파라미터, 로컬 변수, 리턴 값 등을 이용한다.</li>\n<li>위 변수들은 스택 영역에 독립적으로 저장이 되기 때문에 스레드마다 분리되어 있다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-스프링의-빈의-scope는-모두-싱글톤일까\" style=\"position:relative;\"><a href=\"#-%EC%8A%A4%ED%94%84%EB%A7%81%EC%9D%98-%EB%B9%88%EC%9D%98-scope%EB%8A%94-%EB%AA%A8%EB%91%90-%EC%8B%B1%EA%B8%80%ED%86%A4%EC%9D%BC%EA%B9%8C\" aria-label=\" 스프링의 빈의 scope는 모두 싱글톤일까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 스프링의 빈의 scope는 모두 싱글톤일까</h2>\n<ul>\n<li>우선, scope 란?\n<ul>\n<li>scope는 범위라는 뜻의 용어이고 여기서는 스프링의 빈이 <strong>1) 언제 생성되고 2) 언제까지 존재하며 3) 어디까지 적용되는지</strong>를 말한다.</li>\n<li>기본적인 스프링 빈의 scope는 싱글톤이며 빈의 생명주기는 스프링 컨테이너와 함께한다.</li>\n</ul>\n</li>\n<li>이외의 scope도 존재한다!\n<ul>\n<li>프로토타입 Prototype scope\n<ul>\n<li>컨테이너에 빈을 요청할 때마다 매번 새로운 오브젝트를 생성</li>\n</ul>\n</li>\n<li>요청 Request scope\n<ul>\n<li>새로운 HTTP 요청이 생길 때마다 생성</li>\n</ul>\n</li>\n<li>세션 Session scope\n<ul>\n<li>웹의 세션과 유사하게 생성</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-느낀-점\" style=\"position:relative;\"><a href=\"#-%EB%8A%90%EB%82%80-%EC%A0%90\" aria-label=\" 느낀 점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🛋 느낀 점</h2>\n<ul>\n<li><a href=\"https://github.com/yjksw/jwp-dashboard-mvc\">Spring MVC를 직접 구현해보는 미션</a>에서 component scanning으로 빈을 등록했던 것을 떠올리며 위 개념을 학습했더니 더 와닿았다.</li>\n<li>기존의 싱글톤 패턴이 안티패턴인데 멀티 스레드 환경에서는 싱글톤을 사용해야하는 것을 스프링 컨테이너로 해결한 것이 신선했다.</li>\n<li>스프링은 프레임워크이고 프레임워크에 종속적일수록 자바의 이점을 활용하기 어렵다고 생각했는데 이제야 조금씩 <em>토비의 스프링</em>에서 스프링 프레임워크가 자바의 객체지향적인 장점을 잘 살릴 수 있는 프레임워크라고 한 것이 이해되는 것 같다.</li>\n</ul>\n<br>\n<br>\n<p><strong>[참고자료]</strong></p>\n<ul>\n<li>토비의 스프링</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#-intro\">💡 Intro</a></p>\n</li>\n<li>\n<p><a href=\"#-%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4%EC%9D%B4%EB%9E%80\">🌩 싱글톤 패턴이란?</a></p>\n<ul>\n<li><a href=\"#%EC%99%9C-%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4%EC%9D%B4%EC%96%B4%EC%95%BC-%ED%95%A0%EA%B9%8C\">왜 싱글톤 패턴이어야 할까</a></li>\n<li><a href=\"#%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4%EC%9D%B4-%EA%B0%80%EC%A7%80%EA%B3%A0-%EC%9E%88%EB%8A%94-%EB%8B%A8%EC%A0%90\">싱글톤 패턴이 가지고 있는 단점</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-%EC%8B%B1%EA%B8%80%ED%86%A4-%EB%A0%88%EC%A7%80%EC%8A%A4%ED%8A%B8%EB%A6%AC\">🌩 싱글톤 레지스트리</a></p>\n</li>\n<li>\n<p><a href=\"#--%EC%8B%B1%EA%B8%80%ED%86%A4%EC%9D%B4%EA%B8%B0-%EB%95%8C%EB%AC%B8%EC%97%90-%EC%A3%BC%EC%9D%98%ED%95%A0-%EC%A0%90-%EF%B8%8F\">🌩  싱글톤이기 때문에 주의할 점 ‼️</a></p>\n</li>\n<li>\n<p><a href=\"#-%EC%8A%A4%ED%94%84%EB%A7%81%EC%9D%98-%EB%B9%88%EC%9D%98-scope%EB%8A%94-%EB%AA%A8%EB%91%90-%EC%8B%B1%EA%B8%80%ED%86%A4%EC%9D%BC%EA%B9%8C\">🌩 스프링의 빈의 scope는 모두 싱글톤일까</a></p>\n</li>\n<li>\n<p><a href=\"#-%EB%8A%90%EB%82%80-%EC%A0%90\">🛋 느낀 점</a></p>\n</li>\n</ul>\n</div>","frontmatter":{"date":"November 10, 2021","title":"스프링의 싱글톤 레지스트리","categories":"스프링 웹","author":"코다","emoji":"🍀"},"fields":{"slug":"/spring-singleton-registry/"}},"prev":{"id":"c988bf66-5fcc-5cb8-a6d8-82290bf4de3a","html":"<h2 id=\"-intro\" style=\"position:relative;\"><a href=\"#-intro\" aria-label=\" intro permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>💡 Intro</h2>\n<ul>\n<li>POJO에 대해서 ‘그냥 자바 객체요!’라고 말하는 것 이상으로 이해해보자.</li>\n<li>POJO기반 프레임워크란 무엇인지 이해해보고 스프링에서 POJO는 어떠한 형태를 띄는지 알아보자</li>\n<li>스프링이 개발의 복잡도를 낮춰주고 효과적으로 프로그래밍을 할 수 있도록 구체적으로 <strong>어떻게</strong> 가능하게 하는지 공부해보자.</li>\n</ul>\n<br>\n<h2 id=\"-pojo-란\" style=\"position:relative;\"><a href=\"#-pojo-%EB%9E%80\" aria-label=\" pojo 란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 POJO 란?</h2>\n<ul>\n<li>\n<p>유명한 스프링의 삼각형으로 기본 컨텍스트를 맞추고 설명을 시작해보자.</p>\n<ul>\n<li>스프링은 POJO에 주요기술인 IoC/DI, AOP, PSA를 사용한 코드와 POJO가 어떻게 관계를 맺고 동작하는지 정의한 설계정보로 구분된다.</li>\n</ul>\n<p align=\"center\"><img width=\"80%\" src=\"https://user-images.githubusercontent.com/63405904/142145957-19052d27-8363-4f06-9a36-5527c8eaf391.png\"></p>\n</li>\n<li>\n<p>스프링에서 DI는 <strong>유연하게 확장 가능한 오브젝트를 만들고, 그 관계를 외부에서 dynamic하게 설정해주는 것</strong>이며 스프링에서는 이 아이디어를 전반에 걸쳐서 적용한다.</p>\n</li>\n<li>\n<p>POJO는 EJB처럼 복잡하고 제한이 많은 기술로 엔터프라이즈 애플리케이션의 비지니스 로직을 구현하는 것보다 순수 자바 객체를 사용하여 비지니스 로직을 구현하는 것이 더 좋다고 생각하여 나온 개념이다.</p>\n</li>\n</ul>\n<h3 id=\"pojo의-조건\" style=\"position:relative;\"><a href=\"#pojo%EC%9D%98-%EC%A1%B0%EA%B1%B4\" aria-label=\"pojo의 조건 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>POJO의 조건</h3>\n<ol>\n<li>특정 규약에 종속되지 않는다.\n<ul>\n<li>자바 언어와 필요 API를 제외하고 다른 것에 종속되지 말아야 한다.\n<ul>\n<li>특정 규약에 따른 비지니스 컴포넌트를 만들어야하면 POJO가 아니다.</li>\n<li>또한 특정 클래스를 상속해서 만들어야하면 POJO가 아니다 → 단일 상속 제한 때문에 객체지향적인 설계 기법을 적용하기 어렵다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>특정 환경에 종속되지 않는다.\n<ul>\n<li>특정 무언가가 없는 환경에서 그대로 사용하기가 어렵다면 POJO가 아니다.</li>\n<li>그렇다면 JPA를 사용하는 Service 클래스는 POJO라고 할 수 있을까? 🤔\n<ul>\n<li>Service 클래스에서 의존하고 있는 JPA 레파지토리는 구현체인 하이버네이트에 의존하기 보다는 표준 스펙을 정의한 인터페이스이다. 따라서 POJO 프레임워크를 제공하는 것이라고 할 수 있다.</li>\n<li>그런 도메인의 인터페이스에 의존하는 서비스는 POJO라고 할 수 있을 것 같다.</li>\n<li>개인적인 의견이므로 틀리면 댓글로 얼마든지 알려주세요 🙌</li>\n</ul>\n</li>\n<li>특정 벤더의 서버나 프레임워크 안에서만 동작 가능한 코드는 POJO가 아니다.</li>\n<li>웹이라는 환경정보나 웹 기술을 담고 있는 클래스나 인터페이스를 사용하는 것은 POJO가 아니다.\n<ul>\n<li>예를 들어 비즈니스 코드에 HttpServletRequest나 HttpSession 등의 API가 등장하거나 클래스에서 그것을 직접 이용한다면 POJO가 아니다.</li>\n<li>웹 이외의 클라이언트는 해당 객체를 사용하지 못하며 독립적으로 테스트하기 어려워진다.</li>\n</ul>\n</li>\n<li>어노테이션을 쓰면 POJO가 아니다 라고 말할수는 없다. 해당 어노테이션이 환경에 종속되지 않고 부가적인 정보를 담고 있다면 POJO라고 할 수 있다.\n<ul>\n<li>만일 해당 어노테이션이 element에 특정 기술에 환경에 종속적인 정보를 담고 있다면 POJO라고 할 수 없다.\n<ul>\n<li>개인적인 의견) 따라서 JPA의 <code class=\"language-text\">@Entity</code>가 붙은 클래스는 POJO라고 할 수 없을 것 같다. @Id가 반드시 있어야하는 등의 제약사항이 있기 때문이다.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>그렇다고 위 2조건을 만족하는 나머지가 모두 POJO인 것은 아니다!\n<ul>\n<li>객체지향적인 자바의 언어를 잘 활용한 것이 POJO이다.</li>\n<li>재사용이 가능하고 상속과 다형성을 적용하여 객체지향적으로 설계된 오브젝트를 말한다.</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"pojo의-장점\" style=\"position:relative;\"><a href=\"#pojo%EC%9D%98-%EC%9E%A5%EC%A0%90\" aria-label=\"pojo의 장점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>POJO의 장점</h3>\n<ul>\n<li>기술과 환경에 종속되지 않으면 깔끔한 코드를 짤 수 있으며 순수 비즈니스 로직을 담을 수 있다.</li>\n<li>테스트 작성이나 검증이 쉽다.</li>\n<li>기술이나 환경의 변화에 취약하지 않다.</li>\n<li>재사용이 가능하고, 변경에 자유로우며, 확장이 용이한 객체지향적 설계가 가능하다.</li>\n</ul>\n<br>\n<h2 id=\"-pojo-프레임워크\" style=\"position:relative;\"><a href=\"#-pojo-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC\" aria-label=\" pojo 프레임워크 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 POJO 프레임워크</h2>\n<ul>\n<li>“스프링의 정수는 엔터프라이즈 서비스 기능을 POJO에 제공하는 것” 이라고 한다.</li>\n<li>즉, 트랜잭션과 같이 엔터프라이즈 시스템에서 필요한 기술을 순수 자바 객체에서 가능하게 한다는 것이다.</li>\n<li>다시 말하면 엔터프라이즈 서비스 기술과 자바 객체(POJO)를 효과적으로 분리했다는 의미이며 스프링의 가장 큰 장점이다.</li>\n<li>POJO 프로그래밍이 가능하도록 기술적인 기반을 제공하는 것이 POJO 프레임워크이다. 하이버네이트와 스프링이 대표적인 POJO 프레임워크이다.</li>\n<li>스프링은 POJO 기반으로 구현하고 엔터프라이즈 환경의 서비스와 기술을 POJO 방식으로 구현된 코드에 적용할 수 있다.\n<ul>\n<li>비즈니스 로직과 엔터프라이즈 기술을 분리하여 구성한다.</li>\n<li>스프링은 기술영역에만 관여하고 비즈니스 로직을 다루는 POJO에서 모습을 드러내지 않는다.</li>\n<li>데이터 액세스 로직이나 웹 UI 로직에서 최소한의 방법으로 관여한다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-느낀-점\" style=\"position:relative;\"><a href=\"#-%EB%8A%90%EB%82%80-%EC%A0%90\" aria-label=\" 느낀 점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🛋 느낀 점</h2>\n<ul>\n<li>개발자가 POJO 프레임워크를 사용한다고 해서 자동으로 객체지향적인 코드를 짜는 것은 아니다.</li>\n<li>객체지향적 코드가 가능한 기반에서 어떻게 효과적으로 객체지향적 설계를 잘 할지는 개발자의 남은 몫이다.\n<ul>\n<li>JVM, JDK API, 디자인패턴에 대해서 잘 공부하고 적용할 수 있도록 공부해야겠다.</li>\n</ul>\n</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#-intro\">💡 Intro</a></p>\n</li>\n<li>\n<p><a href=\"#-pojo-%EB%9E%80\">🌩 POJO 란?</a></p>\n<ul>\n<li><a href=\"#pojo%EC%9D%98-%EC%A1%B0%EA%B1%B4\">POJO의 조건</a></li>\n<li><a href=\"#pojo%EC%9D%98-%EC%9E%A5%EC%A0%90\">POJO의 장점</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-pojo-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC\">🌩 POJO 프레임워크</a></p>\n</li>\n<li>\n<p><a href=\"#-%EB%8A%90%EB%82%80-%EC%A0%90\">🛋 느낀 점</a></p>\n</li>\n</ul>\n</div>","frontmatter":{"date":"November 15, 2021","title":"스프링, POJO 프레임워크가 무슨 뜻일까","categories":"스프링 웹","author":"코다","emoji":"🍀"},"fields":{"slug":"/spring-pojo/"}},"site":{"siteMetadata":{"siteUrl":"https://yjksw.github.io","comments":{"utterances":{"repo":"yjksw/yjksw.github.io"}}}}},"pageContext":{"slug":"/os-user-kernel-thread/","nextSlug":"/spring-singleton-registry/","prevSlug":"/spring-pojo/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}
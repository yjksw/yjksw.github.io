{"componentChunkName":"component---src-templates-blog-template-js","path":"/oauth/","result":{"data":{"cur":{"id":"9dcfc695-3e64-5efc-9b80-257d69dd5ae2","html":"<h2 id=\"1-intro\" style=\"position:relative;\"><a href=\"#1-intro\" aria-label=\"1 intro permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. INTRO</h2>\n<br>\n<ul>\n<li>많은 어플리케이션에서 소셜 로그인을 지원하는데, 이때 사용되는 것이 OAuth 2.0 이다. </li>\n<li>\n<p>간단하게 이야기하면 OAuth 2.0 이란 사용자의 정보에 대한 권한을 부여하는 <code class=\"language-text\">산업 표준 프로토콜</code>의 일종이다. </p>\n<blockquote>\n<p>(정의) 제 3의 앱이 자원의 소유자인 서비스 이용자를 대신하여 서비스를 요청할 수 있도록 자원 접근 권한을 위임하는 방법 <br> <em>출처: 금융보안원 “OAuth 2.0 개요 및 보안 고려사항” 보안연구부-2015-030</em></p>\n</blockquote>\n</li>\n<li>즉, 정보 소유자 (서비스 이용자)를 대신하여 앱이 다른 서비스에 등록되어 있는 자원에 대한 접근을 요청하는 권한을 위임한다. </li>\n<li>아래 글은 <a href=\"https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2\">링크</a> 원문을 번역하고 일부 요약한 것이다. </li>\n</ul>\n<br>\n<br>\n<br>\n<h2 id=\"2-oauth-주요-개념\" style=\"position:relative;\"><a href=\"#2-oauth-%EC%A3%BC%EC%9A%94-%EA%B0%9C%EB%85%90\" aria-label=\"2 oauth 주요 개념 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. OAuth 주요 개념</h2>\n<br>\n1. **리소스 소유자** (Resource Owner) - 어플리케이션이 인가 요청을 하는 정보의 소유자이다. 즉, 그 정보를 소유하고 있는 '사용자'를 말한다. \n2. **클라이언트** (Client) - 리소스 소유자의 정보를 요청하는 어플리케이션이다. \n3. **리소스 서버** (Resource Server) - 리소스 소유자의 정보를 보유하고 있는 서버이다. \n4. **인가 서버** (Authorization Server) - 클라이언트가 사용자에 대한 정보 권한을 요청할 때, 그 사용자에 대해 검증하고 클라이언트 어플리케이션에 access token을 발급하는 인가 서버이다. 편의상 리소스 서버와 인가 서버를 구별하지 않고 이해해도 좋다. \n<br> \n<br>\n<h2 id=\"3-간단히-보는-oauth-프로토콜-흐름\" style=\"position:relative;\"><a href=\"#3-%EA%B0%84%EB%8B%A8%ED%9E%88-%EB%B3%B4%EB%8A%94-oauth-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-%ED%9D%90%EB%A6%84\" aria-label=\"3 간단히 보는 oauth 프로토콜 흐름 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 간단히 보는 OAuth 프로토콜 흐름</h2>\n<br>\n<p align=\"center\"><img width=\"540\" alt=\"스크린샷 2021-08-17 오후 2 41 53\" src=\"https://user-images.githubusercontent.com/63405904/129669922-d91d3405-3315-4b29-9e47-f8015dec6b13.png\">출처 : Digital Ocean의 An Introduction to OAuth 2.0</p>\n<br>\n<ol>\n<li>어플리케이션 유저에게 리소스에 대한 인가를 요청한다. </li>\n<li>유저는 해당 인가를 승인한다. </li>\n<li>어플리케이션은 리소스를 보유하고 있는 인가 서버에 access token을 요청한다. </li>\n<li>본 어플리케이션이 인증이 되고, 인가 승인을 인증하면 인가 서버는 해당 어플리케이션에 access token을 발급하고 인가 절차가 마무리된다. </li>\n<li>인가를 받은 어플리케이션은 리소스 서버에 access token과 함께 리소스를 요청한다.</li>\n<li>리소스 서버에서 access token을 확인하면 해당 리소스를 어플리케이션에 제공한다. </li>\n</ol>\n<br>\n<br>\n<h2 id=\"4-어플리케이션-등록\" style=\"position:relative;\"><a href=\"#4-%EC%96%B4%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EB%93%B1%EB%A1%9D\" aria-label=\"4 어플리케이션 등록 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. 어플리케이션 등록</h2>\n<br>\n<ul>\n<li>OAuth 기능을 추가하기 이전 본 어플리케이션(클라이언트)를 리소스를 요청하고자 하는 제 3 서비스(Google, Kakao, Github 등등)에 등록해야한다. </li>\n<li>\n<p>등록 정보 </p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">- 어플리케이션 이름\n- 어플리케이션 웹사이트\n- Redirect URI or Callback URL</code></pre></div>\n</li>\n<li>위에서 리다이렉트 URI는 인가 후, 인가 서버(리소스 서버)에서 code를 전송해줄 주소를 말한다.\n<br></li>\n<li>\n<p>어플리케이션 등록 시 다음 정보를 발급 받는다. 다음은 <code class=\"language-text\">Client Credentials</code>이라고 도 한다. </p>\n<ol>\n<li>Client Id - 외부에 노출되는 어플리케이션 identity 이다.</li>\n<li>Client Secret - 외부에 공개되어서는 안되는 key로 어플리케이션을 인증하고 유저의 계정에 접근을 요청할 때 사용한다. (Access Token 발급 시)\n<br>\n<br></li>\n</ol>\n</li>\n</ul>\n<h2 id=\"5-authorization-부여하기\" style=\"position:relative;\"><a href=\"#5-authorization-%EB%B6%80%EC%97%AC%ED%95%98%EA%B8%B0\" aria-label=\"5 authorization 부여하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5. Authorization 부여하기</h2>\n<br>\n<ul>\n<li>\n<p>OAuth 2.0은 3가지 종류로 인가를 부여한다. </p>\n<ol>\n<li>Authorization Code</li>\n<li>Client Credentials</li>\n<li>Device Code</li>\n</ol>\n</li>\n<li>위 3가지 중 이번 프로젝트에서는 <code class=\"language-text\">Authorization Code</code>를 사용했다. <code class=\"language-text\">Authorization Code</code>가 가장 빈번하게 사용이 되는데 server-side applications에 가장 최적화 되어 있기 때문이다. </li>\n<li>아래가 <code class=\"language-text\">Authorization Code</code>를 발급받는 기본 흐름인데, 보면 어플리케이션이 user-agent(유저의 웹 브라우저)와 소통할 수 있어야 하며 user-agent를 통해 라우팅 된 API authorization 코드를 받을 수 있어야 한다. </li>\n</ul>\n<p align=\"center\"><img width=\"688\" alt=\"스크린샷 2021-08-17 오후 4 08 28\" src=\"https://user-images.githubusercontent.com/63405904/129680013-50c21f7f-e1a2-4bb7-89fc-361450ef6c3e.png\">출처 : Digital Ocean의 An Introduction to OAuth 2.0</p>\n<ol>\n<li>\n<p>리소스를 요청하고자 하는 서버에 기재되어 있는 API authorization endpoint URI 에 1) client<em>id 2) redirect</em>uri 3) response_type 4) scope 등을 지정해서 요청을 보낸다. </p>\n<ul>\n<li>본인은 프로젝트에서 Github 소셜 로그인을 구현했었는데 <code class=\"language-text\">https://github.com/login/oauth/authorize?client_id=%s&amp;redirect_uri=%s&amp;scope=%s</code> 로 유저 인가 request를 보내도록 되어 있었다. </li>\n</ul>\n</li>\n<li>그럼 해당 리소스 서버(Github 등)에서 인가를 허가할지 말지 여부를 물어보는 페이지로 이동하여 유저가 허가 또는 거절을 누른다. </li>\n<li>유저가 허가한다면 리소스 서버(인가 서버)는 user-agent(브라우저)가  어플리케이션 등록 시 기재한 redirect URI로 authorization code와 함께 리다이렉트 하도록 한다. </li>\n<li>어플리케이션은 리소스 서버(인가 서버)에 1) client<em>id 2) client</em>secrete 3) grant<em>type 4) code 5) redirect</em>uri 와 함께 Access Token 발급 request를 보낸다. </li>\n<li>리소스 서버(인가 서버)에서 요청을 검사하고 유효하다면 AccessToken을 반환한다.\n<code class=\"language-text\">{\"access_token\":\"ACCESS_TOKEN\",\"token_type\":\"bearer\",\"expires_in\":2592000,\"refresh_token\":\"REFRESH_TOKEN\",\"scope\":\"read\",\"uid\":100101,\"info\":{\"name\":\"developer_coda\",\"email\":\"coda@coda.com\"}}</code>\n<br>\n<br> </li>\n</ol>\n<h2 id=\"6-access-token-활용하기\" style=\"position:relative;\"><a href=\"#6-access-token-%ED%99%9C%EC%9A%A9%ED%95%98%EA%B8%B0\" aria-label=\"6 access token 활용하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>6. Access Token 활용하기</h2>\n<br>\n<ul>\n<li>이후 어플리케이션은 리소스 서버에 원하는 정보 또는 행위를 요청할 때 헤더에 access token을 담아서 요청하도록 한다. </li>\n<li>Access token을 어플리케이션에 어떻게 관리할지는 내부 논의 후 정해서 저장하면 된다. (Redis, JWT 등등 이 있다.)</li>\n<li>본인은 프로젝트에서 JWT 토큰의 value로 저장하고 유저에게 JWT 토큰을 반환했다. </li>\n</ul>\n<br>\n<br>\n<h2 id=\"7-전체적인-흐름도\" style=\"position:relative;\"><a href=\"#7-%EC%A0%84%EC%B2%B4%EC%A0%81%EC%9D%B8-%ED%9D%90%EB%A6%84%EB%8F%84\" aria-label=\"7 전체적인 흐름도 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>7. 전체적인 흐름도</h2>\n<br>\n<p align=\"center\"><img width=\"700\" alt=\"스크린샷 2021-08-17 오후 4 44 00\" src=\"https://user-images.githubusercontent.com/63405904/129685067-5d0bbbdc-0224-42e8-bed4-fe984cb036ec.png\">출처 : NHN Cloud - OAuth 2.0 대표 취약점과 보안 고려 사항 알아보기</p>\n<br>\n<br>\n<h2 id=\"8-번외-oauth의-대표-취약점\" style=\"position:relative;\"><a href=\"#8-%EB%B2%88%EC%99%B8-oauth%EC%9D%98-%EB%8C%80%ED%91%9C-%EC%B7%A8%EC%95%BD%EC%A0%90\" aria-label=\"8 번외 oauth의 대표 취약점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>8. 번외) OAuth의 대표 취약점</h2>\n<br>\n<h3 id=\"81-csrfcross-site-request-forgery-공격\" style=\"position:relative;\"><a href=\"#81-csrfcross-site-request-forgery-%EA%B3%B5%EA%B2%A9\" aria-label=\"81 csrfcross site request forgery 공격 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>8.1. CSRF(Cross Site Request Forgery) 공격</h3>\n<ul>\n<li>OAuth 인증 진행 시, 발급받은 <code class=\"language-text\">Authorization Code</code>와 이전에 발급받은 <code class=\"language-text\">client_secret</code>을 함께 보내어 리소스 서버에 Access Token을 요청하는 단계가 있다. </li>\n<li><code class=\"language-text\">client_secret</code>은 CSRF token과 같은 역할을 해서 중간에 CSRF 공격을 예방하는 역할을 하는데, 만일 이것에 대한 검증이 누락되거나 취약하면 CSRF 공격에 의해 Authorization Code가 탈취되어 사용자의 계정이 노출될 수 있다.</li>\n<li><code class=\"language-text\">client_secret</code>에 대한 검증이 필요하다. </li>\n</ul>\n<br>\n<h3 id=\"82-convert-redirect\" style=\"position:relative;\"><a href=\"#82-convert-redirect\" aria-label=\"82 convert redirect permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>8.2. Convert Redirect</h3>\n<ul>\n<li>유저가 로그인한 후 인가를 승인하고 Authorization Code에 대해서 발급할 때 리다이렉트 되는 redirect_uri에 대한 검증이 안될 경우 공격자가 해당 공격 서버의 uri로 대체하여 Authorization Token을 탈취할 수 있다. </li>\n<li>Redirect URI에 대한 Full path 검증을 진행해야한다. </li>\n</ul>\n<br>\n<br>\n<br>\n<p><strong>[출처]</strong> </p>\n<ul>\n<li><a href=\"https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2\">https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2</a></li>\n<li><a href=\"https://meetup.toast.com/posts/105\">https://meetup.toast.com/posts/105</a></li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#1-intro\">1. INTRO</a></li>\n<li><a href=\"#2-oauth-%EC%A3%BC%EC%9A%94-%EA%B0%9C%EB%85%90\">2. OAuth 주요 개념</a></li>\n<li><a href=\"#3-%EA%B0%84%EB%8B%A8%ED%9E%88-%EB%B3%B4%EB%8A%94-oauth-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-%ED%9D%90%EB%A6%84\">3. 간단히 보는 OAuth 프로토콜 흐름</a></li>\n<li><a href=\"#4-%EC%96%B4%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EB%93%B1%EB%A1%9D\">4. 어플리케이션 등록</a></li>\n<li><a href=\"#5-authorization-%EB%B6%80%EC%97%AC%ED%95%98%EA%B8%B0\">5. Authorization 부여하기</a></li>\n<li><a href=\"#6-access-token-%ED%99%9C%EC%9A%A9%ED%95%98%EA%B8%B0\">6. Access Token 활용하기</a></li>\n<li><a href=\"#7-%EC%A0%84%EC%B2%B4%EC%A0%81%EC%9D%B8-%ED%9D%90%EB%A6%84%EB%8F%84\">7. 전체적인 흐름도</a></li>\n<li>\n<p><a href=\"#8-%EB%B2%88%EC%99%B8-oauth%EC%9D%98-%EB%8C%80%ED%91%9C-%EC%B7%A8%EC%95%BD%EC%A0%90\">8. 번외) OAuth의 대표 취약점</a></p>\n<ul>\n<li><a href=\"#81-csrfcross-site-request-forgery-%EA%B3%B5%EA%B2%A9\">8.1. CSRF(Cross Site Request Forgery) 공격</a></li>\n<li><a href=\"#82-convert-redirect\">8.2. Convert Redirect</a></li>\n</ul>\n</li>\n</ul>\n</div>","excerpt":"1. INTRO 많은 어플리케이션에서 소셜 로그인을 지원하는데, 이때 사용되는 것이 OAuth 2.0 이다.  간단하게 이야기하면 OAuth 2.0 이란 사용자의 정보에 대한 권한을 부여하는 의 일종이다.  (정의) 제 3의 앱이 자원의 소유자인 서비스 이용자를 대신하여 서비스를 요청할 수 있도록 자원 접근 권한을 위임하는 방법  출처: 금융보안원 “OAuth 2.0 개요 및 보안 고려사항” 보안연구부-2015-030 즉, 정보 소유자 (서비스 이용자)를 대신하여 앱이 다른 서비스에 등록되어 있는 자원에 대한 접근을 요청하는 권한을 위임한다.  아래 글은 링크 원문을 번역하고 일부 요약한 것이다.  2. OAuth 주요 개념 3. 간단히 보는 OAuth 프로토콜 흐름 어플리케이션 유저에게 리소스에 대한 인가를 요청한다.  유저는 해당 인가를 승인한다.  어플리케이션은 리소스를 보유하고 있는 인가 서버에 access token을 요청한다.  본 어플리케이션이 인증이 되고, 인가 승인…","frontmatter":{"date":"September 03, 2021","title":"OAuth 알아보기","categories":"웹","author":"코다","emoji":"🖥"},"fields":{"slug":"/oauth/"}},"next":{"id":"ff4d68a5-f01f-5ae1-92ba-074f403b2c61","html":"<h2 id=\"intro\" style=\"position:relative;\"><a href=\"#intro\" aria-label=\"intro permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Intro</h2>\n<hr>\n<ul>\n<li>이번에 프로젝트를 진행하면서 보안상의 이유로 직접 S3 서버에 접근할 수 없었기 때문에 AWS에서 제공하는 CDN 서비스인 CloudFront를 통해서 이미지 등의 리소스에 접근해야 했다. (CDN서버의 본래 목적과는 다소 다른 이유로 사용했다.)</li>\n<li>CDN은 어떤 기술이며, 장점이 무엇이고, 어떻게 동작하는지에 대해서 알아본다. </li>\n<li>CDN을 퉁해 누릴 수 있는 보안적인 이점은 무엇이며, 프로젝트를 진행하면서 CloudFront를 어떻게 활용했는지에 대해서 작성한다. </li>\n</ul>\n<br>\n<br>\n<h2 id=\"cdn이란-무엇인가\" style=\"position:relative;\"><a href=\"#cdn%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80\" aria-label=\"cdn이란 무엇인가 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CDN이란 무엇인가?</h2>\n<hr>\n<p>CDN은 Content Delivery Network의 약자이다. 직역하자면 컨텐츠를 전달해주는 네트워크이다. CDN 컨텐츠를 전송하는 물리적인 서버가 지리적으로 여러곳에 상주하며 유저와 가까이 위치한 서버에서 요청한 컨텐츠를 고속으로 제공해준다.\n<br></p>\n<p>CDN이 제공하는 컨텐츠는 <code class=\"language-text\">HTML</code>, <code class=\"language-text\">javascript</code> 파일, <code class=\"language-text\">css</code>, 이미지, 동영상 등의 대부분의 인터넷 콘텐츠이다. CDN 서비스에 대해서 설명하는 예시에 항상 등장하는 어플리케이션은 넷플릭스이다. 전세계 곳곳에서 유저들이 넷플릭스 컨텐츠를 요청하면 가장 가까이 상주하고 있는 CDN 서버에서 넷플릭스 컨텐츠를 빠르게 유저에게 제공한다. 이외에 Facebook, Amazon 등도 사용 중이다.\n<br></p>\n<p>CDN을 자체로 웹을 호스팅 할 수는 없다. 다만 웹의 컨텐츠를 <code class=\"language-text\">캐싱</code>하여 호스팅하는 웹을 대신하여 전송해서 웹의 성능을 개선한다.\n<br>\n<br></p>\n<h2 id=\"cdn-장점\" style=\"position:relative;\"><a href=\"#cdn-%EC%9E%A5%EC%A0%90\" aria-label=\"cdn 장점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CDN 장점</h2>\n<hr>\n<ol>\n<li>\n<p>캐싱으로 컨텐츠 고속 전송</p>\n<ul>\n<li>사용자와 물리적으로 가까운 CDN 서버에서 컨텐츠를 전송하므로 사용자의 입장에서 컨텐츠 로드 시간이 매우 단축된다. 또한 CDN 서버는 랜덤으로 배치되어 있는 것이 아니라, 전세계 트래픽이 많은 영역에 전략적으로 위치해 있다. </li>\n<li>\n<p>캐싱 과정 </p>\n<ol>\n<li>사용자가 컨텐츠를 요청하면 가장 가까운 CDN 엣지 서버로 요청이 간다. </li>\n<li>(최초 요청일 경우) CDN 엣지 서버에서 원본 서버로 요청을 보낸다. </li>\n<li>원본 서버가 해당 컨텐츠를 엣지 서버에 응답한다. </li>\n<li>\n<p>엣지 서버가 사용자에게 컨텐츠를 응답한다.\n<br></p>\n<p align=\"center\"><img width=\"450\" src=\"https://user-images.githubusercontent.com/63405904/130417611-508fcc23-79f2-4ae7-923b-5a0989a2cf54.png\"><br>이미지 출처: https://www.cloudflare.com/ko-kr/learning/cdn/performance/</p>\n</li>\n</ol>\n</li>\n<li>\n<p>그 이후부터는 동일한 컨텐츠에 대한 요청이 있을 때 해당 컨텐츠가 동일한 CDN 엣지 서버에 요청을 보내고 원본 서버에 요청을 보낼 필요 없이 CDN 엣지 서버가 컨텐츠를 반환한다. 이때 속도가 굉장히 향상된다.\n<br></p>\n<p align=\"center\"><img width=\"450\" src=\"https://user-images.githubusercontent.com/63405904/130417751-e2d97680-8446-401e-bdec-90b95560f87f.png\"><br>이미지 출처: https://www.cloudflare.com/ko-kr/learning/cdn/performance/</p>\n</li>\n</ul>\n</li>\n</ol>\n<br>\n<ol start=\"2\">\n<li>\n<p>CDN의 failover</p>\n<ul>\n<li>failover란? 서버가 갑자기 중단되어 서버에 요청을 보내던 트래픽에 대해 정상적인 응답을 하지 못하는 것을 방지하는 것</li>\n<li>\n<p>CDN은 요청을 보내던 origin server가 죽으면 정상적으로 응답을 할 수 있는 서버로 reroute 하여 사용자가 안정적으로 그 응답을 받을 수 있도록 한다.\n<br></p>\n<p align=\"center\"><img width=\"433\" src=\"https://user-images.githubusercontent.com/63405904/130594395-77cf44f3-049c-4a4c-9be2-f59678f77b7c.png\"><br>이미지 출처: https://www.cloudflare.com/ko-kr/learning/cdn/cdn-load-balance-reliability/</p>\n</li>\n</ul>\n</li>\n</ol>\n<br>\n<ol start=\"3\">\n<li>\n<p>로드밸런싱 및 DDos 공격 완화</p>\n<ul>\n<li>로드 밸런서는 네트워크 트래픽을 여러 서버에 분산해서 성능을 개선하는 것이다. </li>\n<li>CDN은 GSLB(Global Server Load Balancing)으로 로드 밸런싱 기술을 제공한다. (DNS와 GSLB의 차이점에 대해서 학습해도 좋다.) <a href=\"https://www.cloudflare.com/ko-kr/learning/cdn/glossary/global-server-load-balancing-gslb/\">GSLB 참고</a></li>\n<li>CDN은 데이터센터의 로드 밸런싱으로 사용자의 요청을 가능한 서버에 분산해서 요청한다. (GSLB를 사용하기 때문에 요청 서버에 대한 헬스체크도 수행하여 안정적이다.)</li>\n<li>\n<p>속도도 개선시키고, 트래픽도 감소시키므로 DDos 공격도 방지할 수 있다. </p>\n<p align=\"center\"><img width=\"630\" src=\"https://user-images.githubusercontent.com/63405904/130593424-74c410aa-b465-4fee-8dd1-e4213090064a.png\"><br>이미지 출처: https://www.cloudflare.com/ko-kr/learning/cdn/cdn-load-balance-reliability/</p>\n</li>\n</ul>\n</li>\n</ol>\n<br>\n<br>\n<h2 id=\"프로젝트에서-cdn-사용-목적\" style=\"position:relative;\"><a href=\"#%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EC%97%90%EC%84%9C-cdn-%EC%82%AC%EC%9A%A9-%EB%AA%A9%EC%A0%81\" aria-label=\"프로젝트에서 cdn 사용 목적 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>프로젝트에서 CDN 사용 목적</h2>\n<hr>\n<ul>\n<li>\n<p>다음은 프로젝트의 인프라 구조이다. </p>\n<p align=\"center\"><img width=\"605\" src=\"https://user-images.githubusercontent.com/63405904/130720611-034be1a1-c358-4ce5-8fac-8383a87d19e0.png\"></p>\n</li>\n<li>일반적인지는 잘 모르겠지만, 현재 S3 버킷에 프론트 서버가 올라가있다. (그렇지 않더라도 이미지 및 동영상 리소스가 S3 버킷에 저장되어 있다.) </li>\n<li>프로젝트를 하는데 보안상의 이슈로 S3 버킷에 대한 접근을 전체공개할 수 없었고, Cloud Front를 통해서 우회하여 접근하도록 설계했다. </li>\n<li>CDN의 본래 목적은 리소스를 캐싱하여 빠르게 로딩하는 것이지만 이번 프로젝트에서는 S3 버킷 사용 목적으로 설계했다. </li>\n<li>프론트 서버를 분산하거나, 진행중인 프로젝트(개발자 친화적 SNS)의 특성상 이미지 및 동영상 리소스가 굉장히 많아져서 S3 버킷이 추가되면 로드 밸런싱, CDN failover 등의 이점을 누릴 수 있을 것이라고 생각한다. </li>\n</ul>\n<br>\n<br>\n<p><strong>[참고자료]</strong></p>\n<ul>\n<li><a href=\"https://www.cloudflare.com/ko-kr/learning/cdn/performance/\">https://www.cloudflare.com/ko-kr/learning/cdn/performance/</a></li>\n<li><a href=\"https://www.cloudflare.com/ko-kr/learning/cdn/cdn-load-balance-reliability/\">https://www.cloudflare.com/ko-kr/learning/cdn/cdn-load-balance-reliability/</a></li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#intro\">Intro</a></li>\n<li><a href=\"#cdn%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80\">CDN이란 무엇인가?</a></li>\n<li><a href=\"#cdn-%EC%9E%A5%EC%A0%90\">CDN 장점</a></li>\n<li><a href=\"#%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EC%97%90%EC%84%9C-cdn-%EC%82%AC%EC%9A%A9-%EB%AA%A9%EC%A0%81\">프로젝트에서 CDN 사용 목적</a></li>\n</ul>\n</div>","frontmatter":{"date":"September 02, 2021","title":"CDN 알아보기","categories":"인프라","author":"코다","emoji":"🚊"},"fields":{"slug":"/cdn/"}},"prev":{"id":"104d60ac-d178-5742-8d47-caf93db5ba17","html":"<h2 id=\"intro\" style=\"position:relative;\"><a href=\"#intro\" aria-label=\"intro permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>INTRO</h2>\n<ul>\n<li>HTTP는 Stateless 무상태성을 가지고 있다. 따라서 데이터를 상태로 저장하지 않는다.</li>\n<li>HTTP가 무성태성이기 때문에 클라이언트에 대한 데이터를 유지하고 싶을 때는 쿠키 또는 세션을 이용한다. (이전에 요청을 보낸 동일한 사용자임을 확인하고 싶은 경우 등등)</li>\n<li>쿠키는 클라이언트가 정보를 가지고 브라우저에서 저장 및 관리한다. </li>\n<li>세션은 서버가 데이터를 가지고 저장 및 관리한다. </li>\n</ul>\n<br>\n<br>\n<h2 id=\"cookie\" style=\"position:relative;\"><a href=\"#cookie\" aria-label=\"cookie permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Cookie</h2>\n<ul>\n<li>쿠키는 클라이언트가 정보를 가지고 브라우저에서 해당 정보를 저장한다. </li>\n<li>\n<p>따라서 요청을 보낼 때마다 브라우저에서 저장된 쿠키 데이터를 HTTP 헤더에 추가하여 서버에 보낼 수 있다.</p>\n<ul>\n<li>HTTP 메세지 자체는 무상태성이기 때문에 매번 쿠키값을 보내주어야 한다. </li>\n</ul>\n</li>\n<li>쿠키에 저장되는 값의 형태는 text 이다. </li>\n</ul>\n<h3 id=\"쿠키의-단점\" style=\"position:relative;\"><a href=\"#%EC%BF%A0%ED%82%A4%EC%9D%98-%EB%8B%A8%EC%A0%90\" aria-label=\"쿠키의 단점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>쿠키의 단점</h3>\n<ul>\n<li>\n<p>클라이언트가 관리하는 것이기 때문에 데이터가 쉽게 훼손 될 수 있다. </p>\n<ul>\n<li>실제로 크롬 브라우저에서 개발자 도구 -> Application 탭에 가면 쿠키 데이터를 저장하는 저장소를 볼 수 있다. </li>\n<li>여기서 값을 조회, 수정, 삭제를 할 수 있다.\n<img width=\"636\" alt=\"스크린샷 2021-09-04 오후 3 10 59\" src=\"https://user-images.githubusercontent.com/63405904/132084874-b28a2e15-6ade-4fec-87a5-87434675f0b4.png\"></li>\n</ul>\n</li>\n<li>다른 사람이 쉽게 열람할 수 있다. 따라서 민감한 정보를 저장할 수 없다. </li>\n</ul>\n<br>\n<h3 id=\"쿠키-설정하기\" style=\"position:relative;\"><a href=\"#%EC%BF%A0%ED%82%A4-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0\" aria-label=\"쿠키 설정하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>쿠키 설정하기</h3>\n<ul>\n<li>\n<p>쿠키를 설정하고 싶을때는 아래와 같이 서버에서 <code class=\"language-text\">Set-Cookie</code> 헤더로 값을 보내면 된다. </p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">HttpResponse : \n\nHTTP/1.1 302 Found \nSet-Cookie: cookieValue=thisIsCookie!!!\nLocation: http://localhost:8080/index.html </code></pre></div>\n</li>\n<li>\n<p>그 이후 모든 클라이언트의 요청에는 위에 설정한 쿠키값이 Cookie 헤더로 서버에 전송된다. </p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">HttpRequest : \n\nGET /login HTTP/1.1\nHost: localhost:8080\nConnection: keep-alive\nPragma: no-cache\nCache-Control: no-cache\nCookie: cookieValue=thisIsCookie!!!</code></pre></div>\n</li>\n</ul>\n<br>\n<br>\n<h2 id=\"session\" style=\"position:relative;\"><a href=\"#session\" aria-label=\"session permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Session</h2>\n<ul>\n<li>세션은 서버의 메모리에서 데이터를 관리한다. </li>\n<li>외부에 공개하기 위험한 정보를 서버의 메모리에 안전하게 저장할 수 있다. </li>\n<li>세션을 식별하기 위한 고유한 id인 session id가 부여되고 클라이언트는 해당 세션 Id만을 저장하고 관리하면 된다. </li>\n<li>세션에 저장되는 값의 형태는 object 이다. </li>\n</ul>\n<h3 id=\"세션의-단점\" style=\"position:relative;\"><a href=\"#%EC%84%B8%EC%85%98%EC%9D%98-%EB%8B%A8%EC%A0%90\" aria-label=\"세션의 단점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>세션의 단점</h3>\n<ul>\n<li>서버의 메모리에서 지나치게 많은 세션 데이터를 관리하기 힘들 수 있다. </li>\n</ul>\n<br>\n<h3 id=\"세션-설정하기\" style=\"position:relative;\"><a href=\"#%EC%84%B8%EC%85%98-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0\" aria-label=\"세션 설정하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>세션 설정하기</h3>\n<ul>\n<li>서버에서 세션을 설정할 때 <code class=\"language-text\">HttpServletRequest</code>의 <code class=\"language-text\">getSession()</code>을 호출하면 해당 request의 세션을 생성해서 반환한다. 아래에 세션 생성 및 반환 시점에 대해서 추가로 설명한다. </li>\n<li>반환된 세션에 <code class=\"language-text\">setAttribute()</code>를 통해 속성값을 지정한다. 해당 값이 세션에 저장되는 데이터 정보이다. </li>\n<li>세션의 <code class=\"language-text\">getId()</code>를 호출해 해당 세션의 id를 <code class=\"language-text\">Set-Cookie</code> 헤더에 <code class=\"language-text\">JSESSIONID</code> 라는 key로 추가하여 클라이언트에게 응답힌다. </li>\n<li>이후에 쿠키로 등록된 세션 id를 통해서 세션을 유지하고 속성값에 접근할 수 있다. </li>\n<li>\n<p><strong>코드로 보기</strong></p>\n<ul>\n<li>\n<p>스프링부트 웹 프로젝트라고 가정한다. </p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@GetMapping</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/login\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token class-name\">ResponseEntity</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">login</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> account<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> password<span class=\"token punctuation\">,</span> <span class=\"token class-name\">HttpServletRequest</span> request<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"token class-name\">User</span> loginUSer <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">User</span><span class=\"token punctuation\">(</span>account<span class=\"token punctuation\">,</span> password<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token class-name\">HttpSession</span> session <span class=\"token operator\">=</span> <span class=\"token class-name\">HttpServletRequest</span><span class=\"token punctuation\">.</span><span class=\"token function\">getSession</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nsession<span class=\"token punctuation\">.</span><span class=\"token function\">setAttribute</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"user\"</span><span class=\"token punctuation\">,</span> user<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">String</span> sessionId <span class=\"token operator\">=</span> session<span class=\"token punctuation\">.</span><span class=\"token function\">getId</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token class-name\">HttpHeaders</span> responseHeaders <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HttpHeaders</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nresponseHeaders<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Set-Cookie\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"JSESSIONID=\"</span> <span class=\"token operator\">+</span> sessionId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nresponseHeaders<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Location\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"index.html\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">return</span> <span class=\"token class-name\">ResponseEntity</span><span class=\"token punctuation\">.</span><span class=\"token function\">found</span><span class=\"token punctuation\">(</span>responseHeaders<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n</ul>\n</li>\n<li>\n<p>그럼 다음과 같이 응답이 나간다. </p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">HTTPResponse : \n\nHTTP/1.1 302 Found \nSet-Cookie: JSESSIONID=2cfd4acb-0b67-4ce9-90c4-97ee3242e51b \nLocation: http://localhost:8080/index.html </code></pre></div>\n</li>\n<li>\n<p>이후 클라이언트가 요청을 보낼 때마다 쿠키에 세션 ID 값이 포함되어서 보내어 진다. 이 아이디를 통해서 세션을 매핑하고 세션이 유지되는 것을 확인할 수 있다. </p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">HTTPRequest : \n\nGET /login HTTP/1.1\nHost: localhost:8080\nConnection: keep-alive\nPragma: no-cache\nCache-Control: no-cache\nCookie: JSESSIONID=2cfd4acb-0b67-4ce9-90c4-97ee3242e51b</code></pre></div>\n</li>\n</ul>\n<br>\n<h3 id=\"세션은-언제-생성될까-\" style=\"position:relative;\"><a href=\"#%EC%84%B8%EC%85%98%EC%9D%80-%EC%96%B8%EC%A0%9C-%EC%83%9D%EC%84%B1%EB%90%A0%EA%B9%8C-\" aria-label=\"세션은 언제 생성될까  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>세션은 언제 생성될까 ?</h3>\n<ul>\n<li>이번에 직접 HTTP 서버를 구현하는 프로젝트를 하면서 세션을 구현하면서 의문이 들었다. </li>\n<li><code class=\"language-text\">request.getSession()</code>을 하면 항상 세션을 반환하는데 그럼 모든 HttpRequest에 대한 세션이 생성되는 것인지 궁금했다. </li>\n<li><code class=\"language-text\">request.getSession()</code>을 하면 유지되던 세션, 혹은 새로 생성된 세션이 반환되므로 모든 요청에 대한 세션을 생성한다고 생각할 수 있지만 그렇지 않다. </li>\n<li>세션을 만드는 것도 비용이 필요하기 때문에 세션이 필요할 때만 lazy 하게 생성한다.\n<br></li>\n<li><code class=\"language-text\">HttpSession</code>의 경우 세션은 ServletContainer에서 생성이 된다. </li>\n<li>따라서 <code class=\"language-text\">HttpServletRequest</code>에서 세션을 요청할 때 서블릿 컨테이너에서 내부적으로 생성해서 세션을 반환한다. </li>\n<li>실제로 세션이 생성되는 시기는 <code class=\"language-text\">@Autowired</code>로 세션이 주입되는지, 메서드 인자로 주입되는지, request에서 <code class=\"language-text\">getSession()</code>을 호출하는 지에 따라서 다르므로 참고하자. </li>\n<li>\n<p>나는 주로 controller 메서드의 인자로 세션을 호출하는데 그때는 컨트롤러 메서드를 호출하는 즉시 세션을 생성/요청해서 주입해준다. </p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@PostMapping</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"login\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token class-name\">ResponseEntity</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">ResponseMessage</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">login</span><span class=\"token punctuation\">(</span><span class=\"token annotation punctuation\">@RequestBody</span> <span class=\"token class-name\">User</span> user<span class=\"token punctuation\">,</span> <span class=\"token class-name\">HttpSession</span> session<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">//..로직 생략 </span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<br>\n</li>\n<li>세션을 유지 할 때는 헤더에 관련 키가 있다면(<code class=\"language-text\">JSESSIONID</code>와 같은 쿠키값) 해당 세션을 요청해서 반환하고, 없다면 새로운 세션을 생성해서 반환한다. </li>\n</ul>\n<h3 id=\"주의할-점\" style=\"position:relative;\"><a href=\"#%EC%A3%BC%EC%9D%98%ED%95%A0-%EC%A0%90\" aria-label=\"주의할 점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>주의할 점</h3>\n<ul>\n<li>세션이 쿠키보다 보안이 좋은 것은 사실이나, 쿠키에 저장된 <code class=\"language-text\">JSSESIONID</code>를 탈취하여 다른 브라우저의 쿠키값으로 설정한다면 서버는 위 세션 아이디와 동일한 브라우저로 판단해 요청을 처리한다. </li>\n<li>예를 들어서 A 사용자가 로그인해서 부여받은 세션 ID를 다른 브라우저의 쿠키값으로 집어넣기만 해도 A 사용자가 로그인한 상태로 요청을 보내는 것으로 처리되므로 여전히 위험할 수 있다. </li>\n</ul>\n<br>\n<br>\n<h2 id=\"언제-무엇을-사용하는-것이-좋을까\" style=\"position:relative;\"><a href=\"#%EC%96%B8%EC%A0%9C-%EB%AC%B4%EC%97%87%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EA%B2%83%EC%9D%B4-%EC%A2%8B%EC%9D%84%EA%B9%8C\" aria-label=\"언제 무엇을 사용하는 것이 좋을까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>언제 무엇을 사용하는 것이 좋을까?</h2>\n<ul>\n<li>언제 세션을 사용하고 언제 쿠키를 사용하는지에 대해서는 물론 답이 없다. </li>\n<li>웹을 구현하면서 워낙 많은 경우가 있기 때문에 각각 다른 이유들을 비교해서 더 적합한 것을 선택하면 된다. </li>\n<li>나의 경우에는 민감한 정보가 있을 때는 세션을, 그렇지 않은 경우는 쿠키로 관리한다.</li>\n</ul>\n<br>\n<br>\n<h2 id=\"번외-static-code-classlanguage-texthttpsessionscode-클래스-테스트하기-code-classlanguage-textmockstaticltcode\" style=\"position:relative;\"><a href=\"#%EB%B2%88%EC%99%B8-static-code-classlanguage-texthttpsessionscode-%ED%81%B4%EB%9E%98%EC%8A%A4-%ED%85%8C%EC%8A%A4%ED%8A%B8%ED%95%98%EA%B8%B0-code-classlanguage-textmockstaticltcode\" aria-label=\"번외 static code classlanguage texthttpsessionscode 클래스 테스트하기 code classlanguage textmockstaticltcode permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>번외) static <code class=\"language-text\">HttpSessions</code> 클래스 테스트하기 <code class=\"language-text\">MockStatic&lt;></code></h2>\n<ul>\n<li>직접 Http 서버를 구현하면서 세션에 고유한 id를 부여하기 위해 <code class=\"language-text\">UUID.randomUUID()</code>를 통해서 구현했다. </li>\n<li><code class=\"language-text\">HttpSession</code> 을 관리하는 <code class=\"language-text\">HttpSessions</code>는 <code class=\"language-text\">static</code>으로 관리하고 있고, 해당 클래스에서 <code class=\"language-text\">UUID.randomUUID()</code>를 사용해 새로운 HttpSession을 생성하고 아이디를 부여해 리턴 및 저장한다. </li>\n<li>매번 랜덤한 값을 id로 부여하기 때문에 테스트 코드를 짜는데 어려움이 있었고, Mocking을 하려고 했으나 HttpSessions가 static이므로 기존의 모킹 방식으로는 테스트하기가 어려웠다. </li>\n<li>\n<p>따라서 static 을 모킹할 수 있는 방법으로 테스트를 진행했다. </p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">MockedStatic</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">HttpSessions</span><span class=\"token punctuation\">></span></span> mockHttpSessions<span class=\"token punctuation\">;</span>\n\n<span class=\"token class-name\">String</span> sessionId <span class=\"token operator\">=</span> <span class=\"token string\">\"id\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">when</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">HttpSessions</span><span class=\"token punctuation\">.</span><span class=\"token function\">getSession</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">thenReturn</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">HttpSession</span><span class=\"token punctuation\">(</span>sessionId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n</li>\n</ul>\n<br>\n<br>\n<br>\n<p><strong>[참고자료]</strong></p>\n<ul>\n<li><a href=\"https://hahahoho5915.tistory.com/32\">https://hahahoho5915.tistory.com/32</a></li>\n<li><a href=\"https://soon-devblog.tistory.com/2\">https://soon-devblog.tistory.com/2</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=OpoVuwxGRDI\">https://www.youtube.com/watch?v=OpoVuwxGRDI</a></li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#intro\">INTRO</a></li>\n<li>\n<p><a href=\"#cookie\">Cookie</a></p>\n<ul>\n<li><a href=\"#%EC%BF%A0%ED%82%A4%EC%9D%98-%EB%8B%A8%EC%A0%90\">쿠키의 단점</a></li>\n<li><a href=\"#%EC%BF%A0%ED%82%A4-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0\">쿠키 설정하기</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#session\">Session</a></p>\n<ul>\n<li><a href=\"#%EC%84%B8%EC%85%98%EC%9D%98-%EB%8B%A8%EC%A0%90\">세션의 단점</a></li>\n<li><a href=\"#%EC%84%B8%EC%85%98-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0\">세션 설정하기</a></li>\n<li><a href=\"#%EC%84%B8%EC%85%98%EC%9D%80-%EC%96%B8%EC%A0%9C-%EC%83%9D%EC%84%B1%EB%90%A0%EA%B9%8C-\">세션은 언제 생성될까 ?</a></li>\n<li><a href=\"#%EC%A3%BC%EC%9D%98%ED%95%A0-%EC%A0%90\">주의할 점</a></li>\n</ul>\n</li>\n<li><a href=\"#%EC%96%B8%EC%A0%9C-%EB%AC%B4%EC%97%87%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EA%B2%83%EC%9D%B4-%EC%A2%8B%EC%9D%84%EA%B9%8C\">언제 무엇을 사용하는 것이 좋을까?</a></li>\n<li><a href=\"#%EB%B2%88%EC%99%B8-static-httpsessions-%ED%81%B4%EB%9E%98%EC%8A%A4-%ED%85%8C%EC%8A%A4%ED%8A%B8%ED%95%98%EA%B8%B0-mockstatic\">번외) static <code class=\"language-text\">HttpSessions</code> 클래스 테스트하기 <code class=\"language-text\">MockStatic&lt;></code></a></li>\n</ul>\n</div>","frontmatter":{"date":"September 04, 2021","title":"쿠키와 세션 알아보기","categories":"웹","author":"코다","emoji":"🖥"},"fields":{"slug":"/cookie-session/"}},"site":{"siteMetadata":{"siteUrl":"https://yjksw.github.io","comments":{"utterances":{"repo":"yjksw/yjksw.github.io"}}}}},"pageContext":{"slug":"/oauth/","nextSlug":"/cdn/","prevSlug":"/cookie-session/"}},"staticQueryHashes":["1073350324","2938748437"]}
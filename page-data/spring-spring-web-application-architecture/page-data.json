{"componentChunkName":"component---src-templates-blog-template-js","path":"/spring-spring-web-application-architecture/","result":{"data":{"cur":{"id":"156033a5-3d3b-51d5-abc6-61b8996690bf","html":"<p>다음 글은 <a href=\"Understanding%20Spring%20Web%20Application%20Architecture:%20The%20Classic%20Way\">링크</a>에 기술되어 있는 스프링 웹 어플리케이션 구조에 대한 글을 번역 한 내용이다. </p>\n<h2 id=\"좋은-architecture를-위한-두-기둥\" style=\"position:relative;\"><a href=\"#%EC%A2%8B%EC%9D%80-architecture%EB%A5%BC-%EC%9C%84%ED%95%9C-%EB%91%90-%EA%B8%B0%EB%91%A5\" aria-label=\"좋은 architecture를 위한 두 기둥 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>좋은 architecture를 위한 두 기둥</h2>\n<h3 id=\"the-socseparation-of-concerns-원칙\" style=\"position:relative;\"><a href=\"#the-socseparation-of-concerns-%EC%9B%90%EC%B9%99\" aria-label=\"the socseparation of concerns 원칙 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>The SoC(Separation of Concerns) 원칙</h3>\n<blockquote>\n<p>A design principle for separating a computer program into distinct sections, which each section addresses a separate concern. <br> <a href=\"%5Bhttps://en.wikipedia.org/wiki/Separation_of_concerns%5D(https://en.wikipedia.org/wiki/Separation_of_concerns)\">출처</a></p>\n</blockquote>\n<p>SoC에서 신경써야 할 부분은 두가지이다.</p>\n<ol>\n<li>고려해야 할 <strong>concerns</strong>가 무엇인지  </li>\n<li>어디서 해당 <strong>concern</strong>을 다루고 싶은지</li>\n</ol>\n<p>SoC를 준수하게 된다면 각각의 layer와 해당 layer의 책임에 대해서 자연스럽게 정의할 수 있도록 도와준다. </p>\n<h3 id=\"the-kisskeep-it-simple-stupid-원칙\" style=\"position:relative;\"><a href=\"#the-kisskeep-it-simple-stupid-%EC%9B%90%EC%B9%99\" aria-label=\"the kisskeep it simple stupid 원칙 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>The KISS(Keep It Simple Stupid) 원칙</h3>\n<blockquote>\n<p>Most systems work best if they are kept simple rather than made complicated; therefore simplicity should be a key goal in design and unnecessary complexity should be avoided. <br> <a href=\"%5Bhttp://en.wikipedia.org/wiki/KISS_principle%5D(http://en.wikipedia.org/wiki/KISS_principle)\">출처</a></p>\n</blockquote>\n<p>이 원칙은 각 레이어는 그만큼의 비용이 들고 복잡한 구조를 가진 어플리케이션은 그만큼의 높은 비용을 감수해야 한다는 것을 상기시켜준다. </p>\n<ul>\n<li>새로운 feature를 추가하는 경우 해당 정보를 여러 layer에 모두 전달해야 하기 때문에 과정이 오래 걸림</li>\n<li>지나치게 복잡한 구조를 가지고 있기 때문에 아무도 제대로 이해하고 있지 않아서 해당 어플리케이션의 유지보수가 어려움</li>\n</ul>\n<br>\n<h2 id=\"3-layers가-가장-적당하다\" style=\"position:relative;\"><a href=\"#3-layers%EA%B0%80-%EA%B0%80%EC%9E%A5-%EC%A0%81%EB%8B%B9%ED%95%98%EB%8B%A4\" aria-label=\"3 layers가 가장 적당하다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3 Layers가 가장 적당하다</h2>\n<p>웹 어플리케이션의 책임을 고려했을때 웹 어플리케이션 전체적으로 다음과 같은 concerns가 있다.</p>\n<ul>\n<li>사용자의 입력을 받아서 적당한 응답을 반환</li>\n<li>예외 처리를 하여 예외 상황시 적절한 에외 메세지를 반환</li>\n<li>트랜잭션 관리 전략을 가짐</li>\n<li>인가와 인증을 처리함</li>\n<li>어플리케이션의 비지니스 로직을 작성</li>\n<li>사용되는 데이터 저장소와 외부 리소스와의 커뮤니케이션 담당</li>\n</ul>\n<p>위 역할을 감당하기 위해서 다음 3가지 layer로 충분하다. </p>\n<ol>\n<li>\n<p><strong>The Web Layer</strong></p>\n<p>웹 어플리케이션의 최상단에 있는 layer이다. 사용자의 입력을 받아서 적정한 응답을 반환하는 역할을 맡는다. 이 레이어에서는 다른 레이어에서 발생한 예외들에 대한 핸들링을 처리해야한다. <br></p>\n<p>현재 레이어는 해당 어플리케이션의 입구이기 때문에 인증 및 인가를 담당하여 허가되지 않은 사용자에 대한 1차 방어를 해야한다. </p>\n</li>\n<li>\n<p><strong>The Service Layer</strong></p>\n<p>웹 레이어 다음에 위치한 레이어이다. 이 레이어는 트랜잭션 단위를 구분하고, application과 infrastructure 서비스를 모두 포함한다. <br></p>\n<p>여기서 <strong>application services</strong>는 서비스 레이어의 <strong>public API</strong>를 제공한다. 이 뜻은, 어플리케이션 서비스에서 처리하고하고자 하는 일들이 서비스 레이어의 <code class=\"language-text\">public</code> 메소드에서 처리된다는 것이다. 이 메소드 별로 트랜잭션 단위가 나뉘어지고 인증 및 인가 작업도 여기서 담당한다. <br></p>\n<p>서비스 레이어에서 <strong>infrastructure services</strong>는 파일 시스템, 데이터베이스, 이메일 서버 등등의 외부 리소스와 커뮤니케이션하기 때문에 “plumbing code” (배관 코드)라고 불리기도 한다. 이 메소드들은 하나 이상의 어플리케이션 서비스 코드에서 주로 활용된다. </p>\n</li>\n<li>\n<p><strong>The Repository Layer</strong></p>\n<p>웹 어플리케이션의 최하위에 위치해있는 레이어이다. 데이터 저장소와의 연결을 담당한다. </p>\n</li>\n</ol>\n<br>\n<p>특정 레이어에 속한 컴포넌트는 동일 레이어, 혹은 더 하위 레이어의 컴포넌트를 활용할 수 있다. </p>\n<p align=\"center\"><img width=\"85%\" src=\"https://user-images.githubusercontent.com/63405904/135494819-559541d9-1b75-4f2b-a5fe-f03519508483.png\"></p>\n<br>\n<h2 id=\"layer-나누어-설계하기\" style=\"position:relative;\"><a href=\"#layer-%EB%82%98%EB%88%84%EC%96%B4-%EC%84%A4%EA%B3%84%ED%95%98%EA%B8%B0\" aria-label=\"layer 나누어 설계하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Layer 나누어 설계하기</h2>\n<p>이제는 각 레이어에 대한 인터페이스를 설계해야하는데, 여기서 DTO(Domain Transfer Object)와 domain model이라는 키워드가 등장한다. </p>\n<ul>\n<li>\n<p><strong>DTO</strong></p>\n<p>단순한 데이터를 담는 객체로 각기 다른 프로세스와 어플리케이션의 레이어간 데이터 전달 때 사용되는 객체이다. </p>\n</li>\n<li>\n<p><strong>Domain Model</strong></p>\n<p>도메인 모델에는 3가지 다른 역할의 객체들이 있다.</p>\n<ol>\n<li>\n<p><strong>Domain Service</strong></p>\n<p>도메인과 관련된 operation 이지만 enity나 VO의 일부는 아닌 상태가 없는(stateless) 클래스</p>\n</li>\n<li>\n<p><strong>Entity</strong></p>\n<p>전체 라이프 사이클 동안 바뀌지 않고 그 indentity 자체로 정의되는 객체 <strong>(?????)</strong></p>\n</li>\n<li>\n<p><strong>Value Object</strong></p>\n<p>어떤 것의 속성을 나타내고, 그 자체로의 identity나 lifecycle이 없는 객체이다. 주로 VO의 life cycle은 entity의 lifecycle에 종속되어 있다. </p>\n</li>\n</ol>\n</li>\n</ul>\n<p>각 레이어의 인터페이스에는 다음 것들이 포함되어 있어야 한다. </p>\n<ul>\n<li>web layer는 DTO만을 다루어야 한다.</li>\n<li>service layer는 DTO를 메소드 인자로 받고 도메인 모델을 핸들링 할 수는 있지만 DTO만을 web layer에 다시 반환해야 한다.</li>\n<li>repository layer는 entity를 메소드 인자로 받고 entity를 반환해야 한다.</li>\n</ul>\n<p>그렇다면 왜 VO가 아닌 DTO로 레이어간 소통을 해야하는지 궁금할 수 있다. 다음 두가지 이유로 VO를 직접 사용하는 것은 좋지 않다. </p>\n<ol>\n<li>도메인 모델은 어플리케이션 내부 모델이다. 따라서 도메인 모델을 외부로 노출한다면 클라이언트는 해당 도메인 모델을 어떻게 다루어야하는지 인지해야한다. 하지만, 클라이언트는 해당 로직에 대해서 알 필요가 없다. 만일 DTO를 사용한다면 도메인 모델을 클라이언트에게 숨기고, 깔끔하고 쉬운 API를 제공할 수 있다. </li>\n<li>도메인 모델을 외부에 노출한다면 도메인 모델을 수정할 때 해당 도메인 모델이 의존하는 것들을 함께 수정해야한다. 하지만 만일 DTO를 사용한다면도메인 모델을 수정하더라도 다른 것(other stuff)들이 DTO와 연결되어 있기 때문에 다른 것들을 수정하지 않아도 된다. </li>\n</ol>\n<p align=\"center\"><img width=\"85%\" src=\"https://user-images.githubusercontent.com/63405904/135494900-92d34444-4d4a-4312-af6a-a0d45bf62f75.png\"></p>\n<br>\n<br>\n<p><strong>[참고링크]</strong></p>\n<ul>\n<li><a href=\"https://www.petrikainulainen.net/software-development/design/understanding-spring-web-application-architecture-the-classic-way/\">https://www.petrikainulainen.net/software-development/design/understanding-spring-web-application-architecture-the-classic-way/</a></li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#%EC%A2%8B%EC%9D%80-architecture%EB%A5%BC-%EC%9C%84%ED%95%9C-%EB%91%90-%EA%B8%B0%EB%91%A5\">좋은 architecture를 위한 두 기둥</a></p>\n<ul>\n<li><a href=\"#the-socseparation-of-concerns-%EC%9B%90%EC%B9%99\">The SoC(Separation of Concerns) 원칙</a></li>\n<li><a href=\"#the-kisskeep-it-simple-stupid-%EC%9B%90%EC%B9%99\">The KISS(Keep It Simple Stupid) 원칙</a></li>\n</ul>\n</li>\n<li><a href=\"#3-layers%EA%B0%80-%EA%B0%80%EC%9E%A5-%EC%A0%81%EB%8B%B9%ED%95%98%EB%8B%A4\">3 Layers가 가장 적당하다</a></li>\n<li><a href=\"#layer-%EB%82%98%EB%88%84%EC%96%B4-%EC%84%A4%EA%B3%84%ED%95%98%EA%B8%B0\">Layer 나누어 설계하기</a></li>\n</ul>\n</div>","excerpt":"다음 글은 링크에 기술되어 있는 스프링 웹 어플리케이션 구조에 대한 글을 번역 한 내용이다.  좋은 architecture를 위한 두 기둥 The SoC(Separation of Concerns) 원칙 A design principle for separating a computer program into distinct sections, which each section addresses a separate concern.  출처 SoC에서 신경써야 할 부분은 두가지이다. 고려해야 할 concerns가 무엇인지   어디서 해당 concern을 다루고 싶은지 SoC를 준수하게 된다면 각각의 layer와 해당 layer의 책임에 대해서 자연스럽게 정의할 수 있도록 도와준다.  The KISS(Keep It Simple Stupid) 원칙 Most systems work best if they are kept simple rather than made complicated; theref…","frontmatter":{"date":"June 26, 2021","title":"클래식한 스프링 웹 어플리케이션 구조","categories":"스프링 웹","author":"코다","emoji":"🍀"},"fields":{"slug":"/spring-spring-web-application-architecture/"}},"next":{"id":"1f652c1c-da4d-5aba-86ee-d66e7a606fcb","html":"<h2 id=\"intro\" style=\"position:relative;\"><a href=\"#intro\" aria-label=\"intro permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>INTRO</h2>\n<ul>\n<li><code class=\"language-text\">HandlerMethodArgumentResolver</code>는 Spring framework에서 제공하는 인터페이스로 request에서 메소드의 parameters를 해당하는 인자값으로 변환 혹은 바인딩 하는 resolver이다.</li>\n</ul>\n<br>\n<h2 id=\"인터페이스-내용\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-%EB%82%B4%EC%9A%A9\" aria-label=\"인터페이스 내용 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>인터페이스 내용</h2>\n<p><code class=\"language-text\">HandelrMethodArgumentResolver</code>에는 두가지 메소드가 있다. </p>\n<ol>\n<li><code class=\"language-text\">supportsParameter()</code></li>\n<li><code class=\"language-text\">resolveArgument()</code></li>\n</ol>\n<br>\n<h2 id=\"첫번째-parameter가-해당-resolver를-지원하는-여부-확인\" style=\"position:relative;\"><a href=\"#%EC%B2%AB%EB%B2%88%EC%A7%B8-parameter%EA%B0%80-%ED%95%B4%EB%8B%B9-resolver%EB%A5%BC-%EC%A7%80%EC%9B%90%ED%95%98%EB%8A%94-%EC%97%AC%EB%B6%80-%ED%99%95%EC%9D%B8\" aria-label=\"첫번째 parameter가 해당 resolver를 지원하는 여부 확인 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>첫번째, Parameter가 해당 resolver를 지원하는 여부 확인</h2>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token function\">supportsParameter</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">MethodParameter</span> parameter<span class=\"token punctuation\">)</span></code></pre></div>\n<p><strong>[참고]</strong> 아래 설명은 <code class=\"language-text\">@RequestBody</code>가 붙은 인자의 경우를 보는 것이므로 그 구현체가 <code class=\"language-text\">RequestResponseBodyMethodProcess.java</code>의 예시로 설명한 것이다. <br></p>\n<ul>\n<li>Parameter가 있는 수만큼 <code class=\"language-text\">InvocableHanderMethod#InvokeForRequest()</code> → <code class=\"language-text\">getMethodArgumentValues()</code> 안에서 for문을 돌면서 해당 parameter에 대한 argument resolve를 한다. 이때 resolve를 하기 위해서 현재 클래스가 가지고 있는 <code class=\"language-text\">resolvers</code> 가 해당 parameter 지원 하는지 여부를 확인한다.</li>\n<li>→ 확인하는 로직은 <code class=\"language-text\">HandlerMethodArgumentResolverComposite</code> 안에 있는 resolver들의 배열을 돌면서(한번 찾으면 캐싱함) 해당 parameter를 지원하는 resolver를 찾아서 반환하고, null인지 여부를 체크해 boolean을 반환한다. 이때 <code class=\"language-text\">supportsParameter()</code> 메소드가 수행된다.</li>\n<li>→ 다시 <code class=\"language-text\">InvocableHanderMethod#InvokeForRequest()</code> → <code class=\"language-text\">getMethodArgumentValues()</code> 의 반복문 안에서  <code class=\"language-text\">HandlerMethodArgumentResolver#resolveArgument()</code> 가 실행이 되면서(어노테이션에 따라서 구현체가 각기 따로 있음 ex. <code class=\"language-text\">RequestResponseBodyMethodProcess</code> 등등) controller 메서드에서 사용되는 인자를 배열에 저장한다.</li>\n</ul>\n<br>\n<h2 id=\"두번째-해당-parameter를-argument-value로-변환-및-바인딩\" style=\"position:relative;\"><a href=\"#%EB%91%90%EB%B2%88%EC%A7%B8-%ED%95%B4%EB%8B%B9-parameter%EB%A5%BC-argument-value%EB%A1%9C-%EB%B3%80%ED%99%98-%EB%B0%8F-%EB%B0%94%EC%9D%B8%EB%94%A9\" aria-label=\"두번째 해당 parameter를 argument value로 변환 및 바인딩 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>두번째, 해당 parameter를 argument value로 변환 및 바인딩</h2>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token function\">resolveArgument</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">MethodParameter</span> parameter<span class=\"token punctuation\">,</span> <span class=\"token class-name\">ModelAndViewContainer</span> mavContainer<span class=\"token punctuation\">,</span> <span class=\"token class-name\">NativeWebRequest</span> webRequest<span class=\"token punctuation\">,</span> <span class=\"token class-name\">WebDataBinderFactory</span> binderFactory<span class=\"token punctuation\">)</span></code></pre></div>\n<p>Method parameter를 argument value로 변환 및 바인딩 하는 역할을 한다. </p>\n<ul>\n<li><code class=\"language-text\">ModelAndViewContainer</code> 는 request의 model에 접근할 수 있도록 한다.</li>\n<li><code class=\"language-text\">WebDataBinderFactory</code>는 <code class=\"language-text\">WebDataBinder</code> 인스턴스를 추출해 데이터 바인딩이나 타입 변환을 지원한다.</li>\n</ul>\n<p>성공 시 argument value를 리턴하고, 없다면 <code class=\"language-text\">null</code>을 리턴한다. </p>\n<p>만일 <code class=\"language-text\">@Valid</code> 어노테이션이 해당 인자에 붙어있다면 해당하는 validation도 이 메소드에서 처리한다. </p>\n<br>\n<h2 id=\"custom-resolver-구현\" style=\"position:relative;\"><a href=\"#custom-resolver-%EA%B5%AC%ED%98%84\" aria-label=\"custom resolver 구현 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Custom Resolver 구현</h2>\n<ol>\n<li><code class=\"language-text\">HandlerMethodArgumentResolver</code> 인터페이스를 구현하는 custom resovler 클래스를 구현</li>\n<li><code class=\"language-text\">@Override</code> 한 <code class=\"language-text\">supportParameter()</code> 메소드에서 원하는 타입의 인자인 경우 <code class=\"language-text\">true</code>를 반환하도록 구현</li>\n<li><code class=\"language-text\">@Override</code>한 <code class=\"language-text\">resolveArgument()</code>에서 controller의 메서드 인자로 보면 값을 반환하도록 구현 </li>\n<li><code class=\"language-text\">WebMvcConfiguration</code> 를 구현하는 클래스의 <code class=\"language-text\">addArgumentResolver()</code>라는 메소드를 override하여 위 구현한 custom resolver를 추가해준다. </li>\n</ol>\n<br>\n<br>\n<p><strong>[참고링크]</strong></p>\n<ul>\n<li><a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/method/support/HandlerMethodArgumentResolver.html\">https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/method/support/HandlerMethodArgumentResolver.html</a></li>\n<li><a href=\"https://enai.tistory.com/31\">https://enai.tistory.com/31</a></li>\n</ul>\n<br>\n<p><strong>[유용링크]</strong></p>\n<ul>\n<li>스프링에서 요청을 처리하는 과정\n<a href=\"https://m.blog.naver.com/PostView.nhn?blogId=duco777&#x26;logNo=220605479481&#x26;proxyReferer=https:%2F%2Fwww.google.com%2F\">https://m.blog.naver.com/PostView.nhn?blogId=duco777&#x26;logNo=220605479481&#x26;proxyReferer=https:%2F%2Fwww.google.com%2F</a></li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#intro\">INTRO</a></li>\n<li><a href=\"#%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-%EB%82%B4%EC%9A%A9\">인터페이스 내용</a></li>\n<li><a href=\"#%EC%B2%AB%EB%B2%88%EC%A7%B8-parameter%EA%B0%80-%ED%95%B4%EB%8B%B9-resolver%EB%A5%BC-%EC%A7%80%EC%9B%90%ED%95%98%EB%8A%94-%EC%97%AC%EB%B6%80-%ED%99%95%EC%9D%B8\">첫번째, Parameter가 해당 resolver를 지원하는 여부 확인</a></li>\n<li><a href=\"#%EB%91%90%EB%B2%88%EC%A7%B8-%ED%95%B4%EB%8B%B9-parameter%EB%A5%BC-argument-value%EB%A1%9C-%EB%B3%80%ED%99%98-%EB%B0%8F-%EB%B0%94%EC%9D%B8%EB%94%A9\">두번째, 해당 parameter를 argument value로 변환 및 바인딩</a></li>\n<li><a href=\"#custom-resolver-%EA%B5%AC%ED%98%84\">Custom Resolver 구현</a></li>\n</ul>\n</div>","frontmatter":{"date":"June 25, 2021","title":"HandlerMethodArgumentResolver 내부동작 원리 알아보기","categories":"스프링 웹","author":"코다","emoji":"🍀"},"fields":{"slug":"/handler-method-argument-resolver/"}},"prev":{"id":"0574f453-d5ef-573e-bcb2-ee85bc19c34e","html":"<h2 id=\"동시성-문제-발생-가능-상황\" style=\"position:relative;\"><a href=\"#%EB%8F%99%EC%8B%9C%EC%84%B1-%EB%AC%B8%EC%A0%9C-%EB%B0%9C%EC%83%9D-%EA%B0%80%EB%8A%A5-%EC%83%81%ED%99%A9\" aria-label=\"동시성 문제 발생 가능 상황 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>동시성 문제 발생 가능 상황</h2>\n<p>두개의 트랜잭션이 모두 읽는 연산을 하는 경우 문제가 되지 않는다.</p>\n<ul>\n<li>\n<p>하나의 트랜잭션은 read, 하나는 write인 경우 (<strong>Isolation</strong>으로 해결)</p>\n<ul>\n<li>\n<p><strong>Dirty Read</strong></p>\n<p><strong>상황</strong>: 트랜잭션1이 write 할 때 트랜잭션2가 update된 데이터를 읽었지만 트랜잭션1이 rollback 되었을 때 발생 <br></p>\n<p><strong>문제</strong>: 트랜잭션2가 무효된 데이터를 읽었음 <br></p>\n</li>\n<li>\n<p><strong>Non-repeatable Read</strong></p>\n<p><strong>상황</strong>: 트랜잭션1이 데이터를 read하고, 트랜잭션2가 데이터를 write 한 후, 트랜잭션1이 다시 동일한 데이터를 read 할 경우에 발생 <br></p>\n<p><strong>문제</strong>: 트랜잭션이 1이 동일한 read를 했음에도 불구하고 바뀐 데이터를 읽음 <br></p>\n</li>\n<li>\n<p><strong>Phantom Read</strong></p>\n<p><strong>상황</strong>: 트랜잭션1이 데이터(범위)를 read하고, 트랜잭션 2가 데이터를 추가(insert) 했는데, 트랜잭션1이 다시 데이터를 read한 경우 <br></p>\n<p><strong>문제</strong>: 동일한 read를 실행하였는데, 이전에 없었던 값이 추가됨 <br></p>\n</li>\n</ul>\n</li>\n<li>\n<p>두개의 트랜잭션이 모두 wrtie인 경우 (<strong>Currency Control</strong>로 해결)</p>\n<ul>\n<li>\n<p><strong>Lost Update</strong></p>\n<p><strong>상황</strong>: 두개의 트랜잭션이 한 개의 데이터를 동시에 update 할 때 발생 <br></p>\n<p><strong>문제</strong>: 하나의 트랜잭션의 내용을 다른 트랜잭션이 덮어씀으로 이전에 update 한 내용이 손실됨 <br></p>\n</li>\n<li>\n<p><strong>Inconsistency(or Unrecoverability)</strong></p>\n<p><strong>상황</strong>: 한 트랜잭션(T1)이 두개의 일관된 값을 읽어야하는데 다른 트랜잭션(T2)이 그 사이에 실행될 때 발생 <br></p>\n<p><strong>문제</strong>: <code class=\"language-text\">T1</code>이 두개의 값 <code class=\"language-text\">X</code>, <code class=\"language-text\">Y</code>를 읽어 수정할 때, <code class=\"language-text\">T1</code>이 <code class=\"language-text\">X</code>만 읽어서 수정한 상태에서 <code class=\"language-text\">T2</code>가 <code class=\"language-text\">X</code>와 <code class=\"language-text\">Y</code>를 수정하고 이후에 <code class=\"language-text\">T1</code>이 <code class=\"language-text\">Y</code>를 읽어 수정함. 이때 <code class=\"language-text\">T1</code>의 입장에서 하나는 갱신 이전의 값, 또 하나는 갱신 이후의 값을 읽어서 데이터가 불일치한 모순이 일어남. <br></p>\n</li>\n<li>\n<p><strong>Cascading Rollback</strong></p>\n<p><strong>상황</strong>: 한 트랜잭션(T1)이 두개의 값을 읽고 수정하는 사이에 다른 트랜잭션(T2)이 완료되었지만 T1이 rollback 되어야 할 때 발생<br></p>\n<p><strong>문제</strong>: <code class=\"language-text\">T1</code>이 두개의 값 <code class=\"language-text\">X</code>, <code class=\"language-text\">Y</code>를 읽어서 수정할 때, <code class=\"language-text\">T1</code>이 <code class=\"language-text\">X</code>를 수정한 상태에서 <code class=\"language-text\">T2</code>가 <code class=\"language-text\">X</code>를 수정하고 해당 트랜잭션을 완료함. 이후 <code class=\"language-text\">T1</code>에서 오류가 발생해 rollback이 되어야하는 상황에서 <code class=\"language-text\">T2</code>는 이미 완료되었으므로 <code class=\"language-text\">X</code> 값에 대한 rollback이 되지 못하여 문제가 발생함. <br></p>\n</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"트랜잭션-스케줄\" style=\"position:relative;\"><a href=\"#%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EC%8A%A4%EC%BC%80%EC%A4%84\" aria-label=\"트랜잭션 스케줄 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>트랜잭션 스케줄</h2>\n<p>위 문제를 해결하기 위해서 트랜잭션 스케줄을 통해 연산들의 실행 순서를 제어하여 데이터에 오류가 없도록 해야한다. </p>\n<ol>\n<li>\n<p>Serial Schedule 직렬 스케줄 </p>\n<p>모든 트랜잭션이 순차적으로 실행</p>\n</li>\n<li>\n<p>Nonsercial Schedule 비직렬 스케줄</p>\n<p>트랜잭션이 상관없이 병행하여 실행</p>\n</li>\n<li>\n<p>Serializable Schedule 직렬 가능 스케줄</p>\n<p>서로 영향을 주지 않는 스케줄의 경우 병행 실행하고, 나머지는 실행 순서를 제어하여 실행</p>\n</li>\n</ol>\n<p>직렬 스케줄의 경우 오류가 생기지 않도록 보장할 수는 있지만, 효율이 떨어진다는 단점이 있다. 따라서 트랜잭션을 최대한 직렬 가능한 스케줄로 만드는 것이 중요하고 <strong>Locking</strong> 기법을 통해서 트랜잭션 실행 순서를 제어해 직렬 가능한 스케줄로 만들어 데이터에 생길 수 있는 오류를 제어한다. <br></p>\n<p>예를 들어, 두개의 트랜잭션이 모두 READ 연산을 한다면 연산 순서가 중요하지 않으므로 병행 실행한다. <br></p>\n<p>또 두개의 트랜잭션이 다른 데이터에 접근한다면 연산 순서가 중요하지 않으므로 병행 실행한다. <br></p>\n<p>만일 한 데이터에 대해서 읽고 쓰는 작업이 한꺼번에 발생한다면 실행순서가 중요하므로 Lock을 통해서 그 순서를 제어한다. <br></p>\n<br>\n<h2 id=\"locking-기법\" style=\"position:relative;\"><a href=\"#locking-%EA%B8%B0%EB%B2%95\" aria-label=\"locking 기법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Locking 기법</h2>\n<p>여러 트랜잭션이 동일한 데이터에 대해서 병행 접근을 하지 못하도록 제어해서 데이터간 문제가 발생하지 않도록 하는 기법 </p>\n<ul>\n<li>\n<p>Shared-lock 공유락</p>\n<p>읽기를 할 때 거는 lock <br></p>\n<p>read 트랜잭션은 서로 영향을 주지 않으므로 shared-lock이 걸린 상태에서 추가 shared-lock을 걸 수 있음 <br></p>\n<p>read 트랜잭션 중 쓰기가 발생할 경우 데이터가 손상되어 문제가 발생하므로 추가 exclusive-lock은 걸 수 없음 <br></p>\n</li>\n<li>\n<p>Exclusive-lock 베타락</p>\n<p>읽고 쓰기를 할 때 거는 lock <br></p>\n<p>write 트랜잭션은 읽거나 쓰는 트랜잭션 모두에게 영향을 주기 때문에 exclusive-lock이 걸린 상태에서는 다른 lock을 걸 수 없음 <br></p>\n</li>\n</ul>\n<h3 id=\"2단계-로킹-규약-2plp\" style=\"position:relative;\"><a href=\"#2%EB%8B%A8%EA%B3%84-%EB%A1%9C%ED%82%B9-%EA%B7%9C%EC%95%BD-2plp\" aria-label=\"2단계 로킹 규약 2plp permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2단계 로킹 규약 2PLP</h3>\n<p>lock을 걸고 해제할 때 제한을 두어서 두 트랜잭션이 동시 실행되면서 생기는 데이터 일관성이 깨지는 현상을 방지하는 것이다. 로킹 단계를 2가지로 구분 지어서, 각 단계에 다른 제한을 두어 트랜잭션 동시 실행으로 발생할만한 데이터 오류를 방지한다. </p>\n<ul>\n<li>\n<p>Growing Phase 확장 단계</p>\n<p>해당 트랜잭션이 새로운 Lock 연산은 가능하나 unlock 연산을 가능하지 않은 상태</p>\n</li>\n<li>\n<p>Shrinking Phase 축소 단계</p>\n<p>해당 트랜잭션이 unlock 연산만 가능하고 lock 연산은 가능하지 않은 상태 </p>\n</li>\n</ul>\n<p>하지만 2PLP을 준수하므로 <strong>deadlock</strong>이 발생할 여지가 있다. <br></p>\n<p>→ 2단계 로킹 규약을 적용하지 않아서 데이터의 일관성이 깨진 경우 <br></p>\n<p align=\"center\"><img width=\"85%\" src=\"https://user-images.githubusercontent.com/63405904/135496848-c9c42362-63c5-493f-a2e9-fcd05f5cf6c6.png\"></p>\n<p>→ 2단계 로킹 기법을 사용하여 일관성 문제 해결한 경우 <br></p>\n<p align=\"center\"><img width=\"85%\" src=\"https://user-images.githubusercontent.com/63405904/135496984-e425dd70-3f11-4718-a42e-28513c3452bb.png\"></p>\n<h3 id=\"deadlock-데드락-교착상태\" style=\"position:relative;\"><a href=\"#deadlock-%EB%8D%B0%EB%93%9C%EB%9D%BD-%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9C\" aria-label=\"deadlock 데드락 교착상태 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Deadlock 데드락 (교착상태)</h3>\n<p>두개의 트랜잭션이 각자의 데이터에 lock을 걸어놓고 상대의 데이터에 요청을 하므로 무한 대기 상태에 빠지게 되는 문제 </p>\n<br>\n<h2 id=\"트랜잭션-isolation-level\" style=\"position:relative;\"><a href=\"#%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-isolation-level\" aria-label=\"트랜잭션 isolation level permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>트랜잭션 Isolation Level</h2>\n<ul>\n<li>\n<p><strong>READ UNCOMMITTED (LEVEL 0)</strong></p>\n<p>데이터를 읽을 때 shared-lock을 걸지 않고, write 작업 시 exclusive-lock만 거는 것(갱신손실문제 방지) <br></p>\n<p>다른 트랜잭션에 shared-lock/exclusive-lock이 걸렸더라도 데이터를 대기하지 않고 읽는 것<br></p>\n<p>따라서 Dirty read, non-repeatable read, phantom read 모두 방지할 수 없다.<br></p>\n</li>\n<li>\n<p><strong>READ COMMITED (LEVEL 1)</strong></p>\n<p>데이터를 읽을 때 shared-lock을 걸지만, 트랜잭션이 끝나기 전에도 unlock 가능<br></p>\n<p>다른 트랜잭션에 shared-lock이 걸렸다면 데이터를 읽지만, exclusive-lock이 걸린 경우에는 읽지 못함<br></p>\n<p>Dirty read 방지 가능, non-repeatable read, phantom read 방지 불가능<br></p>\n</li>\n<li>\n<p><strong>REPEATABLE READ (LEVEL 2)</strong></p>\n<p>본 데이터에 설정된 shared-lock과 exclusive-lock을 트랜잭션 종료시까지 유지<br></p>\n<p>트랜잭션이 완료될 때까지 SELECT문이 사용하는 모든 데이터에 대해서 shared-lock이 걸린다. 따라서 update가 불가능하지만, insert에 대해서는 다른 제약이 없다.<br></p>\n<p>다른 트랜잭션이 공유한 공유락은 읽고, 배타락은 읽지 않음<br></p>\n<p>다른 isolation level에 비해서 동시성이 낮아 잘 사용하지 않는 것을 추천<br></p>\n<p>Dirty read, non-repeatable read 방지, phantom read 방지 불가능<br></p>\n</li>\n<li>\n<p><strong>SERIALIZABLE (LEVEL 3)</strong></p>\n<p>데이터의 집합 범위에 잠금을 설정함<br></p>\n<p>다른 사용자가 데이터를 update 혹은 insert 할 때 모두 트랜잭션을 격리함<br></p>\n<p>트랜잭션이 완료될 때까지 SELECT문이 사용하는 모든 데이터에 대해서 shared-lock이 걸린다.<br></p>\n<p><strong>인덱스에 공유락을 설정</strong>한다. 따라서 다른 트랜잭션의 insert가 불가능<br></p>\n<p>Dirty read, non-repeatable read, phantom read 방지 <br></p>\n</li>\n</ul>\n<br>\n<br>\n<p><strong>[참고링크]</strong></p>\n<ul>\n<li><a href=\"https://mangkyu.tistory.com/30\">https://mangkyu.tistory.com/30</a></li>\n<li><a href=\"https://medium.com/pocs/%EB%8F%99%EC%8B%9C%EC%84%B1-%EC%A0%9C%EC%96%B4-%EA%B8%B0%EB%B2%95-%EC%9E%A0%EA%B8%88-locking-%EA%B8%B0%EB%B2%95-319bd0e6a68a\">https://medium.com/pocs/동시성-제어-기법-잠금-locking-기법-319bd0e6a68a</a></li>\n<li><a href=\"https://goodmilktea.tistory.com/62\">https://goodmilktea.tistory.com/62</a>## 동시성 문제 발생 가능 상황</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#%EB%8F%99%EC%8B%9C%EC%84%B1-%EB%AC%B8%EC%A0%9C-%EB%B0%9C%EC%83%9D-%EA%B0%80%EB%8A%A5-%EC%83%81%ED%99%A9\">동시성 문제 발생 가능 상황</a></li>\n<li><a href=\"#%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EC%8A%A4%EC%BC%80%EC%A4%84\">트랜잭션 스케줄</a></li>\n<li>\n<p><a href=\"#locking-%EA%B8%B0%EB%B2%95\">Locking 기법</a></p>\n<ul>\n<li><a href=\"#2%EB%8B%A8%EA%B3%84-%EB%A1%9C%ED%82%B9-%EA%B7%9C%EC%95%BD-2plp\">2단계 로킹 규약 2PLP</a></li>\n<li><a href=\"#deadlock-%EB%8D%B0%EB%93%9C%EB%9D%BD-%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9C\">Deadlock 데드락 (교착상태)</a></li>\n</ul>\n</li>\n<li><a href=\"#%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-isolation-level\">트랜잭션 Isolation Level</a></li>\n</ul>\n</div>","frontmatter":{"date":"July 01, 2021","title":"Transaction의 동시성 제어(Currency Control)","categories":"데이터베이스","author":"코다","emoji":"💾"},"fields":{"slug":"/database-transaction-currency-control/"}},"site":{"siteMetadata":{"siteUrl":"https://yjksw.github.io","comments":{"utterances":{"repo":"yjksw/yjksw.github.io"}}}}},"pageContext":{"slug":"/spring-spring-web-application-architecture/","nextSlug":"/handler-method-argument-resolver/","prevSlug":"/database-transaction-currency-control/"}},"staticQueryHashes":["1073350324","2938748437"]}
{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/stream-vs-collection/",
    "result": {"data":{"cur":{"id":"c6060cb1-1a69-5cc5-8508-1df3c8357b5f","html":"<p>요약하자면 Stream과 Collection의 차이는 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token number\">1.</span> 스트림은 요소를 보관하지 않고 필요할 때 생성되거나 하위 <span class=\"token class-name\">Collection</span>에 보관한다<span class=\"token punctuation\">.</span> \n<span class=\"token number\">2.</span> 스트림은 원본을 변경하기보다 새로운 스트림을 생성하여 반환한다<span class=\"token punctuation\">.</span> \n<span class=\"token number\">3.</span> 스트림 연산은 lazy operation이다<span class=\"token punctuation\">.</span> <span class=\"token punctuation\">(</span>따라서 무한 스트림도 가능한 것이다<span class=\"token punctuation\">)</span></code></pre></div>\n<p>개념적으로 접근했을 때 Collection의 경우에는 어떠한 데이터를 담는 자료구조의 역할을 주로 하지만, Stream의 경우는 연산과 관련된 것이 주라고 볼 수 있다.</p>\n<ul>\n<li>\n<p>Quote</p>\n<p>Java <em>Collection</em>s offer efficient mechanisms to store and process the data by providing data structures like <em><a href=\"https://drafts.baeldung.com/java-linkedlist\">List</a></em>, <em><a href=\"https://drafts.baeldung.com/java-hashset\">Set</a></em>, and <em><a href=\"https://drafts.baeldung.com/java-hashmap\">Map</a></em>.</p>\n<p>However, the Stream API is useful for performing various operations on the data without the need for intermediate storage.</p>\n<p>출처: <a href=\"https://www.baeldung.com/java-return-stream-collection\">https://www.baeldung.com/java-return-stream-collection</a></p>\n</li>\n</ul>\n<h3 id=\"traversal\" style=\"position:relative;\"><a href=\"#traversal\" aria-label=\"traversal permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Traversal</h3>\n<p>Collection은 여러번 데이터를 횡단할 수 있지만, Stream은 한번만 가능하며 source로부터 새로운 Stream을 추출해야 새롭게 traverse 할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">Stream</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> numbers <span class=\"token operator\">=</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">;</span>\nnumbers<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//error 없음</span>\nnumbers<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//error 발생</span></code></pre></div>\n<h3 id=\"lazy-operation\" style=\"position:relative;\"><a href=\"#lazy-operation\" aria-label=\"lazy operation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Lazy Operation</h3>\n<p>Collection은 요소를 보관하기 때문에 해당 Collection에 어떠한 요소가 추가되기 전에 operation을 우선 실행해야한다. <br></p>\n<p>하지만 Stream은 lazy하기 연산을 하기 때문에 우선 Stream에 담겨진 요소들에 대해서 선실행을 하지 않는다. 이후에 필요할 때 요소를 꺼내오고 연산을 하도록 한다. 또한 Stream은 불변이므로 요소를 추가하거나 삭제할 수 없다.</p>\n<h3 id=\"외부반복-vs-내부반복\" style=\"position:relative;\"><a href=\"#%EC%99%B8%EB%B6%80%EB%B0%98%EB%B3%B5-vs-%EB%82%B4%EB%B6%80%EB%B0%98%EB%B3%B5\" aria-label=\"외부반복 vs 내부반복 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>외부반복 vs. 내부반복</h3>\n<p>외부에서 값을 꺼내서 반복해야하는 Collection과 다르게 Stream은 내부적으로 알아서 반복문을 돌면서 명령한 연산을 수행한다. <br></p>\n<p>내부 반복을 했을 경우 1) 반복자를 사용하여 명시적으로 표시할 필요가 없고 2) 병렬처리시 스레드간 공유자원에 대한 관리를 할 필요가 없다.</p>\n<h3 id=\"유연성\" style=\"position:relative;\"><a href=\"#%EC%9C%A0%EC%97%B0%EC%84%B1\" aria-label=\"유연성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>유연성</h3>\n<p>Stream은 여러 operation의 조합으로 유연하게 데이터 연산이 가능한 장점이 있다. 어떤 특정 result set을 도출해서 consumer에게 넘겨줄 필요 없이 필요한 연산을 조합하여 바로바로 처리할 수 있다.</p>\n<h3 id=\"functional-behavior\" style=\"position:relative;\"><a href=\"#functional-behavior\" aria-label=\"functional behavior permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Functional Behavior</h3>\n<p>Stream은 functional 하기 때문에 기존 데이터를 변경시키지 않는다. 따라서 result set도 immutable (연산 중에) 하기 때문에 병렬 처리에 강하다. <br></p>\n<br>\n<p>참고 링크:</p>\n<ul>\n<li><a href=\"https://bk-investing.tistory.com/42\">https://bk-investing.tistory.com/42</a></li>\n<li><a href=\"https://javaconceptoftheday.com/collections-and-streams-in-java/#:~:text=Difference%20Between%20Collections%20Vs%20Streams%20In%20Java%20%3A&#x26;text=Collections%20are%20mainly%20used%20to%20store%20and%20group%20the%20data,or%20remove%20elements%20from%20streams\">https://javaconceptoftheday.com/collections-and-streams-in-java/#:~:text=Difference Between Collections Vs Streams In Java %3A&#x26;text=Collections are mainly used to store and group the data,or remove elements from streams</a>.</li>\n<li><a href=\"https://www.baeldung.com/java-return-stream-collection\">https://www.baeldung.com/java-return-stream-collection</a></li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#traversal\">Traversal</a></li>\n<li><a href=\"#lazy-operation\">Lazy Operation</a></li>\n<li><a href=\"#%EC%99%B8%EB%B6%80%EB%B0%98%EB%B3%B5-vs-%EB%82%B4%EB%B6%80%EB%B0%98%EB%B3%B5\">외부반복 vs. 내부반복</a></li>\n<li><a href=\"#%EC%9C%A0%EC%97%B0%EC%84%B1\">유연성</a></li>\n<li><a href=\"#functional-behavior\">Functional Behavior</a></li>\n</ul>\n</div>","excerpt":"요약하자면 Stream과 Collection의 차이는 다음과 같다. 개념적으로 접근했을 때 Collection의 경우에는 어떠한 데이터를 담는 자료구조의 역할을 주로 하지만, Stream의 경우는 연산과 관련된 것이 주라고 볼 수 있다. Quote Java Collections offer efficient mechanisms to store and process the data by providing data structures like List, Set, and Map. However, the Stream API is useful for performing various operations on the data without the need for intermediate storage. 출처: https://www.baeldung.com/java-return-stream-collection Traversal Collection은 여러번 데이터를 횡단할 수 있지만, Stream은 …","frontmatter":{"date":"March 20, 2021","title":"Stream vs. Collection","categories":"자바","author":"코다","emoji":"✊"},"fields":{"slug":"/stream-vs-collection/"}},"next":{"id":"20c3cda7-77dd-5c04-b4a8-7982cb496eaa","html":"<ul>\n<li>이것은 정답이 아니라 한 블로그에 기술된 하나의 의견이다. 읽어보고 신선한 접근이라고 생각해서 정리해둔다. <a href=\"%5Bhttps://changelog.com/posts/you-might-as-well-timestamp-it%5D(https://changelog.com/posts/you-might-as-well-timestamp-it)\">링크</a></li>\n</ul>\n<p>데이터베이스에서 boolean 값을 지정해서 저장해야하는 경우들이 있다. <code class=\"language-text\">is_published</code>, <code class=\"language-text\">is_signed</code>, <code class=\"language-text\">is_finished</code> 등등을 기록해야하는 경우들이다. 이 경우에 boolean으로 저장하지 말고 timestamp로 저장하도록 해보자! 글쓴이의 말을 인용하자면 “단 한번도 후회한적이 없다”. <br></p>\n<p>Boolean 값으로 저장할만한 데이터는 언제 해당 데이터가 set 되었는지에 대한 timestamp를 제공함으로 잃는 것이 없다. 아무리 해당 시간 데이터가 필요하지 않더라도 말이다. 이렇게 구현을 하게 된다면 <code class=\"language-text\">null</code> 은 <code class=\"language-text\">false</code>로 <code class=\"language-text\">non-null</code>은 <code class=\"language-text\">true</code>로 간주되어 처리하면 될 것이다. <br></p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token comment\">//boolean 사용</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>is_finished<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">//timestamp 사용</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>finished_at<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>따라서 자연스럽게 <code class=\"language-text\">deleted_at</code>, <code class=\"language-text\">hidden_at</code>, <code class=\"language-text\">signed_in_at</code> 등등으로 변환될 것이다.</p>\n<h3 id=\"의견\" style=\"position:relative;\"><a href=\"#%EC%9D%98%EA%B2%AC\" aria-label=\"의견 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>의견</h3>\n<p>글쓴이의 말이 일리가 있다. 큰 구현의 차이나 처리의 차이 없이 동일한 연산을 수행할 수 있고, 더 많은 정보를 제공하는 이점이 있다. <br></p>\n<p>하지만 해당 데이터가 <code class=\"language-text\">null</code>로 지정이 되어 있는 시점이 있다는 것이 해당 코드를 취약하게 만들 수도 있을 것 같다. <br></p>\n<p>이 부분에 대한 다른 크루들의 생각을 첨부! <br></p>\n<p align=\"center\"><img width=\"90%\" alt=\"_2021-04-25__7 01 27\" src=\"https://user-images.githubusercontent.com/63405904/134771368-791c2734-8e0e-49e4-9b58-b9608036c69f.png\"></p>","frontmatter":{"date":"March 17, 2021","title":"Boolean 대신 timestamp","categories":"설계","author":"코다","emoji":"🛠"},"fields":{"slug":"/boolean-timestamp/"}},"prev":{"id":"b0ca772e-1b48-53f1-8a7f-24d1a8ffe267","html":"<p>이번에 스프링 체스 자바 웹 어플리케이션을 사용하여 구현하면서 처음에는 모두 <code class=\"language-text\">@RequestParam</code> 으로 데이터를 가져왔었다. 하지만 인자가 너무 많아지는 경우 메서드에 파라미터가 많아지면서 가독성이 안 좋아졌다. 또한 DTO에 해당 데이터를 담아서 서비스 레이어에 전달해야하거나 할 때 일일이 데이터를 DTO에 담아서 가공해야 하는 작업을 해야하기도 했다. 코드를 구현할 때 손가락이 아프다면 수정할 부분을 찾으라고 했었는데 확실히 <code class=\"language-text\">@RequestParam</code>으로 받는 것은 손가락이 아팠다. <br></p>\n<p>아니나 다를까 리뷰어가 @ModelAttribute를 사용하는 걸 추천했다. 마침 레벨1 제이슨 톡방에서도 @ModelAttribute 에 대한 논의가 활발하길래 공부도 하고 코드에 적용을 하며 배운 것을 기록해본다.</p>\n<h2 id=\"modelattribute-vs-requestbody\" style=\"position:relative;\"><a href=\"#modelattribute-vs-requestbody\" aria-label=\"modelattribute vs requestbody permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>@ModelAttribute vs. @RequestBody</h2>\n<p>간단하게 말하면 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token number\">1.</span> <span class=\"token annotation punctuation\">@ModelAttribute</span>은 form data로 오는 데이터를 저장한다<span class=\"token punctuation\">.</span> \n<span class=\"token number\">2.</span> <span class=\"token annotation punctuation\">@RequestBody</span>는 JSON<span class=\"token operator\">/</span>xml 타입으로 오는 body에 담긴 데이터를 저장한다<span class=\"token punctuation\">.</span></code></pre></div>\n<p><code class=\"language-text\">@ModelAttribute</code> 같은 경우는 parameter 값으로 DTO에 바인딩한다. 따라서 해당 DTO 객체에 <code class=\"language-text\">setter</code> 메소드가 반드시 있어야 한다. 따라서 타입에 대한 검증을 한 후에 setting을 한다.</p>\n<p><code class=\"language-text\">@RequestBody</code>의 경우는 본문 body에 있는 Json/xml 타입을 바인딩하기 때문에 <code class=\"language-text\">HttpMessageReader</code>를 통해서 <code class=\"language-text\">ObjectMapper</code>를 한다.</p>\n<p>여기서 <code class=\"language-text\">HttpMessageReader</code>는 들어온 request body의 데이터값을 Java object로 역직렬화 해준다. 이때 역직렬화는 <code class=\"language-text\">ObjectMapper</code>의 <code class=\"language-text\">readValue()</code> 메서드로 변환하므로 setter가 필요가 없다. (단, 기본 생성자의 경우는 필요한 경우가 많다)</p>\n<h2 id=\"사용예시\" style=\"position:relative;\"><a href=\"#%EC%82%AC%EC%9A%A9%EC%98%88%EC%8B%9C\" aria-label=\"사용예시 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>사용예시</h2>\n<ul>\n<li>\n<p>form 데이터로 넘어오는 경우 @ModelAttribute를 사용해서 바인딩한다. 여기서 @RequestBody를 쓰면 에러가 발생한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@PostMapping</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/white-game\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">whiteStart</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Model</span> model<span class=\"token punctuation\">,</span> <span class=\"token class-name\">HttpSession</span> session<span class=\"token punctuation\">,</span> <span class=\"token annotation punctuation\">@ModelAttribute</span> <span class=\"token class-name\">RoomInfoRequestDto</span> roomInfoRequestDto<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">String</span> room <span class=\"token operator\">=</span> roomInfoRequestDto<span class=\"token punctuation\">.</span><span class=\"token function\">getRoomName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">String</span> password <span class=\"token operator\">=</span> roomInfoRequestDto<span class=\"token punctuation\">.</span><span class=\"token function\">getPassword</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        model<span class=\"token punctuation\">.</span><span class=\"token function\">addAttribute</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"room\"</span><span class=\"token punctuation\">,</span> room<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        session<span class=\"token punctuation\">.</span><span class=\"token function\">setAttribute</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"password\"</span><span class=\"token punctuation\">,</span> password<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">return</span> <span class=\"token string\">\"game\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n<li>\n<p>아래의 경우 js에서 데이터를 보내줄 content-type을 지정하지 않았을 때 오류가 났다. 이후에 @RequestBody는 json 타입을 받기 때문에 <code class=\"language-text\">Content-type</code>을  <code class=\"language-text\">application/json</code>으로 지정하니 잘 바인딩이 되었다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@PutMapping</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/game\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">MoveResponseDto</span> <span class=\"token function\">move</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">HttpSession</span> session<span class=\"token punctuation\">,</span> <span class=\"token annotation punctuation\">@RequestBody</span> <span class=\"token class-name\">MoveRequestDto</span> moveRequestDto<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">String</span> password <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">)</span> session<span class=\"token punctuation\">.</span><span class=\"token function\">getAttribute</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"password\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> chessService<span class=\"token punctuation\">.</span><span class=\"token function\">move</span><span class=\"token punctuation\">(</span>moveRequestDto<span class=\"token punctuation\">,</span> password<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n<li>\n<p>번외로, 서버로 내보내는 content-type에서 json을 지정하고 싶을 경우 <code class=\"language-text\">Content-type : 'application/json'</code> 으로 지정하고 서버에서 받는 데이터의 경우 <code class=\"language-text\">Data-type : 'json'</code> 으로 지정해야 한다. (중요한 이유는 없고 그냥 설정이 그렇게 되어 있음)</p>\n</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#modelattribute-vs-requestbody\">@ModelAttribute vs. @RequestBody</a></li>\n<li><a href=\"#%EC%82%AC%EC%9A%A9%EC%98%88%EC%8B%9C\">사용예시</a></li>\n</ul>\n</div>","frontmatter":{"date":"March 25, 2021","title":"@ModelAttribute vs. @RequestBody","categories":"스프링부트","author":"코다","emoji":"🖥"},"fields":{"slug":"/model-attribute-request-body/"}},"site":{"siteMetadata":{"siteUrl":"https://yjksw.github.io","comments":{"utterances":{"repo":"yjksw/yjksw.github.io"}}}}},"pageContext":{"slug":"/stream-vs-collection/","nextSlug":"/boolean-timestamp/","prevSlug":"/model-attribute-request-body/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}
{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/dispatcher-servlet/",
    "result": {"data":{"cur":{"id":"bba3b50e-5ef0-5460-b0ea-d503ef9f2aac","html":"<h2 id=\"servlet-개념-및-구조\" style=\"position:relative;\"><a href=\"#servlet-%EA%B0%9C%EB%85%90-%EB%B0%8F-%EA%B5%AC%EC%A1%B0\" aria-label=\"servlet 개념 및 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Servlet 개념 및 구조</h2>\n<p>Servlet은 <strong>웹 서버</strong>를 구현한 <strong>자바</strong>의 프로그램이며 <strong>interface</strong>이다. 서블릿이 하는 일은 다음과 같다. Servlet은 웹 클라이언트로부터 요청을 받아서 응답을 반환한다.</p>\n<p>Servlet 인터페이스는 servlet을 초기화하고, 서비스를 요청하고, servlet을 서버에서 제거하는 메소드를 제공한다. (이걸 life-cycle 메소드라고 말한다)</p>\n<ol>\n<li><code class=\"language-text\">init</code> 메소드를 통해서 서블릿이 구축된다.</li>\n<li>클라이언트에서 호출된 <code class=\"language-text\">service</code> 메소드가 수행된다.</li>\n<li>수행된 서블릿이 <code class=\"language-text\">service</code>에서 제거되고 <code class=\"language-text\">destroy</code> 메소드를 통해서 소멸된다.</li>\n</ol>\n<p>추가로 Servlet 초기세팅 정보를 <code class=\"language-text\">ServletConfig</code> 에 담아서 반환하는 <code class=\"language-text\">getServletConfig()</code> 와, Servlet 정보를 반환하는 <code class=\"language-text\">getServletInfo()</code> 메소드도 존재한다.</p>\n<h3 id=\"httpservlet-구조\" style=\"position:relative;\"><a href=\"#httpservlet-%EA%B5%AC%EC%A1%B0\" aria-label=\"httpservlet 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>HttpServlet 구조</h3>\n<ul>\n<li><code class=\"language-text\">GenericServlet</code>을 확장하고 <code class=\"language-text\">Servlet</code> 인터페이스를 구현한다.</li>\n<li>웹 환경에 최적화되어 있어서 HTTP 메소드를 지원한다. 즉, HttpServlet 에서는 <code class=\"language-text\">service()</code> 를 override 할 이유가 거의 없다. 왜냐햐면 이미 정의되어 있는 Http 요청들을 수행하도록 되어 있기 때문이다.</li>\n</ul>\n<p align=\"center\"><img width=\"85%\" src=\"https://user-images.githubusercontent.com/63405904/135119857-ab8335e6-7bbf-409f-9213-76beb4941e03.png\"></p>\n<h3 id=\"servlet-동작방식\" style=\"position:relative;\"><a href=\"#servlet-%EB%8F%99%EC%9E%91%EB%B0%A9%EC%8B%9D\" aria-label=\"servlet 동작방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Servlet 동작방식</h3>\n<ol>\n<li>브라우저에서 URL을 입력해서 request를 Servlet Container 로 전송</li>\n<li>Servlet Container에서 <code class=\"language-text\">HttpServletRequest</code>, <code class=\"language-text\">HttpServletResponse</code> 객체 생성</li>\n<li><code class=\"language-text\">xml</code>에 기입된 정보를 통해서 해당 URL과 매칭되는 서블릿을 검색</li>\n<li>해당 서블릿의 service를 호출하여 처리</li>\n<li>해당 서블릿의 service 내의 메소드에서 처리하고 동적 페이지를 생성하여 <code class=\"language-text\">HttpServletResponse</code> 에 응답을 담아서 전송</li>\n<li>모든 처리가 끝난 후 <code class=\"language-text\">HttpServletRequest</code>, <code class=\"language-text\">HttpServletResponse</code> 소멸</li>\n</ol>\n<br>\n<h2 id=\"servlet-container\" style=\"position:relative;\"><a href=\"#servlet-container\" aria-label=\"servlet container permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Servlet Container</h2>\n<p>서블릿을 관리하기 위해서는 서블릿 컨테이너가 필요하다. <br></p>\n<p>톰캣(Tomcat)과 같이 클라이언트의 요청을 받아서 정의된 서블릿을 수행하고, 응답을 할 수 있도록 웹 서버와 소켓 통신을 관리한다. <br></p>\n<p>본래 클라이언트와 웹서버만 통신했을 때에는 정적 페이지만 전송할 수 이기때문에 비효율적이다. 따라서 동적으로 웹 페이지를 서버에서 만들어서 전송할 수 있도록 하는 것이 servlet container이다. 웹 서버에서 클라이언트와 서블릿이 소통할 수 있도록하는 일부분이다. <br></p>\n<p>웹 서버는 http 요청을 받은 경우 servlet container로 해당 요청을 포워딩한다. 이때 부터 서블릿 컨테이너가 요청을 받아서 생명주기에 맞게 핸들링 한다. <br></p>\n<h3 id=\"역할\" style=\"position:relative;\"><a href=\"#%EC%97%AD%ED%95%A0\" aria-label=\"역할 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>역할</h3>\n<ol>\n<li>\n<p>통신 지원 (웹 서버 ↔  소켓)</p>\n<p>서버와 소켓 통신을 하기 위해서는 소켓 생성 및 listen, accept 등의 일을 해야하지만 해당 과정은 복잡하고 동일하게 반복해야하는 부분이다. 따라서 서블릿 컨테이너는 해당 일과 관련된 기능을 API로 제공**(?)** 해줘서 관리하게 해준다. 즉, 비지니스 로직에만 집중할 수 있도록 지원한다.</p>\n</li>\n<li>\n<p>서블릿 생명주기 관리</p>\n<p>서블릿의 탄생 및 죽음을 관리한다.</p>\n<p>즉, 요청이 들어왔을 때, 해당되는 서블릿 클래스를 인스턴스화(<code class=\"language-text\">HttpServletRequest</code>, <code class=\"language-text\">HttpServletResponse</code> 등등) 하고, 서비스 메소드 호출, 처리 후 GC를 진행한다.</p>\n</li>\n<li>\n<p>멀티 스레드 지원 및 관리</p>\n<p>하나의 서블릿 요청 당 하나의 자바 스레드가 생성된다. 서비스 메소드 실행 후 스레드는 소멸된다. 그리고 서버에서 다중 스레드를 관리해준다. (하나의 소켓 당 하나의 스레드가 할당되기 때문에? 그렇다면 소켓 관리를 톰캣이 한다는 것이기 때문에)</p>\n</li>\n<li>\n<p>선언적 보안 관리</p>\n<p>서블릿 컨테이너를 사용할 경우, 보안 내용을 xml에 기록하므로 서블릿이나 자바에 구현하지 않아도 된다.</p>\n</li>\n</ol>\n<h3 id=\"servlet-생명주기\" style=\"position:relative;\"><a href=\"#servlet-%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0\" aria-label=\"servlet 생명주기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Servlet 생명주기</h3>\n<p>간단하게 서블릿의 생명주기는 <code class=\"language-text\">init() → service() → destroy()</code> 로 진행된다.</p>\n<ul>\n<li>여기서 <code class=\"language-text\">init()</code>은 요청이 왔을 때, 서블릿이 메모리에 있는지 확인하고 없는 경우 <code class=\"language-text\">init()</code> 을 실행하고 처음에 한번만 실행한다. 서블릿 요청별로 새로운 스레드가 생성되기 때문에 해당 스레드간 공통적인 부분은 여기에 구현하는 것이 좋다.</li>\n<li>서블릿 컨테이너가 서블릿 종료 요청(<em><strong>종료 요청 시점은? 우선은 톰캣 종료 시점</strong></em>)을 할 때 호출되는 <code class=\"language-text\">destroy()</code> 도 마찬가지로 마지막에 한번만 실행된다.</li>\n</ul>\n<h3 id=\"servlet-과-jvm\" style=\"position:relative;\"><a href=\"#servlet-%EA%B3%BC-jvm\" aria-label=\"servlet 과 jvm permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Servlet 과 Jvm</h3>\n<p>Servlet을 사용하면 jvm에서 각각의 요청들을 각각의 자바 스레드에서 사용할 수 있도록 해준다. jvm에서 각각의 servlet은 하나의 자바 클래스이고, servlet에 요청이 들어오면 그것을 Jvm에서 처리해서 반환한다.</p>\n<br>\n<h2 id=\"dispatcher-servlet\" style=\"position:relative;\"><a href=\"#dispatcher-servlet\" aria-label=\"dispatcher servlet permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Dispatcher Servlet</h2>\n<p>디스패쳐 서블릿을 이해하려면 우선 front controller 패턴에 대한 이해가 있어야 한다. Front controller 패턴(<a href=\"https://www.geeksforgeeks.org/front-controller-design-pattern/\">https://www.geeksforgeeks.org/front-controller-design-pattern/</a>) 에 대해서 간단하게 설명하자면, front-controller는 들어오는 요청에 대해서 하나의 핸들러가 처리를 담당하고 그것을 처리할 수 있는 적합한 핸들러에게 dispatch 즉, 보내는 역할을 하도록 하는 디자인 패턴이다.</p>\n<h3 id=\"dispatcher-servlet-processing\" style=\"position:relative;\"><a href=\"#dispatcher-servlet-processing\" aria-label=\"dispatcher servlet processing permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Dispatcher servlet processing</h3>\n<ul>\n<li>여러 Web-context가 존재할 수 있기 때문에 우선 해당 DispatcherServlet에 해당되는 WebApplicatonContext 을 DispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE 를 키로 우선 검색한다.</li>\n<li><code class=\"language-text\">DispatcherServlet</code>은 <code class=\"language-text\">HandlerAdapter</code> 의 구현체를 <code class=\"language-text\">getHandle()</code> 을 통해서 구현체를 가져온다. 그래서 <code class=\"language-text\">handle()</code> 메서드를 통해서 해당 요청에 대해 처리할 것을 진행한다.</li>\n<li><strong>HandlerExceptionResolver -</strong>  WebapplicationContext 안에 선언되어 있는, 요청 처리 중 발생한 exceptions 들을 처리하는 resolver</li>\n</ul>\n<h3 id=\"handleradapter-interfaces\" style=\"position:relative;\"><a href=\"#handleradapter-interfaces\" aria-label=\"handleradapter interfaces permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>HandlerAdapter Interfaces</h3>\n<p>HandlerAdapter 인터페이스는 controller, servlets, HttpRequests를 관리하여 사용하게 한다. <br></p>\n<p>HandlerAdapter 구현체는 디스패처의 <code class=\"language-text\">getHandler()</code> 메서드를 통해서 <code class=\"language-text\">HandlerExecutionChain</code> 에 들어간다. 여기에 들어간 각각의 구현체들이 <code class=\"language-text\">handle()</code> 메서드를 통해서 <code class=\"language-text\">HttpServletRequest</code> 요청을 처리한다.</p>\n<ul>\n<li>\n<p><strong>Mapping</strong></p>\n<p>HandlerMapping 인터페이스는 컨트롤러와 밀접하게 연관이 되어 있다. 때문에 컨트롤러에 어떠한 annotation이 붙어있는지에 따라서 HandlerMapping을 다르게 동작한다.</p>\n<p><code class=\"language-text\">SimpleControllerHandlerAdapter</code> 의 경우에는 <code class=\"language-text\">@Controller</code> 어노테이션이 붙어있지 않은 컨트롤러의 경우에 동작할 수 있고, <code class=\"language-text\">RequestMappingHandler</code> 은 <code class=\"language-text\">@RequestMapping</code> 어노테이션이 붙은 메서드의 경우에만 적용할 수 있다.</p>\n<p><code class=\"language-text\">RequestMappingHandler</code>의 경우를 자세히 들여다보자. @RequestMapping 어노테이션은 해당 <code class=\"language-text\">WebApplicationContext</code> 내에서 handler가 가능한 지점을 알려준다. 그렇기 때문에 <code class=\"language-text\">@RequestMapping</code> 어노테이션에 서술되어 있는 path는 <code class=\"language-text\">HandlerMapping</code> 인터페이스에 의해서 관리된다. (URL 구조는 <code class=\"language-text\">DispatcherServlet</code>과 관련이 깊으며, servlet mapping에 직접 사용된다)</p>\n</li>\n<li>\n<p><strong>HTTP Request Handling</strong></p>\n<p>DispatcherServlet 의 핵심적인 책임 중 하나는 들어오는 HttpRequest를 알맞은  handler에 보내는(dispatch) 것이다. (여기서 <code class=\"language-text\">@Controller</code>, <code class=\"language-text\">@RestController</code> 어노테이션에 관련이 있다)</p>\n</li>\n<li>\n<p><strong>ViewResolver Interface</strong></p>\n<p><code class=\"language-text\">ViewResolver</code> 는 <code class=\"language-text\">DispatcherServlet</code>에서 <code class=\"language-text\">ApplicationContext</code>에 대한 환경설정을 담당한다. <br></p>\n<p><code class=\"language-text\">ViewResolver</code>는 <code class=\"language-text\">dispatcher</code>에 의해서 제공되는 view의 종류와 어디서 해당 view가 제공되는지 파악한다.  <br></p>\n<p><code class=\"language-text\">ViewResolver</code>가 실제적으로 수행하는 일은 다음과 같다.</p>\n<ol>\n<li>prefix 설정 : 적절한 view를 찾기위한 default URL 경로를 설정</li>\n<li>suffix 설정 : default view type을 설정하는 접미사 설정</li>\n<li>view class 설정 : 적절한 view 클래스를 resolver에 설정해서 렌더링이 필요한 기술을 제공받을 수 있도록 한다. (JSTL or Tiles)</li>\n</ol>\n</li>\n<li>\n<p><strong>LocaleResolver Interface</strong></p>\n<p>디스패처로 session, request, cookie information 등을 LocaleResolver로 커스텀 할 수 있다.</p>\n<ul>\n<li><code class=\"language-text\">CookieLocaleResolver</code>는 쿠키를 통해 stateless한 어플리케이션의 property를 설정할 수 있도록 한다.</li>\n<li><code class=\"language-text\">SessionLocalResolver</code>로 stateful한 어플리케이션의 session-specific  configuration을 설정할 수 있다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Bean</span> \n<span class=\"token keyword\">public</span> <span class=\"token class-name\">CookieLocaleResolver</span> <span class=\"token function\">cookieResolver</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token class-name\">CookieLocaleResolver</span> localeResolver\n\t\t<span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">CookieLocaleResolver</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\tlocaleResolver<span class=\"token punctuation\">.</span><span class=\"token function\">setDefaultLocale</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Locale</span><span class=\"token punctuation\">.</span>ENGLISH<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\tlocaleResolver<span class=\"token punctuation\">.</span><span class=\"token function\">setCookieName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"cookiename\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\tlocaleResolver<span class=\"token punctuation\">.</span><span class=\"token function\">setCookieMaxAge</span><span class=\"token punctuation\">(</span><span class=\"token number\">3600</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">return</span> localeResolver<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n<li>\n<p><strong>ThemeResolver &#x26; MultipartResolver 생략</strong></p>\n</li>\n<li>\n<p><strong>HandlerExceptionResolver</strong></p>\n<p>스프링의 <code class=\"language-text\">HandlerExceptionResolver</code>는 전체 웹 어플리케이션에 대해서 균일한 에러 핸들링을 가능하게 해준다. 어플리케이션 전역적으로 적용이 되는 커스텀 에러 핸들링을 구현하기 위해서는 <strong>@ControllerAdvice 어노테이션을 추가해서 구현하도록 한다.</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@ControllerAdvice</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ExampleGlobalExceptionHandler</span> <span class=\"token punctuation\">{</span>\n\t \n\t<span class=\"token annotation punctuation\">@ExceptionHandler</span>\n\t<span class=\"token annotation punctuation\">@ResponseBody</span>\n\t<span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">handleExampleException</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token comment\">//...</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이 경우 <code class=\"language-text\">@ExceptionHandler</code> 어노테이션이 추가된 클래스는 디스패쳐의 영역 안에 있는 모든 컨트롤러에 적용될 수 있다.</p>\n</li>\n</ul>\n<h3 id=\"spring-mvc-와-dispatcherservlet-동작방식\" style=\"position:relative;\"><a href=\"#spring-mvc-%EC%99%80-dispatcherservlet-%EB%8F%99%EC%9E%91%EB%B0%A9%EC%8B%9D\" aria-label=\"spring mvc 와 dispatcherservlet 동작방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Spring MVC 와 DispatcherServlet 동작방식</h3>\n<p align=\"center\"><img width=\"85%\" src=\"https://user-images.githubusercontent.com/63405904/135120169-742f3adf-be12-4f14-8d35-6c18c4115e06.png\"></p>\n<br>\n<br>\n<h3 id=\"파생-키워드-및-주제\" style=\"position:relative;\"><a href=\"#%ED%8C%8C%EC%83%9D-%ED%82%A4%EC%9B%8C%EB%93%9C-%EB%B0%8F-%EC%A3%BC%EC%A0%9C\" aria-label=\"파생 키워드 및 주제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>파생 키워드 및 주제</h3>\n<p><strong>⇒ 서블릿 컨테이너의 웹 서버와 통신 지원 방식 (Tomcat 내부구현 확인 필요)</strong></p>\n<p><strong>⇒ Front Controller desgin pattern (</strong><a href=\"https://www.geeksforgeeks.org/front-controller-design-pattern/\">https://www.geeksforgeeks.org/front-controller-design-pattern/</a>)</p>\n<p><strong>⇒ SimpleControllerHandlerAdapter 와 annotation이 붙지 않은 controller의 동작 방식</strong></p>\n<p><strong>⇒ SpringController 깊이 알기</strong> (<a href=\"https://www.baeldung.com/spring-controllers\">https://www.baeldung.com/spring-controllers</a>)</p>\n<p><strong>⇒ Spring의 error handling 깊이 알기</strong> (<a href=\"https://www.baeldung.com/exception-handling-for-rest-with-spring\">https://www.baeldung.com/exception-handling-for-rest-with-spring</a>)</p>\n<br>\n<h3 id=\"의문\" style=\"position:relative;\"><a href=\"#%EC%9D%98%EB%AC%B8\" aria-label=\"의문 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>의문</h3>\n<ul>\n<li><del>Spring MVC 의 DispatcherServlet의 동작방식에서 <strong>HandlerMapping</strong>과 <strong>HandlerAdapter</strong>의 차이</del></li>\n</ul>\n<br>\n<h3 id=\"참고링크\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0%EB%A7%81%ED%81%AC\" aria-label=\"참고링크 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고링크</h3>\n<ul>\n<li><a href=\"https://mangkyu.tistory.com/14\">https://mangkyu.tistory.com/14</a></li>\n<li><a href=\"https://dzone.com/articles/what-servlet-container\">https://dzone.com/articles/what-servlet-container</a></li>\n<li><a href=\"https://www.baeldung.com/spring-dispatcherservlet\">https://www.baeldung.com/spring-dispatcherservlet</a></li>\n<li><a href=\"https://velog.io/@ehdrms2034/%EC%8A%A4%ED%94%84%EB%A7%81-MVC-Dispatcher-Servlet%EC%9D%84-%EC%A7%81%EC%A0%91-%EA%B5%AC%ED%98%84%ED%95%B4%EB%B3%B4%EC%9E%90\">https://velog.io/@ehdrms2034/스프링-MVC-Dispatcher-Servlet을-직접-구현해보자</a></li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#servlet-%EA%B0%9C%EB%85%90-%EB%B0%8F-%EA%B5%AC%EC%A1%B0\">Servlet 개념 및 구조</a></p>\n<ul>\n<li><a href=\"#httpservlet-%EA%B5%AC%EC%A1%B0\">HttpServlet 구조</a></li>\n<li><a href=\"#servlet-%EB%8F%99%EC%9E%91%EB%B0%A9%EC%8B%9D\">Servlet 동작방식</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#servlet-container\">Servlet Container</a></p>\n<ul>\n<li><a href=\"#%EC%97%AD%ED%95%A0\">역할</a></li>\n<li><a href=\"#servlet-%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0\">Servlet 생명주기</a></li>\n<li><a href=\"#servlet-%EA%B3%BC-jvm\">Servlet 과 Jvm</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#dispatcher-servlet\">Dispatcher Servlet</a></p>\n<ul>\n<li><a href=\"#dispatcher-servlet-processing\">Dispatcher servlet processing</a></li>\n<li><a href=\"#handleradapter-interfaces\">HandlerAdapter Interfaces</a></li>\n<li><a href=\"#spring-mvc-%EC%99%80-dispatcherservlet-%EB%8F%99%EC%9E%91%EB%B0%A9%EC%8B%9D\">Spring MVC 와 DispatcherServlet 동작방식</a></li>\n<li><a href=\"#%ED%8C%8C%EC%83%9D-%ED%82%A4%EC%9B%8C%EB%93%9C-%EB%B0%8F-%EC%A3%BC%EC%A0%9C\">파생 키워드 및 주제</a></li>\n<li><a href=\"#%EC%9D%98%EB%AC%B8\">의문</a></li>\n<li><a href=\"#%EC%B0%B8%EA%B3%A0%EB%A7%81%ED%81%AC\">참고링크</a></li>\n</ul>\n</li>\n</ul>\n</div>","excerpt":"Servlet 개념 및 구조 Servlet은 웹 서버를 구현한 자바의 프로그램이며 interface이다. 서블릿이 하는 일은 다음과 같다. Servlet은 웹 클라이언트로부터 요청을 받아서 응답을 반환한다. Servlet 인터페이스는 servlet을 초기화하고, 서비스를 요청하고, servlet을 서버에서 제거하는 메소드를 제공한다. (이걸 life-cycle 메소드라고 말한다)  메소드를 통해서 서블릿이 구축된다. 클라이언트에서 호출된  메소드가 수행된다. 수행된 서블릿이 에서 제거되고  메소드를 통해서 소멸된다. 추가로 Servlet 초기세팅 정보를  에 담아서 반환하는  와, Servlet 정보를 반환하는  메소드도 존재한다. HttpServlet 구조 을 확장하고  인터페이스를 구현한다. 웹 환경에 최적화되어 있어서 HTTP 메소드를 지원한다. 즉, HttpServlet 에서는  를 override 할 이유가 거의 없다. 왜냐햐면 이미 정의되어 있는 Http 요청들을 수행하…","frontmatter":{"date":"June 03, 2021","title":"Dispatcher Servlet 알아보기","categories":"웹","author":"코다","emoji":"🖥"},"fields":{"slug":"/dispatcher-servlet/"}},"next":{"id":"0c475bf4-622e-52db-93a0-041e112f245b","html":"<p>스프링 프레임워크에서 사용되는 Bean scope에 6가지 종류가 있다. 일반적으로 많이 쓰이는 scope은 싱글톤이다.</p>\n<h2 id=\"singleton-scope\" style=\"position:relative;\"><a href=\"#singleton-scope\" aria-label=\"singleton scope permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Singleton scope</h2>\n<p>스프링 빈이 singleton scope을 가지고 있다면, 컨테이너가 빈의 단 하나의 인스턴스를 해당 빈이 필요할 때마다 캐싱된 빈을 리턴한다. 빈 객체를 수정하면 해당 빈을 참조하고 있는 모든 곳에 반영이 된다. 싱글톤 스콥은 스프링의 기본값이다.</p>\n<h2 id=\"prototype-scope\" style=\"position:relative;\"><a href=\"#prototype-scope\" aria-label=\"prototype scope permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Prototype scope</h2>\n<p>프로토타입 스콥은 빈 요청이 있을때마다 매번 다른 인스턴스를 컨테이너로부터 반환한다. 설정방법은 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Bean</span>\n<span class=\"token annotation punctuation\">@Scope</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"prototype\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token class-name\">Persion</span> <span class=\"token function\">personPrototype</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"web-aware-scopes\" style=\"position:relative;\"><a href=\"#web-aware-scopes\" aria-label=\"web aware scopes permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Web Aware Scopes</h2>\n<p>앞에 두 개의 범위를 제외하고 4개의 범위가 더 존재한다. 하지만 조건이 있는데, web-aware application 맥락에서만 적용이 될 수 있는 범위이다.</p>\n<h3 id=\"request-scope\" style=\"position:relative;\"><a href=\"#request-scope\" aria-label=\"request scope permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Request Scope</h3>\n<p>Request scope은 하나의 HTTP request 당 하나의 빈을 생성한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Bean</span>\n<span class=\"token annotation punctuation\">@Scope</span><span class=\"token punctuation\">(</span>value <span class=\"token operator\">=</span> <span class=\"token class-name\">WebApplicationContext</span><span class=\"token punctuation\">.</span>SCOPE_REQUEST<span class=\"token punctuation\">,</span> proxyMode <span class=\"token operator\">=</span> <span class=\"token class-name\">ScopedProxyMode</span><span class=\"token punctuation\">.</span>TARGET_CLASS<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token class-name\">HelloMessageGenerator</span> <span class=\"token function\">requestScopedBean</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HelloMessageGenerator</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이 scope을 사용할 때는 proxyMode 속성이 필수로 필요하다. 왜냐하면 웹 어플리케이션 context가 시작하는 그 순간에는 활성화 되어 있는 request 가 없기 때문에 proxy 객체가 필요하다. 스프링이 시작되었을 때 프록시 객체가 주입된다. 그리고 해당 빈이 필요한 request가 왔을 때 대상 bean을 초기화하고 주입한다.</p>\n<p>더 간단하게는 아래와 같이 표현이 가능하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Bean</span>\n<span class=\"token annotation punctuation\">@RequestScope</span>\n<span class=\"token keyword\">public</span> <span class=\"token class-name\">HelloMessageGenerator</span> <span class=\"token function\">requestScopedBean</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HelloMessageGenerator</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이제 컨트롤러에서 requestScopedBean을 정의해서 사용할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Controller</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ScopesController</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token annotation punctuation\">@Resource</span><span class=\"token punctuation\">(</span>name <span class=\"token operator\">=</span> <span class=\"token string\">\"requestScopedBean\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token class-name\">HelloMessageGenerator</span> requestScopedBean<span class=\"token punctuation\">;</span>\n\t\n\t<span class=\"token annotation punctuation\">@RequestMapping</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/scopes/request\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">getRequestScopeMessage</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">final</span> <span class=\"token class-name\">Model</span> model<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\tmodel<span class=\"token punctuation\">.</span><span class=\"token function\">addAttribute</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"previousMessage\"</span><span class=\"token punctuation\">,</span> requestScopedBean<span class=\"token punctuation\">.</span><span class=\"token function\">getMessage</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//이 메세지가 항상 null이 된다.</span>\n\t\trequestScopedBean<span class=\"token punctuation\">.</span><span class=\"token function\">setMessage</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Good Morning!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\tmodel<span class=\"token punctuation\">.</span><span class=\"token function\">addAttribute</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"currentMessage\"</span><span class=\"token punctuation\">,</span> requestScopedBean<span class=\"token punctuation\">.</span><span class=\"token function\">getMessage</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">return</span> <span class=\"token string\">\"scopeExample\"</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3 id=\"session-scope\" style=\"position:relative;\"><a href=\"#session-scope\" aria-label=\"session scope permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Session Scope</h3>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Bean</span>\n<span class=\"token annotation punctuation\">@Scope</span><span class=\"token punctuation\">(</span>value <span class=\"token operator\">=</span> <span class=\"token class-name\">WebApplicationContext</span><span class=\"token punctuation\">.</span>SCOPE_SESSION<span class=\"token punctuation\">,</span> proxyMode <span class=\"token operator\">=</span> <span class=\"token class-name\">ScopedProxyMode</span><span class=\"token punctuation\">.</span>TARGET_CLASS<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token class-name\">HelloMessageGenerator</span> <span class=\"token function\">sessionScopedBean</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HelloMessageGenerator</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>세션의 생명주기와 같은 범위로 bean이 생성된다.</p>\n<h3 id=\"application-scope\" style=\"position:relative;\"><a href=\"#application-scope\" aria-label=\"application scope permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Application Scope</h3>\n<p><code class=\"language-text\">Application scope</code>은 <code class=\"language-text\">ServletContext</code>의 생명주기와 동일하게 빈 생명주기가 결정된다. 그렇기 때문에 어떻게 보면 <code class=\"language-text\">singleton scope</code> 과 굉장히 비슷하지만 bean 의 관점에서 보면 중요한 차이가 있다.</p>\n<p>만일 <code class=\"language-text\">application scope</code>로 되어 있다면, 동일한 bean 인스턴스가 동일한 <code class=\"language-text\">ServletContext</code> 공유하는 여러 servlet-based 어플리케이션에서 활용된다. 하지만 만일, <code class=\"language-text\">singleton scope</code>이라면 하나의 어플리케이션에서 싱글톤 인스턴스로 관리된다.</p>\n<h3 id=\"websocket-scope\" style=\"position:relative;\"><a href=\"#websocket-scope\" aria-label=\"websocket scope permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>WebSocket Scope</h3>\n<p><code class=\"language-text\">WebSocket scope</code>을 사용하면 Bean들이 WebSocket session 속성에 저장이 된다. 따라서 동일한 WebSocket session에 빈 요청이 있을 때, 같은 bean 인스턴스를 반환한다.</p>\n<p>참고자료: <a href=\"https://www.baeldung.com/spring-bean-scopes\">https://www.baeldung.com/spring-bean-scopes</a></p>\n<p><a href=\"https://docs.spring.io/spring-framework/docs/3.0.0.M3/reference/html/ch04s04.html#beans-factory-scopes-prototype\">https://docs.spring.io/spring-framework/docs/3.0.0.M3/reference/html/ch04s04.html#beans-factory-scopes-prototype</a></p>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#singleton-scope\">Singleton scope</a></p>\n</li>\n<li>\n<p><a href=\"#prototype-scope\">Prototype scope</a></p>\n</li>\n<li>\n<p><a href=\"#web-aware-scopes\">Web Aware Scopes</a></p>\n<ul>\n<li><a href=\"#request-scope\">Request Scope</a></li>\n<li><a href=\"#session-scope\">Session Scope</a></li>\n<li><a href=\"#application-scope\">Application Scope</a></li>\n<li><a href=\"#websocket-scope\">WebSocket Scope</a></li>\n</ul>\n</li>\n</ul>\n</div>","frontmatter":{"date":"May 30, 2021","title":"Bean Scope 종류 알아보기","categories":"스프링 웹","author":"코다","emoji":"🍀"},"fields":{"slug":"/bean-scope/"}},"prev":{"id":"8bf91ec6-90fe-5ce0-86c1-d8e98765968f","html":"<p>간단한 JavaBean 규약에 대해서 알고 넘어가기</p>\n<h2 id=\"javabean\" style=\"position:relative;\"><a href=\"#javabean\" aria-label=\"javabean permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JavaBean</h2>\n<p>자바빈 규약을 따르는 Java Class를 말한다.</p>\n<h2 id=\"javabean-규약\" style=\"position:relative;\"><a href=\"#javabean-%EA%B7%9C%EC%95%BD\" aria-label=\"javabean 규약 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JavaBean 규약</h2>\n<ol>\n<li>defulat 패키지가 아닌 패키지 하위에 있는 클래스</li>\n<li>기본 생성자가 존재 (no-arg constructor)</li>\n<li>Property는 모두 private으로 선언</li>\n<li>Getter/setter를 통해서 properties를 조작</li>\n<li><code class=\"language-text\">Serializable</code>을 implement 하여 직렬화 가능</li>\n</ol>\n<h2 id=\"번외--serialization--deserialization\" style=\"position:relative;\"><a href=\"#%EB%B2%88%EC%99%B8--serialization--deserialization\" aria-label=\"번외  serialization  deserialization permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>번외 : Serialization &#x26; Deserialization</h2>\n<ul>\n<li>Serialization : converting state of an object into a byte stream</li>\n<li>Deserialization: reverse process of serialization</li>\n</ul>\n<p>해당 객체에 영속성을 부여하기 위해서 사용되는 매커니즘이다. <br></p>\n<p>Java 객체를 serialize 하게 하기 위해서는 <code class=\"language-text\">java.io.Serializable</code> 인터페이스를 구현하도록 한다. 해당 인터페이스는 멤버변수나 메소드가 존재하지 않는 marker interface(Cloneable이나 Remote와 같은) 이다. <br></p>\n<p>Serializable하면 1) 해당 객체 그대로에 영속성을 부여할 수 있으며 2) 네트워크 상에서 byte stream으로 전송이 가능하다. <br></p>\n<p><strong>Serialization 특징</strong></p>\n<ul>\n<li>\n<p>부모 클래스가 Serializable interface를 구현하면 자식 클래스는 자동으로 Serializable 하다.</p>\n</li>\n<li>\n<p>non-static 멤버 변수만 Serialization 으로 저장될 수 있다. (static 과 transient 데이터는 불가)</p>\n</li>\n<li>\n<p>비밀번호 등의 보안으로 인해 어떠한 멤버 변수가 serialize 되어 저장되지 않기를 원한다면 해당 데이터를 trasient 데이터로 지정하도록 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Member</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Serializable</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">transient</span> <span class=\"token class-name\">String</span> password<span class=\"token punctuation\">;</span>\n\t<span class=\"token class-name\">String</span> name<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n<li>\n<p>해당 객체가 deserialized 될 때 해당 객체의 생성자는 호출되지 않는다.</p>\n</li>\n<li>\n<p>Serializable 한 객체와 연관되어 있는 객체 또한 Serializable 인터페이스를 반드시 구현해야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">ObjectA</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Serializable</span> <span class=\"token punctuation\">{</span>\t\n\t<span class=\"token comment\">//ObjectB는 반드시 Serializable을 구현해야 함\t</span>\n\t<span class=\"token class-name\">ObjectB</span> oj <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ObjectB</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n</ul>\n<p><strong>SerialVersionUID</strong></p>\n<p>Serialization을 진행하면서 각 Serializable class는 <code class=\"language-text\">SerialVersionUID</code> 라는 id를 할당받는다. 해당 id를 통해서 직렬화된 객체의 sender와 receiver를 판별하는데, sender와 reciever는 동일해야한다. 만일 동일하지 않다면 <code class=\"language-text\">InvalidClassException</code>이 deserialize 할 때 발생한다.</p>\n<br>\n<br>\n<p><strong>[참고자료]</strong></p>\n<ul>\n<li><a href=\"https://dololak.tistory.com/133\">https://dololak.tistory.com/133</a></li>\n<li><a href=\"https://www.geeksforgeeks.org/javabean-class-java/#:~:text=JavaBeans%20are%20classes%20that%20encapsulate,public%20getters%20and%20setter%20methods\">https://www.geeksforgeeks.org/javabean-class-java/#:~:text=JavaBeans are classes that encapsulate,public getters and setter methods</a>.</li>\n<li><a href=\"https://www.geeksforgeeks.org/serialization-in-java/\">https://www.geeksforgeeks.org/serialization-in-java/</a></li>\n<li><a href=\"https://www.javatpoint.com/serialization-in-java#:~:text=Serialization%20in%20Java%20is%20a,is%20converted%20into%20an%20object\">https://www.javatpoint.com/serialization-in-java#:~:text=Serialization in Java is a,is converted into an object</a>.</li>\n</ul>\n<p><strong>[MORE]</strong></p>\n<ul>\n<li>non-static 만 serialization 가능한 이유</li>\n<li>SerialVersionUID</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#javabean\">JavaBean</a></li>\n<li><a href=\"#javabean-%EA%B7%9C%EC%95%BD\">JavaBean 규약</a></li>\n<li><a href=\"#%EB%B2%88%EC%99%B8--serialization--deserialization\">번외 : Serialization &#x26; Deserialization</a></li>\n</ul>\n</div>","frontmatter":{"date":"June 08, 2021","title":"자바빈 규약 (번외: Serialization)","categories":"자바","author":"코다","emoji":"✊"},"fields":{"slug":"/java-bean/"}},"site":{"siteMetadata":{"siteUrl":"https://yjksw.github.io","comments":{"utterances":{"repo":"yjksw/yjksw.github.io"}}}}},"pageContext":{"slug":"/dispatcher-servlet/","nextSlug":"/bean-scope/","prevSlug":"/java-bean/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}
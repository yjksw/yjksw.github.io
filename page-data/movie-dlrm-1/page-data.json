{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/movie-dlrm-1/",
    "result": {"data":{"cur":{"id":"00f6784d-9c1b-544a-bbc9-c05f7ea73ba6","html":"<p>인턴을 하는 중에 요즘에 중요한 머신러닝의 한 분야가 되고 있는 개인화 추천에 대한 개발을 맡게 되었다. 요즘 넷플릭스, 왓챠와 같은 OTT 서비스는 물론이고, SNS에 표기되는 광고, 당근마켓 등등과 같은 중고거래 및 쇼핑 어플리케이션에서도 중요한 것이 사용자의 취향을 분석하여서 알맞은 아이템을 추천하는 기술이 핵심이다. 어쩌면 사용자가 의식적으로 파악하고 있는 이상의 취향을 파악해서 추천해야 할 때도 있다. 이전 포스트에서 다루었듯이 개인화 추천에는 여러 통계기반 머신러닝 기법들이 있다. 그리고 인공 신경망이라는 딥러닝 기법이 등장하게 되면서 더욱 세밀하고 정확한 개인화 추천이 가능해졌다. <br></p>\n<p>처음 접했기 때문에 매우 생소하고 낯선 분야였지만 많은 자료들을 찾아보면서 현재 내 삶(<small>유튜브나 넷플릭스의 노예…</small>)과 아주 밀접하게 연관이 되어 있는 많은 어플리케이션과 서비스등에 실제로 사용되고 있는 인공지능 기법이라는 것이 금방 흥미를 불러 일으켰다. 조금 어렵긴 하지만 facebook에서 공개한 DLRM(Deep Learning Recommendation Model) <a href=\"https://ai.facebook.com/blog/dlrm-an-advanced-open-source-deep-learning-recommendation-model/\">자료</a>나 구글에서 공개한 유튜브 개인화 추천 <a href=\"https://research.google/pubs/pub45530/\">논문</a>, 국내의 당근마켓에서 쓴 개인화 추천 관련 블로그 <a href=\"%5Bhttps://medium.com/daangn/%EB%94%A5%EB%9F%AC%EB%8B%9D-%EA%B0%9C%EC%9D%B8%ED%99%94-%EC%B6%94%EC%B2%9C-1eda682c2e8c%5D(https://medium.com/daangn/%EB%94%A5%EB%9F%AC%EB%8B%9D-%EA%B0%9C%EC%9D%B8%ED%99%94-%EC%B6%94%EC%B2%9C-1eda682c2e8c)\">포스트</a> 등을 참고하면서 개인화 추천에 대한 대략적인 아이디어나 개념을 잡았다. <small>물론 매우 매우 어렵기 때문에 모든 것을 이해하는 것은 (나는) 힘들다. 가볍지만 꼼꼼하게 읽으면서 대략적인 맥락을 파악하는 것을 추천한다!</small> <br></p>\n<p>이후에 구현되어 있었던 pytorch를 활용한 딥러닝 모델 예시를 보게 되었고 참고하여 응용하면서 아주 간단한 딥러닝 영화 개인화 추천 모델을 구현하였다. 이번 포스트는 해당 개발의 초반, 데이터 전처리에 관한 내용을 다룰 예정이다. 전체 코드를 보고 싶다면 다음 <a href=\"https://github.com/yjksw/DeepLearning_Movie_Recommendation_System\">github repo</a>를 참고하시길. <br></p>\n<h2 id=\"데이터-모양새\" style=\"position:relative;\"><a href=\"#%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%AA%A8%EC%96%91%EC%83%88\" aria-label=\"데이터 모양새 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>데이터 모양새</h2>\n<p>딥러닝 개인화 추천 모델 구현을 시작하면서 가장 먼저 한 일은 입력 데이터의 형식에 대해서 파악한 것이다. 본 모델을 사용자와 영화 아이템, 그리고 해당  영화에 대한 각 사용자의 ratings 데이터를 담고 있는 MovieLens 데이터를 사용하였다. 해당 사이트에 가서 원하는 파일을 다운받아서 열면 다음과 같은 형식으로 데이터가 담겨져 있다. <br></p>\n<p><img src=\"https://user-images.githubusercontent.com/63405904/110306953-c027de80-8041-11eb-838e-1ca3bf9957f2.png\" alt=\"image\"> <br></p>\n<p>해당 csv. 파일을 읽어서 validation 과 test 데이터를 나누어야 한다. 다음 명령어를 써서 읽은 csv 파일 data frame에 대한 마스크를 씌울 수 있다. <br></p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">msk <span class=\"token operator\">=</span> np<span class=\"token punctuation\">.</span>random<span class=\"token punctuation\">.</span>rand<span class=\"token punctuation\">(</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">0.8</span></code></pre></div>\n<p>나는 구현할 때 80% 정도의 데이터를 학습 데이터로, 나머지 20%의 데이터를 검증 데이터로 사용했다. <br></p>\n<h2 id=\"데이터-전처리\" style=\"position:relative;\"><a href=\"#%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%A0%84%EC%B2%98%EB%A6%AC\" aria-label=\"데이터 전처리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>데이터 전처리</h2>\n<p>데이터 전처리에서 해야할 일들은 매우 간단하다. 기본적으로 학습 데이터와 검증 데이터는 모두 비슷한 과정의 데이터 전처리 과정을 거치지만 개인화 추천을 위한 영화 데이터에 대해서 구현할 때는 검증 데이터 전처리에 관해 조금 다른 부분이 필요하기도 하다. <br></p>\n<p>학습에서 사용되는 데이터는 ratings.csv 파일에서도 특히 <em>userId</em>와 <em>movieId</em> 부분이다. 따라서 해당 column를 하나씩 끌어다가 전처리를 해주어야 한다. 여기서 필요한 전처리 과정은 다음과 같다. <br></p>\n<ol>\n<li>중복을 제거하여 순수한 유저와 아이템 리스트 갯수 및 리스트 생성</li>\n<li>학습 데이터가 아닌 검증 또는 테스트 데이터일 경우, 학습 데이터에 존재하지 않는 유저와 아이템에 대하여 -1 처리하여 제외</li>\n</ol>\n<p><strong>1번</strong> 과정이 필요한 이유는 이후에 신경망 layers를 쌓고 임베딩 할 때에 pytorch의 모듈을 사용하여서 임베딩 테이블을 생성해야하기 때문이다. <strong>2번</strong> 과정이 필요한 이유는 검증 또는 테스트 데이터에 학습 데이터로 학습되지 않은 전혀 새로운 유저나 영화가 나왔을 경우, 제대로 예측할 수 없기 때문에 미리 제거해 주는 것이다. <br></p>\n<h2 id=\"코드\" style=\"position:relative;\"><a href=\"#%EC%BD%94%EB%93%9C\" aria-label=\"코드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>코드</h2>\n<p>위의 데이터 전처리를 하기 위해서 유용한 몇가지 파이썬 코드를 소개한다. <br></p>\n<ol>\n<li>데이터 columns의 중복제거</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">uni <span class=\"token operator\">=</span> train_col<span class=\"token punctuation\">.</span>unique<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>위 메소드는 입력으로 들어온 column에 대해서 중복을 제거한 리스트를 uni 변수에 저장해준다.</p>\n<ol start=\"2\">\n<li>존재하지 않는 아이템에 대하여 -1 처리하기</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">np<span class=\"token punctuation\">.</span>array<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>name2idx<span class=\"token punctuation\">.</span>get<span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">for</span> x <span class=\"token keyword\">in</span> col<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>여기서 name2idx는 중복이 없는 순수한 유저 또는 아이템 리스트와 해당 index이다. 위와 같은 코드를 실행하면 name2idx에서 해당 col에 있는 x 값이 있다면 해당 값을 가져오고, 그렇지 않다면 -1을 입력하도록 하는 간편한 파이썬 문법이다. <br></p>\n<p>이후에 학습 데이터에 존재하지 않는 유저 또는 아이템이 음수로 들어와 있으니 해당 처리를 다음과 같이하면 제외하고 검증 및 테스트 할 수 있다. <br></p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">df <span class=\"token operator\">=</span> df<span class=\"token punctuation\">[</span>df<span class=\"token punctuation\">[</span>col_name<span class=\"token punctuation\">]</span> <span class=\"token operator\">>=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">]</span></code></pre></div>\n<h2 id=\"결과-화면\" style=\"position:relative;\"><a href=\"#%EA%B2%B0%EA%B3%BC-%ED%99%94%EB%A9%B4\" aria-label=\"결과 화면 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>결과 화면</h2>\n<p>위와 같은 데이터 전처리를 끝내면 다음과 같은 전처리된 데이터가 생성된다. 물론 임베딩하는 전처리가 추가로 필요하지만 다음 포스트에서 학습과 함께 다루도록 하겠다. 결과 화면의 데이터는 csv의 데이터와 크게 차이가 없이 지저분한 데이터들을 제외하고 처리해 놓은 데이터라고 생각하면 된다. <br></p>\n<p><img src=\"https://user-images.githubusercontent.com/63405904/110306884-b00fff00-8041-11eb-91f0-51660920fbcf.png\" alt=\"image\"></p>\n<p><strong><small> [참고 자료]: <a href=\"https://jyoondev.tistory.com/65%C2%A0\">https://jyoondev.tistory.com/65 </a></small></strong></p>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%AA%A8%EC%96%91%EC%83%88\">데이터 모양새</a></li>\n<li><a href=\"#%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%A0%84%EC%B2%98%EB%A6%AC\">데이터 전처리</a></li>\n<li><a href=\"#%EC%BD%94%EB%93%9C\">코드</a></li>\n<li><a href=\"#%EA%B2%B0%EA%B3%BC-%ED%99%94%EB%A9%B4\">결과 화면</a></li>\n</ul>\n</div>","excerpt":"인턴을 하는 중에 요즘에 중요한 머신러닝의 한 분야가 되고 있는 개인화 추천에 대한 개발을 맡게 되었다. 요즘 넷플릭스, 왓챠와 같은 OTT 서비스는 물론이고, SNS에 표기되는 광고, 당근마켓 등등과 같은 중고거래 및 쇼핑 어플리케이션에서도 중요한 것이 사용자의 취향을 분석하여서 알맞은 아이템을 추천하는 기술이 핵심이다. 어쩌면 사용자가 의식적으로 파악하고 있는 이상의 취향을 파악해서 추천해야 할 때도 있다. 이전 포스트에서 다루었듯이 개인화 추천에는 여러 통계기반 머신러닝 기법들이 있다. 그리고 인공 신경망이라는 딥러닝 기법이 등장하게 되면서 더욱 세밀하고 정확한 개인화 추천이 가능해졌다.  처음 접했기 때문에 매우 생소하고 낯선 분야였지만 많은 자료들을 찾아보면서 현재 내 삶(유튜브나 넷플릭스의 노예…)과 아주 밀접하게 연관이 되어 있는 많은 어플리케이션과 서비스등에 실제로 사용되고 있는 인공지능 기법이라는 것이 금방 흥미를 불러 일으켰다. 조금 어렵긴 하지만 facebook…","frontmatter":{"date":"August 21, 2020","title":"[머신러닝] 딥러닝 영화 개인화 추천 - Part.1","categories":"머신러닝","author":"코다","emoji":"🪄"},"fields":{"slug":"/movie-dlrm-1/"}},"next":{"id":"3abdc3c5-1be2-5f00-abea-96176b99fce9","html":"<p>모 기업에서 인턴을 하면서 맡은 업무가 <mark>개인화 추천 모델 구현</mark>이었다. 맡은 업무는 딥러닝 기반의 개인화 추천 모델을 제작하는 것이지만 기존에 회사에서 가지고 있는 추천 시스템의 경우 협업 필터링 등으로 이미 구현이 되어 있었기 때문에 간단히 개인화 추천 시스템에 대한 브리핑을 해주시면서 감을 잡을 수 있도록 해주셨다. <br></p>\n<p>추천 시스템 기술을 처음 접해보면서 어떠한 것인지 공부하며 기록해보려고 한다. <br></p>\n<h2 id=\"추천이란\" style=\"position:relative;\"><a href=\"#%EC%B6%94%EC%B2%9C%EC%9D%B4%EB%9E%80\" aria-label=\"추천이란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>추천이란?</h2>\n<p>추천이란 간단히 말해서 사용자(user)에게 관심이 있을 것으로 예상이 되는 아이템(item)을 제안하는 것이다. 특정 아이템에 대한 특정 사용자의 선호도 또는 평가를 예측하는 것이 매우 중요하다. <br></p>\n<p>우리가 흔히 생각해 낼 수 있는 추천 시스템은 페이스북과 같은 것에서의 광고 추천, 넷플릭스나 왓챠와 같은 OTT 서비스에서의 영화 추천 시스템이다. <br></p>\n<h2 id=\"접근-방식\" style=\"position:relative;\"><a href=\"#%EC%A0%91%EA%B7%BC-%EB%B0%A9%EC%8B%9D\" aria-label=\"접근 방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>접근 방식</h2>\n<p>추천 시스템 기술에서의 접근 방식은 크게 다음과 같은 3가지가 있다. <br></p>\n<ul>\n<li>내용 기반 필터링 (Content-based Filtering) <br></li>\n<li>협업 필터링 (Collaborative Filtering) <br></li>\n<li>하이브리드 (Hybrid) <br></li>\n</ul>\n<h3 id=\"1-내용-기반-필터링\" style=\"position:relative;\"><a href=\"#1-%EB%82%B4%EC%9A%A9-%EA%B8%B0%EB%B0%98-%ED%95%84%ED%84%B0%EB%A7%81\" aria-label=\"1 내용 기반 필터링 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1) 내용 기반 필터링</h3>\n<p>사용자의 프로필이나 아이템의 content 정보를 이용하는 방법이다. 사용자의 선호도, 취향 등을 파악하는 방법이 핵심이다. 예를 들어, 회원가입 시 사용자에게 선호하는 아이템 또는 분야 등에 대해서 선택하도록 하여 선호도를 파악하여 해당 정보를 기반으로 추천을 한다. 또는 사용자의 과거에 평가한 아이템 분석을 통해서 선호도를 파악할 수 있다. <br></p>\n<p><img src=\"https://user-images.githubusercontent.com/63405904/110242569-0590d100-7f9a-11eb-8799-e9fe186779e6.jpeg\" alt=\"contentbased\"></p>\n<h3 id=\"2-협업-필터링\" style=\"position:relative;\"><a href=\"#2-%ED%98%91%EC%97%85-%ED%95%84%ED%84%B0%EB%A7%81\" aria-label=\"2 협업 필터링 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2) 협업 필터링</h3>\n<p>협업 필터링은 여러 사용자들의 활동, 기호 정보들을 분석하여, 각 사아요자에게 적합한 아이템을 추천하도록 한다. 예를 들어서 사용자 A와 유사하다고 판단되는 사용자 B가 최근 구매한 상품을 사용자 A에게도 추천하도록 하는 것이다. <br></p>\n<p><img src=\"https://user-images.githubusercontent.com/63405904/110242548-f14cd400-7f99-11eb-927e-2e1000c04eba.jpeg\" alt=\"collaborative\"></p>\n<h3 id=\"3-내용-기반-필터링--협업-필터링의-장단점\" style=\"position:relative;\"><a href=\"#3-%EB%82%B4%EC%9A%A9-%EA%B8%B0%EB%B0%98-%ED%95%84%ED%84%B0%EB%A7%81--%ED%98%91%EC%97%85-%ED%95%84%ED%84%B0%EB%A7%81%EC%9D%98-%EC%9E%A5%EB%8B%A8%EC%A0%90\" aria-label=\"3 내용 기반 필터링  협업 필터링의 장단점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3) 내용 기반 필터링 &#x26; 협업 필터링의 장단점</h3>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>내용 기반 필터링</th>\n<th>협업 필터링</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>장점</td>\n<td>사용자의 명시적인 기호 정보를 직접적으로 반영한다. <br>다른 사용자의 정보나 평가, 행동 등이 필요하지 않다.<br>새로 추가된 아이템에 대한 추천이 가능하다.</td>\n<td>대부분의 경우 추천 성과가 우수하다.<br>잠재적인 특징을 고려하여 다양한 범위의 추천이 가능하다.</td>\n</tr>\n<tr>\n<td>단점</td>\n<td>사용자의 명시적인 프로필 얻기 어려움이 있다.<br>명시적으로 표현된 특징만 다룰 수 있고 잠재적인 것을 캐치하기 어렵다.<br>추천하는 항목이 비슷한 장르에 머무르는 한계가 있다.</td>\n<td>초기 사용자에 대한 믿을만한 추천이 어렵다. Cold start가 존재한다.<br>한번도 평가되지 않은 아이템은 추천 대상에서 제외된다. sparsity, coverage</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"4-하이브리드\" style=\"position:relative;\"><a href=\"#4-%ED%95%98%EC%9D%B4%EB%B8%8C%EB%A6%AC%EB%93%9C\" aria-label=\"4 하이브리드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4) 하이브리드</h3>\n<p>위에서의 내용 기반 필터링과 협업 필터링을 결합하여 사용한다. 결합하는 방식을 다양하기 때문에 어떠한 하이브리드 방식을 택하는지는 매우 광범위 하다. 하지만 간단히 보아서 위의 두가지 방식을 같이 사용함으로 각자의 단점을 보완한다는 장점을 가지고 있다. 다만 시스템적으로 매우 복잡해질 수 있는 단점이 있다.</p>\n<h3 id=\"5-협업-필터링-기술-분류\" style=\"position:relative;\"><a href=\"#5-%ED%98%91%EC%97%85-%ED%95%84%ED%84%B0%EB%A7%81-%EA%B8%B0%EC%88%A0-%EB%B6%84%EB%A5%98\" aria-label=\"5 협업 필터링 기술 분류 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5) 협업 필터링 기술 분류</h3>\n<p>본 기업에서 중점적으로 사용하고 있는 협업 필터링 기술은 다음과 같이 분류된다. <br></p>\n<ul>\n<li>메모리 기반(Memory-based) 협업 필터링 <br>\n<ul>\n<li>사용자 또는 아이템 간의 유사도를 계산하고 그것을 바탕을 추천 결과를 생성하는 방식으로 유사도를 계산하는 방식이 매우 중요함. <br></li>\n<li><strong>대표 알고리즘</strong>: User-based CF / Item-based CF <br></li>\n<li><strong>장점</strong>: 구현이 간단하고 이해하기 쉬움. <br></li>\n<li><strong>한계</strong>: 1) 새로운 사용자와 아이템에 대한 cold start 문제 2) Rating matrix의 sparsity 문제 3) 큰 데이터 셋에 대해 제한된 scalability <br></li>\n</ul>\n</li>\n<li>모델 기반(Model-based) 협업 필터링 <br>\n<ul>\n<li>데이터(rating matrix)에 내재되어 있는 패턴이나 속성을 학습한 모델을 만들고, 이것을 바탕으로 추천 결과를 생성하는 방식. <br></li>\n<li><strong>대표 알고리즘</strong>: Slope-One EF / Matrix Facotrization <br></li>\n<li><strong>장점:</strong> sparsity, scalability 문제에 상대적으로 더 잘 대처하는 것이 가능하고 예측 성능이 향상됨. <br></li>\n<li><strong>한계:</strong> 1) 모델 구축 비용이 큼 2) 예측 성능과 scalability 사이의 trade-off 3) 차원 감소로 인한 정보손실(SVD 실행 시 발생) <br></li>\n</ul>\n</li>\n<li>하이브리드(Hybrid) 방식 협업 필터링 <br>\n<ul>\n<li>메모리 기반 방식과 모델 기반 방식을 결합하여 사용하는 방식 <br></li>\n<li><strong>대표 알고리즘</strong>: 메모리 기반과 모델 기반의 조합 <br></li>\n<li><strong>장점</strong>: 각 방식의 단점을 보완하고 장점만을 취합할 수 있음 <br></li>\n<li><strong>한계:</strong> 구현이 복잡해지고 비용이 증가함. <br></li>\n</ul>\n</li>\n</ul>\n<br>\n<p><strong><small>[참고 자료]: <a href=\"https://www.samsungsemiconstory.com/2265\">https://www.samsungsemiconstory.com/2265</a>, </small></strong></p>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#%EC%B6%94%EC%B2%9C%EC%9D%B4%EB%9E%80\">추천이란?</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%A0%91%EA%B7%BC-%EB%B0%A9%EC%8B%9D\">접근 방식</a></p>\n<ul>\n<li><a href=\"#1-%EB%82%B4%EC%9A%A9-%EA%B8%B0%EB%B0%98-%ED%95%84%ED%84%B0%EB%A7%81\">1) 내용 기반 필터링</a></li>\n<li><a href=\"#2-%ED%98%91%EC%97%85-%ED%95%84%ED%84%B0%EB%A7%81\">2) 협업 필터링</a></li>\n<li><a href=\"#3-%EB%82%B4%EC%9A%A9-%EA%B8%B0%EB%B0%98-%ED%95%84%ED%84%B0%EB%A7%81--%ED%98%91%EC%97%85-%ED%95%84%ED%84%B0%EB%A7%81%EC%9D%98-%EC%9E%A5%EB%8B%A8%EC%A0%90\">3) 내용 기반 필터링 &#x26; 협업 필터링의 장단점</a></li>\n<li><a href=\"#4-%ED%95%98%EC%9D%B4%EB%B8%8C%EB%A6%AC%EB%93%9C\">4) 하이브리드</a></li>\n<li><a href=\"#5-%ED%98%91%EC%97%85-%ED%95%84%ED%84%B0%EB%A7%81-%EA%B8%B0%EC%88%A0-%EB%B6%84%EB%A5%98\">5) 협업 필터링 기술 분류</a></li>\n</ul>\n</li>\n</ul>\n</div>","frontmatter":{"date":"August 10, 2020","title":"[머신러닝] 추천 시스템 기술","categories":"머신러닝","author":"코다","emoji":"🪄"},"fields":{"slug":"/ml-recommendation-system/"}},"prev":{"id":"0da8868f-8e99-5b04-8738-0846bdb6f9b8","html":"<p>이어서 딥러닝 영화 개인화 추천 모델을 구현하면서 구축한 딥러닝 협업 필터링 모델 부분에 대한 코드를 살펴보면서 딥러닝 전체적인 흐름에 대해서 짚어보자. 앞에서 언급했듯이 코드는 다음 <a href=\"https://jyoondev.tistory.com/65?category=823946\">링크</a>에서 참고하여 모델과 전체적인 데이터 처리를 진행했고, 이후에 학습된 output에 대한 데이터 및 결과 후처리는 추가 구현했다. 해당 부분은 다음 파트에 다루도록 하겠다. <br></p>\n<h2 id=\"모델-전체-코드\" style=\"position:relative;\"><a href=\"#%EB%AA%A8%EB%8D%B8-%EC%A0%84%EC%B2%B4-%EC%BD%94%EB%93%9C\" aria-label=\"모델 전체 코드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>모델 전체 코드</h2>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">NNCollabFiltering</span><span class=\"token punctuation\">(</span>nn<span class=\"token punctuation\">.</span>Module<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n  <span class=\"token keyword\">def</span> <span class=\"token function\">__init__</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> num_users<span class=\"token punctuation\">,</span> num_items<span class=\"token punctuation\">,</span> emb_size<span class=\"token operator\">=</span><span class=\"token number\">100</span><span class=\"token punctuation\">,</span> n_hidden<span class=\"token operator\">=</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token builtin\">super</span><span class=\"token punctuation\">(</span>NNCollabFiltering<span class=\"token punctuation\">,</span> self<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>__init__<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    self<span class=\"token punctuation\">.</span>user_emb <span class=\"token operator\">=</span> nn<span class=\"token punctuation\">.</span>Embedding<span class=\"token punctuation\">(</span>num_users<span class=\"token punctuation\">,</span> emb_size<span class=\"token punctuation\">)</span>\n    self<span class=\"token punctuation\">.</span>item_emb <span class=\"token operator\">=</span> nn<span class=\"token punctuation\">.</span>Embedding<span class=\"token punctuation\">(</span>num_items<span class=\"token punctuation\">,</span> emb_size<span class=\"token punctuation\">)</span>\n    self<span class=\"token punctuation\">.</span>lin1 <span class=\"token operator\">=</span> nn<span class=\"token punctuation\">.</span>Linear<span class=\"token punctuation\">(</span>emb_size<span class=\"token operator\">*</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> n_hidden<span class=\"token punctuation\">)</span>\n    self<span class=\"token punctuation\">.</span>lin2 <span class=\"token operator\">=</span> nn<span class=\"token punctuation\">.</span>Linear<span class=\"token punctuation\">(</span>n_hidden<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    self<span class=\"token punctuation\">.</span>drop1 <span class=\"token operator\">=</span> nn<span class=\"token punctuation\">.</span>Dropout<span class=\"token punctuation\">(</span><span class=\"token number\">0.1</span><span class=\"token punctuation\">)</span>\n    \n  <span class=\"token keyword\">def</span> <span class=\"token function\">forward</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> u<span class=\"token punctuation\">,</span> v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    U <span class=\"token operator\">=</span> self<span class=\"token punctuation\">.</span>user_emb<span class=\"token punctuation\">(</span>u<span class=\"token punctuation\">)</span>\n    V <span class=\"token operator\">=</span> self<span class=\"token punctuation\">.</span>item_emb<span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span>\n    x <span class=\"token operator\">=</span> F<span class=\"token punctuation\">.</span>relu<span class=\"token punctuation\">(</span>torch<span class=\"token punctuation\">.</span>cat<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>U<span class=\"token punctuation\">,</span> V<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> dim<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    x <span class=\"token operator\">=</span> self<span class=\"token punctuation\">.</span>drop1<span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span>\n    x <span class=\"token operator\">=</span> F<span class=\"token punctuation\">.</span>relu<span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">.</span>lin1<span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    x <span class=\"token operator\">=</span> self<span class=\"token punctuation\">.</span>lin2<span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> x</code></pre></div>\n<br>\n<h2 id=\"step1-임베딩---nnembedding\" style=\"position:relative;\"><a href=\"#step1-%EC%9E%84%EB%B2%A0%EB%94%A9---nnembedding\" aria-label=\"step1 임베딩   nnembedding permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Step1. 임베딩 - nn.Embedding()</h2>\n<p>위 코드를 보면 먼저 User와 Item에 관한 임베딩으로 시작한다. 파이토치에서 임베딩 벡터를 사용하는 방법은 크게 두가지가 있는데 그 중 위의 <code class=\"language-text\">nn.Embedding()</code> 은 embedding layer를 만들어서 훈련 데이터로부터 처음부터 임베딩 벡터를 학습하는 방법이다. <br></p>\n<p>먼저 임베딩 층의 입력으로 사용하기 위해서는 정수 인코딩이 되어 있어야 한다. 즉 다음과 같은 단계를 따른다. <br></p>\n<blockquote>\n<p>어떤 단어 -> 고유한 정수로 인코딩 -> 임베딩 층을 통과 -> 밀집 벡터</p>\n</blockquote>\n<p>즉, 고유한 정수 인코딩 값에 대해서 밀집 벡터(dense vector)를 맵핑해주는 것이다. 이 밀집 베터가 흔히 알고 있는 임베딩 벡터이다. 임베딩을 시킨다는 것은 어떠한 단어에 대한 고유 인코딩 정수값을 인덱스로 가지고 있는 룩업 테이블에서 해당 임베딩 벡터 값을 가져오는 것이다. 또한 <mark>이 테이블은 단어 집합만큼의 행을 가지고 있으므로 모든 단어들은 고유한 임베딩 벡터를 보유하게 된다.</mark> 이러한 벡터 값을 담고 있는 룩업 테이블을 생성하는 것이 <code class=\"language-text\">nn.Embedding()</code>의 역할이다. <br></p>\n<p><img src=\"https://user-images.githubusercontent.com/63405904/110482824-6bad5d80-812c-11eb-9da2-750e1946c80b.png\" alt=\"image\"></p>\n<p>위의 그림을 참고해보면 단어 ‘great’에 대한 임베딩 벡터가 4차원인 것을 확인할 수 있다. 해당 차원값은 parameter로 넘겨줄 수 있는 부분이다. 이렇게 생성된 임베딩 벡터는 모델의 입력이 되고, 역전파 과정을 거치면서 바로 이 임베딩 벡터값이 학습 되는 것이다. <br></p>\n<h3 id=\"-코드에서-임베딩\" style=\"position:relative;\"><a href=\"#-%EC%BD%94%EB%93%9C%EC%97%90%EC%84%9C-%EC%9E%84%EB%B2%A0%EB%94%A9\" aria-label=\" 코드에서 임베딩 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>> 코드에서 임베딩</h3>\n<p>위 코드에서 임베딩이 어떻게 이루어지고 있는지 살펴보자. 코드를 살펴보면 임베딩 관련한 부분에 다음과 같이 있다. <br></p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\">#def __init__ 메소드 내: </span>\n  self<span class=\"token punctuation\">.</span>user_emb <span class=\"token operator\">=</span> nn<span class=\"token punctuation\">.</span>Embedding<span class=\"token punctuation\">(</span>num_users<span class=\"token punctuation\">,</span> emb_size<span class=\"token punctuation\">)</span>\n  self<span class=\"token punctuation\">.</span>item_emb <span class=\"token operator\">=</span> nn<span class=\"token punctuation\">.</span>Embedding<span class=\"token punctuation\">(</span>num_items<span class=\"token punctuation\">,</span> emb_size<span class=\"token punctuation\">)</span></code></pre></div>\n<p><code class=\"language-text\">nn.Embedding()</code> 에 넘겨지는 parameter는 크게 <strong>2가지</strong>가 있다. 1) 테이블 사이즈 (단어 및 데이터 갯수) 2) 임베딩 사이즈 (embedding vector  차원). <br></p>\n<p>영화에서 모델에 넣어서 학습할 데이터는 사용자 user와 영화 item이다. 이 두개에 대한 임베딩 테이블을 생성하기 위해서 인코딩 하며 중복없이 뽑아낸 user 와 item 리스트의 크기와 임베딩 사이즈를 결정해서 <code class=\"language-text\">nn.Embbeding()</code>을 호출한다. 그럼 임베딩 테이블이 생성되어 각각 user_emb 와 item_emb에 저장된다. <br></p>\n<h2 id=\"step2-linear-layer-생성---nnlinear\" style=\"position:relative;\"><a href=\"#step2-linear-layer-%EC%83%9D%EC%84%B1---nnlinear\" aria-label=\"step2 linear layer 생성   nnlinear permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Step2. Linear Layer 생성 - nn.Linear()</h2>\n<p>다음 코드에서는 Linear layer를 생성한다. 딥러닝의 핵심인 신경망(neural network) 층을 쌓아올려서 학습을 진행한다. 그때 필요한 신경망 층을 생성하는 역할을 한다. 딥러닝을 위한 신경망은 기본적으로 선형회귀분석을 기본으로 하기 때문에 선형변형 함수로 층을 쌓는다. <br></p>\n<p><img src=\"https://user-images.githubusercontent.com/63405904/110482886-7d8f0080-812c-11eb-9b12-6c65a734be69.png\" alt=\"image\"></p>\n<p>파이토치에서 제공하는 <a href=\"https://pytorch.org/docs/stable/nn.html#linear-layers\">document</a>를 살펴보면 위와 같은 선형변형 함수를 사용하는 것을 확인할 수 있다. 선형결합은 보존하는 선형변형 함수를 생성하고 원하는 <strong>in_feature</strong>와 <strong>out_feature</strong>의 사이즈를 parameter로 넘긴다. <br></p>\n<h3 id=\"-코드에서-layer-생성\" style=\"position:relative;\"><a href=\"#-%EC%BD%94%EB%93%9C%EC%97%90%EC%84%9C-layer-%EC%83%9D%EC%84%B1\" aria-label=\" 코드에서 layer 생성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>> 코드에서 layer 생성</h3>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\">#def __init__ 메소드 내:</span>\n\tself<span class=\"token punctuation\">.</span>lin1 <span class=\"token operator\">=</span> nn<span class=\"token punctuation\">.</span>Linear<span class=\"token punctuation\">(</span>emb_size<span class=\"token operator\">*</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> n_hidden<span class=\"token punctuation\">)</span>\n  self<span class=\"token punctuation\">.</span>lin2 <span class=\"token operator\">=</span> nn<span class=\"token punctuation\">.</span>Linear<span class=\"token punctuation\">(</span>n_hidden<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>위 코드는 입력 차원이 emb_size의 두배인 input sample에 대해서 n_hidden 사이즈 만큼의 차원으로 선형변형을 하는 linear layer 하나와, n_hidden 사이즈의 input sample에 대해서 1로 선형변형을 하는 linear layer 두개를 생성한다. <br></p>\n<h2 id=\"step3-모델-일반화---nndropout\" style=\"position:relative;\"><a href=\"#step3-%EB%AA%A8%EB%8D%B8-%EC%9D%BC%EB%B0%98%ED%99%94---nndropout\" aria-label=\"step3 모델 일반화   nndropout permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Step3. 모델 일반화 - nn.Dropout()</h2>\n<p>Dropout은 모델을 일반화 기법으로 일부 파라미터를 학습에 반영하지 않는 것이다. Validation과 test 시에는 적용하지 않고 train 시에 dropout을 적용하는데, 일종의 정규화 기법이라고 볼 수 있다. 모델을 학습할 때 과적합(overfitting)의 위험을 줄이고, 학습속도를 개선하는 문제를 해결하기 위한 방법이다. 모델을 학습할 때 지나치게 학습 데이터에 대한 높은 정확도를 보이기 보다, 범용적으로 사용될 수 있도록 overfitting 문제를 피하기 위해서 고안된 해결책 중 하나이다. 일반적으로 신경망의 층이 깊어지고, 학습률이 작을수록 overfitting이 될 가능성이 높다. <br></p>\n<p>이중 본 코드에서 사용하고 있는 모델 일반화의 방법은 드롭아웃 Dropout이다. 신경망 모델이 지나치게 복잡해질 때, 뉴런의 연결을 임의로 삭제하여 전달하지 않도록 떨어뜨리는 역할을 한다. 다만, 테스트를 할 때에는 모든 뉴런을 사용하기 때문에 반드시 학습시에만 드롭아웃을 적용해야 한다. <br></p>\n<p><img src=\"https://user-images.githubusercontent.com/63405904/110482706-47ea1780-812c-11eb-9908-5686512aae8c.png\" alt=\"image\"></p>\n<p>파이토치 <a href=\"https://pytorch.org/docs/stable/generated/torch.nn.Dropout.html#torch.nn.Dropout\">document</a>를 보면 <code class=\"language-text\">nn.torch</code> 모듈에서 드롭아웃 또한 지원을 한다. <br></p>\n<p><img src=\"https://user-images.githubusercontent.com/63405904/110482789-5fc19b80-812c-11eb-960c-8f7da3b2597f.png\" alt=\"image\"></p>\n<p>파이토치에 제공하는 도큐멘트를 살펴보면 학습시 무작위로 몇개의 뉴런들에 대해서 <em>p</em> 확률만큼  ‘zeros’ 시킨다고 나와있다. 이때 <em>p</em>는 parameter로 주어지는 확률 변수이고, default는 0.5이다. <code class=\"language-text\">forward</code>함수가 호출될 때마다 적용되도록 되어 있다. <br></p>\n<h3 id=\"-코드에서-dropout\" style=\"position:relative;\"><a href=\"#-%EC%BD%94%EB%93%9C%EC%97%90%EC%84%9C-dropout\" aria-label=\" 코드에서 dropout permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>> 코드에서 Dropout</h3>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\">#def __init__ 메소드 내:</span>\n\tself<span class=\"token punctuation\">.</span>drop1 <span class=\"token operator\">=</span> nn<span class=\"token punctuation\">.</span>Dropout<span class=\"token punctuation\">(</span><span class=\"token number\">0.1</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>본 코드를 살펴보면 nn.torch 모둘에서 Dropout 함수를 호출하고 확률 변수를 0.1로 주었다. <br></p>\n<h2 id=\"step4-활성화함수---torchnnfunctionalrelu\" style=\"position:relative;\"><a href=\"#step4-%ED%99%9C%EC%84%B1%ED%99%94%ED%95%A8%EC%88%98---torchnnfunctionalrelu\" aria-label=\"step4 활성화함수   torchnnfunctionalrelu permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Step4. 활성화함수 - torch.nn.functional.relu()</h2>\n<p>다음 딥러닝 신경망 모델 구축에서 중요한 부분은 활성화 함수(Activation Function)이다. 활성화 함수는 최종출력 신호 후, 다음 뉴런으로 보낼지 말지를 결정하는 함수이다. 즉, 특정 뉴런이 다음 뉴런으로 신호를 보낼 때 입력신호의 어떠한 기준에 따라서 보내고 보내지 않는지를 결정하도록 하는 것이다. 딥러닝에서는 뉴런들을 다음 레이어로 전달할 때 비선형 함수를 통화시킨 후 전달하도록 하는데 이때 사용되는 함수가 활성화 함수이다. <br></p>\n<p>딥러닝 학습의 핵심은 이름에서 볼 수 있듯이 깊게 층을 쌓아서 그 층을 통과하면서 학습되는 것인데, 선형함수를 사용하게 되면 층을 깊게 하는 의미가 줄어들게 된다. 해당 설명은 [밑바닥부터 시작하는 딥러닝] 책의 한 부분을 인용하도록 하겠다. <br></p>\n<blockquote>\n<p>선형합수인 h(x)=cx를 활성화함수로 사용한 3층 네트워크를 떠올려 보세요. 이를 식으로 나타내면 y(x) = h(h(h(x)))가 됩니다. 이는 실은 y(x)=ax와 똑같은 식 입니다. a=c3이라고 하면 끝이죠. 즉, 은닉층이 없는 네트워크로 표현할 수 있습니다. 뉴럴네트워크에서 층을 쌓는 혜택을 얻고 싶다면 활성화 함수로는 반드시 비선형 함수를 사용해야 한다.</p>\n<p>-밑바닥부터 시작하는 딥러닝-</p>\n</blockquote>\n<p>이러한 역할을 하는 활성화 함수는 많은 종류가 있다. <strong>1) 시그모이드 함수 2) tanh 함수 3) ReLU 함수.</strong>  본 코드에서는 가장 많이 사용되는 활성화 함수인 ReLU 함수를 사용했다. <br></p>\n<p><img src=\"https://user-images.githubusercontent.com/63405904/110482937-8b448600-812c-11eb-9672-04dc7c7e5928.png\" alt=\"image\"></p>\n<p>ReLU 함수를 살펴보면 $x > 0$ 이면 기울기가 1인 직선이고 $x &#x3C; 0$이면 함수값이 0이 된다. 따라서 다른 활성화함수에 비해서 굉장히 간단하고 빠르다. 해당 함수는 양수에서는 Linear function 과 같은 모습을 보이지만 음수의 경우 0으로 버려지므로 non-linear 한 함수로 작동하여 layer를 깊게 쌓을 수 있는 장점을 가진다. <br></p>\n<h3 id=\"-코드에서-활성화함수\" style=\"position:relative;\"><a href=\"#-%EC%BD%94%EB%93%9C%EC%97%90%EC%84%9C-%ED%99%9C%EC%84%B1%ED%99%94%ED%95%A8%EC%88%98\" aria-label=\" 코드에서 활성화함수 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>> 코드에서 활성화함수</h3>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\">#def forward 내</span>\n\tx <span class=\"token operator\">=</span> F<span class=\"token punctuation\">.</span>relu<span class=\"token punctuation\">(</span>torch<span class=\"token punctuation\">.</span>cat<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>U<span class=\"token punctuation\">,</span> V<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> dim<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>선형함수가 linear layer에 들어가기 전에 비선형 함수를 거친다. 위의 코드에서 F는 <code class=\"language-text\">torch.nn.funtional</code>모듈이며 모듈 내에 있는 <code class=\"language-text\">relu()</code>를 사용하고 있다. <br></p>\n<br>\n<br>\n<p><strong><small> [참고 자료]: <a href=\"https://wikidocs.net/64779,%C2%A0https://tutorials.pytorch.kr/beginner/blitz/neural_networks_tutorial.html,%C2%A0https://pytorch.org/docs/,%C2%A0https://yeomko.tistory.com/39,%C2%A0https://reniew.github.io/12/,%C2%A0https://eda-ai-lab.tistory.com/405,%C2%A0https://jyoondev.tistory.com/65?category=823946,%C2%A0https://sacko.tistory.com/45\">https://wikidocs.net/64779, https://tutorials.pytorch.kr/beginner/blitz/neural_networks_tutorial.html, https://pytorch.org/docs/, https://yeomko.tistory.com/39, https://reniew.github.io/12/, https://eda-ai-lab.tistory.com/405, https://jyoondev.tistory.com/65?category=823946, https://sacko.tistory.com/45</a></small></strong></p>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#%EB%AA%A8%EB%8D%B8-%EC%A0%84%EC%B2%B4-%EC%BD%94%EB%93%9C\">모델 전체 코드</a></p>\n</li>\n<li>\n<p><a href=\"#step1-%EC%9E%84%EB%B2%A0%EB%94%A9---nnembedding\">Step1. 임베딩 - nn.Embedding()</a></p>\n<ul>\n<li><a href=\"#-%EC%BD%94%EB%93%9C%EC%97%90%EC%84%9C-%EC%9E%84%EB%B2%A0%EB%94%A9\">> 코드에서 임베딩</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#step2-linear-layer-%EC%83%9D%EC%84%B1---nnlinear\">Step2. Linear Layer 생성 - nn.Linear()</a></p>\n<ul>\n<li><a href=\"#-%EC%BD%94%EB%93%9C%EC%97%90%EC%84%9C-layer-%EC%83%9D%EC%84%B1\">> 코드에서 layer 생성</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#step3-%EB%AA%A8%EB%8D%B8-%EC%9D%BC%EB%B0%98%ED%99%94---nndropout\">Step3. 모델 일반화 - nn.Dropout()</a></p>\n<ul>\n<li><a href=\"#-%EC%BD%94%EB%93%9C%EC%97%90%EC%84%9C-dropout\">> 코드에서 Dropout</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#step4-%ED%99%9C%EC%84%B1%ED%99%94%ED%95%A8%EC%88%98---torchnnfunctionalrelu\">Step4. 활성화함수 - torch.nn.functional.relu()</a></p>\n<ul>\n<li><a href=\"#-%EC%BD%94%EB%93%9C%EC%97%90%EC%84%9C-%ED%99%9C%EC%84%B1%ED%99%94%ED%95%A8%EC%88%98\">> 코드에서 활성화함수</a></li>\n</ul>\n</li>\n</ul>\n</div>","frontmatter":{"date":"August 22, 2020","title":"[머신러닝] 딥러닝 영화 개인화 추천 - Part.2","categories":"머신러닝","author":"코다","emoji":"🪄"},"fields":{"slug":"/movie-dlrm-2/"}},"site":{"siteMetadata":{"siteUrl":"https://yjksw.github.io","comments":{"utterances":{"repo":"yjksw/yjksw.github.io"}}}}},"pageContext":{"slug":"/movie-dlrm-1/","nextSlug":"/ml-recommendation-system/","prevSlug":"/movie-dlrm-2/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}
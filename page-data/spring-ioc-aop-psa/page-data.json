{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/spring-ioc-aop-psa/",
    "result": {"data":{"cur":{"id":"b07a3ebb-de77-55b2-820a-0f1162a587a2","html":"<h2 id=\"-intro\" style=\"position:relative;\"><a href=\"#-intro\" aria-label=\" intro permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>💡 Intro</h2>\n<ul>\n<li>스프링에서 어느날 등장한 개념은 아니고 어떠한 이름으로든 사용이 되고 있던 기술인데 스프링에서 더 잘 사용되도록 특정 형태를 부여했다.</li>\n<li>이 3가지 기술들이 그 자체로 스프링이기보다 POJO 기반 엔터프라이즈 개발을 편하게 해줄 수 있는 일종의 도구이다. 즉, 객체지향적인 구현에 충실하면서 자연스럽게 등장하게 된 결과라고 할 수 있다.</li>\n<li>스프링에서 제공하는 PSA, AOP만 사용하는 것이 아니라 그 개념을 차출하여 객체지향적 구현을 하는 것이 중요하다.</li>\n</ul>\n<br>\n<h2 id=\"-iocdi\" style=\"position:relative;\"><a href=\"#-iocdi\" aria-label=\" iocdi permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 IoC/DI</h2>\n<ul>\n<li>AOP, PSA도 IoC/DI에 바탕을 두고 있는 기술이다.</li>\n<li>느슨한 결합을 위해 인터페이스를 두고 실제 구현체를 DI를 통해 외부에서 주입하는 것이다.</li>\n</ul>\n<h3 id=\"왜-강한-결합보다-느슨한-결합이-나은가\" style=\"position:relative;\"><a href=\"#%EC%99%9C-%EA%B0%95%ED%95%9C-%EA%B2%B0%ED%95%A9%EB%B3%B4%EB%8B%A4-%EB%8A%90%EC%8A%A8%ED%95%9C-%EA%B2%B0%ED%95%A9%EC%9D%B4-%EB%82%98%EC%9D%80%EA%B0%80\" aria-label=\"왜 강한 결합보다 느슨한 결합이 나은가 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>왜 강한 결합보다 느슨한 결합이 나은가?</h3>\n<ul>\n<li>유연한 확장이 가능하게 하기 위해서 → OCP</li>\n<li>변경에 닫혀있다는 것은 <strong>재사용이 가능하다</strong> 라는 뜻이다.\n<ul>\n<li>A → B 의존관계일 때 B가 변경이 되어도 A가 아무 영향을 받지 않으면 A 입장에서는 폐쇄이며 B 관점에서는 유연한 확장이다.</li>\n<li>B가 B1, B2, B3로 바뀔수도 있고, A는 그대로 재사용이 가능하기 때문이다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"di의-활용-방법-및-장점\" style=\"position:relative;\"><a href=\"#di%EC%9D%98-%ED%99%9C%EC%9A%A9-%EB%B0%A9%EB%B2%95-%EB%B0%8F-%EC%9E%A5%EC%A0%90\" aria-label=\"di의 활용 방법 및 장점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>DI의 활용 방법 및 장점</h3>\n<ol>\n<li>핵심기능의 변경\n<ul>\n<li>구현체를 바꿀 수 있다.</li>\n<li>예를 들어 DAO를 사용하고 그 구현을 JDBC, JPA 하이버네이트, JDO 등으로 바꿀 수 있다.</li>\n</ul>\n</li>\n<li>핵심기능의 동적인 변겅\n<ul>\n<li>애플리케이션 동작 중간에 의존 대상을 다이나믹하게 변경할 수 있다.</li>\n<li>예를들어 사용자의 입력에 따라서 다른 DataSource를 사용하게 만들 수 있다.</li>\n<li>기술적으로 프록시를 활용한 것인데 이것은 DI 없이는 불가능한 기술이다.</li>\n</ul>\n</li>\n<li>부가기능의 추가\n<ul>\n<li>핵심 기능은 그대로 둔 채 부가기능을 추가하는 데코레이터 패턴과 같은 것이다.</li>\n<li>DI를 사용해서 데코레이터 패턴을 쉽게 적용할 수 있다.</li>\n<li>클라이언트 코드에는 영향을 주지 않으면서 부가기능 추가가 가능하다.</li>\n<li>부가 작업을 특정 오브젝트를 대상으로 하는 것이 아니라 많은 대상으로 일반화 한다면 AOP가 되는 것이다.</li>\n</ul>\n</li>\n<li>인터페이스의 변경\n<ul>\n<li>클라이언트에서 사용하는 인터페이스와 오브젝트의 인터페이스가 일치하지 않을 때 DI를 활용하여 어댑터 패턴을 응용할 수 있다.</li>\n<li>예를 들어 A가 B인터페이스에 의존하지만 C 오브젝트를 사용하고자 할 때, B 인터페이스를 상속하고 C기능을 제공하는 어댑터를 구현하여 해결할 수 있다.</li>\n<li>일반화하여 인터페이스가 다양한 구현을 같은 방식으로 사용하도록 할 수도 있다. → PSA\n<ul>\n<li>구현체는 다양하지만 클라이언트 입장에서는 같은 방식으로 늘 사용하는 것이다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>프록시\n<ul>\n<li>필요한 시점에서 실제로 사용할 오브젝트를 초기화해고 지연된 로딩을 적용할 때 사용할 수 있다.</li>\n</ul>\n</li>\n<li>템플릿과 콜백\n<ul>\n<li>작업의 흐름 사이에 자주 바뀌는 부분을 템플릿과 콜백으로 만들고 DI 원리를 사용하면 코드를 간결하게 구현할 수 있다.</li>\n</ul>\n</li>\n<li>싱글톤과 오브젝트 스코프\n<ul>\n<li>DI하는 오브젝트의 생명주기를 제어할 수 있다. DI를 컨테이너가 한다면 오브젝트의 생명주기를 마음대로 관리하고 제어할 수 있다.</li>\n<li>기본 스코프는 싱글톤이다. 웹 엔터프라이즈는 수많은 클라이언트를 대상으로 서비스를 제공해야하기 때문에 여러 스레드의 요청을 동시에 처리할 수 있도록 하기 위해서다.</li>\n<li>전통적인 싱글톤은 오브젝트에 많은 제약을 가했지만 IoC 방식의 싱글톤은 자유로운 설계가 가능하다.</li>\n</ul>\n</li>\n<li>테스트\n<ul>\n<li>오브젝트를 효과적으로 테스트하기 위해서는 오브젝트가 고립되어야 한다.</li>\n<li>다른 오브젝트와 협력하는 부분을 테스트하기 위해서는 환경 전체를 테스트해야한다는 부담감이 있다.</li>\n<li>DI를 한다면 의존 오브젝트를 대신하여 스텁 혹은 목 오브젝트 같이 테스트 대역을 할 수 있다.\n<ul>\n<li>\n<p>번외) stub과 mock의 차이</p>\n<p>stub은 더미 객체를 사용하여 실제로 동작하는 것 처럼 보이도록 하는 것이다. 상태검증을 한다.</p>\n<p>mock은 기대값을 명세하고 특정 결과를 반환하도록 하는 것이다. 행위검증을 한다.</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<br>\n<h2 id=\"-aop\" style=\"position:relative;\"><a href=\"#-aop\" aria-label=\" aop permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 AOP</h2>\n<ul>\n<li>관점 지향 프로그래밍이라고도 많이 알려져 있다.</li>\n<li>관심사가 같은 코드를 분리해 객체지향의 원칙에 따라서 분리하고 응집된 것들을 한 곳에 모으는 것이 좋다.</li>\n<li>트랜잭션의 경우\n<ul>\n<li>트랜잭션은 한 곳에 모을 수 없고 여기저기에 흩어져있다. 따라서 모듈화가 힘들다.</li>\n<li>부가기능이기 때문에 스스로 독립적인 방식으로 존재하는 것이 어렵다.</li>\n<li>흩어져있는 부가로직을 분리하여 중복되지 않고, 변경이 필요한 경우 한 곳만 변경할 수 있도록 하는 것이 AOP의 역할이다.</li>\n</ul>\n</li>\n<li>Aspect는 부가 기능을 정의한 advice와 해당 advice를 적용할 포인트컷을 가지고 있다.</li>\n<li>부가기능이 핵심기능 모듈에 침투하면서 핵심기능을 파악하고 수정하고 테스트하기 어렵다.</li>\n<li>AOP와 OOP\n<ul>\n<li>AOP와 OOP가 대체관계라고 생각할 수 있지만 사실 보조하는 기술이다.</li>\n<li>부가기능이 핵심기능 안으로 침투하면 핵심기능에 객체지향 기술을 부여하기 힘들고 테스트하기 어려움으로 AOP로 해당 로직을 분리하여 객체지향적인 가치를 지킬 수 있도록 해주는 것이다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-psa\" style=\"position:relative;\"><a href=\"#-psa\" aria-label=\" psa permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 PSA</h2>\n<ul>\n<li>환경과 세부 기술의 변화와 관계없이 일관된 방식으로 기술에 접근할 수 있다.</li>\n<li>POJO 코드가 JavaEE에 직접 노출되지 않도록 해준다.\n<ul>\n<li>예를 들어서 트랜잭션이라는 엔터프라이즈 기술을 직접 POJO에 노출하는 것이 아니라 일관적인 서비스 추상화 기술의 형태로 제공해준다.</li>\n</ul>\n</li>\n<li>대신 설정을 통해 추상화 된 부분에 어떤 기술을 할 것인지 지정해주어야한다.</li>\n</ul>\n<br>\n<h2 id=\"-느낀-점\" style=\"position:relative;\"><a href=\"#-%EB%8A%90%EB%82%80-%EC%A0%90\" aria-label=\" 느낀 점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🛋 느낀 점</h2>\n<ul>\n<li>스프링 프레임워크의 목적은 “엔터프라이즈 기술을 사용하되 비즈니스 로직을 객체지향적으로 구현하고자 하는 것”이다.</li>\n<li>이해하기 어려운 스프링 프레임워크의 기술도 이 관점으로 보면 나름 이해할 수 있다.</li>\n<li>그리고 그 모든 기술의 기반은 바로 DI 다 !! 추상적으로 구현하여 확장성을 보장하고 변경에 자유로운 객체지향적 코드를 구현할 수 있도록 해준다.</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#-intro\">💡 Intro</a></p>\n</li>\n<li>\n<p><a href=\"#-iocdi\">🌩 IoC/DI</a></p>\n<ul>\n<li><a href=\"#%EC%99%9C-%EA%B0%95%ED%95%9C-%EA%B2%B0%ED%95%A9%EB%B3%B4%EB%8B%A4-%EB%8A%90%EC%8A%A8%ED%95%9C-%EA%B2%B0%ED%95%A9%EC%9D%B4-%EB%82%98%EC%9D%80%EA%B0%80\">왜 강한 결합보다 느슨한 결합이 나은가?</a></li>\n<li><a href=\"#di%EC%9D%98-%ED%99%9C%EC%9A%A9-%EB%B0%A9%EB%B2%95-%EB%B0%8F-%EC%9E%A5%EC%A0%90\">DI의 활용 방법 및 장점</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-aop\">🌩 AOP</a></p>\n</li>\n<li>\n<p><a href=\"#-psa\">🌩 PSA</a></p>\n</li>\n<li>\n<p><a href=\"#-%EB%8A%90%EB%82%80-%EC%A0%90\">🛋 느낀 점</a></p>\n</li>\n</ul>\n</div>","excerpt":"💡 Intro 스프링에서 어느날 등장한 개념은 아니고 어떠한 이름으로든 사용이 되고 있던 기술인데 스프링에서 더 잘 사용되도록 특정 형태를 부여했다. 이 3가지 기술들이 그 자체로 스프링이기보다 POJO 기반 엔터프라이즈 개발을 편하게 해줄 수 있는 일종의 도구이다. 즉, 객체지향적인 구현에 충실하면서 자연스럽게 등장하게 된 결과라고 할 수 있다. 스프링에서 제공하는 PSA, AOP만 사용하는 것이 아니라 그 개념을 차출하여 객체지향적 구현을 하는 것이 중요하다. 🌩 IoC/DI AOP, PSA도 IoC/DI에 바탕을 두고 있는 기술이다. 느슨한 결합을 위해 인터페이스를 두고 실제 구현체를 DI를 통해 외부에서 주입하는 것이다. 왜 강한 결합보다 느슨한 결합이 나은가? 유연한 확장이 가능하게 하기 위해서 → OCP 변경에 닫혀있다는 것은 재사용이 가능하다 라는 뜻이다. A → B 의존관계일 때 B가 변경이 되어도 A가 아무 영향을 받지 않으면 A 입장에서는 폐쇄이며 B 관점에서는 …","frontmatter":{"date":"November 16, 2021","title":"스프링 3대 개념 - IoC/DI, AOP, PSA","categories":"스프링 웹","author":"코다","emoji":"🍀"},"fields":{"slug":"/spring-ioc-aop-psa/"}},"next":{"id":"c988bf66-5fcc-5cb8-a6d8-82290bf4de3a","html":"<h2 id=\"-intro\" style=\"position:relative;\"><a href=\"#-intro\" aria-label=\" intro permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>💡 Intro</h2>\n<ul>\n<li>POJO에 대해서 ‘그냥 자바 객체요!’라고 말하는 것 이상으로 이해해보자.</li>\n<li>POJO기반 프레임워크란 무엇인지 이해해보고 스프링에서 POJO는 어떠한 형태를 띄는지 알아보자</li>\n<li>스프링이 개발의 복잡도를 낮춰주고 효과적으로 프로그래밍을 할 수 있도록 구체적으로 <strong>어떻게</strong> 가능하게 하는지 공부해보자.</li>\n</ul>\n<br>\n<h2 id=\"-pojo-란\" style=\"position:relative;\"><a href=\"#-pojo-%EB%9E%80\" aria-label=\" pojo 란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 POJO 란?</h2>\n<ul>\n<li>\n<p>유명한 스프링의 삼각형으로 기본 컨텍스트를 맞추고 설명을 시작해보자.</p>\n<ul>\n<li>스프링은 POJO에 주요기술인 IoC/DI, AOP, PSA를 사용한 코드와 POJO가 어떻게 관계를 맺고 동작하는지 정의한 설계정보로 구분된다.</li>\n</ul>\n<p align=\"center\"><img width=\"80%\" src=\"https://user-images.githubusercontent.com/63405904/142145957-19052d27-8363-4f06-9a36-5527c8eaf391.png\"></p>\n</li>\n<li>\n<p>스프링에서 DI는 <strong>유연하게 확장 가능한 오브젝트를 만들고, 그 관계를 외부에서 dynamic하게 설정해주는 것</strong>이며 스프링에서는 이 아이디어를 전반에 걸쳐서 적용한다.</p>\n</li>\n<li>\n<p>POJO는 EJB처럼 복잡하고 제한이 많은 기술로 엔터프라이즈 애플리케이션의 비지니스 로직을 구현하는 것보다 순수 자바 객체를 사용하여 비지니스 로직을 구현하는 것이 더 좋다고 생각하여 나온 개념이다.</p>\n</li>\n</ul>\n<h3 id=\"pojo의-조건\" style=\"position:relative;\"><a href=\"#pojo%EC%9D%98-%EC%A1%B0%EA%B1%B4\" aria-label=\"pojo의 조건 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>POJO의 조건</h3>\n<ol>\n<li>특정 규약에 종속되지 않는다.\n<ul>\n<li>자바 언어와 필요 API를 제외하고 다른 것에 종속되지 말아야 한다.\n<ul>\n<li>특정 규약에 따른 비지니스 컴포넌트를 만들어야하면 POJO가 아니다.</li>\n<li>또한 특정 클래스를 상속해서 만들어야하면 POJO가 아니다 → 단일 상속 제한 때문에 객체지향적인 설계 기법을 적용하기 어렵다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>특정 환경에 종속되지 않는다.\n<ul>\n<li>특정 무언가가 없는 환경에서 그대로 사용하기가 어렵다면 POJO가 아니다.</li>\n<li>그렇다면 JPA를 사용하는 Service 클래스는 POJO라고 할 수 있을까? 🤔\n<ul>\n<li>Service 클래스에서 의존하고 있는 JPA 레파지토리는 구현체인 하이버네이트에 의존하기 보다는 표준 스펙을 정의한 인터페이스이다. 따라서 POJO 프레임워크를 제공하는 것이라고 할 수 있다.</li>\n<li>그런 도메인의 인터페이스에 의존하는 서비스는 POJO라고 할 수 있을 것 같다.</li>\n<li>개인적인 의견이므로 틀리면 댓글로 얼마든지 알려주세요 🙌</li>\n</ul>\n</li>\n<li>특정 벤더의 서버나 프레임워크 안에서만 동작 가능한 코드는 POJO가 아니다.</li>\n<li>웹이라는 환경정보나 웹 기술을 담고 있는 클래스나 인터페이스를 사용하는 것은 POJO가 아니다.\n<ul>\n<li>예를 들어 비즈니스 코드에 HttpServletRequest나 HttpSession 등의 API가 등장하거나 클래스에서 그것을 직접 이용한다면 POJO가 아니다.</li>\n<li>웹 이외의 클라이언트는 해당 객체를 사용하지 못하며 독립적으로 테스트하기 어려워진다.</li>\n</ul>\n</li>\n<li>어노테이션을 쓰면 POJO가 아니다 라고 말할수는 없다. 해당 어노테이션이 환경에 종속되지 않고 부가적인 정보를 담고 있다면 POJO라고 할 수 있다.\n<ul>\n<li>만일 해당 어노테이션이 element에 특정 기술에 환경에 종속적인 정보를 담고 있다면 POJO라고 할 수 없다.\n<ul>\n<li>개인적인 의견) 따라서 JPA의 <code class=\"language-text\">@Entity</code>가 붙은 클래스는 POJO라고 할 수 없을 것 같다. @Id가 반드시 있어야하는 등의 제약사항이 있기 때문이다.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>그렇다고 위 2조건을 만족하는 나머지가 모두 POJO인 것은 아니다!\n<ul>\n<li>객체지향적인 자바의 언어를 잘 활용한 것이 POJO이다.</li>\n<li>재사용이 가능하고 상속과 다형성을 적용하여 객체지향적으로 설계된 오브젝트를 말한다.</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"pojo의-장점\" style=\"position:relative;\"><a href=\"#pojo%EC%9D%98-%EC%9E%A5%EC%A0%90\" aria-label=\"pojo의 장점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>POJO의 장점</h3>\n<ul>\n<li>기술과 환경에 종속되지 않으면 깔끔한 코드를 짤 수 있으며 순수 비즈니스 로직을 담을 수 있다.</li>\n<li>테스트 작성이나 검증이 쉽다.</li>\n<li>기술이나 환경의 변화에 취약하지 않다.</li>\n<li>재사용이 가능하고, 변경에 자유로우며, 확장이 용이한 객체지향적 설계가 가능하다.</li>\n</ul>\n<br>\n<h2 id=\"-pojo-프레임워크\" style=\"position:relative;\"><a href=\"#-pojo-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC\" aria-label=\" pojo 프레임워크 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 POJO 프레임워크</h2>\n<ul>\n<li>“스프링의 정수는 엔터프라이즈 서비스 기능을 POJO에 제공하는 것” 이라고 한다.</li>\n<li>즉, 트랜잭션과 같이 엔터프라이즈 시스템에서 필요한 기술을 순수 자바 객체에서 가능하게 한다는 것이다.</li>\n<li>다시 말하면 엔터프라이즈 서비스 기술과 자바 객체(POJO)를 효과적으로 분리했다는 의미이며 스프링의 가장 큰 장점이다.</li>\n<li>POJO 프로그래밍이 가능하도록 기술적인 기반을 제공하는 것이 POJO 프레임워크이다. 하이버네이트와 스프링이 대표적인 POJO 프레임워크이다.</li>\n<li>스프링은 POJO 기반으로 구현하고 엔터프라이즈 환경의 서비스와 기술을 POJO 방식으로 구현된 코드에 적용할 수 있다.\n<ul>\n<li>비즈니스 로직과 엔터프라이즈 기술을 분리하여 구성한다.</li>\n<li>스프링은 기술영역에만 관여하고 비즈니스 로직을 다루는 POJO에서 모습을 드러내지 않는다.</li>\n<li>데이터 액세스 로직이나 웹 UI 로직에서 최소한의 방법으로 관여한다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-느낀-점\" style=\"position:relative;\"><a href=\"#-%EB%8A%90%EB%82%80-%EC%A0%90\" aria-label=\" 느낀 점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🛋 느낀 점</h2>\n<ul>\n<li>개발자가 POJO 프레임워크를 사용한다고 해서 자동으로 객체지향적인 코드를 짜는 것은 아니다.</li>\n<li>객체지향적 코드가 가능한 기반에서 어떻게 효과적으로 객체지향적 설계를 잘 할지는 개발자의 남은 몫이다.\n<ul>\n<li>JVM, JDK API, 디자인패턴에 대해서 잘 공부하고 적용할 수 있도록 공부해야겠다.</li>\n</ul>\n</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#-intro\">💡 Intro</a></p>\n</li>\n<li>\n<p><a href=\"#-pojo-%EB%9E%80\">🌩 POJO 란?</a></p>\n<ul>\n<li><a href=\"#pojo%EC%9D%98-%EC%A1%B0%EA%B1%B4\">POJO의 조건</a></li>\n<li><a href=\"#pojo%EC%9D%98-%EC%9E%A5%EC%A0%90\">POJO의 장점</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-pojo-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC\">🌩 POJO 프레임워크</a></p>\n</li>\n<li>\n<p><a href=\"#-%EB%8A%90%EB%82%80-%EC%A0%90\">🛋 느낀 점</a></p>\n</li>\n</ul>\n</div>","frontmatter":{"date":"November 15, 2021","title":"스프링, POJO 프레임워크가 무슨 뜻일까","categories":"스프링 웹","author":"코다","emoji":"🍀"},"fields":{"slug":"/spring-pojo/"}},"prev":{"id":"00e80243-2a3a-528a-8625-03c3c7bfbedb","html":"<h2 id=\"-intro\" style=\"position:relative;\"><a href=\"#-intro\" aria-label=\" intro permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>💡 Intro</h2>\n<ul>\n<li>JVM은 자바의 큰 장점 중 하나로 이 가상머신이 깔려있는 운영체제에서는 모두 동일하게 자바 클래스 파일이 실행될 수 있다.</li>\n<li>JVM의 기본 구조를 알아보자 🙌</li>\n</ul>\n<br>\n<h2 id=\"-jvm-메모리-구조\" style=\"position:relative;\"><a href=\"#-jvm-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0\" aria-label=\" jvm 메모리 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 JVM 메모리 구조</h2>\n<p><strong>1) Class Loader 2) Execution Engine 3) Garbage Collector 4) Runtime Data Area</strong> 4가지로 나뉘어져 있다.</p>\n<h3 id=\"class-loader\" style=\"position:relative;\"><a href=\"#class-loader\" aria-label=\"class loader permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Class Loader</h3>\n<ul>\n<li>JVM 내로 클래스 파일을 로드하고 링크를 통해 배치하는 작업을 수행한다.</li>\n<li>런타임 시에 동적으로 클래스를 로드한다.</li>\n</ul>\n<h3 id=\"execution-engine\" style=\"position:relative;\"><a href=\"#execution-engine\" aria-label=\"execution engine permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Execution Engine</h3>\n<ul>\n<li>클래스 로더가 Runtime Data Area에 배치한 바이트 코드들을 명령어 단위로 읽어서 실행하는 작업을 수행한다.</li>\n<li>최초 JVM에서는 인터프리터 방식이어서 느렸지만 JIT 컴파일러로 변경되면서 실행이 빠르다는 장점이 있다.</li>\n<li>모든 코드 JIT으로 하지 않고 인터프리터로 하다가 일정한 기준이 넘어가면 JIT 컴파일러 방식으로 실행한다.\n<ul>\n<li>한번 읽어서 기계어로 변경한 소스코드는 변역하지 않는다.</li>\n<li>저장소에 저장하여 반복되는 코드는 한꺼번에 컴파일하여서 사용한다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"garbage-collector\" style=\"position:relative;\"><a href=\"#garbage-collector\" aria-label=\"garbage collector permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Garbage Collector</h3>\n<ul>\n<li>힙 메모리 영역에 객체 중 더이상 참조되지 않는 객체들을 제거하는 역할을 한다.\n<ul>\n<li>Reference Counting 혹은 Mark-and-sweep 방식을 사용</li>\n<li>Minor GC(eden, survivor1, survivor2)와 Major GC(old)</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"runtime-data-area\" style=\"position:relative;\"><a href=\"#runtime-data-area\" aria-label=\"runtime data area permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Runtime Data Area</h3>\n<ul>\n<li>애플리케이션이 실행할 때 사용되는 데이터를 적재하는 영역\n<ul>\n<li><strong>Method Area</strong> → 모든 스레드가 공유하는 메모리 영역으로 클래스, 인터페이스, 메소드, 필드, static 변수 등의 바이트 코드를 보관</li>\n<li><strong>Heap Area</strong> → 모든 스레드가 공유하며 new 키워드로 생성된 객체와 배열이 생성되는 영역</li>\n<li><strong>Stack Area</strong> → 메서드 호출시마다 스택 프레임을 생성하여 매개변수, 지역변수, 리턴 값, 연산 시 값들을 임시로 저장하며 메서드 수행이 끝나면 프레임을 삭제</li>\n<li><strong>PC Register</strong> → 쓰레드 시작 시 생성되며 스레드마다 하나씩 존재하고 무슨 명령어를 실행할지 명령의 주소 보관</li>\n<li><strong>Native Method Stack</strong> → 자바 외 언어로 작성된 네이티브 코드를 저장하는 메모리</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-느낀-점\" style=\"position:relative;\"><a href=\"#-%EB%8A%90%EB%82%80-%EC%A0%90\" aria-label=\" 느낀 점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🛋 느낀 점</h2>\n<ul>\n<li>JVM의 구조를 알고 있어야지 자바 코드가 실행되는 부분이 일종의 ‘매직’처럼 남아있지 않고 구체화 되어서 그려질 것 같다.</li>\n<li>공부를 할수록 그냥 되는줄 알았던 부분들이 차츰차츰 명료해지는 것 같다.</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#-intro\">💡 Intro</a></p>\n</li>\n<li>\n<p><a href=\"#-jvm-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0\">🌩 JVM 메모리 구조</a></p>\n<ul>\n<li><a href=\"#class-loader\">Class Loader</a></li>\n<li><a href=\"#execution-engine\">Execution Engine</a></li>\n<li><a href=\"#garbage-collector\">Garbage Collector</a></li>\n<li><a href=\"#runtime-data-area\">Runtime Data Area</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-%EB%8A%90%EB%82%80-%EC%A0%90\">🛋 느낀 점</a></p>\n</li>\n</ul>\n</div>","frontmatter":{"date":"November 17, 2021","title":"JVM 구조 알아보기","categories":"자바","author":"코다","emoji":"✊"},"fields":{"slug":"/java-jvm/"}},"site":{"siteMetadata":{"siteUrl":"https://yjksw.github.io","comments":{"utterances":{"repo":"yjksw/yjksw.github.io"}}}}},"pageContext":{"slug":"/spring-ioc-aop-psa/","nextSlug":"/spring-pojo/","prevSlug":"/java-jvm/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}
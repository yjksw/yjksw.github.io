{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/spring-ioc-aop-psa/",
    "result": {"data":{"cur":{"id":"b07a3ebb-de77-55b2-820a-0f1162a587a2","html":"<h2 id=\"-intro\" style=\"position:relative;\"><a href=\"#-intro\" aria-label=\" intro permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>💡 Intro</h2>\n<ul>\n<li>스프링에서 어느날 등장한 개념은 아니고 어떠한 이름으로든 사용이 되고 있던 기술인데 스프링에서 더 잘 사용되도록 특정 형태를 부여했다.</li>\n<li>이 3가지 기술들이 그 자체로 스프링이기보다 POJO 기반 엔터프라이즈 개발을 편하게 해줄 수 있는 일종의 도구이다. 즉, 객체지향적인 구현에 충실하면서 자연스럽게 등장하게 된 결과라고 할 수 있다.</li>\n<li>스프링에서 제공하는 PSA, AOP만 사용하는 것이 아니라 그 개념을 차출하여 객체지향적 구현을 하는 것이 중요하다.</li>\n</ul>\n<br>\n<h2 id=\"-iocdi\" style=\"position:relative;\"><a href=\"#-iocdi\" aria-label=\" iocdi permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 IoC/DI</h2>\n<ul>\n<li>AOP, PSA도 IoC/DI에 바탕을 두고 있는 기술이다.</li>\n<li>느슨한 결합을 위해 인터페이스를 두고 실제 구현체를 DI를 통해 외부에서 주입하는 것이다.</li>\n</ul>\n<h3 id=\"왜-강한-결합보다-느슨한-결합이-나은가\" style=\"position:relative;\"><a href=\"#%EC%99%9C-%EA%B0%95%ED%95%9C-%EA%B2%B0%ED%95%A9%EB%B3%B4%EB%8B%A4-%EB%8A%90%EC%8A%A8%ED%95%9C-%EA%B2%B0%ED%95%A9%EC%9D%B4-%EB%82%98%EC%9D%80%EA%B0%80\" aria-label=\"왜 강한 결합보다 느슨한 결합이 나은가 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>왜 강한 결합보다 느슨한 결합이 나은가?</h3>\n<ul>\n<li>유연한 확장이 가능하게 하기 위해서 → OCP</li>\n<li>변경에 닫혀있다는 것은 <strong>재사용이 가능하다</strong> 라는 뜻이다.\n<ul>\n<li>A → B 의존관계일 때 B가 변경이 되어도 A가 아무 영향을 받지 않으면 A 입장에서는 폐쇄이며 B 관점에서는 유연한 확장이다.</li>\n<li>B가 B1, B2, B3로 바뀔수도 있고, A는 그대로 재사용이 가능하기 때문이다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"di의-활용-방법-및-장점\" style=\"position:relative;\"><a href=\"#di%EC%9D%98-%ED%99%9C%EC%9A%A9-%EB%B0%A9%EB%B2%95-%EB%B0%8F-%EC%9E%A5%EC%A0%90\" aria-label=\"di의 활용 방법 및 장점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>DI의 활용 방법 및 장점</h3>\n<ol>\n<li>핵심기능의 변경\n<ul>\n<li>구현체를 바꿀 수 있다.</li>\n<li>예를 들어 DAO를 사용하고 그 구현을 JDBC, JPA 하이버네이트, JDO 등으로 바꿀 수 있다.</li>\n</ul>\n</li>\n<li>핵심기능의 동적인 변겅\n<ul>\n<li>애플리케이션 동작 중간에 의존 대상을 다이나믹하게 변경할 수 있다.</li>\n<li>예를들어 사용자의 입력에 따라서 다른 DataSource를 사용하게 만들 수 있다.</li>\n<li>기술적으로 프록시를 활용한 것인데 이것은 DI 없이는 불가능한 기술이다.</li>\n</ul>\n</li>\n<li>부가기능의 추가\n<ul>\n<li>핵심 기능은 그대로 둔 채 부가기능을 추가하는 데코레이터 패턴과 같은 것이다.</li>\n<li>DI를 사용해서 데코레이터 패턴을 쉽게 적용할 수 있다.</li>\n<li>클라이언트 코드에는 영향을 주지 않으면서 부가기능 추가가 가능하다.</li>\n<li>부가 작업을 특정 오브젝트를 대상으로 하는 것이 아니라 많은 대상으로 일반화 한다면 AOP가 되는 것이다.</li>\n</ul>\n</li>\n<li>인터페이스의 변경\n<ul>\n<li>클라이언트에서 사용하는 인터페이스와 오브젝트의 인터페이스가 일치하지 않을 때 DI를 활용하여 어댑터 패턴을 응용할 수 있다.</li>\n<li>예를 들어 A가 B인터페이스에 의존하지만 C 오브젝트를 사용하고자 할 때, B 인터페이스를 상속하고 C기능을 제공하는 어댑터를 구현하여 해결할 수 있다.</li>\n<li>일반화하여 인터페이스가 다양한 구현을 같은 방식으로 사용하도록 할 수도 있다. → PSA\n<ul>\n<li>구현체는 다양하지만 클라이언트 입장에서는 같은 방식으로 늘 사용하는 것이다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>프록시\n<ul>\n<li>필요한 시점에서 실제로 사용할 오브젝트를 초기화해고 지연된 로딩을 적용할 때 사용할 수 있다.</li>\n</ul>\n</li>\n<li>템플릿과 콜백\n<ul>\n<li>작업의 흐름 사이에 자주 바뀌는 부분을 템플릿과 콜백으로 만들고 DI 원리를 사용하면 코드를 간결하게 구현할 수 있다.</li>\n</ul>\n</li>\n<li>싱글톤과 오브젝트 스코프\n<ul>\n<li>DI하는 오브젝트의 생명주기를 제어할 수 있다. DI를 컨테이너가 한다면 오브젝트의 생명주기를 마음대로 관리하고 제어할 수 있다.</li>\n<li>기본 스코프는 싱글톤이다. 웹 엔터프라이즈는 수많은 클라이언트를 대상으로 서비스를 제공해야하기 때문에 여러 스레드의 요청을 동시에 처리할 수 있도록 하기 위해서다.</li>\n<li>전통적인 싱글톤은 오브젝트에 많은 제약을 가했지만 IoC 방식의 싱글톤은 자유로운 설계가 가능하다.</li>\n</ul>\n</li>\n<li>테스트\n<ul>\n<li>오브젝트를 효과적으로 테스트하기 위해서는 오브젝트가 고립되어야 한다.</li>\n<li>다른 오브젝트와 협력하는 부분을 테스트하기 위해서는 환경 전체를 테스트해야한다는 부담감이 있다.</li>\n<li>DI를 한다면 의존 오브젝트를 대신하여 스텁 혹은 목 오브젝트 같이 테스트 대역을 할 수 있다.\n<ul>\n<li>\n<p>번외) stub과 mock의 차이</p>\n<p>stub은 더미 객체를 사용하여 실제로 동작하는 것 처럼 보이도록 하는 것이다. 상태검증을 한다.</p>\n<p>mock은 기대값을 명세하고 특정 결과를 반환하도록 하는 것이다. 행위검증을 한다.</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<br>\n<h2 id=\"-aop\" style=\"position:relative;\"><a href=\"#-aop\" aria-label=\" aop permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 AOP</h2>\n<ul>\n<li>관점 지향 프로그래밍이라고도 많이 알려져 있다.</li>\n<li>관심사가 같은 코드를 분리해 객체지향의 원칙에 따라서 분리하고 응집된 것들을 한 곳에 모으는 것이 좋다.</li>\n<li>트랜잭션의 경우\n<ul>\n<li>트랜잭션은 한 곳에 모을 수 없고 여기저기에 흩어져있다. 따라서 모듈화가 힘들다.</li>\n<li>부가기능이기 때문에 스스로 독립적인 방식으로 존재하는 것이 어렵다.</li>\n<li>흩어져있는 부가로직을 분리하여 중복되지 않고, 변경이 필요한 경우 한 곳만 변경할 수 있도록 하는 것이 AOP의 역할이다.</li>\n</ul>\n</li>\n<li>Aspect는 부가 기능을 정의한 advice와 해당 advice를 적용할 포인트컷을 가지고 있다.</li>\n<li>부가기능이 핵심기능 모듈에 침투하면서 핵심기능을 파악하고 수정하고 테스트하기 어렵다.</li>\n<li>AOP와 OOP\n<ul>\n<li>AOP와 OOP가 대체관계라고 생각할 수 있지만 사실 보조하는 기술이다.</li>\n<li>부가기능이 핵심기능 안으로 침투하면 핵심기능에 객체지향 기술을 부여하기 힘들고 테스트하기 어려움으로 AOP로 해당 로직을 분리하여 객체지향적인 가치를 지킬 수 있도록 해주는 것이다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-psa\" style=\"position:relative;\"><a href=\"#-psa\" aria-label=\" psa permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 PSA</h2>\n<ul>\n<li>환경과 세부 기술의 변화와 관계없이 일관된 방식으로 기술에 접근할 수 있다.</li>\n<li>POJO 코드가 JavaEE에 직접 노출되지 않도록 해준다.\n<ul>\n<li>예를 들어서 트랜잭션이라는 엔터프라이즈 기술을 직접 POJO에 노출하는 것이 아니라 일관적인 서비스 추상화 기술의 형태로 제공해준다.</li>\n</ul>\n</li>\n<li>대신 설정을 통해 추상화 된 부분에 어떤 기술을 할 것인지 지정해주어야한다.</li>\n</ul>\n<br>\n<h2 id=\"-느낀-점\" style=\"position:relative;\"><a href=\"#-%EB%8A%90%EB%82%80-%EC%A0%90\" aria-label=\" 느낀 점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🛋 느낀 점</h2>\n<ul>\n<li>스프링 프레임워크의 목적은 “엔터프라이즈 기술을 사용하되 비즈니스 로직을 객체지향적으로 구현하고자 하는 것”이다.</li>\n<li>이해하기 어려운 스프링 프레임워크의 기술도 이 관점으로 보면 나름 이해할 수 있다.</li>\n<li>그리고 그 모든 기술의 기반은 바로 DI 다 !! 추상적으로 구현하여 확장성을 보장하고 변경에 자유로운 객체지향적 코드를 구현할 수 있도록 해준다.</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#-intro\">💡 Intro</a></p>\n</li>\n<li>\n<p><a href=\"#-iocdi\">🌩 IoC/DI</a></p>\n<ul>\n<li><a href=\"#%EC%99%9C-%EA%B0%95%ED%95%9C-%EA%B2%B0%ED%95%A9%EB%B3%B4%EB%8B%A4-%EB%8A%90%EC%8A%A8%ED%95%9C-%EA%B2%B0%ED%95%A9%EC%9D%B4-%EB%82%98%EC%9D%80%EA%B0%80\">왜 강한 결합보다 느슨한 결합이 나은가?</a></li>\n<li><a href=\"#di%EC%9D%98-%ED%99%9C%EC%9A%A9-%EB%B0%A9%EB%B2%95-%EB%B0%8F-%EC%9E%A5%EC%A0%90\">DI의 활용 방법 및 장점</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-aop\">🌩 AOP</a></p>\n</li>\n<li>\n<p><a href=\"#-psa\">🌩 PSA</a></p>\n</li>\n<li>\n<p><a href=\"#-%EB%8A%90%EB%82%80-%EC%A0%90\">🛋 느낀 점</a></p>\n</li>\n</ul>\n</div>","excerpt":"💡 Intro 스프링에서 어느날 등장한 개념은 아니고 어떠한 이름으로든 사용이 되고 있던 기술인데 스프링에서 더 잘 사용되도록 특정 형태를 부여했다. 이 3가지 기술들이 그 자체로 스프링이기보다 POJO 기반 엔터프라이즈 개발을 편하게 해줄 수 있는 일종의 도구이다. 즉, 객체지향적인 구현에 충실하면서 자연스럽게 등장하게 된 결과라고 할 수 있다. 스프링에서 제공하는 PSA, AOP만 사용하는 것이 아니라 그 개념을 차출하여 객체지향적 구현을 하는 것이 중요하다. 🌩 IoC/DI AOP, PSA도 IoC/DI에 바탕을 두고 있는 기술이다. 느슨한 결합을 위해 인터페이스를 두고 실제 구현체를 DI를 통해 외부에서 주입하는 것이다. 왜 강한 결합보다 느슨한 결합이 나은가? 유연한 확장이 가능하게 하기 위해서 → OCP 변경에 닫혀있다는 것은 재사용이 가능하다 라는 뜻이다. A → B 의존관계일 때 B가 변경이 되어도 A가 아무 영향을 받지 않으면 A 입장에서는 폐쇄이며 B 관점에서는 …","frontmatter":{"date":"November 16, 2021","title":"스프링 3대 개념 - IoC/DI, AOP, PSA","categories":"스프링 웹","author":"코다","emoji":"🍀"},"fields":{"slug":"/spring-ioc-aop-psa/"}},"next":{"id":"0f7262a6-8cc3-5ad6-a8f8-5c468e91c6c6","html":"<h2 id=\"-intro\" style=\"position:relative;\"><a href=\"#-intro\" aria-label=\" intro permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>💡 Intro</h2>\n<ul>\n<li>인터페이스와 추상클래스의 차이를 명확하게 구분해보자.</li>\n<li>언제 무엇을 쓰는 것이 좋은지 나름의 정의를 내려본다.</li>\n<li>상속의 위험성에 대해서 고민해본다.</li>\n</ul>\n<br>\n<h2 id=\"-추상클래스\" style=\"position:relative;\"><a href=\"#-%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4\" aria-label=\" 추상클래스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 추상클래스</h2>\n<ul>\n<li>추상 클래스는 “미완성 설계도” 이다.</li>\n<li>공통부분을 우선 정의한 미완성 설계도를 만들고 각기 다른 상황에 대해서 추가로 구현할 수 있다.\n<ul>\n<li>완성되지 않은 abstract 메소드를 포함하고 있다.</li>\n</ul>\n</li>\n<li>추상클래스는 abstract 메소드가 있다는 것을 제외하고는 일반클래스와 동일하다.</li>\n<li><strong>상속은 자손 클래스를 만드는데 조상 클래스를 사용하는 것</strong></li>\n<li><strong>추상화는 자손 클래스의 공통부분을 뽑아내서 조상 클래스를 만드는 것</strong></li>\n</ul>\n<h3 id=\"상속\" style=\"position:relative;\"><a href=\"#%EC%83%81%EC%86%8D\" aria-label=\"상속 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>상속</h3>\n<ul>\n<li>추상클래스를 <code class=\"language-text\">extends</code> 하는 명령어가 상속에서 사용되기 때문에 두 개념이 혼용되어서 사용되기도 한다. 엄밀히 말하면 두 개념이 겹칠수도 있지만 완전히 동일한 것은 아니다.</li>\n<li>상속이란 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것\n<ul>\n<li>적은 양의 코드로 새로운 클래스를 작성할 수 있고 공통부분을 관리할 수 있다는 장점이 있다.</li>\n</ul>\n</li>\n<li><strong>상속은 is-a 관계로 표현될 수 있다.</strong></li>\n<li><code class=\"language-text\">**final</code>로 정의된 클래스가 아니라면 모두 상속이 가능하다. 추상클래스는 그 일부분이다.**</li>\n<li>상속을 할 때 주의할 점 ‼️\n<ul>\n<li>상속은 조상 클래스의 캡슐화가 깨지는 위험이 있다.</li>\n<li>또한 조상 클래스와 자손 클래스간의 강한 결합이기 때문에 조상 클래스 메서드에 변화가 생기면 자손 클래스에 아무런 변화가 없음에도 다르게 동작할 수 있다.</li>\n<li>따라서 상속보다는 <strong>조합</strong>을 사용하도록 추천한다. (Deck는 Card를 가지고 있다 와 같은 경우에 조합 사용 has-a 관계)</li>\n<li>일반 클래스는 <code class=\"language-text\">final</code>을 추가하여 상속을 막거나 미완성 설계도인 abstract 클래스를 정의하도록 추천한다.\n<ul>\n<li>또한 추상클래스의 부모 메소드를 수정하지 않는 것이 좋다.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"왜-자바는-단일-상속일까-single-inheritance\" style=\"position:relative;\"><a href=\"#%EC%99%9C-%EC%9E%90%EB%B0%94%EB%8A%94-%EB%8B%A8%EC%9D%BC-%EC%83%81%EC%86%8D%EC%9D%BC%EA%B9%8C-single-inheritance\" aria-label=\"왜 자바는 단일 상속일까 single inheritance permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>왜 자바는 단일 상속일까? (single inheritance)</h3>\n<ul>\n<li>다중상속을 하게 되면 복합적인 기능을 가진 클래스를 손쉽게 구현할 수 있지만 클래스 간 관계가 굉장히 복잡해진다.</li>\n<li>여러 다른 클래스로 상속받은 멤버의 이름이나 메서드가 같은 경우 구별도 어렵다.</li>\n</ul>\n<br>\n<h2 id=\"-인터페이스\" style=\"position:relative;\"><a href=\"#-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4\" aria-label=\" 인터페이스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 인터페이스</h2>\n<ul>\n<li>인터페이스는 “기본 설계도”이다. (추상클래스는 “미완성 설계도”)</li>\n<li>인터페이스는 면대면이 만나는 부분이라는 뜻을 가지고 있으며 2개의 구성요소가 상호작용할 수 있도록 접속 경계를 연결하는 부분이다. (플러그와 같은 역할)</li>\n<li>인터페이스끼리 상속받을 수 있으며 다중상속이 가능하다.</li>\n<li>인터페이스는 <code class=\"language-text\">implements</code> 를 사용해서 구현하며 다중구현이 가능하다.</li>\n<li>인터페이스는 구현 메서드나 멤버 필드가 없다.\n<ul>\n<li>default 메서드가 가능하도록 jdk1.8부터 추가가 되었고, static 변수만 가능하다.</li>\n</ul>\n</li>\n<li>인터페이스는 해당 인터페이스를 구현하는 모든 클래스가 특정 메소드를 반드시 구현하도록 강제하는 역할을 한다 → 따라서 명세의 역할을 한다고도 한다.</li>\n</ul>\n<h3 id=\"추상클래스와의-차이점\" style=\"position:relative;\"><a href=\"#%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90\" aria-label=\"추상클래스와의 차이점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>추상클래스와의 차이점</h3>\n<ul>\n<li>우선 구현메서드 존재 여부, 필드 존재 여부, 다중 상속 및 구현에 대한 차이점이 존재한다</li>\n<li>추상클래스는 공통기능에 대한 재사용과 정제의 역할을 한다. (정제란 불완전한 행동을 완전하게 만드는 것을 의미)</li>\n<li>인터페이스는 구현체가 특정 메소드가 반드시 존재하도록 하는 역할을 하여 특정 기능을 반드시 제공한다는 것을 보장하는 역할을 한다.</li>\n</ul>\n<h3 id=\"동일-메서드를-가진-인터페이스\" style=\"position:relative;\"><a href=\"#%EB%8F%99%EC%9D%BC-%EB%A9%94%EC%84%9C%EB%93%9C%EB%A5%BC-%EA%B0%80%EC%A7%84-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4\" aria-label=\"동일 메서드를 가진 인터페이스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>동일 메서드를 가진 인터페이스</h3>\n<ul>\n<li>동일한 메서드 명과 시그니처를 가진 메서드가 두 개의 인터페이스에 있을때는 어떻게 할까?\n<ul>\n<li>이때는 컴파일 오류로 충돌을 해결해야만 컴파일이 가능하다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-느낀-점\" style=\"position:relative;\"><a href=\"#-%EB%8A%90%EB%82%80-%EC%A0%90\" aria-label=\" 느낀 점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🛋 느낀 점</h2>\n<ul>\n<li>추상클래스와 인터페이스는 역할 자체가 다르다.\n<ul>\n<li>추상 클래스는 정제의 역할을 인터페이스는 기능 구현 강제의 역할을 한다.</li>\n<li>인터페이스를 통해서는 중복을 해결할 수 없다. 어떤 두 요소가 연결되기 위해 사전에 정의한 기능들이 모두 구현이 된다는 것을 보장할 뿐이다.</li>\n<li>상속은 부모 클래스의 캡슐화가 깨지기 때문에 조합을 이용하는 것이 더 적절하다.</li>\n</ul>\n</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#-intro\">💡 Intro</a></p>\n</li>\n<li>\n<p><a href=\"#-%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4\">🌩 추상클래스</a></p>\n<ul>\n<li><a href=\"#%EC%83%81%EC%86%8D\">상속</a></li>\n<li><a href=\"#%EC%99%9C-%EC%9E%90%EB%B0%94%EB%8A%94-%EB%8B%A8%EC%9D%BC-%EC%83%81%EC%86%8D%EC%9D%BC%EA%B9%8C-single-inheritance\">왜 자바는 단일 상속일까? (single inheritance)</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4\">🌩 인터페이스</a></p>\n<ul>\n<li><a href=\"#%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90\">추상클래스와의 차이점</a></li>\n<li><a href=\"#%EB%8F%99%EC%9D%BC-%EB%A9%94%EC%84%9C%EB%93%9C%EB%A5%BC-%EA%B0%80%EC%A7%84-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4\">동일 메서드를 가진 인터페이스</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-%EB%8A%90%EB%82%80-%EC%A0%90\">🛋 느낀 점</a></p>\n</li>\n</ul>\n</div>","frontmatter":{"date":"November 15, 2021","title":"추상클래스와 인터페이스 더 이상 헷갈리지 않기","categories":"자바","author":"코다","emoji":"✊"},"fields":{"slug":"/java-abstract-vs-interface/"}},"prev":{"id":"00e80243-2a3a-528a-8625-03c3c7bfbedb","html":"<h2 id=\"-intro\" style=\"position:relative;\"><a href=\"#-intro\" aria-label=\" intro permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>💡 Intro</h2>\n<ul>\n<li>JVM은 자바의 큰 장점 중 하나로 이 가상머신이 깔려있는 운영체제에서는 모두 동일하게 자바 클래스 파일이 실행될 수 있다.</li>\n<li>JVM의 기본 구조를 알아보자 🙌</li>\n</ul>\n<br>\n<h2 id=\"-jvm-메모리-구조\" style=\"position:relative;\"><a href=\"#-jvm-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0\" aria-label=\" jvm 메모리 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 JVM 메모리 구조</h2>\n<p><strong>1) Class Loader 2) Execution Engine 3) Garbage Collector 4) Runtime Data Area</strong> 4가지로 나뉘어져 있다.</p>\n<h3 id=\"class-loader\" style=\"position:relative;\"><a href=\"#class-loader\" aria-label=\"class loader permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Class Loader</h3>\n<ul>\n<li>JVM 내로 클래스 파일을 로드하고 링크를 통해 배치하는 작업을 수행한다.</li>\n<li>런타임 시에 동적으로 클래스를 로드한다.</li>\n</ul>\n<h3 id=\"execution-engine\" style=\"position:relative;\"><a href=\"#execution-engine\" aria-label=\"execution engine permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Execution Engine</h3>\n<ul>\n<li>클래스 로더가 Runtime Data Area에 배치한 바이트 코드들을 명령어 단위로 읽어서 실행하는 작업을 수행한다.</li>\n<li>최초 JVM에서는 인터프리터 방식이어서 느렸지만 JIT 컴파일러로 변경되면서 실행이 빠르다는 장점이 있다.</li>\n<li>모든 코드 JIT으로 하지 않고 인터프리터로 하다가 일정한 기준이 넘어가면 JIT 컴파일러 방식으로 실행한다.\n<ul>\n<li>한번 읽어서 기계어로 변경한 소스코드는 변역하지 않는다.</li>\n<li>저장소에 저장하여 반복되는 코드는 한꺼번에 컴파일하여서 사용한다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"garbage-collector\" style=\"position:relative;\"><a href=\"#garbage-collector\" aria-label=\"garbage collector permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Garbage Collector</h3>\n<ul>\n<li>힙 메모리 영역에 객체 중 더이상 참조되지 않는 객체들을 제거하는 역할을 한다.\n<ul>\n<li>Reference Counting 혹은 Mark-and-sweep 방식을 사용</li>\n<li>Minor GC(eden, survivor1, survivor2)와 Major GC(old)</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"runtime-data-area\" style=\"position:relative;\"><a href=\"#runtime-data-area\" aria-label=\"runtime data area permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Runtime Data Area</h3>\n<ul>\n<li>애플리케이션이 실행할 때 사용되는 데이터를 적재하는 영역\n<ul>\n<li><strong>Method Area</strong> → 모든 스레드가 공유하는 메모리 영역으로 클래스, 인터페이스, 메소드, 필드, static 변수 등의 바이트 코드를 보관</li>\n<li><strong>Heap Area</strong> → 모든 스레드가 공유하며 new 키워드로 생성된 객체와 배열이 생성되는 영역</li>\n<li><strong>Stack Area</strong> → 메서드 호출시마다 스택 프레임을 생성하여 매개변수, 지역변수, 리턴 값, 연산 시 값들을 임시로 저장하며 메서드 수행이 끝나면 프레임을 삭제</li>\n<li><strong>PC Register</strong> → 쓰레드 시작 시 생성되며 스레드마다 하나씩 존재하고 무슨 명령어를 실행할지 명령의 주소 보관</li>\n<li><strong>Native Method Stack</strong> → 자바 외 언어로 작성된 네이티브 코드를 저장하는 메모리</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-느낀-점\" style=\"position:relative;\"><a href=\"#-%EB%8A%90%EB%82%80-%EC%A0%90\" aria-label=\" 느낀 점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🛋 느낀 점</h2>\n<ul>\n<li>JVM의 구조를 알고 있어야지 자바 코드가 실행되는 부분이 일종의 ‘매직’처럼 남아있지 않고 구체화 되어서 그려질 것 같다.</li>\n<li>공부를 할수록 그냥 되는줄 알았던 부분들이 차츰차츰 명료해지는 것 같다.</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#-intro\">💡 Intro</a></p>\n</li>\n<li>\n<p><a href=\"#-jvm-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0\">🌩 JVM 메모리 구조</a></p>\n<ul>\n<li><a href=\"#class-loader\">Class Loader</a></li>\n<li><a href=\"#execution-engine\">Execution Engine</a></li>\n<li><a href=\"#garbage-collector\">Garbage Collector</a></li>\n<li><a href=\"#runtime-data-area\">Runtime Data Area</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-%EB%8A%90%EB%82%80-%EC%A0%90\">🛋 느낀 점</a></p>\n</li>\n</ul>\n</div>","frontmatter":{"date":"November 17, 2021","title":"JVM 구조 알아보기","categories":"자바","author":"코다","emoji":"✊"},"fields":{"slug":"/java-jvm/"}},"site":{"siteMetadata":{"siteUrl":"https://yjksw.github.io","comments":{"utterances":{"repo":"yjksw/yjksw.github.io"}}}}},"pageContext":{"slug":"/spring-ioc-aop-psa/","nextSlug":"/java-abstract-vs-interface/","prevSlug":"/java-jvm/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}
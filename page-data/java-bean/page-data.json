{"componentChunkName":"component---src-templates-blog-template-js","path":"/java-bean/","result":{"data":{"cur":{"id":"8bf91ec6-90fe-5ce0-86c1-d8e98765968f","html":"<p>간단한 JavaBean 규약에 대해서 알고 넘어가기</p>\n<h2 id=\"javabean\" style=\"position:relative;\"><a href=\"#javabean\" aria-label=\"javabean permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JavaBean</h2>\n<p>자바빈 규약을 따르는 Java Class를 말한다. </p>\n<h2 id=\"javabean-규약\" style=\"position:relative;\"><a href=\"#javabean-%EA%B7%9C%EC%95%BD\" aria-label=\"javabean 규약 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JavaBean 규약</h2>\n<ol>\n<li>defulat 패키지가 아닌 패키지 하위에 있는 클래스</li>\n<li>기본 생성자가 존재 (no-arg constructor)</li>\n<li>Property는 모두 private으로 선언</li>\n<li>Getter/setter를 통해서 properties를 조작</li>\n<li><code class=\"language-text\">Serializable</code>을 implement 하여 직렬화 가능</li>\n</ol>\n<h2 id=\"번외--serialization--deserialization\" style=\"position:relative;\"><a href=\"#%EB%B2%88%EC%99%B8--serialization--deserialization\" aria-label=\"번외  serialization  deserialization permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>번외 : Serialization &#x26; Deserialization</h2>\n<ul>\n<li>Serialization : converting state of an object into a byte stream</li>\n<li>Deserialization: reverse process of serialization</li>\n</ul>\n<p>해당 객체에 영속성을 부여하기 위해서 사용되는 매커니즘이다. <br></p>\n<p>Java 객체를 serialize 하게 하기 위해서는 <code class=\"language-text\">java.io.Serializable</code> 인터페이스를 구현하도록 한다. 해당 인터페이스는 멤버변수나 메소드가 존재하지 않는 marker interface(Cloneable이나 Remote와 같은) 이다. <br></p>\n<p>Serializable하면 1) 해당 객체 그대로에 영속성을 부여할 수 있으며 2) 네트워크 상에서 byte stream으로 전송이 가능하다. <br></p>\n<p><strong>Serialization 특징</strong></p>\n<ul>\n<li>부모 클래스가 Serializable interface를 구현하면 자식 클래스는 자동으로 Serializable 하다.</li>\n<li>non-static 멤버 변수만 Serialization 으로 저장될 수 있다. (static 과 transient 데이터는 불가)</li>\n<li>\n<p>비밀번호 등의 보안으로 인해 어떠한 멤버 변수가 serialize 되어 저장되지 않기를 원한다면 해당 데이터를 trasient 데이터로 지정하도록 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Member</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Serializable</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">transient</span> <span class=\"token class-name\">String</span> password<span class=\"token punctuation\">;</span>\n\t<span class=\"token class-name\">String</span> name<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n<li>해당 객체가 deserialized 될 때 해당 객체의 생성자는 호출되지 않는다.</li>\n<li>\n<p>Serializable 한 객체와 연관되어 있는 객체 또한 Serializable 인터페이스를 반드시 구현해야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">ObjectA</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Serializable</span> <span class=\"token punctuation\">{</span>\t\n\t<span class=\"token comment\">//ObjectB는 반드시 Serializable을 구현해야 함\t</span>\n\t<span class=\"token class-name\">ObjectB</span> oj <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ObjectB</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n</ul>\n<p><strong>SerialVersionUID</strong></p>\n<p>Serialization을 진행하면서 각 Serializable class는 <code class=\"language-text\">SerialVersionUID</code> 라는 id를 할당받는다. 해당 id를 통해서 직렬화된 객체의 sender와 receiver를 판별하는데, sender와 reciever는 동일해야한다. 만일 동일하지 않다면 <code class=\"language-text\">InvalidClassException</code>이 deserialize 할 때 발생한다. </p>\n<br>\n<br>\n<p><strong>[참고자료]</strong></p>\n<ul>\n<li><a href=\"https://dololak.tistory.com/133\">https://dololak.tistory.com/133</a></li>\n<li><a href=\"https://www.geeksforgeeks.org/javabean-class-java/#:~:text=JavaBeans%20are%20classes%20that%20encapsulate,public%20getters%20and%20setter%20methods\">https://www.geeksforgeeks.org/javabean-class-java/#:~:text=JavaBeans are classes that encapsulate,public getters and setter methods</a>.</li>\n<li><a href=\"https://www.geeksforgeeks.org/serialization-in-java/\">https://www.geeksforgeeks.org/serialization-in-java/</a></li>\n<li><a href=\"https://www.javatpoint.com/serialization-in-java#:~:text=Serialization%20in%20Java%20is%20a,is%20converted%20into%20an%20object\">https://www.javatpoint.com/serialization-in-java#:~:text=Serialization in Java is a,is converted into an object</a>.</li>\n</ul>\n<p><strong>[MORE]</strong></p>\n<ul>\n<li>non-static 만 serialization 가능한 이유</li>\n<li>SerialVersionUID</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#javabean\">JavaBean</a></li>\n<li><a href=\"#javabean-%EA%B7%9C%EC%95%BD\">JavaBean 규약</a></li>\n<li><a href=\"#%EB%B2%88%EC%99%B8--serialization--deserialization\">번외 : Serialization &#x26; Deserialization</a></li>\n</ul>\n</div>","excerpt":"간단한 JavaBean 규약에 대해서 알고 넘어가기 JavaBean 자바빈 규약을 따르는 Java Class를 말한다.  JavaBean 규약 defulat 패키지가 아닌 패키지 하위에 있는 클래스 기본 생성자가 존재 (no-arg constructor) Property는 모두 private으로 선언 Getter/setter를 통해서 properties를 조작 을 implement 하여 직렬화 가능 번외 : Serialization & Deserialization Serialization : converting state of an object into a byte stream Deserialization: reverse process of serialization 해당 객체에 영속성을 부여하기 위해서 사용되는 매커니즘이다.  Java 객체를 serialize 하게 하기 위해서는  인터페이스를 구현하도록 한다. 해당 인터페이스는 멤버변수나 메소드가 존재하지 않는 marker int…","frontmatter":{"date":"June 08, 2021","title":"자바빈 규약 (번외: Serialization)","categories":"자바","author":"코다","emoji":"✊"},"fields":{"slug":"/java-bean/"}},"next":{"id":"bba3b50e-5ef0-5460-b0ea-d503ef9f2aac","html":"<h2 id=\"servlet-개념-및-구조\" style=\"position:relative;\"><a href=\"#servlet-%EA%B0%9C%EB%85%90-%EB%B0%8F-%EA%B5%AC%EC%A1%B0\" aria-label=\"servlet 개념 및 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Servlet 개념 및 구조</h2>\n<p>Servlet은 <strong>웹 서버</strong>를 구현한 <strong>자바</strong>의 프로그램이며 <strong>interface</strong>이다. 서블릿이 하는 일은 다음과 같다. Servlet은 웹 클라이언트로부터 요청을 받아서 응답을 반환한다. </p>\n<p>Servlet 인터페이스는 servlet을 초기화하고, 서비스를 요청하고, servlet을 서버에서 제거하는 메소드를 제공한다. (이걸 life-cycle 메소드라고 말한다) </p>\n<ol>\n<li><code class=\"language-text\">init</code> 메소드를 통해서 서블릿이 구축된다. </li>\n<li>클라이언트에서 호출된 <code class=\"language-text\">service</code> 메소드가 수행된다. </li>\n<li>수행된 서블릿이 <code class=\"language-text\">service</code>에서 제거되고 <code class=\"language-text\">destroy</code> 메소드를 통해서 소멸된다. </li>\n</ol>\n<p>추가로 Servlet 초기세팅 정보를 <code class=\"language-text\">ServletConfig</code> 에 담아서 반환하는 <code class=\"language-text\">getServletConfig()</code> 와, Servlet 정보를 반환하는 <code class=\"language-text\">getServletInfo()</code> 메소드도 존재한다. </p>\n<h3 id=\"httpservlet-구조\" style=\"position:relative;\"><a href=\"#httpservlet-%EA%B5%AC%EC%A1%B0\" aria-label=\"httpservlet 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>HttpServlet 구조</h3>\n<ul>\n<li><code class=\"language-text\">GenericServlet</code>을 확장하고 <code class=\"language-text\">Servlet</code> 인터페이스를 구현한다.</li>\n<li>웹 환경에 최적화되어 있어서 HTTP 메소드를 지원한다. 즉, HttpServlet 에서는 <code class=\"language-text\">service()</code> 를 override 할 이유가 거의 없다. 왜냐햐면 이미 정의되어 있는 Http 요청들을 수행하도록 되어 있기 때문이다.</li>\n</ul>\n<p align=\"center\"><img width=\"85%\" src=\"https://user-images.githubusercontent.com/63405904/135119857-ab8335e6-7bbf-409f-9213-76beb4941e03.png\"></p>\n<h3 id=\"servlet-동작방식\" style=\"position:relative;\"><a href=\"#servlet-%EB%8F%99%EC%9E%91%EB%B0%A9%EC%8B%9D\" aria-label=\"servlet 동작방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Servlet 동작방식</h3>\n<ol>\n<li>브라우저에서 URL을 입력해서 request를 Servlet Container 로 전송</li>\n<li>Servlet Container에서 <code class=\"language-text\">HttpServletRequest</code>, <code class=\"language-text\">HttpServletResponse</code> 객체 생성</li>\n<li><code class=\"language-text\">xml</code>에 기입된 정보를 통해서 해당 URL과 매칭되는 서블릿을 검색</li>\n<li>해당 서블릿의 service를 호출하여 처리</li>\n<li>해당 서블릿의 service 내의 메소드에서 처리하고 동적 페이지를 생성하여 <code class=\"language-text\">HttpServletResponse</code> 에 응답을 담아서 전송</li>\n<li>모든 처리가 끝난 후 <code class=\"language-text\">HttpServletRequest</code>, <code class=\"language-text\">HttpServletResponse</code> 소멸</li>\n</ol>\n<br>\n<h2 id=\"servlet-container\" style=\"position:relative;\"><a href=\"#servlet-container\" aria-label=\"servlet container permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Servlet Container</h2>\n<p>서블릿을 관리하기 위해서는 서블릿 컨테이너가 필요하다. <br></p>\n<p>톰캣(Tomcat)과 같이 클라이언트의 요청을 받아서 정의된 서블릿을 수행하고, 응답을 할 수 있도록 웹 서버와 소켓 통신을 관리한다. <br></p>\n<p>본래 클라이언트와 웹서버만 통신했을 때에는 정적 페이지만 전송할 수 이기때문에 비효율적이다. 따라서 동적으로 웹 페이지를 서버에서 만들어서 전송할 수 있도록 하는 것이 servlet container이다. 웹 서버에서 클라이언트와 서블릿이 소통할 수 있도록하는 일부분이다. <br></p>\n<p>웹 서버는 http 요청을 받은 경우 servlet container로 해당 요청을 포워딩한다. 이때 부터 서블릿 컨테이너가 요청을 받아서 생명주기에 맞게 핸들링 한다. <br></p>\n<h3 id=\"역할\" style=\"position:relative;\"><a href=\"#%EC%97%AD%ED%95%A0\" aria-label=\"역할 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>역할</h3>\n<ol>\n<li>\n<p>통신 지원 (웹 서버 ↔  소켓)</p>\n<p>서버와 소켓 통신을 하기 위해서는 소켓 생성 및 listen, accept 등의 일을 해야하지만 해당 과정은 복잡하고 동일하게 반복해야하는 부분이다. 따라서 서블릿 컨테이너는 해당 일과 관련된 기능을 API로 제공<strong>(?)</strong> 해줘서 관리하게 해준다. 즉, 비지니스 로직에만 집중할 수 있도록 지원한다. </p>\n</li>\n<li>\n<p>서블릿 생명주기 관리</p>\n<p>서블릿의 탄생 및 죽음을 관리한다. </p>\n<p>즉, 요청이 들어왔을 때, 해당되는 서블릿 클래스를 인스턴스화(<code class=\"language-text\">HttpServletRequest</code>, <code class=\"language-text\">HttpServletResponse</code> 등등) 하고, 서비스 메소드 호출, 처리 후 GC를 진행한다.</p>\n</li>\n<li>\n<p>멀티 스레드 지원 및 관리</p>\n<p>하나의 서블릿 요청 당 하나의 자바 스레드가 생성된다. 서비스 메소드 실행 후 스레드는 소멸된다. 그리고 서버에서 다중 스레드를 관리해준다. (하나의 소켓 당 하나의 스레드가 할당되기 때문에? 그렇다면 소켓 관리를 톰캣이 한다는 것이기 때문에)</p>\n</li>\n<li>\n<p>선언적 보안 관리</p>\n<p>서블릿 컨테이너를 사용할 경우, 보안 내용을 xml에 기록하므로 서블릿이나 자바에 구현하지 않아도 된다. </p>\n</li>\n</ol>\n<h3 id=\"servlet-생명주기\" style=\"position:relative;\"><a href=\"#servlet-%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0\" aria-label=\"servlet 생명주기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Servlet 생명주기</h3>\n<p>간단하게 서블릿의 생명주기는 <code class=\"language-text\">init() → service() → destroy()</code> 로 진행된다.</p>\n<ul>\n<li>여기서 <code class=\"language-text\">init()</code>은 요청이 왔을 때, 서블릿이 메모리에 있는지 확인하고 없는 경우 <code class=\"language-text\">init()</code> 을 실행하고 처음에 한번만 실행한다. 서블릿 요청별로 새로운 스레드가 생성되기 때문에 해당 스레드간 공통적인 부분은 여기에 구현하는 것이 좋다.</li>\n<li>서블릿 컨테이너가 서블릿 종료 요청(<strong><em>종료 요청 시점은? 우선은 톰캣 종료 시점</em></strong>)을 할 때 호출되는 <code class=\"language-text\">destroy()</code> 도 마찬가지로 마지막에 한번만 실행된다.</li>\n</ul>\n<h3 id=\"servlet-과-jvm\" style=\"position:relative;\"><a href=\"#servlet-%EA%B3%BC-jvm\" aria-label=\"servlet 과 jvm permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Servlet 과 Jvm</h3>\n<p>Servlet을 사용하면 jvm에서 각각의 요청들을 각각의 자바 스레드에서 사용할 수 있도록 해준다. jvm에서 각각의 servlet은 하나의 자바 클래스이고, servlet에 요청이 들어오면 그것을 Jvm에서 처리해서 반환한다. </p>\n<br>\n<h2 id=\"dispatcher-servlet\" style=\"position:relative;\"><a href=\"#dispatcher-servlet\" aria-label=\"dispatcher servlet permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Dispatcher Servlet</h2>\n<p>디스패쳐 서블릿을 이해하려면 우선 front controller 패턴에 대한 이해가 있어야 한다. Front controller 패턴(<a href=\"https://www.geeksforgeeks.org/front-controller-design-pattern/\">https://www.geeksforgeeks.org/front-controller-design-pattern/</a>) 에 대해서 간단하게 설명하자면, front-controller는 들어오는 요청에 대해서 하나의 핸들러가 처리를 담당하고 그것을 처리할 수 있는 적합한 핸들러에게 dispatch 즉, 보내는 역할을 하도록 하는 디자인 패턴이다. </p>\n<h3 id=\"dispatcher-servlet-processing\" style=\"position:relative;\"><a href=\"#dispatcher-servlet-processing\" aria-label=\"dispatcher servlet processing permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Dispatcher servlet processing</h3>\n<ul>\n<li>여러 Web-context가 존재할 수 있기 때문에 우선 해당 DispatcherServlet에 해당되는 WebApplicatonContext 을 DispatcherServlet.WEB<em>APPLICATION</em>CONTEXT_ATTRIBUTE 를 키로 우선 검색한다. </li>\n<li><code class=\"language-text\">DispatcherServlet</code>은 <code class=\"language-text\">HandlerAdapter</code> 의 구현체를 <code class=\"language-text\">getHandle()</code> 을 통해서 구현체를 가져온다. 그래서 <code class=\"language-text\">handle()</code> 메서드를 통해서 해당 요청에 대해 처리할 것을 진행한다.</li>\n<li><strong>HandlerExceptionResolver -</strong>  WebapplicationContext 안에 선언되어 있는, 요청 처리 중 발생한 exceptions 들을 처리하는 resolver</li>\n</ul>\n<h3 id=\"handleradapter-interfaces\" style=\"position:relative;\"><a href=\"#handleradapter-interfaces\" aria-label=\"handleradapter interfaces permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>HandlerAdapter Interfaces</h3>\n<p>HandlerAdapter 인터페이스는 controller, servlets, HttpRequests를 관리하여 사용하게 한다. <br></p>\n<p>HandlerAdapter 구현체는 디스패처의 <code class=\"language-text\">getHandler()</code> 메서드를 통해서 <code class=\"language-text\">HandlerExecutionChain</code> 에 들어간다. 여기에 들어간 각각의 구현체들이 <code class=\"language-text\">handle()</code> 메서드를 통해서 <code class=\"language-text\">HttpServletRequest</code> 요청을 처리한다. </p>\n<ul>\n<li>\n<p><strong>Mapping</strong></p>\n<p>HandlerMapping 인터페이스는 컨트롤러와 밀접하게 연관이 되어 있다. 때문에 컨트롤러에 어떠한 annotation이 붙어있는지에 따라서 HandlerMapping을 다르게 동작한다. </p>\n<p><code class=\"language-text\">SimpleControllerHandlerAdapter</code> 의 경우에는 <code class=\"language-text\">@Controller</code> 어노테이션이 붙어있지 않은 컨트롤러의 경우에 동작할 수 있고, <code class=\"language-text\">RequestMappingHandler</code> 은 <code class=\"language-text\">@RequestMapping</code> 어노테이션이 붙은 메서드의 경우에만 적용할 수 있다. </p>\n<p><code class=\"language-text\">RequestMappingHandler</code>의 경우를 자세히 들여다보자. @RequestMapping 어노테이션은 해당 <code class=\"language-text\">WebApplicationContext</code> 내에서 handler가 가능한 지점을 알려준다. 그렇기 때문에 <code class=\"language-text\">@RequestMapping</code> 어노테이션에 서술되어 있는 path는 <code class=\"language-text\">HandlerMapping</code> 인터페이스에 의해서 관리된다. (URL 구조는 <code class=\"language-text\">DispatcherServlet</code>과 관련이 깊으며, servlet mapping에 직접 사용된다) </p>\n</li>\n<li>\n<p><strong>HTTP Request Handling</strong></p>\n<p>DispatcherServlet 의 핵심적인 책임 중 하나는 들어오는 HttpRequest를 알맞은  handler에 보내는(dispatch) 것이다. (여기서 <code class=\"language-text\">@Controller</code>, <code class=\"language-text\">@RestController</code> 어노테이션에 관련이 있다) </p>\n</li>\n<li>\n<p><strong>ViewResolver Interface</strong></p>\n<p><code class=\"language-text\">ViewResolver</code> 는 <code class=\"language-text\">DispatcherServlet</code>에서 <code class=\"language-text\">ApplicationContext</code>에 대한 환경설정을 담당한다. <br></p>\n<p><code class=\"language-text\">ViewResolver</code>는 <code class=\"language-text\">dispatcher</code>에 의해서 제공되는 view의 종류와 어디서 해당 view가 제공되는지 파악한다.  <br></p>\n<p><code class=\"language-text\">ViewResolver</code>가 실제적으로 수행하는 일은 다음과 같다. </p>\n<ol>\n<li>prefix 설정 : 적절한 view를 찾기위한 default URL 경로를 설정</li>\n<li>suffix 설정 : default view type을 설정하는 접미사 설정</li>\n<li>view class 설정 : 적절한 view 클래스를 resolver에 설정해서 렌더링이 필요한 기술을 제공받을 수 있도록 한다. (JSTL or Tiles) </li>\n</ol>\n</li>\n<li>\n<p><strong>LocaleResolver Interface</strong></p>\n<p>디스패처로 session, request, cookie information 등을 LocaleResolver로 커스텀 할 수 있다. </p>\n<ul>\n<li><code class=\"language-text\">CookieLocaleResolver</code>는 쿠키를 통해 stateless한 어플리케이션의 property를 설정할 수 있도록 한다.</li>\n<li><code class=\"language-text\">SessionLocalResolver</code>로 stateful한 어플리케이션의 session-specific  configuration을 설정할 수 있다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Bean</span> \n<span class=\"token keyword\">public</span> <span class=\"token class-name\">CookieLocaleResolver</span> <span class=\"token function\">cookieResolver</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token class-name\">CookieLocaleResolver</span> localeResolver\n\t\t<span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">CookieLocaleResolver</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\tlocaleResolver<span class=\"token punctuation\">.</span><span class=\"token function\">setDefaultLocale</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Locale</span><span class=\"token punctuation\">.</span>ENGLISH<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\tlocaleResolver<span class=\"token punctuation\">.</span><span class=\"token function\">setCookieName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"cookiename\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\tlocaleResolver<span class=\"token punctuation\">.</span><span class=\"token function\">setCookieMaxAge</span><span class=\"token punctuation\">(</span><span class=\"token number\">3600</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">return</span> localeResolver<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n<li><strong>ThemeResolver &#x26; MultipartResolver 생략</strong></li>\n<li>\n<p><strong>HandlerExceptionResolver</strong></p>\n<p>스프링의 <code class=\"language-text\">HandlerExceptionResolver</code>는 전체 웹 어플리케이션에 대해서 균일한 에러 핸들링을 가능하게 해준다. 어플리케이션 전역적으로 적용이 되는 커스텀 에러 핸들링을 구현하기 위해서는 <strong>@ControllerAdvice 어노테이션을 추가해서 구현하도록 한다.</strong> </p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@ControllerAdvice</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ExampleGlobalExceptionHandler</span> <span class=\"token punctuation\">{</span>\n\t \n\t<span class=\"token annotation punctuation\">@ExceptionHandler</span>\n\t<span class=\"token annotation punctuation\">@ResponseBody</span>\n\t<span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">handleExampleException</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token comment\">//...</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이 경우 <code class=\"language-text\">@ExceptionHandler</code> 어노테이션이 추가된 클래스는 디스패쳐의 영역 안에 있는 모든 컨트롤러에 적용될 수 있다. </p>\n</li>\n</ul>\n<h3 id=\"spring-mvc-와-dispatcherservlet-동작방식\" style=\"position:relative;\"><a href=\"#spring-mvc-%EC%99%80-dispatcherservlet-%EB%8F%99%EC%9E%91%EB%B0%A9%EC%8B%9D\" aria-label=\"spring mvc 와 dispatcherservlet 동작방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Spring MVC 와 DispatcherServlet 동작방식</h3>\n<p align=\"center\"><img width=\"85%\" src=\"https://user-images.githubusercontent.com/63405904/135120169-742f3adf-be12-4f14-8d35-6c18c4115e06.png\"></p>\n<br>\n<br>\n<h3 id=\"파생-키워드-및-주제\" style=\"position:relative;\"><a href=\"#%ED%8C%8C%EC%83%9D-%ED%82%A4%EC%9B%8C%EB%93%9C-%EB%B0%8F-%EC%A3%BC%EC%A0%9C\" aria-label=\"파생 키워드 및 주제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>파생 키워드 및 주제</h3>\n<p><strong>⇒ 서블릿 컨테이너의 웹 서버와 통신 지원 방식 (Tomcat 내부구현 확인 필요)</strong> </p>\n<p><strong>⇒ Front Controller desgin pattern (</strong><a href=\"https://www.geeksforgeeks.org/front-controller-design-pattern/\">https://www.geeksforgeeks.org/front-controller-design-pattern/</a>)</p>\n<p><strong>⇒ SimpleControllerHandlerAdapter 와 annotation이 붙지 않은 controller의 동작 방식</strong> </p>\n<p><strong>⇒ SpringController 깊이 알기</strong> (<a href=\"https://www.baeldung.com/spring-controllers\">https://www.baeldung.com/spring-controllers</a>)</p>\n<p><strong>⇒ Spring의 error handling 깊이 알기</strong> (<a href=\"https://www.baeldung.com/exception-handling-for-rest-with-spring\">https://www.baeldung.com/exception-handling-for-rest-with-spring</a>)</p>\n<br>\n<h3 id=\"의문\" style=\"position:relative;\"><a href=\"#%EC%9D%98%EB%AC%B8\" aria-label=\"의문 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>의문</h3>\n<ul>\n<li><del>Spring MVC 의 DispatcherServlet의 동작방식에서 <strong>HandlerMapping</strong>과 <strong>HandlerAdapter</strong>의 차이</del></li>\n</ul>\n<br>\n<h3 id=\"참고링크\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0%EB%A7%81%ED%81%AC\" aria-label=\"참고링크 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고링크</h3>\n<ul>\n<li><a href=\"https://mangkyu.tistory.com/14\">https://mangkyu.tistory.com/14</a></li>\n<li><a href=\"https://dzone.com/articles/what-servlet-container\">https://dzone.com/articles/what-servlet-container</a></li>\n<li><a href=\"https://www.baeldung.com/spring-dispatcherservlet\">https://www.baeldung.com/spring-dispatcherservlet</a></li>\n<li><a href=\"https://velog.io/@ehdrms2034/%EC%8A%A4%ED%94%84%EB%A7%81-MVC-Dispatcher-Servlet%EC%9D%84-%EC%A7%81%EC%A0%91-%EA%B5%AC%ED%98%84%ED%95%B4%EB%B3%B4%EC%9E%90\">https://velog.io/@ehdrms2034/스프링-MVC-Dispatcher-Servlet을-직접-구현해보자</a></li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#servlet-%EA%B0%9C%EB%85%90-%EB%B0%8F-%EA%B5%AC%EC%A1%B0\">Servlet 개념 및 구조</a></p>\n<ul>\n<li><a href=\"#httpservlet-%EA%B5%AC%EC%A1%B0\">HttpServlet 구조</a></li>\n<li><a href=\"#servlet-%EB%8F%99%EC%9E%91%EB%B0%A9%EC%8B%9D\">Servlet 동작방식</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#servlet-container\">Servlet Container</a></p>\n<ul>\n<li><a href=\"#%EC%97%AD%ED%95%A0\">역할</a></li>\n<li><a href=\"#servlet-%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0\">Servlet 생명주기</a></li>\n<li><a href=\"#servlet-%EA%B3%BC-jvm\">Servlet 과 Jvm</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#dispatcher-servlet\">Dispatcher Servlet</a></p>\n<ul>\n<li><a href=\"#dispatcher-servlet-processing\">Dispatcher servlet processing</a></li>\n<li><a href=\"#handleradapter-interfaces\">HandlerAdapter Interfaces</a></li>\n<li><a href=\"#spring-mvc-%EC%99%80-dispatcherservlet-%EB%8F%99%EC%9E%91%EB%B0%A9%EC%8B%9D\">Spring MVC 와 DispatcherServlet 동작방식</a></li>\n<li><a href=\"#%ED%8C%8C%EC%83%9D-%ED%82%A4%EC%9B%8C%EB%93%9C-%EB%B0%8F-%EC%A3%BC%EC%A0%9C\">파생 키워드 및 주제</a></li>\n<li><a href=\"#%EC%9D%98%EB%AC%B8\">의문</a></li>\n<li><a href=\"#%EC%B0%B8%EA%B3%A0%EB%A7%81%ED%81%AC\">참고링크</a></li>\n</ul>\n</li>\n</ul>\n</div>","frontmatter":{"date":"June 03, 2021","title":"Dispatcher Servlet 알아보기","categories":"웹","author":"코다","emoji":"🖥"},"fields":{"slug":"/dispatcher-servlet/"}},"prev":{"id":"38ae2cc9-d468-5d33-af6e-18533bf42cae","html":"<h2 id=\"jwtjson-web-token-배경\" style=\"position:relative;\"><a href=\"#jwtjson-web-token-%EB%B0%B0%EA%B2%BD\" aria-label=\"jwtjson web token 배경 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JWT(JSON Web Token) 배경</h2>\n<p>이전에 인증 절차를 거치려면 사용자의 해싱값을 DB에 저장하고 매번 요청이 있을 때마다 해당 해싱값을 검증해야한다. 검증시 DB에 접근하는 쿼리가 실행되어야하는데 성능면에서 좋지 않다. 따라서 JWT가 등장하게 되고 위와 같은 절차를 거치지만 DB 접근 쿼리가 필요하지 않게 된다. </p>\n<ul>\n<li>\n<p><em>JWT 정의: A string that is sent in the HTTP request (from client or server) to validate the authenticity of the client. It is saved on the client-side only.</em></p>\n<p><a href=\"%5Bhttps://medium.com/jspoint/so-what-the-heck-is-jwt-or-json-web-token-dca8bcb719a6%5D(https://medium.com/jspoint/so-what-the-heck-is-jwt-or-json-web-token-dca8bcb719a6)\">출처</a> </p>\n</li>\n</ul>\n<br>\n<h2 id=\"jwt-특징\" style=\"position:relative;\"><a href=\"#jwt-%ED%8A%B9%EC%A7%95\" aria-label=\"jwt 특징 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JWT 특징</h2>\n<ul>\n<li>compact</li>\n<li>self-contained</li>\n<li>\n<p>digitally signed : it is signed using a secret key(<strong>HMAC</strong> algorithm) or public/private key pair using (<strong>RSA</strong> or <strong>ECDSA</strong>)</p>\n<ul>\n<li>sgined 토큰 이라면 claim의 무결성(integrity)를 검증할 수 있다.</li>\n<li>만일 토큰이 public/private key로 signed 되었다면, 시그니처는 private key를 들고있는 쪽이 signed 한 것이라는 것을 보장한다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"jwt-언제-사용하면-좋을까\" style=\"position:relative;\"><a href=\"#jwt-%EC%96%B8%EC%A0%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%A9%B4-%EC%A2%8B%EC%9D%84%EA%B9%8C\" aria-label=\"jwt 언제 사용하면 좋을까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JWT 언제 사용하면 좋을까</h2>\n<ul>\n<li><strong>Authorization</strong>: 유저가 로그인하여 어떠한 요청들을 보낼 때, JWT를 통해서 인증을 한다. JWT가 사용되는 가장 대표적인 시나리오다. <code class=\"language-text\">Single Sign On</code> 이라고 하는데, 이 때 JWT를 사용하면 부하도 적고 여러 다른 도메인에서 쉽게 사용될 수 있다. (cross-origin일 때 용이)</li>\n<li><strong>Information Exchange</strong>: 정보들을 안전하게 전달하려고 할 때 JWT를 사용하기도 한다. JWT를 signed 할 수 있으니 송신자가 누군지 보장할 수 있다. 또한 시그니처를 통해서 header와 payload를 계산하기 때문에 해당 컨텐츠가 무결함을 보장할 수 있다.</li>\n</ul>\n<br>\n<h2 id=\"jwt-생성\" style=\"position:relative;\"><a href=\"#jwt-%EC%83%9D%EC%84%B1\" aria-label=\"jwt 생성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JWT 생성</h2>\n<p>secret key를 사용해서 JWT를 생성하며, 해당 secret key는 private하여 외부에 공개되거나 JWT 토큰에 주입될 경우가 없다. 또한 JWT를 클라이언트에게 받았을 때 서버에 저장되어 있는 secret key를 통해서 검증한다. <br></p>\n<p>JWT 생성하기 위해서 <a href=\"%5Bhttps://jwt.io/%5D(https://jwt.io/)\">여기</a> 에서 원하는 라이브러리를 다운 받아서 사용한다. </p>\n<br>\n<h2 id=\"jwt-구조\" style=\"position:relative;\"><a href=\"#jwt-%EA%B5%AC%EC%A1%B0\" aria-label=\"jwt 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JWT 구조</h2>\n<p><code class=\"language-text\">xxxx.yyyy.zzzz</code> 으로 header, payload, signature가 (<code class=\"language-text\">.</code>)로 연결되어 있다. </p>\n<ul>\n<li>\n<p>Header</p>\n<ul>\n<li>type of token (ex. JWT)</li>\n<li>signing algorithm</li>\n<li>JSON 타입, <code class=\"language-text\">Base64Url</code>로 인코딩</li>\n</ul>\n</li>\n<li>\n<p>Payload</p>\n<ul>\n<li>claims - entity(유저) 정보나 이외의 추가 정보 등등</li>\n<li>\n<p>registered - 등록되어 있는 claims로 항상 추가하기를 권장하는 유용한 claims</p>\n<ul>\n<li>iss(issuer), exp(expiration time), sub(subject), aud(audience) 등등</li>\n<li>JWT은 compact 하기 때문에 3글자로 제한하여 정의함</li>\n</ul>\n</li>\n<li>\n<p>public -  JWT 사용하는 입장에서 정의할 수 있는 claims</p>\n<ul>\n<li>충돌을 피하기 위해서 JWT Registry에 정의된 것들만 사용하거나, 충돌방지할 수 있는 URI 형태</li>\n</ul>\n</li>\n<li>private - 커스텀 claims로 양쪽에서 합의하여 공유하기로 한 정보에 대해서 서술한 claims</li>\n<li>JSON 타입, <code class=\"language-text\">Base64Url</code>로 인코딩, 때문에 어느 누구나 디코딩하여 접근할 수 있는 정보이기 때문에 민감한 정보는 담지 않도록 한다.</li>\n</ul>\n</li>\n<li>\n<p>Signature</p>\n<ul>\n<li>인코딩 된 header, payload, secrete을 조합하여 header에 있는 알고리즘으로 시그니처를 생성</li>\n<li>이 시그니처를 통해서 담긴 정보의 무결성을 보장</li>\n<li>private key로 signed 되었을 경우 JWT sender 또한 보장 가능</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"jwt-signature\" style=\"position:relative;\"><a href=\"#jwt-signature\" aria-label=\"jwt signature permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JWT Signature</h3>\n<p>위 header와 payload는 쉽게 디코딩해 내용을 확인할 수 있다. 따라서 해당 token을 보안에 사용할 수 있도록 하는 요소는 signature이다. <br></p>\n<p>제 3자가 토큰의 header나 payload를 변경하지 않았음을 보장하기 위해서 secret key와 해당 키로 생성된 signaturer를 사용한다. <br></p>\n<p>Token 검증을 할 때, 전송된 JWT에 있는 header, payload를 가지고 서버에 저장되어 있는 secret을 통해서 test signature를 생성한다. test signature와 token에 있는 처음 token 생성시 추가된 original signature와 동일한지 비교하여 데이터 변경 여부를 체크한다. 이 방법을 통해서 token은 데이터 무결성을 보장한다. <br></p>\n<br>\n<h2 id=\"왜-jwt\" style=\"position:relative;\"><a href=\"#%EC%99%9C-jwt\" aria-label=\"왜 jwt permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>왜 JWT?</h2>\n<p>Simple Web Tokens(<strong>SWT</strong>)와 Security Assertion Markup Language Tokens(<strong>SAML</strong>) 비교했을 때 장점들이다. <br></p>\n<p>JSON은 우선 XML보다 간단(덜 장황함)하여 인코딩 했을 때, 그 사이즈가 훨씬 작고 <strong>SAML</strong>보다 compact 하다. <br></p>\n<p align=\"center\"><img width=\"85%\" src=\"https://user-images.githubusercontent.com/63405904/135121193-926e8de5-411d-49dc-873c-09cfb0a552df.png\"></p>\n<p align=\"center\"><img width=\"85%\" src=\"https://user-images.githubusercontent.com/63405904/135121388-68caa14c-464b-449e-8901-70491a30b765.png\"></p>\n<p>보안적 측면에서는 <strong>SWT</strong>는 대칭키를 활용하는 HMAC 알고리즘만 사용이 가능한데, <strong>JWT</strong>, <strong>SAML</strong>은 public/private key 페어를 사용할 수 있다. 더해서 XML signing보다 JSON signing이 훨씬 쉽다. <br></p>\n<p>또한 잘 구축되어 있는 여러 JSON 파서들을 활용할 수 있다. <br></p>\n<p>마지막으로 활용 측면에서 <strong>JWT</strong>는 인터넷 환경에서 많이 쓰인다. 그렇기 때문에 클라이언트의 입장에서 <strong>JWT</strong>를 여러 환경(특히, 모바일 환경에서도)에서 활용하기 용이하다는 장점이 있다.  <br></p>\n<br>\n<br>\n<p><strong>[참고자료]</strong></p>\n<ul>\n<li><a href=\"https://jwt.io/introduction\">https://jwt.io/introduction</a></li>\n<li><a href=\"https://stackoverflow.com/questions/31309759/what-is-secret-key-for-jwt-based-authentication-and-how-to-generate-it\">https://stackoverflow.com/questions/31309759/what-is-secret-key-for-jwt-based-authentication-and-how-to-generate-it</a></li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#jwtjson-web-token-%EB%B0%B0%EA%B2%BD\">JWT(JSON Web Token) 배경</a></li>\n<li><a href=\"#jwt-%ED%8A%B9%EC%A7%95\">JWT 특징</a></li>\n<li><a href=\"#jwt-%EC%96%B8%EC%A0%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%A9%B4-%EC%A2%8B%EC%9D%84%EA%B9%8C\">JWT 언제 사용하면 좋을까</a></li>\n<li><a href=\"#jwt-%EC%83%9D%EC%84%B1\">JWT 생성</a></li>\n<li>\n<p><a href=\"#jwt-%EA%B5%AC%EC%A1%B0\">JWT 구조</a></p>\n<ul>\n<li><a href=\"#jwt-signature\">JWT Signature</a></li>\n</ul>\n</li>\n<li><a href=\"#%EC%99%9C-jwt\">왜 JWT?</a></li>\n</ul>\n</div>","frontmatter":{"date":"June 13, 2021","title":"JWT (JSON Web Token) 알아보기","categories":"웹","author":"코다","emoji":"🖥"},"fields":{"slug":"/jwt-token/"}},"site":{"siteMetadata":{"siteUrl":"https://yjksw.github.io","comments":{"utterances":{"repo":"yjksw/yjksw.github.io"}}}}},"pageContext":{"slug":"/java-bean/","nextSlug":"/dispatcher-servlet/","prevSlug":"/jwt-token/"}},"staticQueryHashes":["1073350324","2938748437"]}
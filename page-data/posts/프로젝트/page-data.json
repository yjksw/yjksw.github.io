{"componentChunkName":"component---src-templates-category-template-js","path":"/posts/프로젝트","result":{"pageContext":{"currentCategory":"프로젝트","categories":["All","웹","책","성능테스트","인프라","스프링부트","네트워크","운영체제","자바","알고리즘","스프링","데이터베이스","JPA","프로젝트","설계","테스트","머신러닝","아무말","블로그","운영","빌드","기타"],"edges":[{"node":{"id":"c5e44e8c-2ca4-5cbc-ae8a-04e3d2e1640a","excerpt":"💡 Intro JPA를 프로젝트에서 사용하면서 연관 엔티티를 호출할 때 생기는 N+1을 해결한 경험이 있다. 이때 해결 방법으로 hibernate의 를 yml에 설정하여 해결했었다. 참고링크 해결부분 프로젝트를 전반적으로 체크하던 와중에 위 설정에 의한 in query가 실행되지 않고 여전히 N+1 문제가 발생하는 부분을 발견하였다.  해당 현상을 공유하기 위해 글을 작성한다. (여전히 이유는 못 찾았다 😢) 🌩  우선 간단하게 위 설정에 대해서 짚고 넘어가보자. 설정할 수 있는 방법은 두 가지 이다.   어노테이션 활용  클래스, 메소드, 필드 레벨에서 사용할 수 있다.  해당 사이즈 만큼의 상위 엔티티 id가 in query로 나간다.  를 application.properties에 지정 전역적으로 적용이 되어서 상위 엔티티의 lazy loading된 하위 엔티티를 한꺼번에 in query로 로딩한다.  Hibernate javadocs 공식 문서에 다음과 같이 서술한다.  즉…","fields":{"slug":"/jpa-default-batch-fetch-size-not-working/"},"frontmatter":{"categories":"JPA 프로젝트","title":"하이버네이트 default-batch-fetch-size 가 안되는 현상 😢","date":"October 21, 2021"}},"next":{"fields":{"slug":"/operating-system-8/"}},"previous":{"fields":{"slug":"/process_synchronization/"}}},{"node":{"id":"79b6b456-21f6-50d7-af26-9328d6bda772","excerpt":"💡 Intro 이전 포스트에서 진행한 프로젝트에서 홈피드 게시물 조회 성능 테스트에 대한 결과를 보고 개선대상을 파악하고 개선한다.  개선 후 테스트를 재진행하여 결과를 비교한다.  🌩 쿼리 진단 이전 포스트에서 진행한 성능 테스트를 통해 DB 쿼리 쪽 병목이 있다는 것을 알아냈다. 구체적으로 쿼리를 자세히 살펴보면서 어떤 문제가 있는지 확인해보자.  홈피드 게시물을 반환할 때 발생하는 slow query 현재는 포스트 조회하는 쿼리가 최대값으로는 3.62 초가 소요된다.  쿼리의 실행계획을 확인해서 문제점을 파악해보니 100만건의 데이터를 거의 다 훑으면서 filesort를 하고 있었다. 게시물을 최신순으로 정렬하여 상위 10개를 가지고 오는 Pagination을 적용하고 있기 때문이다.  🌩 개선하기 createt_At 칼럼에 인덱스를 추가하여 데이터가 정렬되도록 한다. 인덱스를 건 후 실행계획을 확인해보니 filesort가 제거되었고 훑는 row 수가 대폭 줄어들었다.  🌩 …","fields":{"slug":"/project-pickgit-homefeed-performance-test-2/"},"frontmatter":{"categories":"웹 프로젝트 성능테스트 데이터베이스","title":"K6를 활용한 성능테스트 경험기 2 - 홈피드 조회 기능 향상","date":"October 15, 2021"}},"next":{"fields":{"slug":"/project-pickgit-homefeed-performance-test-1/"}},"previous":{"fields":{"slug":"/netflix-performance-analysis/"}}},{"node":{"id":"5c1b47d1-8778-57cd-9be5-9beb636f6354","excerpt":"💡 Intro 진행 중인 프로젝트에서 구현한 웹 어플리케이션이 어느 정도의 부하를 견딜 수 있는지에 대한 성능테스트를 진행했다.  프로젝트는 개발자를 타켓으로 한 깃헙 레포지토리를 연동한 게시물을 업로드하여 개발자들이 자신의 작업을 공유하고 다른 이들의 프로젝트를 캐줄얼하게 엿볼 수 있는 SNS형 웹 어플리케이션이다.  웹 어플리케이션에 들어가자마자 최신순으로 정렬된 게시물 피드를 볼 수 있다. (비로그인/로그인 모두 가능) 홈피드 게시물 조회 성능테스트를 진행, 병목 지점을 분석하고 개선하는 과정을 따라가보자.  🌩 사전 작업 테스트 더미 데이터 입력 테스트를 진행하기 위해서는 실제 운영환경과 최대한 유사한 환경에서 테스트하는 것이 중요하다.  운영환경과 유사한 환경이라고 하면 크게 1) 인프라 구조 2) 데이터 두 가지가 있다.  먼저 대량의 더미 데이터를 입력하도록 한다. (팀원 케빈이 수고해주었다 !! 👍) MariaDB 쿼리 캐시 끄기 왜 쿼리 캐시를 껐을까? 실제 어플리…","fields":{"slug":"/project-pickgit-homefeed-performance-test-1/"},"frontmatter":{"categories":"웹 프로젝트 성능테스트 데이터베이스","title":"K6를 활용한 성능테스트 경험기 1 - 홈피드 조회 기능 향상","date":"October 15, 2021"}},"next":{"fields":{"slug":"/operating-system-4/"}},"previous":{"fields":{"slug":"/project-pickgit-homefeed-performance-test-2/"}}},{"node":{"id":"f536d063-bb0a-5d8a-89be-12abd97a0c4e","excerpt":"Intro JPA의  사용시 별칭을 쓰면 안되는 이유가 무엇인지 알아본다.  프로젝트애서 fetch join 시 별칭 사용에 대해서 고민해본다.  fetch join 별칭은 왜 안될까 ? fetch join에서 별칭이 안되는 이유는 데이터의 일관성이 깨지기 때문이다. 예를 들어서 다음과 같은 코드는 fetch join 대상에 조건문이 들어가서 일관성이 깨진 경우이다. TeamA에 대한 member collection 은 본래 3개이다. 그리고 fetch join을 하면 연관된 데이터가 모두 들어올 것이라고 가정한다.  하지만 위와 같이 fetch join 대상에 별칭을 주어 where 필터링 조건을 사용하면 실제로 TeamA에 연관된 멤버는 3명이지만 만 연관 데이터로 들어온다.  DB의 상태에 대한 일관성이 깨진다.  하지만 예외는 있다 일관성을 해치지지 않는 한에서 성능에 도움이 된다면 예외적으로 사용해도 된다. (아마도 하이버네이트가 별칭을 허용하는 이유…) 예를 들어 다음과…","fields":{"slug":"/jpa-fetch-join-nickname/"},"frontmatter":{"categories":"JPA 프로젝트","title":"JPA 에서 별칭을 쓰지 않는 이유 (하지만 쓴 이유)","date":"October 06, 2021"}},"next":{"fields":{"slug":"/one-percent-network-8/"}},"previous":{"fields":{"slug":"/one-percent-network-9/"}}},{"node":{"id":"7df6549b-317d-5023-9260-e4d9249565d0","excerpt":"INTRO JPA 에서는 데이터베이스에서 연관객체 탐색을 효율적으로 하기 위해서 지연로딩 전략을 사용한다.  지연로딩의 핵심은 연관관계에 있는 Entity가 실제로 사용되기 이전까지 DB에 실제로 참조하지 않고 프록시 객체로 대체하는 것이다.  JPA의 프록시 객체는 유용하지만 내부 동작방식에 대해서 제대로 알고있지 않으면 찾기 어려운 버그를 만날 수도 있다.  다음은 JPA proxy 관련해서 프로젝트 진행시 만난 버그에 대한 내용이다.  문제 상황 Entity 구조 참고: 설명과 관련된 부분만 남기고 다른 로직 및 어노테이션은 대부분 생략했다.   - 게시물 엔티티 와  - Post 엔티티 하위의 Embedded 게시물 Like collection 포장객체 참고: 설명하고자 하는 부분과 깊게 연관된 핵심 Entity는 아니지만  상황 설명을 위해 간단히 프로퍼티만 소개한다.   - 어플리케이션 사용자 (게시물 좋아요, 유저간 팔로우 팔로잉 등의 행위를 함) 와   - 해당 의 …","fields":{"slug":"/jpa-proxy-equals-bug/"},"frontmatter":{"categories":"JPA 프로젝트","title":"JPA 프록시 관련 버그 경험기","date":"August 26, 2021"}},"next":{"fields":{"slug":"/jpa-proxy/"}},"previous":{"fields":{"slug":"/jpa-query-bug/"}}}]}},"staticQueryHashes":["1073350324","2938748437"]}
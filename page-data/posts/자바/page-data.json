{
    "componentChunkName": "component---src-templates-category-template-js",
    "path": "/posts/자바",
    "result": {"pageContext":{"currentCategory":"자바","categories":["All","책","자바","스프링","웹","운영체제","아무말","스프링부트","테스트","네트워크","JPA","프로젝트","성능테스트","데이터베이스","인프라","블로그","featured","운영","설계","빌드","기타","알고리즘","머신러닝"],"edges":[{"node":{"id":"39669800-a8a1-59fe-b30a-a447fd689c46","excerpt":"💡 Intro 데이터의 그룹을 저장하는 클래스들을 표준화한 프로그래밍 방식 컬렉션 프레임워크는 다수의 데이터를 다루는 여러 클래스를 제공하여 개발자의 부담을 덜어준다. 인터페이스와 다형성을 이용해서 객체지향적으로 설계가 되어 있기 때문에 추상적이고 재사용성이 높은 좋은 프레임워크이다. 🌩 핵심 인터페이스 컬렉션에 담기는 데이터를 크게 3가지로 나누어 각각을 인터페이스로 정의해두었다. 그리고 3가지 중 List, Set의 공통점을 뽑아 따로 인터페이스로 추상화 되어 있다. 각 인터페이스와 특징은 다음과 같다. List: 순서가 있으며 중복이 허용된 데이터의 집합 ArrayList, LinkedList, Stack, Vector, etc. Set: 순서가 없으며 중복을 허용하지 않는 데이터의 집합 HashSet, TreeSet, etc. Map: 키와 값의 쌍으로 이루어진 데이터의 집합이며 순서를 유지하지 않으며 키는 중복을 허용하지 않음 HashMap, TreeMap, Hashtab…","fields":{"slug":"/java-collection-framework-1/"},"frontmatter":{"categories":"자바","title":"자바 컬렉션 프레임워크 파헤치기 1 - 기본 & ArrayList","date":"December 03, 2021"}},"next":{"fields":{"slug":"/reactive-programming/"}},"previous":{"fields":{"slug":"/growing-together-1/"}}},{"node":{"id":"00e80243-2a3a-528a-8625-03c3c7bfbedb","excerpt":"💡 Intro JVM은 자바의 큰 장점 중 하나로 이 가상머신이 깔려있는 운영체제에서는 모두 동일하게 자바 클래스 파일이 실행될 수 있다. JVM의 기본 구조를 알아보자 🙌 🌩 JVM 메모리 구조 1) Class Loader 2) Execution Engine 3) Garbage Collector 4) Runtime Data Area 4가지로 나뉘어져 있다. Class Loader JVM 내로 클래스 파일을 로드하고 링크를 통해 배치하는 작업을 수행한다. 런타임 시에 동적으로 클래스를 로드한다. Execution Engine 클래스 로더가 Runtime Data Area에 배치한 바이트 코드들을 명령어 단위로 읽어서 실행하는 작업을 수행한다. 최초 JVM에서는 인터프리터 방식이어서 느렸지만 JIT 컴파일러로 변경되면서 실행이 빠르다는 장점이 있다. 모든 코드 JIT으로 하지 않고 인터프리터로 하다가 일정한 기준이 넘어가면 JIT 컴파일러 방식으로 실행한다. 한번 읽어서 기계어로 변…","fields":{"slug":"/java-jvm/"},"frontmatter":{"categories":"자바","title":"JVM 구조 알아보기","date":"November 17, 2021"}},"next":{"fields":{"slug":"/spring-ioc-aop-psa/"}},"previous":{"fields":{"slug":"/reactive-programming/"}}},{"node":{"id":"0f7262a6-8cc3-5ad6-a8f8-5c468e91c6c6","excerpt":"💡 Intro 인터페이스와 추상클래스의 차이를 명확하게 구분해보자. 언제 무엇을 쓰는 것이 좋은지 나름의 정의를 내려본다. 상속의 위험성에 대해서 고민해본다. 🌩 추상클래스 추상 클래스는 “미완성 설계도” 이다. 공통부분을 우선 정의한 미완성 설계도를 만들고 각기 다른 상황에 대해서 추가로 구현할 수 있다. 완성되지 않은 abstract 메소드를 포함하고 있다. 추상클래스는 abstract 메소드가 있다는 것을 제외하고는 일반클래스와 동일하다. 상속은 자손 클래스를 만드는데 조상 클래스를 사용하는 것 추상화는 자손 클래스의 공통부분을 뽑아내서 조상 클래스를 만드는 것 상속 추상클래스를  하는 명령어가 상속에서 사용되기 때문에 두 개념이 혼용되어서 사용되기도 한다. 엄밀히 말하면 두 개념이 겹칠수도 있지만 완전히 동일한 것은 아니다. 상속이란 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것 적은 양의 코드로 새로운 클래스를 작성할 수 있고 공통부분을 관리할 수 있다는 장점이 …","fields":{"slug":"/java-abstract-vs-interface/"},"frontmatter":{"categories":"자바","title":"추상클래스와 인터페이스 더 이상 헷갈리지 않기","date":"November 15, 2021"}},"next":{"fields":{"slug":"/os-user-kernel-thread/"}},"previous":{"fields":{"slug":"/spring-pojo/"}}},{"node":{"id":"44979c6c-3a26-53fb-9abc-7e9b88c7744c","excerpt":"[INTRO] 자바가 업데이트 되면서 메소드를 일급시민으로 취급할 수 있게 되었다. 이로 인해 동작 파라미터를 통해서 어떠한 동작을 인자로 넘길 수 있다. 메소드를 일급 시민으로 취급하면서 함수형 인터페이스 등의 개념이 등장한다. 코드의 명확성을 증진시키기 위해 익명 클래스, 람다 함수, 메서드 참조 등등의 개념이 활용된다. 동작 파라미터를 활용한 예시로 콜백 함수를 들여다보자. [왜 동작 파라미터인가?] 코딩을 할 때 가장 중요한 요소 중 하나는 변화하는 요구사항에 대응하는 것이다. 동작 파라미터화는 나중에 실행할 코드 블록을 인수로 넘겨서 행동을 결정하는 것이다. 나중에 실행되도록 넘기는 콜백 함수와 같은 동일하게 작용한다. (내재된 개념이다) 이해를 돕기 위해 모던 자바 인 액션 에 나온 예제를 살펴보자. 상황1: 사과를 색으로 필터링 하는 요구사항을 구현한다. 상황2: 사과를 무게로 필터링하는 요구사항을 구현한다. 위 두 코드가 상당히 유사하다. (실제로 작성할 때도 복붙하…","fields":{"slug":"/behavior-parameterization/"},"frontmatter":{"categories":"자바","title":"동작 파라미터부터 람다까지: 콜백함수를 곁들인","date":"September 22, 2021"}},"next":{"fields":{"slug":"/db-replication/"}},"previous":{"fields":{"slug":"/high-traffic-service_1/"}}},{"node":{"id":"41ff080c-8050-53a6-a648-d015de29c91e","excerpt":"자바 I/O 스트림 Stream은 데이터의 연속이다. Sequence of Data 다르게 말하면 Stream 이란 한쪽으로 흐르는 통로같은 것이다. 자바에서 Stream이란 한쪽 source에서 destination으로 흐르는 데이터를 위한 단방향 통로이다. 자바에서는 여러 매체를 읽거나 쓸 수 있고 각자를 위한 I/O Stream이 구현되어 있다. (disk files, devices, programs, memory arrays) Stream은 단방향 통신이기때문에 들어오는 데이터, 나가는 데이터에 따로 InputStream, OutputStream이 있는 것이다. I/O 스트림은 여러가지 종류의 데이터들을 처리할 수 있다: 바이트, primitive data type, characters, objects Stream은 단순히 데이터를 전달하는 역할만 하기도하고, 몇몇 stream은 데이터를 조작하고 편리하게 변환하는 역할을 수행하기도 한다. 모든 Stream은 사용 후 반드시…","fields":{"slug":"/java-iostream-file/"},"frontmatter":{"categories":"자바","title":"Java IOStream 과 파일 입출력","date":"August 26, 2021"}},"next":{"fields":{"slug":"/profile-active-profile/"}},"previous":{"fields":{"slug":"/jpa-proxy-equals-bug/"}}},{"node":{"id":"8316d4d6-553f-5d70-b995-11dc98735d16","excerpt":"Intro 함수는 시스템의 상태를 바꾸는지에 따라서 크게 두 가지로 나뉜다. 1) Command 2) Query. 이 두 가지 분류법에 대해서 하나의 함수가 두 가지 경우를 모두 담당하는 것은 좋지 않다. Command vs. Query Query 주어진 쿼리에 대한 결과값을 반환하고 시스템의 상태를 변화시키지는 않는다. 다른 값을 바꾸지 않고 오직 질문에만 대답한다. 부작용에서 자유롭다. (read-only) Command 값을 반환하지 않아도 시스템의 상태를 변화시킨다. (영구적) 부작용이 생길 여기자 있다. (mutator, modifier) 이렇게 함수를 두 가지로 나누는 것은 유용하다. 현재 사용하는 함수가 상태를 바꾸지 않는 query 라면 신뢰를 가지고 사용할 수 있다. 하지만 상태를 바꾸는 command라면 함수간 순서에 주의를 기울이고 부작용이 생길 여지를 인지하고 있어야 한다. CQS - Command Query Separation Betrand Meyer라는 프…","fields":{"slug":"/java-cqs/"},"frontmatter":{"categories":"자바","title":"CQS(Command Query Separation) 간단히 알아보기","date":"July 17, 2021"}},"next":{"fields":{"slug":"/gatsby-github-blog/"}},"previous":{"fields":{"slug":"/jpa-lazyinitialization-exception/"}}},{"node":{"id":"89cc4854-91bf-5d0c-abe5-c82fe6e01006","excerpt":"들어가기 전에 암호화(Encryption)과 해싱은 다른 개념 암호화 - 양방향이므로 복호화가 가능 해싱 - 단방향이므로 복호화가 불가능 단방향 해시 함수 (One-Way Hash Function) 기본적으로 패스워드 등의 보안의 문제가 걸린 정보를 DB에 저장할 때 평문으로 저장하지 않고 해싱한 값을 저장한다. (평문으로 저장할 경우 DB가 해킹되었을 때 심각한 문제가 발생한다)  단방향 해시 함수를 사용해서 원본 내용을 완전히 새로운 내용으로 다이제스트(digest)로 매핑한다. 이때 매핑하는 것을 해시라고 한다. 이것은 단방향이므로 복호화할 수 없다.  해시 함수 종류 SHA MD HAS WHIRLPOOL 한계점 Rainbow Table 동일한 데이터를 동일한 해시 함수로 연산한 다이제스트는 동일한 값을 가진다. 따라서 여러 값들에 대한 다이제스트를 모아놓은 Rainbow Table이라는 것이 존재하고 이것을 통해서 원본 데이터를 유추할 수 있다. Brute-force 해싱 …","fields":{"slug":"/hash-salt/"},"frontmatter":{"categories":"웹 자바","title":"Hash와 Salt","date":"June 21, 2021"}},"next":{"fields":{"slug":"/spring-exception-handling/"}},"previous":{"fields":{"slug":"/symmetric-vs-asymmetric-encryption/"}}},{"node":{"id":"8bf91ec6-90fe-5ce0-86c1-d8e98765968f","excerpt":"간단한 JavaBean 규약에 대해서 알고 넘어가기 JavaBean 자바빈 규약을 따르는 Java Class를 말한다. JavaBean 규약 defulat 패키지가 아닌 패키지 하위에 있는 클래스 기본 생성자가 존재 (no-arg constructor) Property는 모두 private으로 선언 Getter/setter를 통해서 properties를 조작 을 implement 하여 직렬화 가능 번외 : Serialization & Deserialization Serialization : converting state of an object into a byte stream Deserialization: reverse process of serialization 해당 객체에 영속성을 부여하기 위해서 사용되는 매커니즘이다.  Java 객체를 serialize 하게 하기 위해서는  인터페이스를 구현하도록 한다. 해당 인터페이스는 멤버변수나 메소드가 존재하지 않는 marker inte…","fields":{"slug":"/java-bean/"},"frontmatter":{"categories":"자바","title":"자바빈 규약 (번외: Serialization)","date":"June 08, 2021"}},"next":{"fields":{"slug":"/dispatcher-servlet/"}},"previous":{"fields":{"slug":"/jwt-token/"}}},{"node":{"id":"c6060cb1-1a69-5cc5-8508-1df3c8357b5f","excerpt":"요약하자면 Stream과 Collection의 차이는 다음과 같다. 개념적으로 접근했을 때 Collection의 경우에는 어떠한 데이터를 담는 자료구조의 역할을 주로 하지만, Stream의 경우는 연산과 관련된 것이 주라고 볼 수 있다. Quote Java Collections offer efficient mechanisms to store and process the data by providing data structures like List, Set, and Map. However, the Stream API is useful for performing various operations on the data without the need for intermediate storage. 출처: https://www.baeldung.com/java-return-stream-collection Traversal Collection은 여러번 데이터를 횡단할 수 있지만, Stream은 …","fields":{"slug":"/stream-vs-collection/"},"frontmatter":{"categories":"자바","title":"Stream vs. Collection","date":"March 20, 2021"}},"next":{"fields":{"slug":"/boolean-timestamp/"}},"previous":{"fields":{"slug":"/gatsby-starter-zoomkoding-introduction/"}}},{"node":{"id":"915623df-4098-5aa0-a151-1520961c52ed","excerpt":"프리코스를 진행하면서 구글에서 제공하는 javaGuide를 읽고 해당 convention을 따라서 코딩 하도록 하기 위해서 해당 문서를 정독했다. 원래 알고 있던 부분들도 있고 아닌 부분들도 있는데, 이렇게 잘 문서화 되어 있다는 것을 처음 알았다. 다음은 해당 문서를 읽으면서 두고두고 참고할 내용들을 정리한 것들이다.  다음 사이트 참고: Google Java Style Guide 1. Source file structure Java 소스 파일은 다음과 같은 구조를 가지고 있다. 순서에 유의하여 구조화 되어 있다. 만약 존재한다면, license or copyright information Package 명시 Import statements 단 하나의 top-level class → 위의 4 section을 1줄 간격(exactly one blank)으로 나눈다. 1-1. copyright information 소스파일 맨 위에 시작 주석으로 파일 클래스 이름, 버전 정보, 날짜…","fields":{"slug":"/java-coding-convention/"},"frontmatter":{"categories":"자바","title":"[JAVA] 구글에서 제공하는 Java Coding Convention Guide","date":"November 28, 2020"}},"next":{"fields":{"slug":"/binomial-coefficient/"}},"previous":{"fields":{"slug":"/commit-message-convetion/"}}},{"node":{"id":"e6f0d0ff-4840-58a3-a95a-131f2cc9d72d","excerpt":"자바에서 LIST 인터페이스를 구현한 Collection 구현체 중 가장 많이 쓰고 헷갈리는 것이 ArrayList와 LinkedList의 차이이다. 알고리즘 코딩을 공부하다가 특정 답을 배열 구조에 담을 일이 있어서 찾아보다 문득 ArrayList, LinkedList 중 무엇을 쓸까 고민하는 김에 정리하게 되었다.  인터페이스도 같고 사용하는 방식도 비슷한 부분이 많기 때문에 ArrayList를 써야할 때 LinkedList를 쓰거나 그 반대로 사용하더라도 큰 차이가 없이 느껴지기도 한다. 하지만 두 가지 자료구조가 구분되어 있는 만큼 더 적절한 부분이 있다. 간단히 한번 알아보자.  Java에서는 변수를 저장하기 위해서 배열을 사용한다. 하지만 배열의 단점은 초기에 길이를 저장해서 미리 메모리를 확보해 놓아야 한다는 것이다. 다라서 동적으로 메모리 할당이 어려울 뿐만 아니라, 예상하지 못하는 입력크기에 대해서는 애초에 크게 배열의 크기를 잡아놓는 비효율적인 방법을 택해야 한다…","fields":{"slug":"/java-list/"},"frontmatter":{"categories":"자바","title":"[JAVA] ArrayList와 LinkedList 차이점","date":"August 09, 2020"}},"next":{"fields":{"slug":"/java-wrapper-class/"}},"previous":{"fields":{"slug":"/ml-recommendation-system/"}}},{"node":{"id":"ca95173c-b23d-5aec-933f-46102018988a","excerpt":"다음은 Java에 존재하는 아주 특이한 클래스인 Wrapper class에 대한 내용이다. JAVA wrapper class에 대해서 설명한 한 사이트를 번역하는 겸 공부한 내용을 정리해 작성해놓았다. 1. 개요 Wrapper class(감싸는 클래스) 이름이 설명하듯이 wrapper class는 자바의 Primitive types들을 객체로 감싸는 역할을 하는 클래스이다.  다음과 같은 자바의 primitive 타입들은 모두 각자의 wrapper 클래스가 있다.  boolean, byte, short, char, int, long, float, double  Boolean, Byte, Short, Character, Integer, Long, Float, Double 이것들은 모두 java.lang 패키지에 정의되어 있으므로 따로 import 하지 않아도 사용할 수 있다.  2. Wrapper Classes “Wrapper 클래스의 목적은 무엇입니까?”는 자바 관련 인터뷰에서 흔…","fields":{"slug":"/java-wrapper-class/"},"frontmatter":{"categories":"자바","title":"[Java] Wrapper Classes in Java","date":"August 08, 2020"}},"next":{"fields":{"slug":"/naivebayes/"}},"previous":{"fields":{"slug":"/java-list/"}}}]}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}
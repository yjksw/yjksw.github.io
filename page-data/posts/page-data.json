{"componentChunkName":"component---src-templates-category-template-js","path":"/posts","result":{"pageContext":{"currentCategory":"All","categories":["All","JPA","인프라","웹","스프링부트","블로그","알고리즘","데이터베이스","자바","테스트","머신러닝"],"edges":[{"node":{"id":"11b32bd6-6da4-513d-9a84-05d7450180a7","excerpt":"INTRO DB Replication을 MySQL 공식 홈페이지에서 찾아보면 다음과 같이 말한다.     Replication enables data from one MySQL databse server (known as a source) to be copied to one or more MySQL database servers (know as replicas) \n출처 : 링크 즉, 하나의 데이터베이스(master/source)에서 다른 하나 또는 그 이상의 데이터베이스(slaves/replicas)로 데이터를 복제하여 저장하는 것이다.  Replication은 비동기로 동작한다. 따라서 replicas가 master에 지속적으로 연결되어는 동기식으로 동작하지 않는다.  설정에 따라서 여러 데이터베이스, 선택된 데이터베이스, 선택된 테이블에만 replication을 적용할 수도 있다.  MySQL replication 장점 공식 홈페이지에 나와있는 장점 4가지는 다음과 같다.  S…","fields":{"slug":"/db-replication/"},"frontmatter":{"categories":"데이터베이스 인프라","title":"DB 리플리케이션 적용하기","date":"September 10, 2021"}},"next":{"fields":{"slug":"/cookie-session/"}},"previous":null},{"node":{"id":"104d60ac-d178-5742-8d47-caf93db5ba17","excerpt":"INTRO HTTP는 Stateless 무상태성을 가지고 있다. 따라서 데이터를 상태로 저장하지 않는다. HTTP가 무성태성이기 때문에 클라이언트에 대한 데이터를 유지하고 싶을 때는 쿠키 또는 세션을 이용한다. (이전에 요청을 보낸 동일한 사용자임을 확인하고 싶은 경우 등등) 쿠키는 클라이언트가 정보를 가지고 브라우저에서 저장 및 관리한다.  세션은 서버가 데이터를 가지고 저장 및 관리한다.  Cookie 쿠키는 클라이언트가 정보를 가지고 브라우저에서 해당 정보를 저장한다.  따라서 요청을 보낼 때마다 브라우저에서 저장된 쿠키 데이터를 HTTP 헤더에 추가하여 서버에 보낼 수 있다. HTTP 메세지 자체는 무상태성이기 때문에 매번 쿠키값을 보내주어야 한다.  쿠키에 저장되는 값의 형태는 text 이다.  쿠키의 단점 클라이언트가 관리하는 것이기 때문에 데이터가 쉽게 훼손 될 수 있다.  실제로 크롬 브라우저에서 개발자 도구 -> Application 탭에 가면 쿠키 데이터를 저장하…","fields":{"slug":"/cookie-session/"},"frontmatter":{"categories":"웹","title":"쿠키와 세션 알아보기","date":"September 04, 2021"}},"next":{"fields":{"slug":"/oauth/"}},"previous":{"fields":{"slug":"/db-replication/"}}},{"node":{"id":"9dcfc695-3e64-5efc-9b80-257d69dd5ae2","excerpt":"1. INTRO 많은 어플리케이션에서 소셜 로그인을 지원하는데, 이때 사용되는 것이 OAuth 2.0 이다.  간단하게 이야기하면 OAuth 2.0 이란 사용자의 정보에 대한 권한을 부여하는 의 일종이다.  (정의) 제 3의 앱이 자원의 소유자인 서비스 이용자를 대신하여 서비스를 요청할 수 있도록 자원 접근 권한을 위임하는 방법  출처: 금융보안원 “OAuth 2.0 개요 및 보안 고려사항” 보안연구부-2015-030 즉, 정보 소유자 (서비스 이용자)를 대신하여 앱이 다른 서비스에 등록되어 있는 자원에 대한 접근을 요청하는 권한을 위임한다.  아래 글은 링크 원문을 번역하고 일부 요약한 것이다.  2. OAuth 주요 개념 3. 간단히 보는 OAuth 프로토콜 흐름 어플리케이션 유저에게 리소스에 대한 인가를 요청한다.  유저는 해당 인가를 승인한다.  어플리케이션은 리소스를 보유하고 있는 인가 서버에 access token을 요청한다.  본 어플리케이션이 인증이 되고, 인가 승인…","fields":{"slug":"/oauth/"},"frontmatter":{"categories":"웹","title":"OAuth 알아보기","date":"September 03, 2021"}},"next":{"fields":{"slug":"/cdn/"}},"previous":{"fields":{"slug":"/cookie-session/"}}},{"node":{"id":"ff4d68a5-f01f-5ae1-92ba-074f403b2c61","excerpt":"Intro 이번에 프로젝트를 진행하면서 보안상의 이유로 직접 S3 서버에 접근할 수 없었기 때문에 AWS에서 제공하는 CDN 서비스인 CloudFront를 통해서 이미지 등의 리소스에 접근해야 했다. (CDN서버의 본래 목적과는 다소 다른 이유로 사용했다.) CDN은 어떤 기술이며, 장점이 무엇이고, 어떻게 동작하는지에 대해서 알아본다.  CDN을 퉁해 누릴 수 있는 보안적인 이점은 무엇이며, 프로젝트를 진행하면서 CloudFront를 어떻게 활용했는지에 대해서 작성한다.  CDN이란 무엇인가? CDN은 Content Delivery Network의 약자이다. 직역하자면 컨텐츠를 전달해주는 네트워크이다. CDN 컨텐츠를 전송하는 물리적인 서버가 지리적으로 여러곳에 상주하며 유저와 가까이 위치한 서버에서 요청한 컨텐츠를 고속으로 제공해준다. \n CDN이 제공하는 컨텐츠는 ,  파일, , 이미지, 동영상 등의 대부분의 인터넷 콘텐츠이다. CDN 서비스에 대해서 설명하는 예시에 항상 등…","fields":{"slug":"/cdn/"},"frontmatter":{"categories":"인프라","title":"CDN 알아보기","date":"September 02, 2021"}},"next":{"fields":{"slug":"/jpa-proxy/"}},"previous":{"fields":{"slug":"/oauth/"}}},{"node":{"id":"0bbf1a5f-5450-5c71-8533-7652d2132ffe","excerpt":"INTRO JPA는 DB의 데이터와 객체간의 모순을 해결하기 위해서 나온 것이다. 객체는 객체 그래프로 탐색이 가능하지만 데이터베이스에 저장된 데이터는 객체를 탐색하듯이 탐색하기가 어렵다. 따라서 데이터베이스에 저장된 데이터들을 가지고 객체 그래프 탐색이 가능하기 위해서 프록시 라는 기술이 나왔다. JPA에서는 연관된 객체를 로딩하는데 지연 로딩과 즉시 로딩이라는 두가지 기법을 사용한다. 여기서 지연 로딩시 프록시 기술이 사용된다. 기본 예시 Entity Member Team  프록시 지연 로딩을 설정된 연관 객체를 가져올 때 프록시 객체를 가져온다. 를 사용하면 실제 객체를 가져오고, 를 사용하면 프록시 객체를 가져온다. 프록시 객체를 가져온다는 것은 query는 실행되지 않는 것이다. 특정 객체에 대해 를 하면 연관된 객체에 대해서는 설정되어 있는  종류에 따라 즉시로딩 혹은 지연로딩한다. 실제 Entity 조회 -  위 테스트를 실행하면 다음과 같은 select 쿼리가 실행된…","fields":{"slug":"/jpa-proxy/"},"frontmatter":{"categories":"JPA","title":"JPA 프록시 알아보기","date":"August 26, 2021"}},"next":{"fields":{"slug":"/jpa-query-bug/"}},"previous":{"fields":{"slug":"/cdn/"}}},{"node":{"id":"7bad748d-3789-5403-bce9-4bf2f8205619","excerpt":"INTRO JPA에서는 데이터와 객체지향으로 설계 사이의 모순을 해소하기 위해서 나온 기술이다.  많은 객체들은 내부에 Collection 형태로 다른 객체에 대한 참조가 가능하게 설계된다.  예)  객체 내부에 에 속해있는  와 팀에 할당된 가 존재한다.  이때 상위 객체를 select 하면서 하위 객체를 가져오는 경우 다음 두가지 fetch 타입에 각각 다음과 같은 문제가 있다.  일 경우 : 이 발생 일 경우 :  문제 발생 상위 엔티티에서 다수의 collection 형태의 연관엔티티를 가지고 있을 때 여러 상황 및 문제와 해결 방법에 대해서 공부해본다.  Entity 상황 과 가 1:N 연관관계 - ,  과 가 1:N 연관관계 - ,  참고 : 우선 모든 연관관계는 로 적용하고 테스트 상황에 따라 로 변경  엔티티  엔티티  엔티티 JPA에서 collection fetch join Team에 대한 모든 정보가 필요한 경우 Team을 가져오면서 Members와 Lockers …","fields":{"slug":"/jpa-query-bug/"},"frontmatter":{"categories":"JPA","title":"JPA N+1 문제 및 해결방법 알아보기","date":"August 26, 2021"}},"next":{"fields":{"slug":"/java-iostream-file/"}},"previous":{"fields":{"slug":"/jpa-proxy/"}}},{"node":{"id":"41ff080c-8050-53a6-a648-d015de29c91e","excerpt":"자바 I/O 스트림 Stream은 데이터의 연속이다. Sequence of Data 다르게 말하면 Stream 이란 한쪽으로 흐르는 통로같은 것이다. 자바에서 Stream이란 한쪽 source에서 destination으로 흐르는 데이터를 위한 단방향 통로이다. 자바에서는 여러 매체를 읽거나 쓸 수 있고 각자를 위한 I/O Stream이 구현되어 있다. (disk files, devices, programs, memory arrays) Stream은 단방향 통신이기때문에 들어오는 데이터, 나가는 데이터에 따로 InputStream, OutputStream이 있는 것이다.  I/O 스트림은 여러가지 종류의 데이터들을 처리할 수 있다: 바이트, primitive data type, characters, objects Stream은 단순히 데이터를 전달하는 역할만 하기도하고, 몇몇 stream은 데이터를 조작하고 편리하게 변환하는 역할을 수행하기도 한다. 모든 Stream은 사용 후 반드…","fields":{"slug":"/java-iostream-file/"},"frontmatter":{"categories":"자바","title":"Java IOStream 과 파일 입출력","date":"August 26, 2021"}},"next":{"fields":{"slug":"/jpa-proxy-equals-bug/"}},"previous":{"fields":{"slug":"/jpa-query-bug/"}}},{"node":{"id":"7df6549b-317d-5023-9260-e4d9249565d0","excerpt":"INTRO JPA 에서는 데이터베이스에서 연관객체 탐색을 효율적으로 하기 위해서 지연로딩 전략을 사용한다.  지연로딩의 핵심은 연관관계에 있는 Entity가 실제로 사용되기 이전까지 DB에 실제로 참조하지 않고 프록시 객체로 대체하는 것이다.  JPA의 프록시 객체는 유용하지만 내부 동작방식에 대해서 제대로 알고있지 않으면 찾기 어려운 버그를 만날 수도 있다.  다음은 JPA proxy 관련해서 프로젝트 진행시 만난 버그에 대한 내용이다.  문제 상황 Entity 구조 참고: 설명과 관련된 부분만 남기고 다른 로직 및 어노테이션은 대부분 생략했다.   - 게시물 엔티티 와  - Post 엔티티 하위의 Embedded 게시물 Like collection 포장객체 참고: 설명하고자 하는 부분과 깊게 연관된 핵심 Entity는 아니지만  상황 설명을 위해 간단히 프로퍼티만 소개한다.   - 어플리케이션 사용자 (게시물 좋아요, 유저간 팔로우 팔로잉 등의 행위를 함) 와   - 해당 의 …","fields":{"slug":"/jpa-proxy-equals-bug/"},"frontmatter":{"categories":"JPA","title":"JPA 프록시 관련 버그 경험기","date":"August 26, 2021"}},"next":{"fields":{"slug":"/profile-active-profile/"}},"previous":{"fields":{"slug":"/java-iostream-file/"}}},{"node":{"id":"d5d76813-7bae-5b9a-b7c6-1a21a2637ac2","excerpt":"Intro 프로젝트를 진행하다 보면 상황에 따라 각기 다른 운영환경을 설정해야할때가 있다. 그때마다 properties 설정 파일에 가서 설정되어있는 운영 환경을 바꾸고 돌리기는 어렵다.  이때 각기 다른 를 적용해서 상황에 따라 적합한  설정을 따르도록 할 수 있다.  yml 파일로 설정 나누기 - 간단하게  또는 를 통해서 profile 설정을 나눌 수 있다.  각각 원하는 환경에 대한 설정정보를 , 에 기재한 후  또는 로 지정한다.  여러 profile 환경으로 나눠져 있을 경우 어떤 profile을 기본적으로 실행할 것인지 에 지정해 주어야 한다.  나누어진 profile을 적용하기 위해서는 로 적용하고자하는 프로필을 지정하여 실행하거나  어노테이션을 활용할 수 있다.  사용 예시 본인은 프로젝트 진행 시 다음과 같이 local, prod, test로 환경을 나누었다.  application-local.yml application-prod.yml application-te…","fields":{"slug":"/profile-active-profile/"},"frontmatter":{"categories":"스프링부트","title":"웹 개발 시 Profile 전략 - @Profile & @ActiveProfile","date":"August 19, 2021"}},"next":{"fields":{"slug":"/spring-boot-test/"}},"previous":{"fields":{"slug":"/jpa-proxy-equals-bug/"}}},{"node":{"id":"24937c05-73a7-52fc-9328-64c422c66fb2","excerpt":"Intro 스프링부트 프로젝트를 진행하다보면 웹 mvc에 대한 테스트를 진행해야할 때가 있다.  때로는 각 layer에 대한 슬라이스 테스트를 작성하거나, 일부분에 대한 통합 테스트만을 진행할 때 Mock 테스트를 해야할 때도 있다.  테스트 관련 annotation에 대해서 정리하고 각 annotation의 차이 및 언제 무엇을 사용하면 좋을지 정리해본다.    어노테이션은  을 찾아 해당 configuration에 맞추어 실제 Spring web context를 실행햔다.  Spring context의 설정으로 그대로 적용해서 테스트를 진행해야 할 경우에 해당 어노테이션을 붙여서 테스트를 하는 것이 좋다.  하지만 전체 컨텍스트를 로드하는 만큼 굉장히 오랜 시간이 걸린다.  실제로  어노테이션이 붙은 테스트를 돌려본다면 다음과 같은 스프링 컨텍스트르 로딩하는 긴 로그가 찍히는 것을 확인할 수 있다.   위 어노테이션은 다음과 같이 를 주입받아서 톰캣 서버를 띄우지 않은 상태로 …","fields":{"slug":"/spring-boot-test/"},"frontmatter":{"categories":"스프링부트 테스트","title":"Springboot 언제 어떤 테스트를 사용할까","date":"August 17, 2021"}},"next":{"fields":{"slug":"/gatsby-github-blog/"}},"previous":{"fields":{"slug":"/profile-active-profile/"}}},{"node":{"id":"0283bad7-48b6-5692-a776-c4eead11c892","excerpt":"제 블로그의 테마나 Gatsby의 다른 테마를 활용해서 Github Blog를 만들고 싶은 분들이 계실텐데요! 이런 분들에게 도움을 드리고자 이 글을 쓰게 되었습니다. 잘 안되는 부분이나 궁금한 점을 댓글로 남겨주면 확인해보고 답변 드리도록 하겠습니다! 1. Repository 생성하기 GitHub Blog를 만들려면 Github에 Repository를 생성해야 합니다.  GitHub에 로그인 한 뒤에 우측 상단에 있는 New Repository 버튼을 클릭하면 repository 생성 페이지로 이동하게 됩니다. 이 때 Import a repository 버튼을 클릭합니다.  아래 페이지에 도달하시면 두 가지 정보를 넣어주셔야 하는데, Your old repository’s clone URL에는 사용하고자 하는 gatsby 테마가 있는 repository의 주소를 넣어주시면 됩니다. 제 블로그 테마를 쓰고 싶으신 분들은 여기에 https://github.com/zoomKoding/…","fields":{"slug":"/gatsby-github-blog/"},"frontmatter":{"categories":"블로그","title":"Gatsby 테마로 GitHub Blog 만들기","date":"July 06, 2021"}},"next":{"fields":{"slug":"/gatsby-starter-zoomkoding-introduction/"}},"previous":{"fields":{"slug":"/spring-boot-test/"}}},{"node":{"id":"173c5b8e-1b25-5de9-b81f-6d9b68fd8ac4","excerpt":"👋 소개 블로그를 직접 운영하면서 조금씩 그려봤던 이상적인 개발 블로그 테마를 Gatsby를 통해 만들어보게 되었습니다. 이 테마가 블로그를 운영하고자 하시는 분들에게 자신의 이야기를 잘 담을 수 있는 공간이 되었으면 좋겠습니다.🙌 블로그 테마가 맘에 드셨다면 아래 과정을 통해 자신의 블로그를 만들어보시길 바랍니다! 혹시 만드시는 과정에서 궁금하신 점이나 어려움이 있으시다면 이슈를 통해 문의 남겨주세요! 스타는 블로그 테마를 지속적으로 발전시키는데 큰 힘이 됩니다!⭐️ 🚀 시작하기 Github Page나 Netlify 중 원하시는 배포 환경에 따라 다음 과정을 진행하시면 빠르게 블로그를 만드실 수 있습니다. 🦖 GitHub Page로 만들기 깃헙 페이지를 통해 블로그를 만드시다면 아래 글을 참고해주세요! Gatsby 테마로 GitHub Blog 만들기 🔧 Netlify로 만들기 아래 버튼을 활용하면 개인 계정에 를 사용하고 있는 Repository 생성과 Netlify에 배포를 동시…","fields":{"slug":"/gatsby-starter-zoomkoding-introduction/"},"frontmatter":{"categories":"블로그","title":"쉽고 빠르게 나만의 개츠비(Gatsby) 블로그 만들기","date":"March 22, 2021"}},"next":{"fields":{"slug":"/segment-tree-2/"}},"previous":{"fields":{"slug":"/gatsby-github-blog/"}}},{"node":{"id":"434d77fc-ebc7-5228-996f-38867e14fc32","excerpt":"앞서 히스토그램 문제에 대한 접근 방법을 간단하게 설명하고 세그먼트 트리를 히스토그램에 맞추어서 설명했다. 이번 글에서는 구체적으로 어떻게 세그먼트 트리를 구현하여 히스토그램 문제를 푸는데까지 이어지는지 다루어 보도록 하겠다.  이 문제는 레벨이 높은 문제이긴 하지만 아이디어 자체가 굉장히 어렵거나 하진 않다. 다만 시간 복잡도 측면에서 효율적으로 접근하기 위해 세그먼트 트리를 활용하는게 좀 낯설어서 어려웠던 것 같다.  Segment Tree 구현 Segment Tree를 구현할 때 배열을 사용해서 구현하도록 할텐데 segment tree는 다음과 같은 성질을 가지고 있다.  세그먼트 트리는 거의 Full Binary Tree(비슷한 형태를 지님)의 모습을 하고 있다.  왼쪽 자식: 부모노트 * 2 오른쪽 자식: 부모노드 * 2 + 1  높이: lgN 배열을 통해서 tree를 구현하려면 사전에 tree의 노드 갯수를 파악해서 배열의 크기를 지정해야한다. 위의 성질들을 이용하면 해…","fields":{"slug":"/segment-tree-2/"},"frontmatter":{"categories":"알고리즘","title":"세그먼트 트리를 활용한 히스토그램 문제 풀이_2","date":"September 10, 2020"}},"next":{"fields":{"slug":"/segment-tree-1/"}},"previous":{"fields":{"slug":"/gatsby-starter-zoomkoding-introduction/"}}},{"node":{"id":"e2eeb2c3-459a-5343-b311-e5d107abbb71","excerpt":"히스토그램에서 가장 큰 직사각형의 크기를 찾는 알고리즘을 풀다가, 관련 문제의 풀이법을 간단히 찾아서 금방 해결할 줄 알았으니 구현에서 의도치 않은 오랜 시간이 걸렸다.  먼저 문제의 해결 방법을 요약하면 다음과 같다.  히스토그램 중, 높이가 가장 낮은 min 값과 해당 너비값을 곱하여 넓이를 구함.  해당 최소값을 기준으로 히스토램을 나누어서 1번을 반복함.  더 이상 나눌 수 없을 때까지 반복하며 매번 넓이의 max 값을 업데이트 함.  다음은 백준 블로그에 있는 문제 해설에서 가져온 그림이다. 위의 해결 방법을 이해하는데 도움이 된다.  histogram{: width=“80%“} 처음에 단순히 이 풀이방법을 배열과 재귀를 사용해서 구현하는 방법으로 시도를 했었다. 사이트에 나와있는 테스트 케이스가 통과하길래 바로 채점을 했더니 결과는 시간초과 였다.. 개인적으로 알고리즘을 할 때 가장 어려운 부분이 답을 출력이 되지만 시간초과가 나올 때 인 것 같다. 문제설명 밑에 해당 …","fields":{"slug":"/segment-tree-1/"},"frontmatter":{"categories":"알고리즘","title":"세그먼트 트리를 활용한 히스토그램 문제 풀이_1","date":"September 09, 2020"}},"next":{"fields":{"slug":"/naivebayes/"}},"previous":{"fields":{"slug":"/segment-tree-2/"}}},{"node":{"id":"a4372d20-6e28-5dbb-8c71-3e1d2675dfe2","excerpt":"강남의 어느 검색 솔루션 기업에서 인턴한지 어연 4주차가 지나간다. 중간 지점을 지나가면서 한 것을 정리할 겸 나이브베이즈 문서 분류기 구현과 이론에 대해서 정리해 보려고 한다. 최대한 쉽게!! 나이브 베이즈 분류기는 베이즈 정리(Bayes’ theorem)을 사용한 분류 알고리즘이다. 이것은 전통적으로 텍스트 분류를 하는 분류기로 인공지능의 기능을 기학적으로 올려준 인공 신경망 알고리즘은 아니지만 머신 러닝의 중요한 알고리즘 중 하나로 꽤 좋은 성능을 보인다. 나이브 베이즈 분류기에서 사용하는 베이즈 정리는 무엇일까? 베이즈의 정리(Bayes’ theorem)를 사용한 분류 기법 베이즈 정리는 조건부 확률을 계산하는 방법 중 하나이다. 다음과 같이 표현할 수 있다.  P(A): 사전확률(Prior). 사건 B가 발생하기 전 A가 가지고 있던 확률 P(B): 정규화 상수(normalizing constant). B가 일어날 확률 P(B | A): 가능도(likelihood). A가…","fields":{"slug":"/naivebayes/"},"frontmatter":{"categories":"머신러닝","title":"나이브 베이즈 분류기 - Naive Bayes Classifier","date":"July 24, 2020"}},"next":null,"previous":{"fields":{"slug":"/segment-tree-1/"}}}]}},"staticQueryHashes":["1073350324","2938748437"]}
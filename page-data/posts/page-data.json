{"componentChunkName":"component---src-templates-category-template-js","path":"/posts","result":{"pageContext":{"currentCategory":"All","categories":["All","설계","웹","데이터베이스","인프라","자바","JPA","스프링부트","테스트","블로그","알고리즘","스프링","빌드","머신러닝"],"edges":[{"node":{"id":"3144633b-9fb5-54a7-9f11-f6a48517333b","excerpt":"INTRO 현재 진행중인 프로젝트에서 DB Replication을 적용했었다.  Replication 알아보기 DB replication 적용 이후 Master DB를 업그레이드 해야하는 상황에서 replicas와의 연동에 문제가 생긴적이 있었다. 이때 Master와 replicas 간의 데이터 연동 방법을 이해하고 해결한 (매우 간단한) 방법을 기록한다.  Master DB와 replicas 동기화 Master DB에 데이터를 쓰기 위해서는 replicas에서 master db 의 데이터와 연결되어 있어야 한다. 그러기 위해서 replication을 설정할 때  라는 명령어를 통해서 나온 값과  값을 replica db 설정시 적용해 주었다.  여기서 File은 master db의 binary 로그 파일이고 Position 값은 해당 파일의 현재 위치이다.  위 log 파일에는 어떤 내용이 담겨 있을까? The MariaDB binary log is a series of file…","fields":{"slug":"/db-replication-binary-log/"},"frontmatter":{"categories":"데이터베이스 인프라","title":"DB 리플리케이션 적용시 Binary 로그 에러 해결방법","date":"September 26, 2021"}},"next":{"fields":{"slug":"/behavior-parameterization/"}},"previous":null},{"node":{"id":"44979c6c-3a26-53fb-9abc-7e9b88c7744c","excerpt":"INTRO 자바가 업데이트 되면서 메소드를 일급시민으로 취급할 수 있게 되었다. 이로 인해 동작 파라미터를 통해서 어떠한 동작을 인자로 넘길 수 있다.  메소드를 일급 시민으로 취급하면서 함수형 인터페이스 등의 개념이 등장한다. 코드의 명확성을 증진시키기 위해 익명 클래스, 람다 함수, 메서드 참조 등등의 개념이 활용된다.  동작 파라미터를 활용한 예시로 콜백 함수를 들여다보자.  왜 동작 파라미터인가? 코딩을 할 때 가장 중요한 요소 중 하나는 변화하는 요구사항에 대응하는 것이다.  동작 파라미터화는 나중에 실행할 코드 블록을 인수로 넘겨서 행동을 결정하는 것이다.  나중에 실행되도록 넘기는 콜백 함수와 같은 동일하게 작용한다. (내재된 개념이다) 이해를 돕기 위해 모던 자바 인 액션 에 나온 예제를 살펴보자.  상황1: 사과를 색으로 필터링 하는 요구사항을 구현한다.  상황2: 사과를 무게로 필터링하는 요구사항을 구현한다.  위 두 코드가 상당히 유사하다. (실제로 작성할 때도…","fields":{"slug":"/behavior-parameterization/"},"frontmatter":{"categories":"자바","title":"동작 파라미터부터 람다까지: 콜백함수를 곁들인","date":"September 22, 2021"}},"next":{"fields":{"slug":"/db-replication/"}},"previous":{"fields":{"slug":"/db-replication-binary-log/"}}},{"node":{"id":"11b32bd6-6da4-513d-9a84-05d7450180a7","excerpt":"INTRO DB Replication을 MySQL 공식 홈페이지에서 찾아보면 다음과 같이 말한다.     Replication enables data from one MySQL databse server (known as a source) to be copied to one or more MySQL database servers (know as replicas) \n출처 : 링크 즉, 하나의 데이터베이스(master/source)에서 다른 하나 또는 그 이상의 데이터베이스(slaves/replicas)로 데이터를 복제하여 저장하는 것이다.  Replication은 비동기로 동작한다. 따라서 replicas가 master에 지속적으로 연결되어는 동기식으로 동작하지 않는다.  설정에 따라서 여러 데이터베이스, 선택된 데이터베이스, 선택된 테이블에만 replication을 적용할 수도 있다.  MySQL replication 장점 공식 홈페이지에 나와있는 장점 4가지는 다음과 같다.  S…","fields":{"slug":"/db-replication/"},"frontmatter":{"categories":"데이터베이스 인프라","title":"DB 리플리케이션 적용하기","date":"September 10, 2021"}},"next":{"fields":{"slug":"/cookie-session/"}},"previous":{"fields":{"slug":"/behavior-parameterization/"}}},{"node":{"id":"104d60ac-d178-5742-8d47-caf93db5ba17","excerpt":"INTRO HTTP는 Stateless 무상태성을 가지고 있다. 따라서 데이터를 상태로 저장하지 않는다. HTTP가 무성태성이기 때문에 클라이언트에 대한 데이터를 유지하고 싶을 때는 쿠키 또는 세션을 이용한다. (이전에 요청을 보낸 동일한 사용자임을 확인하고 싶은 경우 등등) 쿠키는 클라이언트가 정보를 가지고 브라우저에서 저장 및 관리한다.  세션은 서버가 데이터를 가지고 저장 및 관리한다.  Cookie 쿠키는 클라이언트가 정보를 가지고 브라우저에서 해당 정보를 저장한다.  따라서 요청을 보낼 때마다 브라우저에서 저장된 쿠키 데이터를 HTTP 헤더에 추가하여 서버에 보낼 수 있다. HTTP 메세지 자체는 무상태성이기 때문에 매번 쿠키값을 보내주어야 한다.  쿠키에 저장되는 값의 형태는 text 이다.  쿠키의 단점 클라이언트가 관리하는 것이기 때문에 데이터가 쉽게 훼손 될 수 있다.  실제로 크롬 브라우저에서 개발자 도구 -> Application 탭에 가면 쿠키 데이터를 저장하…","fields":{"slug":"/cookie-session/"},"frontmatter":{"categories":"웹","title":"쿠키와 세션 알아보기","date":"September 04, 2021"}},"next":{"fields":{"slug":"/oauth/"}},"previous":{"fields":{"slug":"/db-replication/"}}},{"node":{"id":"9dcfc695-3e64-5efc-9b80-257d69dd5ae2","excerpt":"1. INTRO 많은 어플리케이션에서 소셜 로그인을 지원하는데, 이때 사용되는 것이 OAuth 2.0 이다.  간단하게 이야기하면 OAuth 2.0 이란 사용자의 정보에 대한 권한을 부여하는 의 일종이다.  (정의) 제 3의 앱이 자원의 소유자인 서비스 이용자를 대신하여 서비스를 요청할 수 있도록 자원 접근 권한을 위임하는 방법  출처: 금융보안원 “OAuth 2.0 개요 및 보안 고려사항” 보안연구부-2015-030 즉, 정보 소유자 (서비스 이용자)를 대신하여 앱이 다른 서비스에 등록되어 있는 자원에 대한 접근을 요청하는 권한을 위임한다.  아래 글은 링크 원문을 번역하고 일부 요약한 것이다.  2. OAuth 주요 개념 리소스 소유자 (Resource Owner) - 어플리케이션이 인가 요청을 하는 정보의 소유자이다. 즉, 그 정보를 소유하고 있는 ‘사용자’를 말한다.  클라이언트 (Client) - 리소스 소유자의 정보를 요청하는 어플리케이션이다.  리소스 서버 (Resou…","fields":{"slug":"/oauth/"},"frontmatter":{"categories":"웹","title":"OAuth 알아보기","date":"September 03, 2021"}},"next":{"fields":{"slug":"/cdn/"}},"previous":{"fields":{"slug":"/cookie-session/"}}},{"node":{"id":"ff4d68a5-f01f-5ae1-92ba-074f403b2c61","excerpt":"Intro 이번에 프로젝트를 진행하면서 보안상의 이유로 직접 S3 서버에 접근할 수 없었기 때문에 AWS에서 제공하는 CDN 서비스인 CloudFront를 통해서 이미지 등의 리소스에 접근해야 했다. (CDN서버의 본래 목적과는 다소 다른 이유로 사용했다.) CDN은 어떤 기술이며, 장점이 무엇이고, 어떻게 동작하는지에 대해서 알아본다.  CDN을 퉁해 누릴 수 있는 보안적인 이점은 무엇이며, 프로젝트를 진행하면서 CloudFront를 어떻게 활용했는지에 대해서 작성한다.  CDN이란 무엇인가? CDN은 Content Delivery Network의 약자이다. 직역하자면 컨텐츠를 전달해주는 네트워크이다. CDN 컨텐츠를 전송하는 물리적인 서버가 지리적으로 여러곳에 상주하며 유저와 가까이 위치한 서버에서 요청한 컨텐츠를 고속으로 제공해준다.  CDN이 제공하는 컨텐츠는 ,  파일, , 이미지, 동영상 등의 대부분의 인터넷 콘텐츠이다. CDN 서비스에 대해서 설명하는 예시에 항상 등장…","fields":{"slug":"/cdn/"},"frontmatter":{"categories":"인프라","title":"CDN 알아보기","date":"September 02, 2021"}},"next":{"fields":{"slug":"/java-iostream-file/"}},"previous":{"fields":{"slug":"/oauth/"}}},{"node":{"id":"41ff080c-8050-53a6-a648-d015de29c91e","excerpt":"자바 I/O 스트림 Stream은 데이터의 연속이다. Sequence of Data 다르게 말하면 Stream 이란 한쪽으로 흐르는 통로같은 것이다. 자바에서 Stream이란 한쪽 source에서 destination으로 흐르는 데이터를 위한 단방향 통로이다. 자바에서는 여러 매체를 읽거나 쓸 수 있고 각자를 위한 I/O Stream이 구현되어 있다. (disk files, devices, programs, memory arrays) Stream은 단방향 통신이기때문에 들어오는 데이터, 나가는 데이터에 따로 InputStream, OutputStream이 있는 것이다.  I/O 스트림은 여러가지 종류의 데이터들을 처리할 수 있다: 바이트, primitive data type, characters, objects Stream은 단순히 데이터를 전달하는 역할만 하기도하고, 몇몇 stream은 데이터를 조작하고 편리하게 변환하는 역할을 수행하기도 한다. 모든 Stream은 사용 후 반드…","fields":{"slug":"/java-iostream-file/"},"frontmatter":{"categories":"자바","title":"Java IOStream 과 파일 입출력","date":"August 26, 2021"}},"next":{"fields":{"slug":"/jpa-proxy/"}},"previous":{"fields":{"slug":"/cdn/"}}},{"node":{"id":"0bbf1a5f-5450-5c71-8533-7652d2132ffe","excerpt":"INTRO JPA는 DB의 데이터와 객체간의 모순을 해결하기 위해서 나온 것이다. 객체는 객체 그래프로 탐색이 가능하지만 데이터베이스에 저장된 데이터는 객체를 탐색하듯이 탐색하기가 어렵다. 따라서 데이터베이스에 저장된 데이터들을 가지고 객체 그래프 탐색이 가능하기 위해서 프록시 라는 기술이 나왔다. JPA에서는 연관된 객체를 로딩하는데 지연 로딩과 즉시 로딩이라는 두가지 기법을 사용한다. 여기서 지연 로딩시 프록시 기술이 사용된다. 기본 예시 Entity Member Team  프록시 지연 로딩을 설정된 연관 객체를 가져올 때 프록시 객체를 가져온다. 를 사용하면 실제 객체를 가져오고, 를 사용하면 프록시 객체를 가져온다. 프록시 객체를 가져온다는 것은 query는 실행되지 않는 것이다. 특정 객체에 대해 를 하면 연관된 객체에 대해서는 설정되어 있는  종류에 따라 즉시로딩 혹은 지연로딩한다. 실제 Entity 조회 -  위 테스트를 실행하면 다음과 같은 select 쿼리가 실행된…","fields":{"slug":"/jpa-proxy/"},"frontmatter":{"categories":"JPA","title":"JPA 프록시 알아보기","date":"August 26, 2021"}},"next":{"fields":{"slug":"/jpa-proxy-equals-bug/"}},"previous":{"fields":{"slug":"/java-iostream-file/"}}},{"node":{"id":"7df6549b-317d-5023-9260-e4d9249565d0","excerpt":"INTRO JPA 에서는 데이터베이스에서 연관객체 탐색을 효율적으로 하기 위해서 지연로딩 전략을 사용한다.  지연로딩의 핵심은 연관관계에 있는 Entity가 실제로 사용되기 이전까지 DB에 실제로 참조하지 않고 프록시 객체로 대체하는 것이다.  JPA의 프록시 객체는 유용하지만 내부 동작방식에 대해서 제대로 알고있지 않으면 찾기 어려운 버그를 만날 수도 있다.  다음은 JPA proxy 관련해서 프로젝트 진행시 만난 버그에 대한 내용이다.  문제 상황 Entity 구조 참고: 설명과 관련된 부분만 남기고 다른 로직 및 어노테이션은 대부분 생략했다.   - 게시물 엔티티 와  - Post 엔티티 하위의 Embedded 게시물 Like collection 포장객체 참고: 설명하고자 하는 부분과 깊게 연관된 핵심 Entity는 아니지만  상황 설명을 위해 간단히 프로퍼티만 소개한다.   - 어플리케이션 사용자 (게시물 좋아요, 유저간 팔로우 팔로잉 등의 행위를 함) 와   - 해당 의 …","fields":{"slug":"/jpa-proxy-equals-bug/"},"frontmatter":{"categories":"JPA","title":"JPA 프록시 관련 버그 경험기","date":"August 26, 2021"}},"next":{"fields":{"slug":"/jpa-query-bug/"}},"previous":{"fields":{"slug":"/jpa-proxy/"}}},{"node":{"id":"7bad748d-3789-5403-bce9-4bf2f8205619","excerpt":"INTRO JPA에서는 데이터와 객체지향으로 설계 사이의 모순을 해소하기 위해서 나온 기술이다.  많은 객체들은 내부에 Collection 형태로 다른 객체에 대한 참조가 가능하게 설계된다.  예)  객체 내부에 에 속해있는  와 팀에 할당된 가 존재한다.  이때 상위 객체를 select 하면서 하위 객체를 가져오는 경우 다음 두가지 fetch 타입에 각각 다음과 같은 문제가 있다.  일 경우 : 이 발생 일 경우 :  문제 발생 상위 엔티티에서 다수의 collection 형태의 연관엔티티를 가지고 있을 때 여러 상황 및 문제와 해결 방법에 대해서 공부해본다.  Entity 상황 과 가 1:N 연관관계 - ,  과 가 1:N 연관관계 - ,  참고 : 우선 모든 연관관계는 로 적용하고 테스트 상황에 따라 로 변경  엔티티  엔티티  엔티티 JPA에서 collection fetch join Team에 대한 모든 정보가 필요한 경우 Team을 가져오면서 Members와 Lockers …","fields":{"slug":"/jpa-query-bug/"},"frontmatter":{"categories":"JPA","title":"JPA N+1 문제 및 해결방법 알아보기","date":"August 26, 2021"}},"next":{"fields":{"slug":"/profile-active-profile/"}},"previous":{"fields":{"slug":"/jpa-proxy-equals-bug/"}}},{"node":{"id":"d5d76813-7bae-5b9a-b7c6-1a21a2637ac2","excerpt":"Intro 프로젝트를 진행하다 보면 상황에 따라 각기 다른 운영환경을 설정해야할때가 있다. 그때마다 properties 설정 파일에 가서 설정되어있는 운영 환경을 바꾸고 돌리기는 어렵다.  이때 각기 다른 를 적용해서 상황에 따라 적합한  설정을 따르도록 할 수 있다.  yml 파일로 설정 나누기 - 간단하게  또는 를 통해서 profile 설정을 나눌 수 있다.  각각 원하는 환경에 대한 설정정보를 , 에 기재한 후  또는 로 지정한다.  여러 profile 환경으로 나눠져 있을 경우 어떤 profile을 기본적으로 실행할 것인지 에 지정해 주어야 한다.  나누어진 profile을 적용하기 위해서는 로 적용하고자하는 프로필을 지정하여 실행하거나  어노테이션을 활용할 수 있다.  사용 예시 본인은 프로젝트 진행 시 다음과 같이 local, prod, test로 환경을 나누었다.  application-local.yml application-prod.yml application-te…","fields":{"slug":"/profile-active-profile/"},"frontmatter":{"categories":"스프링부트","title":"웹 개발 시 Profile 전략 - @Profile & @ActiveProfile","date":"August 19, 2021"}},"next":{"fields":{"slug":"/spring-boot-test/"}},"previous":{"fields":{"slug":"/jpa-query-bug/"}}},{"node":{"id":"24937c05-73a7-52fc-9328-64c422c66fb2","excerpt":"Intro 스프링부트 프로젝트를 진행하다보면 웹 mvc에 대한 테스트를 진행해야할 때가 있다.  때로는 각 layer에 대한 슬라이스 테스트를 작성하거나, 일부분에 대한 통합 테스트만을 진행할 때 Mock 테스트를 해야할 때도 있다.  테스트 관련 annotation에 대해서 정리하고 각 annotation의 차이 및 언제 무엇을 사용하면 좋을지 정리해본다.    어노테이션은  을 찾아 해당 configuration에 맞추어 실제 Spring web context를 실행햔다.  Spring context의 설정으로 그대로 적용해서 테스트를 진행해야 할 경우에 해당 어노테이션을 붙여서 테스트를 하는 것이 좋다.  하지만 전체 컨텍스트를 로드하는 만큼 굉장히 오랜 시간이 걸린다.  실제로  어노테이션이 붙은 테스트를 돌려본다면 다음과 같은 스프링 컨텍스트르 로딩하는 긴 로그가 찍히는 것을 확인할 수 있다.   위 어노테이션은 다음과 같이 를 주입받아서 톰캣 서버를 띄우지 않은 상태로 …","fields":{"slug":"/spring-boot-test/"},"frontmatter":{"categories":"스프링부트 테스트","title":"Springboot 언제 어떤 테스트를 사용할까","date":"August 17, 2021"}},"next":{"fields":{"slug":"/gatsby-github-blog/"}},"previous":{"fields":{"slug":"/profile-active-profile/"}}},{"node":{"id":"0283bad7-48b6-5692-a776-c4eead11c892","excerpt":"제 블로그의 테마나 Gatsby의 다른 테마를 활용해서 Github Blog를 만들고 싶은 분들이 계실텐데요! 이런 분들에게 도움을 드리고자 이 글을 쓰게 되었습니다. 잘 안되는 부분이나 궁금한 점을 댓글로 남겨주면 확인해보고 답변 드리도록 하겠습니다! 1. Repository 생성하기 GitHub Blog를 만들려면 Github에 Repository를 생성해야 합니다.  GitHub에 로그인 한 뒤에 우측 상단에 있는 New Repository 버튼을 클릭하면 repository 생성 페이지로 이동하게 됩니다. 이 때 Import a repository 버튼을 클릭합니다.  아래 페이지에 도달하시면 두 가지 정보를 넣어주셔야 하는데, Your old repository’s clone URL에는 사용하고자 하는 gatsby 테마가 있는 repository의 주소를 넣어주시면 됩니다. 제 블로그 테마를 쓰고 싶으신 분들은 여기에 https://github.com/zoomKoding/…","fields":{"slug":"/gatsby-github-blog/"},"frontmatter":{"categories":"블로그","title":"Gatsby 테마로 GitHub Blog 만들기","date":"July 06, 2021"}},"next":{"fields":{"slug":"/model-attribute-request-body/"}},"previous":{"fields":{"slug":"/spring-boot-test/"}}},{"node":{"id":"b0ca772e-1b48-53f1-8a7f-24d1a8ffe267","excerpt":"이번에 스프링 체스 자바 웹 어플리케이션을 사용하여 구현하면서 처음에는 모두  으로 데이터를 가져왔었다. 하지만 인자가 너무 많아지는 경우 메서드에 파라미터가 많아지면서 가독성이 안 좋아졌다. 또한 DTO에 해당 데이터를 담아서 서비스 레이어에 전달해야하거나 할 때 일일이 데이터를 DTO에 담아서 가공해야 하는 작업을 해야하기도 했다. 코드를 구현할 때 손가락이 아프다면 수정할 부분을 찾으라고 했었는데 확실히 으로 받는 것은 손가락이 아팠다.  아니나 다를까 리뷰어가 @ModelAttribute를 사용하는 걸 추천했다. 마침 레벨1 제이슨 톡방에서도 @ModelAttribute 에 대한 논의가 활발하길래 공부도 하고 코드에 적용을 하며 배운 것을 기록해본다.  @ModelAttribute vs. @RequestBody 간단하게 말하면 다음과 같다.  같은 경우는 parameter 값으로 DTO에 바인딩한다. 따라서 해당 DTO 객체에  메소드가 반드시 있어야 한다. 따라서 타입에 …","fields":{"slug":"/model-attribute-request-body/"},"frontmatter":{"categories":"스프링부트","title":"@ModelAttribute vs. @RequestBody","date":"March 25, 2021"}},"next":{"fields":{"slug":"/gatsby-starter-zoomkoding-introduction/"}},"previous":{"fields":{"slug":"/gatsby-github-blog/"}}},{"node":{"id":"173c5b8e-1b25-5de9-b81f-6d9b68fd8ac4","excerpt":"👋 소개 블로그를 직접 운영하면서 조금씩 그려봤던 이상적인 개발 블로그 테마를 Gatsby를 통해 만들어보게 되었습니다. 이 테마가 블로그를 운영하고자 하시는 분들에게 자신의 이야기를 잘 담을 수 있는 공간이 되었으면 좋겠습니다.🙌 블로그 테마가 맘에 드셨다면 아래 과정을 통해 자신의 블로그를 만들어보시길 바랍니다! 혹시 만드시는 과정에서 궁금하신 점이나 어려움이 있으시다면 이슈를 통해 문의 남겨주세요! 스타는 블로그 테마를 지속적으로 발전시키는데 큰 힘이 됩니다!⭐️ 🚀 시작하기 Github Page나 Netlify 중 원하시는 배포 환경에 따라 다음 과정을 진행하시면 빠르게 블로그를 만드실 수 있습니다. 🦖 GitHub Page로 만들기 깃헙 페이지를 통해 블로그를 만드시다면 아래 글을 참고해주세요! Gatsby 테마로 GitHub Blog 만들기 🔧 Netlify로 만들기 아래 버튼을 활용하면 개인 계정에 를 사용하고 있는 Repository 생성과 Netlify에 배포를 동시…","fields":{"slug":"/gatsby-starter-zoomkoding-introduction/"},"frontmatter":{"categories":"블로그","title":"쉽고 빠르게 나만의 개츠비(Gatsby) 블로그 만들기","date":"March 22, 2021"}},"next":{"fields":{"slug":"/stream-vs-collection/"}},"previous":{"fields":{"slug":"/model-attribute-request-body/"}}},{"node":{"id":"c6060cb1-1a69-5cc5-8508-1df3c8357b5f","excerpt":"요약하자면 Stream과 Collection의 차이는 다음과 같다.  개념적으로 접근했을 때 Collection의 경우에는 어떠한 데이터를 담는 자료구조의 역할을 주로 하지만, Stream의 경우는 연산과 관련된 것이 주라고 볼 수 있다.  Quote Java Collections offer efficient mechanisms to store and process the data by providing data structures like List, Set, and Map. However, the Stream API is useful for performing various operations on the data without the need for intermediate storage. 출처: https://www.baeldung.com/java-return-stream-collection Traversal Collection은 여러번 데이터를 횡단할 수 있지만, Stream…","fields":{"slug":"/stream-vs-collection/"},"frontmatter":{"categories":"자바","title":"Stream vs. Collection","date":"March 20, 2021"}},"next":{"fields":{"slug":"/boolean-timestamp/"}},"previous":{"fields":{"slug":"/gatsby-starter-zoomkoding-introduction/"}}},{"node":{"id":"20c3cda7-77dd-5c04-b4a8-7982cb496eaa","excerpt":"이것은 정답이 아니라 한 블로그에 기술된 하나의 의견이다. 읽어보고 신선한 접근이라고 생각해서 정리해둔다. 링크 데이터베이스에서 boolean 값을 지정해서 저장해야하는 경우들이 있다. , ,  등등을 기록해야하는 경우들이다. 이 경우에 boolean으로 저장하지 말고 timestamp로 저장하도록 해보자! 글쓴이의 말을 인용하자면 “단 한번도 후회한적이 없다”.  Boolean 값으로 저장할만한 데이터는 언제 해당 데이터가 set 되었는지에 대한 timestamp를 제공함으로 잃는 것이 없다. 아무리 해당 시간 데이터가 필요하지 않더라도 말이다. 이렇게 구현을 하게 된다면  은 로 은 로 간주되어 처리하면 될 것이다.  따라서 자연스럽게 , ,  등등으로 변환될 것이다.  의견 글쓴이의 말이 일리가 있다. 큰 구현의 차이나 처리의 차이 없이 동일한 연산을 수행할 수 있고, 더 많은 정보를 제공하는 이점이 있다.  하지만 해당 데이터가 로 지정이 되어 있는 시점이 있다는 것이 해당…","fields":{"slug":"/boolean-timestamp/"},"frontmatter":{"categories":"설계","title":"Boolean 대신 timestamp","date":"March 17, 2021"}},"next":{"fields":{"slug":"/dip/"}},"previous":{"fields":{"slug":"/stream-vs-collection/"}}},{"node":{"id":"21e10a37-af41-506b-8eda-5a0ffa60b567","excerpt":"스프링 강의 중 DAO vs. Repository의 차이점에 대해서 논의하다가 다음과 같은 표현이 나왔다.  Repository의 추상 인터페이스는 Domain Layer에 속하며 Domain 객체들을 관리하고 생애주기를 같이한다. 그 구현체인 SimpleJpaRepository는 Infrastructure에 속한다. 추상화된 repository 인터페이스를 사용하면서 추상에 의존하고 구체에 의존하지 않도록 구성(DIP) 하여 유연성 있는 시스템을 구성한다. 여기서 나오는 DIP는 무엇이고 위와 같은 구성이 어떻게 우연성을 제공하는 걸까?  DIP 요약 Dependency Inversion Principle의 약자이다. 본래 객체는 상위 계층이 하위 계층에 의존한다. DIP는 그 관계를 역전시켜서 상위 계층이 하위 계층의 구현에서 독립하도록 한다. 그러기 위한 원칙 두가지는 다음과 같다.  상위 모듈과 하위 모듈이 서로 의존하는 것이 아니라 모두 추상화에 의존한다.  추상화가 구현…","fields":{"slug":"/dip/"},"frontmatter":{"categories":"스프링 웹","title":"DIP 의존관계 역전의 원칙","date":"March 13, 2021"}},"next":{"fields":{"slug":"/transaction/"}},"previous":{"fields":{"slug":"/boolean-timestamp/"}}},{"node":{"id":"88e09de5-4062-57a5-9ae6-1b90ae07ab3a","excerpt":"Transaction 이란? 개인이 설정할 수 있는 작업의 최소 단위이다. Transaction을 기준으로 을 할 수도, 을 할 수도 있다. Transaction을 사용할 때 DBMS에서 ACID를 제공받을 수 있다. Atomic(원자성) : 한꺼번에 모두 처리가 되거나, 한꺼번에 모두 처리가 되지 않도록 원자성을 부여한다. 데이터 관련 일부만 처리되었을 때 생길 복잡한 상황과 부작용을 막을 수 있다. Consistency(일치성) : 하나의 데이터가 처리되었을 때 관련된 다른 테이블 혹은 상황에서 일관된 논리가 수행 되도록 하는 것을 보장한다 (ex. A 에서 1000원이 차감되면 B에서 1000원이 증감되어야 하는 상황 등등.) Isolation(독립성) : 데이터가 처리되는 도중 다른 일이 중간에 일어나지 않도록 해당 데이터를 보호하도록 보장. 중간에 다른 일이 끼어들어 부작용이 생기는 것을 방지한다. Durability(영구보존성) : 데이터를 DB에 저장하여 보존하도록 한…","fields":{"slug":"/transaction/"},"frontmatter":{"categories":"데이터베이스","title":"Transaction의 동작제어","date":"March 09, 2021"}},"next":{"fields":{"slug":"/web-layer/"}},"previous":{"fields":{"slug":"/dip/"}}},{"node":{"id":"93c8960d-fd12-539f-93d8-ad36d2740d7c","excerpt":"데이터의 흐름 또는 코드가 책임지는 부분의 유사도에 따라서 계층별로 나누어서 대규모 웹 어플리케이션을 구현한다. 이때의 이점은 각 계층이 담당하고 있는 책임을 알 수 있기 때문에 대량의 코드에서도 필요한 부분을 찾아서 수정하기 다소 쉽다. 또한 구조적으로 정리되어 있는 이점이 있다.  웹 어플리케이션을 구현할 때 이러한 계층들에 대한 제대로 된 정의를 가지고 각자가 담당하는 기능을 구현하는 것이 좋다. 함께 일하는 동료 개발자나 이후에 레거시 코드로 받을 다른 개발자들과의 의사소통 비용을 크게 감소하고 쉽게 코드와 구조를 이해할 수 있기 때문이다.  총 5개의 계층이 있다. Presentation Layer 식당에서  역할 UI를 담당하는 계층이다. User에게 보여지는 화면 담당 User의 입력을 받는 담당 입력에 따른 결과를 서버로부터 받아서 다시 화면에 띄우는 담당 다른 계층과의 접촉이 없고 Control layer를 통해서 다른 계층과 협업한다. 따라서 presentatio…","fields":{"slug":"/web-layer/"},"frontmatter":{"categories":"웹","title":"웹 Layers에 대해","date":"March 05, 2021"}},"next":{"fields":{"slug":"/gradle-dependency/"}},"previous":{"fields":{"slug":"/transaction/"}}},{"node":{"id":"3ff22722-319b-55d8-82ed-b7434e408311","excerpt":"웹 UI/DB 를 적용한 온라인 체스 게임을 구현하는 중 리뷰어가 다음과 같은 질문을 했다. 처음 웹 개발을 해보는 것이라서 우선 돌아가기 위해 인터넷과 크루들이 추가한  를 우선 가져와 추가했었는데 리뷰어의 질문을 받고 해당 개념을 찾아보았다.  참고 링크 결론부터 말해서 다음을 기억하면 될 것 같다.   은 Gradle 7.0 부터 depracated 되므로 대부분의 상황에서  을 사용하도록 한다. 과 은 거의 같은 가능을 하기 때문에 서로가 대체 되어도 상관없다.  그렇다면 implementation 의존성 주입은 무엇일까? Java 프로젝트가 실행이 될 때 2개의 classpath가 존재한다.  Complie classpath  Runtime classpath  Gradle dependency를 추가할 때 위 두가지 경우에 필요한 의존성들이 나누어지고 둘다 필요한 경우도 있다. 따라서 각각 필요한 경우에 추가할 수 있는 경우들과 두가지 경우 모두 필요할 경우 추가할 수 있는…","fields":{"slug":"/gradle-dependency/"},"frontmatter":{"categories":"빌드","title":"Gradle 의존성 주입 시 implementation vs. compile","date":"March 02, 2021"}},"next":{"fields":{"slug":"/singleton-vs-static/"}},"previous":{"fields":{"slug":"/web-layer/"}}},{"node":{"id":"d6ed2c46-51b8-5365-a4ce-bb6cc111355c","excerpt":"아직 잘 모르는 분야라서 우선 두개의 차이점에 대해서만 기록해본다. 둘 중 어느 것을 어느 때에 사용해야 하는지에 대한 판단은 잘 모르겠지만 이 링크 를  확인해보면 singleton 사용을 지양하라고 했고, 또 정적 메소드도 객체지향에서는 지양하는 것이 좋다고 한다.  싱글톤 단 하나의 객체만을 생성할 수 있는 패턴이다. 객체를 생성하려고 할 때마다 이미 생성된 것을 반환하거나 없다면 해당 시간에 처음 생성하도록 한다. 정적 클래스와는 달리 싱클톤 클래스는 과 이 가능하다. 언제 생성하는지에 대한 시점을 조정할 수 있다. 객체이기 때문에 힙에 싱글톤 객체가 저장된다. 따라서 쓰레드간 공유가 가능하다. 싱글톤은 구현으로 단 하나만 생성되게 보장한 것이지만 그 자체로는 클래스 객체이기 때문에 직렬화가 가능하다. Static 클래스 Static 메소드를 가지는 클래스를 말한다. 어플리케이션이 메모리에 로드 될 때 정적 스택에 바로 초기화 된다. 표준 클래스라고 보기는 어렵고  라고 볼…","fields":{"slug":"/singleton-vs-static/"},"frontmatter":{"categories":"설계","title":"싱글톤 vs. Static","date":"Invalid date"}},"next":{"fields":{"slug":"/strategy-pattern/"}},"previous":{"fields":{"slug":"/gradle-dependency/"}}},{"node":{"id":"a31d3ec2-ded1-5cd7-b9e1-9aa1ecf9b0c9","excerpt":"전략 패턴(Strategy Pattern)이란? 객체가 할 수 있는 행위에 대한  생성하여 해당 행위들을 캡슐화(인터페이스화) 하여 사용하는 것이다.  즉, 행위를 각각의 전략 클래스로 생성하고 수정이 필요한 경우 전략을 바꾸는 것으로 행위를 수정하도록 한다.  왜 전략 패턴을 사용해야 할까? 예를 들어 움직이는 Bus, Train 이라는 객체가 있다고 하고 각각 move() 함수를 통해서 움직인다.  그런데, Bus는 도로로 Train은 선로로 움직인다. 만약 이때 버스가 더 이상 길이 아니라 선로로 움직인다고 가정할 때, 버스의 move() 메소드를 선로로 움직이는 로직으로 수정해야 한다.  이때 두 가지 문제가 발생한다.  OCP (Open-Closed Principle)에 위배 : 수정에 닫혀있어야 하는데,  메소드를 직접 수정 확장이 될 경우 메서드 중복 문제 :  메소드를 가진 여러 객체가 있을 때 일일이 수정을 해아함 이 때 전략 패턴을 사용하면, 위 두 문제를 마주하…","fields":{"slug":"/strategy-pattern/"},"frontmatter":{"categories":"설계","title":"전략 패턴이란?","date":"Invalid date"}},"next":{"fields":{"slug":"/state-pattern/"}},"previous":{"fields":{"slug":"/singleton-vs-static/"}}},{"node":{"id":"ad427acb-0b76-5d44-a5eb-8db7c23257a3","excerpt":"FSM 을 State Design Pattern 으로! FSM (Finite State Machine) : 유한 상태 기계 특징 유한한 개수의 상태를 가짐. 그 중 하나의 상태만 취함. 특정 조건이 되면 다른 상태로 변함. 가능한 상태 집합과 각 상태들의 전이 조건으로 정의됨. 왜 쓸까? 가능한 상태들을 명확히 규정할 수 있음. 상태 중복을 피하고 전이들읠 명확하게 규정할 수 있음. 기계의 동작이 명확히 규정됨. 이러한 FSM 을 구현하려면 각 상황에 대한 수많은 분기문들을 통해서 구현이 되어야 한다.  또한 기능이 하나 추가가 될 때 고려해야 할 상황과 추가해야할 코드들이 굉장히 많아진다.  State Design Pattern 상태 디자인 패턴 언제 사용할까? 객체가 상태를 가져야 할 때 특정한 조건을 판단하여 해당하는 상태로 변환해야 하는 로직이 있을 때 각 상태마다 전이 조건이 있어 상황이 달라질 때 State Pattern 을 사용한다면? State Pattern 을 사용…","fields":{"slug":"/state-pattern/"},"frontmatter":{"categories":"설계","title":"상태 패턴이란?","date":"Invalid date"}},"next":{"fields":{"slug":"/tdd-tests/"}},"previous":{"fields":{"slug":"/strategy-pattern/"}}},{"node":{"id":"cb8b1699-6eb2-57ae-b2f6-9f902372f5bb","excerpt":"총 4가지 테스트에 대해서 간단히 다룰 것이다. 지금 우테코 LEVEL1에서 진행하고 있는 미션에서는 단위 테스트를 연습하는 TDD를 하고 있다. 내가 TDD를 할 줄이야.. 유닛 테스트(Unit Test) 가장 작은 단위의 테스트로 메서드 레벨로 테스트를 한다. (현재 내가 진행중인 TDD 방식)  즉각적인 결과가 나와서, 해당 메소드에 대한 원하는 결과가 연산이 되는지에 대한 확인이 가능한 테스트이다.  테스트 하기 어려운 메소드들이 등장하곤 하는데 이때는 stub (더미 객체가 마치 실제로 동작하는 것처럼 보이도록 만든 객체) 을 사용하여서 테스트 하는데 비용을 따져서 판단하도록 한다. (비용 관점을 항상 고려해야한다!)  하나의 메소드가 원하는 방식으로 동작한다는 것을 확인할 수 있지만, 결합되었을 때, 잘 동작하는지에 대한 보장은 어렵다.  전 구간 테스트(End-To-End Test) 시스템 자체와 시스템을 구축하고 배포하는 프로세스를 모두 시험한다.  내부 기능들(클래…","fields":{"slug":"/tdd-tests/"},"frontmatter":{"categories":"테스트","title":"TDD 맛보기 - 테스트 종류","date":"February 25, 2021"}},"next":{"fields":{"slug":"/mvc-pattern/"}},"previous":{"fields":{"slug":"/state-pattern/"}}},{"node":{"id":"38332c86-9e30-5529-a076-df8e79f95c5b","excerpt":"처음 MVC 패턴을 공부하게 되면서 잘 이해하지 못한 상태로 1단계 코드를 제출한 것 같다.  라는 부분을 간과하고 모든 도메인 모델에 대한 로직을 모두 Controller로 넘겼다. 하지만 MVC는 그렇게 분리되는 것이 아니었다.  이 부분에 대해 리뷰어에게 질문을 했더니 좋은 소스와 함께 정성스럽게 답해주셨다.  즉,  인데 Controller는 View로 부터 받은 입력을 기반으로 Model에 적절한 메세지를 보낸다. 그리고, Model은 해당 메시지에 따른 로직을 수행하고, 그에 따른 결과를 다시 Controller에 전달한다. 이렇게 왔다갔다 상호작용 하는 중간다리 역할이 Controller이다. 모든 서비스 로직을 Controller에다가만 구현하는 것이 아니다.  우테코에서 제공한 MVC 패턴에 대한 설명에도 핵심적인 설명이 있다.  리뷰어도 이것만 챙겨도 절반 이상이 MVC 패턴에 맞추어 진다고 한다.  공부하기에 좋은 자료로 추천한 위키피디아와, 모델-뷰-컨트롤러 …","fields":{"slug":"/mvc-pattern/"},"frontmatter":{"categories":"설계","title":"MVC 패턴 첫 적용기","date":"February 24, 2021"}},"next":{"fields":{"slug":"/segment-tree-2/"}},"previous":{"fields":{"slug":"/tdd-tests/"}}},{"node":{"id":"434d77fc-ebc7-5228-996f-38867e14fc32","excerpt":"앞서 히스토그램 문제에 대한 접근 방법을 간단하게 설명하고 세그먼트 트리를 히스토그램에 맞추어서 설명했다. 이번 글에서는 구체적으로 어떻게 세그먼트 트리를 구현하여 히스토그램 문제를 푸는데까지 이어지는지 다루어 보도록 하겠다.  이 문제는 레벨이 높은 문제이긴 하지만 아이디어 자체가 굉장히 어렵거나 하진 않다. 다만 시간 복잡도 측면에서 효율적으로 접근하기 위해 세그먼트 트리를 활용하는게 좀 낯설어서 어려웠던 것 같다.  Segment Tree 구현 Segment Tree를 구현할 때 배열을 사용해서 구현하도록 할텐데 segment tree는 다음과 같은 성질을 가지고 있다.  세그먼트 트리는 거의 Full Binary Tree(비슷한 형태를 지님)의 모습을 하고 있다.  왼쪽 자식: 부모노트 * 2 오른쪽 자식: 부모노드 * 2 + 1  높이: lgN 배열을 통해서 tree를 구현하려면 사전에 tree의 노드 갯수를 파악해서 배열의 크기를 지정해야한다. 위의 성질들을 이용하면 해…","fields":{"slug":"/segment-tree-2/"},"frontmatter":{"categories":"알고리즘","title":"세그먼트 트리를 활용한 히스토그램 문제 풀이_2","date":"September 10, 2020"}},"next":{"fields":{"slug":"/segment-tree-1/"}},"previous":{"fields":{"slug":"/mvc-pattern/"}}},{"node":{"id":"e2eeb2c3-459a-5343-b311-e5d107abbb71","excerpt":"히스토그램에서 가장 큰 직사각형의 크기를 찾는 알고리즘을 풀다가, 관련 문제의 풀이법을 간단히 찾아서 금방 해결할 줄 알았으니 구현에서 의도치 않은 오랜 시간이 걸렸다.  먼저 문제의 해결 방법을 요약하면 다음과 같다.  히스토그램 중, 높이가 가장 낮은 min 값과 해당 너비값을 곱하여 넓이를 구함.  해당 최소값을 기준으로 히스토램을 나누어서 1번을 반복함.  더 이상 나눌 수 없을 때까지 반복하며 매번 넓이의 max 값을 업데이트 함.  다음은 백준 블로그에 있는 문제 해설에서 가져온 그림이다. 위의 해결 방법을 이해하는데 도움이 된다.  histogram{: width=“80%“} 처음에 단순히 이 풀이방법을 배열과 재귀를 사용해서 구현하는 방법으로 시도를 했었다. 사이트에 나와있는 테스트 케이스가 통과하길래 바로 채점을 했더니 결과는 시간초과 였다.. 개인적으로 알고리즘을 할 때 가장 어려운 부분이 답을 출력이 되지만 시간초과가 나올 때 인 것 같다. 문제설명 밑에 해당 …","fields":{"slug":"/segment-tree-1/"},"frontmatter":{"categories":"알고리즘","title":"세그먼트 트리를 활용한 히스토그램 문제 풀이_1","date":"September 09, 2020"}},"next":{"fields":{"slug":"/naivebayes/"}},"previous":{"fields":{"slug":"/segment-tree-2/"}}},{"node":{"id":"a4372d20-6e28-5dbb-8c71-3e1d2675dfe2","excerpt":"강남의 어느 검색 솔루션 기업에서 인턴한지 어연 4주차가 지나간다. 중간 지점을 지나가면서 한 것을 정리할 겸 나이브베이즈 문서 분류기 구현과 이론에 대해서 정리해 보려고 한다. 최대한 쉽게!! 나이브 베이즈 분류기는 베이즈 정리(Bayes’ theorem)을 사용한 분류 알고리즘이다. 이것은 전통적으로 텍스트 분류를 하는 분류기로 인공지능의 기능을 기학적으로 올려준 인공 신경망 알고리즘은 아니지만 머신 러닝의 중요한 알고리즘 중 하나로 꽤 좋은 성능을 보인다. 나이브 베이즈 분류기에서 사용하는 베이즈 정리는 무엇일까? 베이즈의 정리(Bayes’ theorem)를 사용한 분류 기법 베이즈 정리는 조건부 확률을 계산하는 방법 중 하나이다. 다음과 같이 표현할 수 있다.  P(A): 사전확률(Prior). 사건 B가 발생하기 전 A가 가지고 있던 확률 P(B): 정규화 상수(normalizing constant). B가 일어날 확률 P(B | A): 가능도(likelihood). A가…","fields":{"slug":"/naivebayes/"},"frontmatter":{"categories":"머신러닝","title":"나이브 베이즈 분류기 - Naive Bayes Classifier","date":"July 24, 2020"}},"next":null,"previous":{"fields":{"slug":"/segment-tree-1/"}}}]}},"staticQueryHashes":["1073350324","2938748437"]}
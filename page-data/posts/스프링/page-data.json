{"componentChunkName":"component---src-templates-category-template-js","path":"/posts/스프링","result":{"pageContext":{"currentCategory":"스프링","categories":["All","설계","웹","데이터베이스","인프라","자바","JPA","스프링부트","테스트","블로그","알고리즘","스프링","빌드","머신러닝"],"edges":[{"node":{"id":"d5d76813-7bae-5b9a-b7c6-1a21a2637ac2","excerpt":"Intro 프로젝트를 진행하다 보면 상황에 따라 각기 다른 운영환경을 설정해야할때가 있다. 그때마다 properties 설정 파일에 가서 설정되어있는 운영 환경을 바꾸고 돌리기는 어렵다.  이때 각기 다른 를 적용해서 상황에 따라 적합한  설정을 따르도록 할 수 있다.  yml 파일로 설정 나누기 - 간단하게  또는 를 통해서 profile 설정을 나눌 수 있다.  각각 원하는 환경에 대한 설정정보를 , 에 기재한 후  또는 로 지정한다.  여러 profile 환경으로 나눠져 있을 경우 어떤 profile을 기본적으로 실행할 것인지 에 지정해 주어야 한다.  나누어진 profile을 적용하기 위해서는 로 적용하고자하는 프로필을 지정하여 실행하거나  어노테이션을 활용할 수 있다.  사용 예시 본인은 프로젝트 진행 시 다음과 같이 local, prod, test로 환경을 나누었다.  application-local.yml application-prod.yml application-te…","fields":{"slug":"/profile-active-profile/"},"frontmatter":{"categories":"스프링부트","title":"웹 개발 시 Profile 전략 - @Profile & @ActiveProfile","date":"August 19, 2021"}},"next":{"fields":{"slug":"/spring-boot-test/"}},"previous":{"fields":{"slug":"/jpa-query-bug/"}}},{"node":{"id":"24937c05-73a7-52fc-9328-64c422c66fb2","excerpt":"Intro 스프링부트 프로젝트를 진행하다보면 웹 mvc에 대한 테스트를 진행해야할 때가 있다.  때로는 각 layer에 대한 슬라이스 테스트를 작성하거나, 일부분에 대한 통합 테스트만을 진행할 때 Mock 테스트를 해야할 때도 있다.  테스트 관련 annotation에 대해서 정리하고 각 annotation의 차이 및 언제 무엇을 사용하면 좋을지 정리해본다.    어노테이션은  을 찾아 해당 configuration에 맞추어 실제 Spring web context를 실행햔다.  Spring context의 설정으로 그대로 적용해서 테스트를 진행해야 할 경우에 해당 어노테이션을 붙여서 테스트를 하는 것이 좋다.  하지만 전체 컨텍스트를 로드하는 만큼 굉장히 오랜 시간이 걸린다.  실제로  어노테이션이 붙은 테스트를 돌려본다면 다음과 같은 스프링 컨텍스트르 로딩하는 긴 로그가 찍히는 것을 확인할 수 있다.   위 어노테이션은 다음과 같이 를 주입받아서 톰캣 서버를 띄우지 않은 상태로 …","fields":{"slug":"/spring-boot-test/"},"frontmatter":{"categories":"스프링부트 테스트","title":"Springboot 언제 어떤 테스트를 사용할까","date":"August 17, 2021"}},"next":{"fields":{"slug":"/gatsby-github-blog/"}},"previous":{"fields":{"slug":"/profile-active-profile/"}}},{"node":{"id":"b0ca772e-1b48-53f1-8a7f-24d1a8ffe267","excerpt":"이번에 스프링 체스 자바 웹 어플리케이션을 사용하여 구현하면서 처음에는 모두  으로 데이터를 가져왔었다. 하지만 인자가 너무 많아지는 경우 메서드에 파라미터가 많아지면서 가독성이 안 좋아졌다. 또한 DTO에 해당 데이터를 담아서 서비스 레이어에 전달해야하거나 할 때 일일이 데이터를 DTO에 담아서 가공해야 하는 작업을 해야하기도 했다. 코드를 구현할 때 손가락이 아프다면 수정할 부분을 찾으라고 했었는데 확실히 으로 받는 것은 손가락이 아팠다.  아니나 다를까 리뷰어가 @ModelAttribute를 사용하는 걸 추천했다. 마침 레벨1 제이슨 톡방에서도 @ModelAttribute 에 대한 논의가 활발하길래 공부도 하고 코드에 적용을 하며 배운 것을 기록해본다.  @ModelAttribute vs. @RequestBody 간단하게 말하면 다음과 같다.  같은 경우는 parameter 값으로 DTO에 바인딩한다. 따라서 해당 DTO 객체에  메소드가 반드시 있어야 한다. 따라서 타입에 …","fields":{"slug":"/model-attribute-request-body/"},"frontmatter":{"categories":"스프링부트","title":"@ModelAttribute vs. @RequestBody","date":"March 25, 2021"}},"next":{"fields":{"slug":"/gatsby-starter-zoomkoding-introduction/"}},"previous":{"fields":{"slug":"/gatsby-github-blog/"}}},{"node":{"id":"21e10a37-af41-506b-8eda-5a0ffa60b567","excerpt":"스프링 강의 중 DAO vs. Repository의 차이점에 대해서 논의하다가 다음과 같은 표현이 나왔다.  Repository의 추상 인터페이스는 Domain Layer에 속하며 Domain 객체들을 관리하고 생애주기를 같이한다. 그 구현체인 SimpleJpaRepository는 Infrastructure에 속한다. 추상화된 repository 인터페이스를 사용하면서 추상에 의존하고 구체에 의존하지 않도록 구성(DIP) 하여 유연성 있는 시스템을 구성한다. 여기서 나오는 DIP는 무엇이고 위와 같은 구성이 어떻게 우연성을 제공하는 걸까?  DIP 요약 Dependency Inversion Principle의 약자이다. 본래 객체는 상위 계층이 하위 계층에 의존한다. DIP는 그 관계를 역전시켜서 상위 계층이 하위 계층의 구현에서 독립하도록 한다. 그러기 위한 원칙 두가지는 다음과 같다.  상위 모듈과 하위 모듈이 서로 의존하는 것이 아니라 모두 추상화에 의존한다.  추상화가 구현…","fields":{"slug":"/dip/"},"frontmatter":{"categories":"스프링 웹","title":"DIP 의존관계 역전의 원칙","date":"March 13, 2021"}},"next":{"fields":{"slug":"/transaction/"}},"previous":{"fields":{"slug":"/boolean-timestamp/"}}}]}},"staticQueryHashes":["1073350324","2938748437"]}
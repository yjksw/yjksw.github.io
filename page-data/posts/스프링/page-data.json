{"componentChunkName":"component---src-templates-category-template-js","path":"/posts/스프링","result":{"pageContext":{"currentCategory":"스프링","categories":["All","웹","자바","스프링부트","알고리즘","스프링","JPA","데이터베이스","설계","머신러닝","인프라","테스트","블로그","운영","기타","빌드"],"edges":[{"node":{"id":"d5d76813-7bae-5b9a-b7c6-1a21a2637ac2","excerpt":"Intro 프로젝트를 진행하다 보면 상황에 따라 각기 다른 운영환경을 설정해야할때가 있다. 그때마다 properties 설정 파일에 가서 설정되어있는 운영 환경을 바꾸고 돌리기는 어렵다.  이때 각기 다른 를 적용해서 상황에 따라 적합한  설정을 따르도록 할 수 있다.  yml 파일로 설정 나누기 - 간단하게  또는 를 통해서 profile 설정을 나눌 수 있다.  각각 원하는 환경에 대한 설정정보를 , 에 기재한 후  또는 로 지정한다.  여러 profile 환경으로 나눠져 있을 경우 어떤 profile을 기본적으로 실행할 것인지 에 지정해 주어야 한다.  나누어진 profile을 적용하기 위해서는 로 적용하고자하는 프로필을 지정하여 실행하거나  어노테이션을 활용할 수 있다.  사용 예시 본인은 프로젝트 진행 시 다음과 같이 local, prod, test로 환경을 나누었다.  application-local.yml application-prod.yml application-te…","fields":{"slug":"/profile-active-profile/"},"frontmatter":{"categories":"스프링부트","title":"웹 개발 시 Profile 전략 - @Profile & @ActiveProfile","date":"August 19, 2021"}},"next":{"fields":{"slug":"/spring-boot-test/"}},"previous":{"fields":{"slug":"/java-iostream-file/"}}},{"node":{"id":"24937c05-73a7-52fc-9328-64c422c66fb2","excerpt":"Intro 스프링부트 프로젝트를 진행하다보면 웹 mvc에 대한 테스트를 진행해야할 때가 있다.  때로는 각 layer에 대한 슬라이스 테스트를 작성하거나, 일부분에 대한 통합 테스트만을 진행할 때 Mock 테스트를 해야할 때도 있다.  테스트 관련 annotation에 대해서 정리하고 각 annotation의 차이 및 언제 무엇을 사용하면 좋을지 정리해본다.    어노테이션은  을 찾아 해당 configuration에 맞추어 실제 Spring web context를 실행햔다.  Spring context의 설정으로 그대로 적용해서 테스트를 진행해야 할 경우에 해당 어노테이션을 붙여서 테스트를 하는 것이 좋다.  하지만 전체 컨텍스트를 로드하는 만큼 굉장히 오랜 시간이 걸린다.  실제로  어노테이션이 붙은 테스트를 돌려본다면 다음과 같은 스프링 컨텍스트르 로딩하는 긴 로그가 찍히는 것을 확인할 수 있다.   위 어노테이션은 다음과 같이 를 주입받아서 톰캣 서버를 띄우지 않은 상태로 …","fields":{"slug":"/spring-boot-test/"},"frontmatter":{"categories":"스프링부트 테스트","title":"Springboot 언제 어떤 테스트를 사용할까","date":"August 17, 2021"}},"next":{"fields":{"slug":"/jpa-lazyinitialization-exception/"}},"previous":{"fields":{"slug":"/profile-active-profile/"}}},{"node":{"id":"156033a5-3d3b-51d5-abc6-61b8996690bf","excerpt":"다음 글은 링크에 기술되어 있는 스프링 웹 어플리케이션 구조에 대한 글을 번역 한 내용이다.  좋은 architecture를 위한 두 기둥 The SoC(Separation of Concerns) 원칙 A design principle for separating a computer program into distinct sections, which each section addresses a separate concern.  출처 SoC에서 신경써야 할 부분은 두가지이다. 고려해야 할 concerns가 무엇인지   어디서 해당 concern을 다루고 싶은지 SoC를 준수하게 된다면 각각의 layer와 해당 layer의 책임에 대해서 자연스럽게 정의할 수 있도록 도와준다.  The KISS(Keep It Simple Stupid) 원칙 Most systems work best if they are kept simple rather than made complicated; theref…","fields":{"slug":"/spring-spring-web-application-architecture/"},"frontmatter":{"categories":"스프링 웹","title":"클래식한 스프링 웹 어플리케이션 구조","date":"June 26, 2021"}},"next":{"fields":{"slug":"/handler-method-argument-resolver/"}},"previous":{"fields":{"slug":"/database-transaction-currency-control/"}}},{"node":{"id":"1f652c1c-da4d-5aba-86ee-d66e7a606fcb","excerpt":"INTRO 는 Spring framework에서 제공하는 인터페이스로 request에서 메소드의 parameters를 해당하는 인자값으로 변환 혹은 바인딩 하는 resolver이다. 인터페이스 내용 에는 두가지 메소드가 있다.    첫번째, Parameter가 해당 resolver를 지원하는 여부 확인 참고 아래 설명은 가 붙은 인자의 경우를 보는 것이므로 그 구현체가 의 예시로 설명한 것이다.  Parameter가 있는 수만큼  →  안에서 for문을 돌면서 해당 parameter에 대한 argument resolve를 한다. 이때 resolve를 하기 위해서 현재 클래스가 가지고 있는  가 해당 parameter 지원 하는지 여부를 확인한다. → 확인하는 로직은  안에 있는 resolver들의 배열을 돌면서(한번 찾으면 캐싱함) 해당 parameter를 지원하는 resolver를 찾아서 반환하고, null인지 여부를 체크해 boolean을 반환한다. 이때  메소드가 수행된다. …","fields":{"slug":"/handler-method-argument-resolver/"},"frontmatter":{"categories":"스프링 웹","title":"HandlerMethodArgumentResolver 내부동작 원리 알아보기","date":"June 25, 2021"}},"next":{"fields":{"slug":"/spring-interceptor/"}},"previous":{"fields":{"slug":"/spring-spring-web-application-architecture/"}}},{"node":{"id":"90dcdd48-5814-5261-9fed-a768d1269d4a","excerpt":"개요 Handler interceptors는 어떤 요청들에 대한 특정 기능을 적용하고 싶을 때 사용이 되는데, 특히 어떤 조건 및 원칙들을 검증하는데 많이 사용된다.  Interceptor 구성 Interceptor를 구현하기 위해서는 HandlerInterceptor를 구현해야 한다. 해당 인터페이스에는 interceptor가 실행되는 3가지 경우에 대한 메소드가 정의되어 있다.  handler가 실행되기 이전 handler가 실행된 이후 전체 요청 처리가 모두 수행된 이후 이것들 중 handler 실행 이전에 수행되는 메소드인  은 boolean 값을 반환한다. 과 은 void를 반환한다.  위 세가지 메소드 모두 공통된 인자로 Servlet에 의해서 생성된 , , (Object 타입)을 받는다. 따라서 void 반환타입인 경우 HttpServletResponse에 후처리를 할 수 있다. (의 경우에는 를 은 을  속성으로 받는다)   preHandle() 동작원리 은 와 를 …","fields":{"slug":"/spring-interceptor/"},"frontmatter":{"categories":"스프링 웹","title":"초간단 Interceptor 알아보기","date":"June 23, 2021"}},"next":{"fields":{"slug":"/symmetric-vs-asymmetric-encryption/"}},"previous":{"fields":{"slug":"/handler-method-argument-resolver/"}}},{"node":{"id":"aa4dffec-9907-5cba-91ed-6988835a5453","excerpt":"를 통해서 어플리케이션 전역적으로 exception을 핸들링 할 수 있다. 다르게 표현하면  메서드에서 던져지는 exceptions들의 interceptor라고 할 수 있다. (shared across multiple @Controller classes) 주로 에서 전역적으로 처리하고 싶은 어노테이션은 , ,  등이 있다.  클래스가  어노테이션에서 전역적인 exception handling 을 구현할 수 있도록 하는 base class이다. 해당 클래스에서 Spring MVC 내부에서 발생한 예외들을 처리할 수 있는 메서드들을 제공한다. (는 를 반환하는 반면 는 를 반환한다) 여러 @ControllerAdvice 간의 우선순위 @ControllerAdvice 클래스들은 Bean으로 등록이 되도록 하는데, 해당 빈들은  인터페이스를 구현하여 orderable 한 속성을 부여하거나, / 를 사용해서 우선순위를 부여할 수 있다. (여기서  semantic이 /  에 우선순위를 가진다…","fields":{"slug":"/springboot-controller-advice/"},"frontmatter":{"categories":"스프링부트","title":"@ControllerAdvice 알아보기","date":"June 19, 2021"}},"next":{"fields":{"slug":"/spring-exception-handling/"}},"previous":{"fields":{"slug":"/hash-salt/"}}},{"node":{"id":"debf7ec4-ca5a-5118-ab72-01b5b73f51e7","excerpt":"Spring Boot Spring boot 자체에서 핸들링 되지 않은 error 에 대한 대비책을 마련해 두었다.  먼저, Spring boot 자체에서  에 대한 매핑을 찾아서 해당 URL에 대해서 동일한 이름을 가진  뷰를 매핑 한다. 해당 뷰는  을 반환한다. (해당 뷰는  Thymeleaf template인데, 만일 JSP를 사용한다면 를 반환하도록 에서 변경할 수 있다) 실질적인 매핑은 ViewResolver에서 담당한다. 만일 에 대해 그 어떠한 view-resolver도 매핑이 되어 있지 않다면 spring boot는 내부적으로 가지고 있는 대체 에러 페이지인 “Whitelabel Error Page”를 가지고 있다. 이때 만일 RESTful request에 대한 응답이라면 Spring boot는 자체적인 JSON 형태로 “Whitelabel Error Page”의 응답을 받은 error 정보를 반환한다. Spring boot는 컨테이너에 대한 디폴트 error-pag…","fields":{"slug":"/spring-exception-handling/"},"frontmatter":{"categories":"스프링부트 스프링 웹","title":"스프링부트의 Exception handling","date":"June 19, 2021"}},"next":{"fields":{"slug":"/request-body-model-attribute-advanced/"}},"previous":{"fields":{"slug":"/springboot-controller-advice/"}}},{"node":{"id":"2696e70c-e746-5fb0-96cc-3b651a5c3483","excerpt":"@RequestBody request body를 method argument로 바꿀 때 를 사용한다.  는 두가지를 담당한다. 첫번째는 Http request message를 객체로 변환하는 것, 두번째는 객체를 Http response body로 변환하는 작업이다. 동작원리 에 의해서 호출되는 handler의 method parameters은 스프링의 에 의해 생성이 되고, handler의 return value는 에 의해서 처리된다. 와 를 다루는 구현체는 이다.  DispatcherServlet의 handle에서부터 Argument resolve 하는 과정  →  →  →  →  →  →  → (Interface) → (Imp)  내부에서 HttpMessageConverter를 사용해서 변환시키는 과정  → (extends  AbstractMessageConverterMethodArgumentResolver) → (Imp HandlerMethodArgumentResolver)…","fields":{"slug":"/request-body-model-attribute-advanced/"},"frontmatter":{"categories":"스프링부트","title":"@ModelAttribute vs. @RequestBody 더 깊이 파헤치기","date":"June 19, 2021"}},"next":{"fields":{"slug":"/jwt-token/"}},"previous":{"fields":{"slug":"/spring-exception-handling/"}}},{"node":{"id":"0c475bf4-622e-52db-93a0-041e112f245b","excerpt":"스프링 프레임워크에서 사용되는 Bean scope에 6가지 종류가 있다. 일반적으로 많이 쓰이는 scope은 싱글톤이다.  Singleton scope 스프링 빈이 singleton scope을 가지고 있다면, 컨테이너가 빈의 단 하나의 인스턴스를 해당 빈이 필요할 때마다 캐싱된 빈을 리턴한다. 빈 객체를 수정하면 해당 빈을 참조하고 있는 모든 곳에 반영이 된다. 싱글톤 스콥은 스프링의 기본값이다.  Prototype scope  프로토타입 스콥은 빈 요청이 있을때마다 매번 다른 인스턴스를 컨테이너로부터 반환한다. 설정방법은 다음과 같다.  Web Aware Scopes 앞에 두 개의 범위를 제외하고 4개의 범위가 더 존재한다. 하지만 조건이 있는데, web-aware application 맥락에서만 적용이 될 수 있는 범위이다.  Request Scope Request scope은 하나의 HTTP request 당 하나의 빈을 생성한다.  이 scope을 사용할 때는 proxyM…","fields":{"slug":"/bean-scope/"},"frontmatter":{"categories":"스프링 웹","title":"Bean Scope 종류 알아보기","date":"May 30, 2021"}},"next":{"fields":{"slug":"/annotation-valid/"}},"previous":{"fields":{"slug":"/dispatcher-servlet/"}}},{"node":{"id":"a1fc154b-ec1d-5302-b815-b48084f79b36","excerpt":"@Valid - 스프링 부트에서 어노테이션으로 validation을 할 수 있도록 기능을 추가해주는 것. 즉, controller에서 인자를 받을 때 유효성 검사를 할 수 있도록 해주는 것이다.  DTO의 필드나, 도메인 객체의 필드 위에 유효성 검사를 하고 싶은 어노테이션을 추가하고, controller의 인자 앞에 @Valid 를 추가해서 붙여준다.  java.validation 어노테이션 사용 예시","fields":{"slug":"/annotation-valid/"},"frontmatter":{"categories":"스프링부트","title":"@Valid 어노테이션 초간단 입문","date":"May 24, 2021"}},"next":{"fields":{"slug":"/cicd-jenkins/"}},"previous":{"fields":{"slug":"/bean-scope/"}}},{"node":{"id":"75f61000-50f8-58be-a445-5bda37396ef5","excerpt":"트랜잭션을 사용하는 이유 트랜잭션을 사용하면 각각의 단위로 나누어져있는 작업의 단위를 하나로 합칠 수 있다. 즉, 일련의 연산들을 하나의 독립된 작업 단위로 보고 하나로 취급하기 위해서 사용하는 것이다.  언제 일련의 연산들을 하나로 봐야 할 때가 생길까?  예를 들어서 돈을 송금하는 시스템이 있다고 가정해보자. 계좌A에서 계좌B로 돈을 송금해야 할 때, 계좌A에 충분한 잔액이 있는 것을 확인하고 돈을 송금하기 위해서 돈을 차감했다. 그리고 계좌B에 입금을 하려고 하는 순간 예외가 발생하면서 입금을 하지 못했다. 그런데 계좌A에서는 여전히 돈이 차감된 상태이다. 중간에 송금하려고 했던 돈이 사라지게 된 것이다.  이때, 위의 과정을 로 관리를 하게 된다면 위의 여러 작업들을 하나의 단위로 보고 중간에 예외가 발생한다면 위에서 실행중이던 작업을 한꺼번에 롤백해준다.  트랜잭션 기본 방법 2개 이상의 쿼리를 하나의 커넥션으로 묶어 DB에 전송하고, 에러가 발생할 경우 자동으로 모든 과…","fields":{"slug":"/transaction-annotation/"},"frontmatter":{"categories":"스프링부트 웹 데이터베이스","title":"@Transactional","date":"May 10, 2021"}},"next":{"fields":{"slug":"/controller-vs-restcontroller/"}},"previous":{"fields":{"slug":"/cicd/"}}},{"node":{"id":"154e5bdf-92b6-5e1e-a764-8f5e8aa71162","excerpt":"제일 핵심이 되는 차이점은 HTTPResponse Body의 생성 방식이다.  @Controller 본래 Spring MVC 컨트롤러의 주 역할은 View를 반환하는 것이다.  아래 사진을 보면, 클라이언트가 URL을 통해서 Dispatcher Servlet 에 요청을 보내면 적절한 Handler를 매핍하고 컨트롤러에서 해당 View를 를 통해서 반환한다.   하지만 컨트롤러는 항상 View를 반환하는 것이 아니라 data도 반환해야한다. 이때는 @ResponseBody 어노테이션을 통해서 Json 형태로 클라이언트에 데이터를 반환할 수 있도록 해야 한다. 이때는 View를 반환할 때 사용하는 ViewResolver를 반환하는 것이 아니라 HttpMessageConverter 을 사용해서 데이터를 반환한다.  따라서 Data를 반환하는 응답에 대해서는 를 붙여주어야하는데 매번 그러기가 번거로우니 Controller에 가 자동으로 붙어있는 가 등장하게 된 것이다. @Controller","fields":{"slug":"/controller-vs-restcontroller/"},"frontmatter":{"categories":"스프링부트","title":"@Controller vs. @RestController","date":"April 28, 2021"}},"next":{"fields":{"slug":"/model-attribute-request-body/"}},"previous":{"fields":{"slug":"/transaction-annotation/"}}},{"node":{"id":"b0ca772e-1b48-53f1-8a7f-24d1a8ffe267","excerpt":"이번에 스프링 체스 자바 웹 어플리케이션을 사용하여 구현하면서 처음에는 모두  으로 데이터를 가져왔었다. 하지만 인자가 너무 많아지는 경우 메서드에 파라미터가 많아지면서 가독성이 안 좋아졌다. 또한 DTO에 해당 데이터를 담아서 서비스 레이어에 전달해야하거나 할 때 일일이 데이터를 DTO에 담아서 가공해야 하는 작업을 해야하기도 했다. 코드를 구현할 때 손가락이 아프다면 수정할 부분을 찾으라고 했었는데 확실히 으로 받는 것은 손가락이 아팠다.  아니나 다를까 리뷰어가 @ModelAttribute를 사용하는 걸 추천했다. 마침 레벨1 제이슨 톡방에서도 @ModelAttribute 에 대한 논의가 활발하길래 공부도 하고 코드에 적용을 하며 배운 것을 기록해본다.  @ModelAttribute vs. @RequestBody 간단하게 말하면 다음과 같다.  같은 경우는 parameter 값으로 DTO에 바인딩한다. 따라서 해당 DTO 객체에  메소드가 반드시 있어야 한다. 따라서 타입에 …","fields":{"slug":"/model-attribute-request-body/"},"frontmatter":{"categories":"스프링부트","title":"@ModelAttribute vs. @RequestBody","date":"March 25, 2021"}},"next":{"fields":{"slug":"/gatsby-starter-zoomkoding-introduction/"}},"previous":{"fields":{"slug":"/controller-vs-restcontroller/"}}},{"node":{"id":"21e10a37-af41-506b-8eda-5a0ffa60b567","excerpt":"스프링 강의 중 DAO vs. Repository의 차이점에 대해서 논의하다가 다음과 같은 표현이 나왔다.  Repository의 추상 인터페이스는 Domain Layer에 속하며 Domain 객체들을 관리하고 생애주기를 같이한다. 그 구현체인 SimpleJpaRepository는 Infrastructure에 속한다. 추상화된 repository 인터페이스를 사용하면서 추상에 의존하고 구체에 의존하지 않도록 구성(DIP) 하여 유연성 있는 시스템을 구성한다. 여기서 나오는 DIP는 무엇이고 위와 같은 구성이 어떻게 우연성을 제공하는 걸까?  DIP 요약 Dependency Inversion Principle의 약자이다. 본래 객체는 상위 계층이 하위 계층에 의존한다. DIP는 그 관계를 역전시켜서 상위 계층이 하위 계층의 구현에서 독립하도록 한다. 그러기 위한 원칙 두가지는 다음과 같다.  상위 모듈과 하위 모듈이 서로 의존하는 것이 아니라 모두 추상화에 의존한다.  추상화가 구현…","fields":{"slug":"/dip/"},"frontmatter":{"categories":"스프링 웹","title":"DIP 의존관계 역전의 원칙","date":"March 13, 2021"}},"next":{"fields":{"slug":"/transaction/"}},"previous":{"fields":{"slug":"/boolean-timestamp/"}}}]}},"staticQueryHashes":["1073350324","2938748437"]}
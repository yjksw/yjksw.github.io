{"componentChunkName":"component---src-templates-category-template-js","path":"/posts/웹","result":{"pageContext":{"currentCategory":"웹","categories":["All","웹","스프링부트","자바","스프링","데이터베이스","설계","JPA","인프라","테스트","블로그","운영","알고리즘","빌드","머신러닝"],"edges":[{"node":{"id":"104d60ac-d178-5742-8d47-caf93db5ba17","excerpt":"INTRO HTTP는 Stateless 무상태성을 가지고 있다. 따라서 데이터를 상태로 저장하지 않는다. HTTP가 무성태성이기 때문에 클라이언트에 대한 데이터를 유지하고 싶을 때는 쿠키 또는 세션을 이용한다. (이전에 요청을 보낸 동일한 사용자임을 확인하고 싶은 경우 등등) 쿠키는 클라이언트가 정보를 가지고 브라우저에서 저장 및 관리한다.  세션은 서버가 데이터를 가지고 저장 및 관리한다.  Cookie 쿠키는 클라이언트가 정보를 가지고 브라우저에서 해당 정보를 저장한다.  따라서 요청을 보낼 때마다 브라우저에서 저장된 쿠키 데이터를 HTTP 헤더에 추가하여 서버에 보낼 수 있다. HTTP 메세지 자체는 무상태성이기 때문에 매번 쿠키값을 보내주어야 한다.  쿠키에 저장되는 값의 형태는 text 이다.  쿠키의 단점 클라이언트가 관리하는 것이기 때문에 데이터가 쉽게 훼손 될 수 있다.  실제로 크롬 브라우저에서 개발자 도구 -> Application 탭에 가면 쿠키 데이터를 저장하…","fields":{"slug":"/cookie-session/"},"frontmatter":{"categories":"웹","title":"쿠키와 세션 알아보기","date":"September 04, 2021"}},"next":{"fields":{"slug":"/oauth/"}},"previous":{"fields":{"slug":"/db-replication/"}}},{"node":{"id":"9dcfc695-3e64-5efc-9b80-257d69dd5ae2","excerpt":"1. INTRO 많은 어플리케이션에서 소셜 로그인을 지원하는데, 이때 사용되는 것이 OAuth 2.0 이다.  간단하게 이야기하면 OAuth 2.0 이란 사용자의 정보에 대한 권한을 부여하는 의 일종이다.  (정의) 제 3의 앱이 자원의 소유자인 서비스 이용자를 대신하여 서비스를 요청할 수 있도록 자원 접근 권한을 위임하는 방법  출처: 금융보안원 “OAuth 2.0 개요 및 보안 고려사항” 보안연구부-2015-030 즉, 정보 소유자 (서비스 이용자)를 대신하여 앱이 다른 서비스에 등록되어 있는 자원에 대한 접근을 요청하는 권한을 위임한다.  아래 글은 링크 원문을 번역하고 일부 요약한 것이다.  2. OAuth 주요 개념 리소스 소유자 (Resource Owner) - 어플리케이션이 인가 요청을 하는 정보의 소유자이다. 즉, 그 정보를 소유하고 있는 ‘사용자’를 말한다.  클라이언트 (Client) - 리소스 소유자의 정보를 요청하는 어플리케이션이다.  리소스 서버 (Resou…","fields":{"slug":"/oauth/"},"frontmatter":{"categories":"웹","title":"OAuth 알아보기","date":"September 03, 2021"}},"next":{"fields":{"slug":"/cdn/"}},"previous":{"fields":{"slug":"/cookie-session/"}}},{"node":{"id":"156033a5-3d3b-51d5-abc6-61b8996690bf","excerpt":"다음 글은 링크에 기술되어 있는 스프링 웹 어플리케이션 구조에 대한 글을 번역 한 내용이다.  좋은 architecture를 위한 두 기둥 The SoC(Separation of Concerns) 원칙 A design principle for separating a computer program into distinct sections, which each section addresses a separate concern.  출처 SoC에서 신경써야 할 부분은 두가지이다. 고려해야 할 concerns가 무엇인지   어디서 해당 concern을 다루고 싶은지 SoC를 준수하게 된다면 각각의 layer와 해당 layer의 책임에 대해서 자연스럽게 정의할 수 있도록 도와준다.  The KISS(Keep It Simple Stupid) 원칙 Most systems work best if they are kept simple rather than made complicated; theref…","fields":{"slug":"/spring-spring-web-application-architecture/"},"frontmatter":{"categories":"스프링 웹","title":"클래식한 스프링 웹 어플리케이션 구조","date":"June 26, 2021"}},"next":{"fields":{"slug":"/handler-method-argument-resolver/"}},"previous":{"fields":{"slug":"/database-transaction-currency-control/"}}},{"node":{"id":"1f652c1c-da4d-5aba-86ee-d66e7a606fcb","excerpt":"INTRO 는 Spring framework에서 제공하는 인터페이스로 request에서 메소드의 parameters를 해당하는 인자값으로 변환 혹은 바인딩 하는 resolver이다. 인터페이스 내용 에는 두가지 메소드가 있다.    첫번째, Parameter가 해당 resolver를 지원하는 여부 확인 참고 아래 설명은 가 붙은 인자의 경우를 보는 것이므로 그 구현체가 의 예시로 설명한 것이다.  Parameter가 있는 수만큼  →  안에서 for문을 돌면서 해당 parameter에 대한 argument resolve를 한다. 이때 resolve를 하기 위해서 현재 클래스가 가지고 있는  가 해당 parameter 지원 하는지 여부를 확인한다. → 확인하는 로직은  안에 있는 resolver들의 배열을 돌면서(한번 찾으면 캐싱함) 해당 parameter를 지원하는 resolver를 찾아서 반환하고, null인지 여부를 체크해 boolean을 반환한다. 이때  메소드가 수행된다. …","fields":{"slug":"/handler-method-argument-resolver/"},"frontmatter":{"categories":"스프링 웹","title":"HandlerMethodArgumentResolver 내부동작 원리 알아보기","date":"June 25, 2021"}},"next":{"fields":{"slug":"/spring-interceptor/"}},"previous":{"fields":{"slug":"/spring-spring-web-application-architecture/"}}},{"node":{"id":"90dcdd48-5814-5261-9fed-a768d1269d4a","excerpt":"개요 Handler interceptors는 어떤 요청들에 대한 특정 기능을 적용하고 싶을 때 사용이 되는데, 특히 어떤 조건 및 원칙들을 검증하는데 많이 사용된다.  Interceptor 구성 Interceptor를 구현하기 위해서는 HandlerInterceptor를 구현해야 한다. 해당 인터페이스에는 interceptor가 실행되는 3가지 경우에 대한 메소드가 정의되어 있다.  handler가 실행되기 이전 handler가 실행된 이후 전체 요청 처리가 모두 수행된 이후 이것들 중 handler 실행 이전에 수행되는 메소드인  은 boolean 값을 반환한다. 과 은 void를 반환한다.  위 세가지 메소드 모두 공통된 인자로 Servlet에 의해서 생성된 , , (Object 타입)을 받는다. 따라서 void 반환타입인 경우 HttpServletResponse에 후처리를 할 수 있다. (의 경우에는 를 은 을  속성으로 받는다)   preHandle() 동작원리 은 와 를 …","fields":{"slug":"/spring-interceptor/"},"frontmatter":{"categories":"스프링 웹","title":"초간단 Interceptor 알아보기","date":"June 23, 2021"}},"next":{"fields":{"slug":"/symmetric-vs-asymmetric-encryption/"}},"previous":{"fields":{"slug":"/handler-method-argument-resolver/"}}},{"node":{"id":"a6cc1d2b-0f6b-57b4-afda-42f7b4ab4500","excerpt":"Intro 암호화(encryption)에는 3가지 기술이 있다.  Symmetric encryption - 대칭키 Asymmestric encryption - 비대칭키 Hash functions(keyless) - 해싱 여기서는 대칭키, 비대칭키에 대해서만 다룰 것인데 둘다 각각의 장단점이 있다.  대칭키와 비대칭키의 간단한 차이점  우선 모두 key를 사용해서 데이터를 encrypt/decrypt 한다. 대칭키의 경우 동일한 key를 가지고 암호화/복호화를 하기 때문에 사용하기가 쉽다. 비대칭키의 경우 public key를 사용해서 데이터를 암호화하고, private key를 사용해서 복호화한다. Symmetric encryption 대칭키? 대칭키를 사용하면 데이터의 암호화/복호화 모두 하나의 key를 사용한다. 그리고 해당 키를 수령인과 공유한다. (수령인이 암호화된 데이터를 받았을 때 복호화를 위해서 필요)  대칭키 장단점 장점 세팅이 쉽고 간단하다. (jiffy 순간적으로…","fields":{"slug":"/symmetric-vs-asymmetric-encryption/"},"frontmatter":{"categories":"웹","title":"대칭키와 비대칭키 비교하기","date":"June 21, 2021"}},"next":{"fields":{"slug":"/hash-salt/"}},"previous":{"fields":{"slug":"/spring-interceptor/"}}},{"node":{"id":"89cc4854-91bf-5d0c-abe5-c82fe6e01006","excerpt":"들어가기 전에 암호화(Encryption)과 해싱은 다른 개념 암호화 - 양방향이므로 복호화가 가능 해싱 - 단방향이므로 복호화가 불가능 단방향 해시 함수 (One-Way Hash Function) 기본적으로 패스워드 등의 보안의 문제가 걸린 정보를 DB에 저장할 때 평문으로 저장하지 않고 해싱한 값을 저장한다. (평문으로 저장할 경우 DB가 해킹되었을 때 심각한 문제가 발생한다)  단방향 해시 함수를 사용해서 원본 내용을 완전히 새로운 내용으로 다이제스트(digest)로 매핑한다. 이때 매핑하는 것을 해시라고 한다. 이것은 단방향이므로 복호화할 수 없다.  해시 함수 종류 SHA MD HAS WHIRLPOOL 한계점 Rainbow Table 동일한 데이터를 동일한 해시 함수로 연산한 다이제스트는 동일한 값을 가진다. 따라서 여러 값들에 대한 다이제스트를 모아놓은 Rainbow Table이라는 것이 존재하고 이것을 통해서 원본 데이터를 유추할 수 있다.  Brute-force 해싱…","fields":{"slug":"/hash-salt/"},"frontmatter":{"categories":"웹 자바","title":"Hash와 Salt","date":"June 21, 2021"}},"next":{"fields":{"slug":"/springboot-controller-advice/"}},"previous":{"fields":{"slug":"/symmetric-vs-asymmetric-encryption/"}}},{"node":{"id":"debf7ec4-ca5a-5118-ab72-01b5b73f51e7","excerpt":"Spring Boot Spring boot 자체에서 핸들링 되지 않은 error 에 대한 대비책을 마련해 두었다.  먼저, Spring boot 자체에서  에 대한 매핑을 찾아서 해당 URL에 대해서 동일한 이름을 가진  뷰를 매핑 한다. 해당 뷰는  을 반환한다. (해당 뷰는  Thymeleaf template인데, 만일 JSP를 사용한다면 를 반환하도록 에서 변경할 수 있다) 실질적인 매핑은 ViewResolver에서 담당한다. 만일 에 대해 그 어떠한 view-resolver도 매핑이 되어 있지 않다면 spring boot는 내부적으로 가지고 있는 대체 에러 페이지인 “Whitelabel Error Page”를 가지고 있다. 이때 만일 RESTful request에 대한 응답이라면 Spring boot는 자체적인 JSON 형태로 “Whitelabel Error Page”의 응답을 받은 error 정보를 반환한다. Spring boot는 컨테이너에 대한 디폴트 error-pag…","fields":{"slug":"/spring-exception-handling/"},"frontmatter":{"categories":"스프링부트 스프링 웹","title":"스프링부트의 Exception handling","date":"June 19, 2021"}},"next":{"fields":{"slug":"/jwt-token/"}},"previous":{"fields":{"slug":"/request-body-model-attribute-advanced/"}}},{"node":{"id":"38ae2cc9-d468-5d33-af6e-18533bf42cae","excerpt":"JWT(JSON Web Token) 배경 이전에 인증 절차를 거치려면 사용자의 해싱값을 DB에 저장하고 매번 요청이 있을 때마다 해당 해싱값을 검증해야한다. 검증시 DB에 접근하는 쿼리가 실행되어야하는데 성능면에서 좋지 않다. 따라서 JWT가 등장하게 되고 위와 같은 절차를 거치지만 DB 접근 쿼리가 필요하지 않게 된다.  JWT 정의: A string that is sent in the HTTP request (from client or server) to validate the authenticity of the client. It is saved on the client-side only. 출처  JWT 특징 compact self-contained digitally signed : it is signed using a secret key(HMAC algorithm) or public/private key pair using (RSA or ECDSA) sgined 토큰 이라면…","fields":{"slug":"/jwt-token/"},"frontmatter":{"categories":"웹","title":"JWT (JSON Web Token) 알아보기","date":"June 13, 2021"}},"next":{"fields":{"slug":"/java-bean/"}},"previous":{"fields":{"slug":"/spring-exception-handling/"}}},{"node":{"id":"bba3b50e-5ef0-5460-b0ea-d503ef9f2aac","excerpt":"Servlet 개념 및 구조 Servlet은 웹 서버를 구현한 자바의 프로그램이며 interface이다. 서블릿이 하는 일은 다음과 같다. Servlet은 웹 클라이언트로부터 요청을 받아서 응답을 반환한다.  Servlet 인터페이스는 servlet을 초기화하고, 서비스를 요청하고, servlet을 서버에서 제거하는 메소드를 제공한다. (이걸 life-cycle 메소드라고 말한다)   메소드를 통해서 서블릿이 구축된다.  클라이언트에서 호출된  메소드가 수행된다.  수행된 서블릿이 에서 제거되고  메소드를 통해서 소멸된다.  추가로 Servlet 초기세팅 정보를  에 담아서 반환하는  와, Servlet 정보를 반환하는  메소드도 존재한다.  HttpServlet 구조 을 확장하고  인터페이스를 구현한다. 웹 환경에 최적화되어 있어서 HTTP 메소드를 지원한다. 즉, HttpServlet 에서는  를 override 할 이유가 거의 없다. 왜냐햐면 이미 정의되어 있는 Http 요청…","fields":{"slug":"/dispatcher-servlet/"},"frontmatter":{"categories":"웹","title":"Dispatcher Servlet 알아보기","date":"June 03, 2021"}},"next":{"fields":{"slug":"/bean-scope/"}},"previous":{"fields":{"slug":"/java-bean/"}}},{"node":{"id":"0c475bf4-622e-52db-93a0-041e112f245b","excerpt":"스프링 프레임워크에서 사용되는 Bean scope에 6가지 종류가 있다. 일반적으로 많이 쓰이는 scope은 싱글톤이다.  Singleton scope 스프링 빈이 singleton scope을 가지고 있다면, 컨테이너가 빈의 단 하나의 인스턴스를 해당 빈이 필요할 때마다 캐싱된 빈을 리턴한다. 빈 객체를 수정하면 해당 빈을 참조하고 있는 모든 곳에 반영이 된다. 싱글톤 스콥은 스프링의 기본값이다.  Prototype scope  프로토타입 스콥은 빈 요청이 있을때마다 매번 다른 인스턴스를 컨테이너로부터 반환한다. 설정방법은 다음과 같다.  Web Aware Scopes 앞에 두 개의 범위를 제외하고 4개의 범위가 더 존재한다. 하지만 조건이 있는데, web-aware application 맥락에서만 적용이 될 수 있는 범위이다.  Request Scope Request scope은 하나의 HTTP request 당 하나의 빈을 생성한다.  이 scope을 사용할 때는 proxyM…","fields":{"slug":"/bean-scope/"},"frontmatter":{"categories":"스프링 웹","title":"Bean Scope 종류 알아보기","date":"May 30, 2021"}},"next":{"fields":{"slug":"/annotation-valid/"}},"previous":{"fields":{"slug":"/dispatcher-servlet/"}}},{"node":{"id":"36216a08-7f3b-5fae-a020-c6ecb5db3d3e","excerpt":"자바 + 스프링 MVC 프로젝트 배포과정 (별도 인스턴스 활용) 이번에 몇몇 크루들과 미션을 진행하면서 웹을 처음으로 호스팅 해보았다. 웹을 배포 할 때 더욱 편리하다는 DevOps의 꽃 ci/cd를 학습해보기 위해서 6명이 모여서 한번 적용해보았다. 적용하면서 밟은 단계들을 기록해둔다.  아래와 같이 그대로 적용하다가 본 프로젝트에 맞게 어느정도 커스텀하여 다르게 설정한 것도 있다. 특히 버전같은 것들은 좀 outdated 된 정보일 수 있다.  추후에 진행할 팀 프로젝트에 큰 도움이 될 것 같다.  docker 설치 EC2에서 Jenkins key 받기 및 적용 Jenkins 포트 번호 변경 젠킨스는 내부적으로 톰캣 서버를 이용하므로 기본포트 8080을 이용한다. 대부분의 스프링 프로젝트도 8080 톰캣 포트를 이용하기 때문에 젠킨스의 포트번호를 변경해야한다.  Jenkins 홈 디렉토리 Jenkins 기본 설정파일 & 로그 파일 포트 변경 후 재시작 Jenkins 접속 및 설…","fields":{"slug":"/cicd-jenkins/"},"frontmatter":{"categories":"웹 운영","title":"젠킨스를 활용한 CI/CD 적용기","date":"May 19, 2021"}},"next":{"fields":{"slug":"/cicd/"}},"previous":{"fields":{"slug":"/annotation-valid/"}}},{"node":{"id":"f02c63aa-3997-5d83-92ac-51b2edd0b27e","excerpt":"CI/CD 의 필요성 개발 후 운영을 하기까지 다음 그림의 프로세스가 반복해서 진행된다.  즉, 개발 프로세스(Dev)의 일종으로 개발을 하여 빌드를 하고 운영 프로세스(Ops)의 일종으로 릴리즈, 배포, 모니터링이 반복된다. 점점 이것을 짧은 쥐기로 반복하는 DevOps가 등장하면서 CI/CD가 중요해졌다.  CI - Continuous Integration 정의: 지속적으로 퀄리티 컨트롤을 적용하는 프로세스를 실행하는 것 어플리케이션 코드에 변경이 생기더라도 정기적인 빌드와 테스트를 통과하여 하나의 레포지토리에 관리가 되는 것 예시: SCM(Source Code Management): 깃헙 레포 하나로 소스코드를 머지하고 충도를 처리하는 과정 테스트 코드를 통해서 유효성을 검증하는 과정 장점: 소스코드를 Ready-to-run 상태로 유지할 수 있다. 이 부분은 혼자 개발할 경우 장점을 느끼기 어렵지만 주로 여러명이서 협업하여 개발을 하기 때문에 중간에 합류한 그 누구도 빌드가…","fields":{"slug":"/cicd/"},"frontmatter":{"categories":"웹 운영","title":"CI/CD란 무엇일까","date":"May 17, 2021"}},"next":{"fields":{"slug":"/transaction-annotation/"}},"previous":{"fields":{"slug":"/cicd-jenkins/"}}},{"node":{"id":"75f61000-50f8-58be-a445-5bda37396ef5","excerpt":"트랜잭션을 사용하는 이유 트랜잭션을 사용하면 각각의 단위로 나누어져있는 작업의 단위를 하나로 합칠 수 있다. 즉, 일련의 연산들을 하나의 독립된 작업 단위로 보고 하나로 취급하기 위해서 사용하는 것이다.  언제 일련의 연산들을 하나로 봐야 할 때가 생길까?  예를 들어서 돈을 송금하는 시스템이 있다고 가정해보자. 계좌A에서 계좌B로 돈을 송금해야 할 때, 계좌A에 충분한 잔액이 있는 것을 확인하고 돈을 송금하기 위해서 돈을 차감했다. 그리고 계좌B에 입금을 하려고 하는 순간 예외가 발생하면서 입금을 하지 못했다. 그런데 계좌A에서는 여전히 돈이 차감된 상태이다. 중간에 송금하려고 했던 돈이 사라지게 된 것이다.  이때, 위의 과정을 로 관리를 하게 된다면 위의 여러 작업들을 하나의 단위로 보고 중간에 예외가 발생한다면 위에서 실행중이던 작업을 한꺼번에 롤백해준다.  트랜잭션 기본 방법 2개 이상의 쿼리를 하나의 커넥션으로 묶어 DB에 전송하고, 에러가 발생할 경우 자동으로 모든 과…","fields":{"slug":"/transaction-annotation/"},"frontmatter":{"categories":"스프링부트 웹 데이터베이스","title":"@Transactional","date":"May 10, 2021"}},"next":{"fields":{"slug":"/controller-vs-restcontroller/"}},"previous":{"fields":{"slug":"/cicd/"}}},{"node":{"id":"21e10a37-af41-506b-8eda-5a0ffa60b567","excerpt":"스프링 강의 중 DAO vs. Repository의 차이점에 대해서 논의하다가 다음과 같은 표현이 나왔다.  Repository의 추상 인터페이스는 Domain Layer에 속하며 Domain 객체들을 관리하고 생애주기를 같이한다. 그 구현체인 SimpleJpaRepository는 Infrastructure에 속한다. 추상화된 repository 인터페이스를 사용하면서 추상에 의존하고 구체에 의존하지 않도록 구성(DIP) 하여 유연성 있는 시스템을 구성한다. 여기서 나오는 DIP는 무엇이고 위와 같은 구성이 어떻게 우연성을 제공하는 걸까?  DIP 요약 Dependency Inversion Principle의 약자이다. 본래 객체는 상위 계층이 하위 계층에 의존한다. DIP는 그 관계를 역전시켜서 상위 계층이 하위 계층의 구현에서 독립하도록 한다. 그러기 위한 원칙 두가지는 다음과 같다.  상위 모듈과 하위 모듈이 서로 의존하는 것이 아니라 모두 추상화에 의존한다.  추상화가 구현…","fields":{"slug":"/dip/"},"frontmatter":{"categories":"스프링 웹","title":"DIP 의존관계 역전의 원칙","date":"March 13, 2021"}},"next":{"fields":{"slug":"/transaction/"}},"previous":{"fields":{"slug":"/boolean-timestamp/"}}},{"node":{"id":"93c8960d-fd12-539f-93d8-ad36d2740d7c","excerpt":"데이터의 흐름 또는 코드가 책임지는 부분의 유사도에 따라서 계층별로 나누어서 대규모 웹 어플리케이션을 구현한다. 이때의 이점은 각 계층이 담당하고 있는 책임을 알 수 있기 때문에 대량의 코드에서도 필요한 부분을 찾아서 수정하기 다소 쉽다. 또한 구조적으로 정리되어 있는 이점이 있다.  웹 어플리케이션을 구현할 때 이러한 계층들에 대한 제대로 된 정의를 가지고 각자가 담당하는 기능을 구현하는 것이 좋다. 함께 일하는 동료 개발자나 이후에 레거시 코드로 받을 다른 개발자들과의 의사소통 비용을 크게 감소하고 쉽게 코드와 구조를 이해할 수 있기 때문이다.  총 5개의 계층이 있다. Presentation Layer 식당에서  역할 UI를 담당하는 계층이다. User에게 보여지는 화면 담당 User의 입력을 받는 담당 입력에 따른 결과를 서버로부터 받아서 다시 화면에 띄우는 담당 다른 계층과의 접촉이 없고 Control layer를 통해서 다른 계층과 협업한다. 따라서 presentatio…","fields":{"slug":"/web-layer/"},"frontmatter":{"categories":"웹","title":"웹 Layers에 대해","date":"March 05, 2021"}},"next":{"fields":{"slug":"/gradle-dependency/"}},"previous":{"fields":{"slug":"/transaction/"}}}]}},"staticQueryHashes":["1073350324","2938748437"]}
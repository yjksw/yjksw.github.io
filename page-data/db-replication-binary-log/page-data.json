{"componentChunkName":"component---src-templates-blog-template-js","path":"/db-replication-binary-log/","result":{"data":{"cur":{"id":"3144633b-9fb5-54a7-9f11-f6a48517333b","html":"<h2 id=\"intro\" style=\"position:relative;\"><a href=\"#intro\" aria-label=\"intro permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>INTRO</h2>\n<ul>\n<li>\n<p>현재 진행중인 <a href=\"https://github.com/woowacourse-teams/2021-pick-git\">프로젝트</a>에서 DB Replication을 적용했었다. </p>\n<ul>\n<li><a href=\"https://yjksw.github.io/db-replication/\">Replication 알아보기</a></li>\n</ul>\n</li>\n<li>DB replication 적용 이후 Master DB를 업그레이드 해야하는 상황에서 replicas와의 연동에 문제가 생긴적이 있었다. 이때 Master와 replicas 간의 데이터 연동 방법을 이해하고 해결한 (매우 간단한) 방법을 기록한다. </li>\n</ul>\n<h2 id=\"master-db와-replicas-동기화\" style=\"position:relative;\"><a href=\"#master-db%EC%99%80-replicas-%EB%8F%99%EA%B8%B0%ED%99%94\" aria-label=\"master db와 replicas 동기화 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Master DB와 replicas 동기화</h2>\n<ul>\n<li>Master DB에 데이터를 쓰기 위해서는 replicas에서 master db 의 데이터와 연결되어 있어야 한다. 그러기 위해서 replication을 설정할 때 <code class=\"language-text\">show master status</code> 라는 명령어를 통해서 나온 <code class=\"language-text\">File</code>값과 <code class=\"language-text\">Position</code> 값을 replica db 설정시 적용해 주었다. </li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"mysql\"><pre class=\"language-mysql\"><code class=\"language-mysql\">MariaDB [pickgit]&gt; show master status;\n+--------------------+----------+--------------+------------------+\n| File               | Position | Binlog_Do_DB | Binlog_Ignore_DB |\n+--------------------+----------+--------------+------------------+\n| mariadb-bin.000008 | 68143505 |              |                  |\n+--------------------+----------+--------------+------------------+\n1 row in set (0.000 sec)</code></pre></div>\n<ul>\n<li>여기서 File은 master db의 binary 로그 파일이고 Position 값은 해당 파일의 현재 위치이다. </li>\n<li>\n<p>위 log 파일에는 어떤 내용이 담겨 있을까?</p>\n<blockquote>\n<p>The MariaDB binary log is a series of files that contain events. An event is a description of a modification to the contents of our database. <br>출처: Big Data and Business Intelligence</p>\n</blockquote>\n</li>\n<li>로그 파일에는 데이터베이스에서 일어난 <code class=\"language-text\">event</code>에 대해서 적혀 있는데, 여기서 <code class=\"language-text\">event</code>라고 하는 것은 데이터베이스의 컨텐츠에 대해 일어난 변경사항을 말한다. </li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"mysql\"><pre class=\"language-mysql\"><code class=\"language-mysql\">MariaDB [pickgit]&gt; show master status;\n+--------------------+----------+--------------+------------------+\n| File               | Position | Binlog_Do_DB | Binlog_Ignore_DB |\n+--------------------+----------+--------------+------------------+\n| mariadb-bin.000008 | 68143656 |              |                  |\n+--------------------+----------+--------------+------------------+\n1 row in set (0.000 sec)</code></pre></div>\n<ul>\n<li>실제로 테이블을 추가하는 쿼리를 날린 후 다시 확인해보니 Position값이 증가한 것을 확인할 수 있다. </li>\n<li>Replicas 설정시 위 값을 지정한다는 것은 replicas에 데이터를 업데이트하는 file과 해당 file에서의 위치를 지정하는 것이다. </li>\n<li>번외로 만일 binary loggin이 비활성되어 있는 상태에서 master 데이터베이스가 실행중이었다면 <code class=\"language-text\">show master status;</code> 명령어에 나오는 값이 비어있을 것이다. 그 경우 replicas에 master의 로그파일과 position을 지정할 때 빈 스트링 (”)과 4를 지정하면 된다. </li>\n</ul>\n<h2 id=\"문제상황-및-해결\" style=\"position:relative;\"><a href=\"#%EB%AC%B8%EC%A0%9C%EC%83%81%ED%99%A9-%EB%B0%8F-%ED%95%B4%EA%B2%B0\" aria-label=\"문제상황 및 해결 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>문제상황 및 해결</h2>\n<ul>\n<li>본래 사용한 MariaDB 버전은 10.1이었다. 하지만 Flyway를 적용한 이후 MariaDB를 10.4로 업그레이드 하지 않으면 적용할 수 없다는 오류가 생겼다. MariaDB 버전을 업그레이드 할 수 있는 방법을 찾아보았지만 현재 사용 중인 DB 데이터를 백업하고 삭제 후 10.4 버전을 새로 설치하여 데이터를 복원하라는 내용밖에 나오지 않았다. </li>\n<li>현재 Master 1개 slave 2개를 사용중이었기 때문에 DB 3개를 모두 삭제하고 재설치하는 것은 지나치게 많은 작업이라고 생각했다. (replication 설정, 유저 생성 및 권한 부여 등등 자잘한 설정이 많음) 따라서 Flyway가 직접 적용되는 Master DB만 수정하고 Slave DB는 기존의 것을 유지하기로 했다. </li>\n<li>\n<p>Master DB를 새로 구성하는 와중에 다음과 같은 문제 상황이 발생했다. </p>\n<ul>\n<li>문제 상황</li>\n<li>Master DB의 설정을 마치고 Slave에 Master를 지정하여 연결을 완료함 </li>\n<li>Master DB의 <code class=\"language-text\">replication</code> 유저에게 외부에서 쓰기 권한을 부여하지 않은 것을 깨달음 </li>\n<li>Master DB의 <code class=\"language-text\">replication</code> 유저에게 권한을 부여함</li>\n<li>Slave DB에 Master DB의 데이터가 반영이 되지 않음  </li>\n</ul>\n</li>\n<li>\n<p>Master에서 연결된 slave hosts를 확인해 보면 잘 연결되어 있는 것을 확인할 수 있다. </p>\n<div class=\"gatsby-highlight\" data-language=\"mysql\"><pre class=\"language-mysql\"><code class=\"language-mysql\">MariaDB [pickgit]&gt; show slave hosts;\n+-----------+------+------+-----------+\n| Server_id | Host | Port | Master_id |\n+-----------+------+------+-----------+\n|         3 |      | 9000 |         1 |\n|         2 |      | 9000 |         1 |\n+-----------+------+------+-----------+\n2 rows in set (0.000 sec)</code></pre></div>\n</li>\n<li>Slave 의 상태를 확인해보면 <code class=\"language-text\">Slave_IO_State: Waiting for master to sent event</code> 라고 나와있는 것을 확인할 수 있다. </li>\n</ul>\n<p align=\"center\"><img width=\"90%\" src=\"https://user-images.githubusercontent.com/63405904/134805936-9f3469e3-aa3e-496f-91b3-ae5b7f6e881d.png\"></p>\n<ul>\n<li>위 상태의 더 아래에 <code class=\"language-text\">Last_Error</code> 와 <code class=\"language-text\">Last_SQL_Error</code>를 확인해보면 특정 쿼리에 에러가 발생했다는 로그가 출력되어 있다. 즉, <code class=\"language-text\">replication</code> 이라는 유저가 Master에서는 잘 적용이 되었지만 Slave DB에는 존재하지 않기 때문에 에러가 발생한 것이다. 해당 로그 이후에 추가 및 변경된 데이터에 대해서는 slave db에 더 이상 반영이 되지 않았다. </li>\n<li>위 문제를 해결하기 위해서는 Slave DB가 Master의 로그 파일을 읽는 Position을 위 쿼리가 실행된 이후로 옮겨서 해당 쿼리를 건너뛰어야 한다. 따라서 <code class=\"language-text\">show master status</code>를 다시 실행하여 나온 최신 position을 slave DB 설정에 넣어주어 문제를 해결했다. 여기서 주의할 점은 만일 이전에 변경된 데이터가 있다면 해당 변경 로그도 모두 건너뛰게 되니 다시 적용해주어야 한다. </li>\n</ul>\n<p><strong>[참고자료]</strong></p>\n<ul>\n<li><a href=\"https://dev.mysql.com/doc/refman/8.0/en/replication-setup-replicas.html#replication-howto-newservers\">https://dev.mysql.com/doc/refman/8.0/en/replication-setup-replicas.html#replication-howto-newservers</a></li>\n<li><a href=\"https://dev.mysql.com/doc/refman/8.0/en/replication-howto-masterstatus.html\">https://dev.mysql.com/doc/refman/8.0/en/replication-howto-masterstatus.html</a></li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#intro\">INTRO</a></li>\n<li><a href=\"#master-db%EC%99%80-replicas-%EB%8F%99%EA%B8%B0%ED%99%94\">Master DB와 replicas 동기화</a></li>\n<li><a href=\"#%EB%AC%B8%EC%A0%9C%EC%83%81%ED%99%A9-%EB%B0%8F-%ED%95%B4%EA%B2%B0\">문제상황 및 해결</a></li>\n</ul>\n</div>","excerpt":"INTRO 현재 진행중인 프로젝트에서 DB Replication을 적용했었다.  Replication 알아보기 DB replication 적용 이후 Master DB를 업그레이드 해야하는 상황에서 replicas와의 연동에 문제가 생긴적이 있었다. 이때 Master와 replicas 간의 데이터 연동 방법을 이해하고 해결한 (매우 간단한) 방법을 기록한다.  Master DB와 replicas 동기화 Master DB에 데이터를 쓰기 위해서는 replicas에서 master db 의 데이터와 연결되어 있어야 한다. 그러기 위해서 replication을 설정할 때  라는 명령어를 통해서 나온 값과  값을 replica db 설정시 적용해 주었다.  여기서 File은 master db의 binary 로그 파일이고 Position 값은 해당 파일의 현재 위치이다.  위 log 파일에는 어떤 내용이 담겨 있을까? The MariaDB binary log is a series of file…","frontmatter":{"date":"September 26, 2021","title":"DB 리플리케이션 적용시 Binary 로그 에러 해결방법","categories":"데이터베이스 인프라","author":"코다","emoji":"🚊"},"fields":{"slug":"/db-replication-binary-log/"}},"next":{"id":"fe08b31d-d1b9-5132-8265-561e8d82be9a","html":"<blockquote>\n<p>다음은 웹 개발자를 위한 대규모 서비스를 지탱하는 기술을 읽고 정리한 내용입니다 🙌</p>\n</blockquote>\n<br>\n<h2 id=\"강의8-os-캐시-구조\" style=\"position:relative;\"><a href=\"#%EA%B0%95%EC%9D%988-os-%EC%BA%90%EC%8B%9C-%EA%B5%AC%EC%A1%B0\" aria-label=\"강의8 os 캐시 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[강의8] OS 캐시 구조</h2>\n<h2 id=\"os의-캐시-구조를-알고-애플리케이션-작성하기---페이지-캐시\" style=\"position:relative;\"><a href=\"#os%EC%9D%98-%EC%BA%90%EC%8B%9C-%EA%B5%AC%EC%A1%B0%EB%A5%BC-%EC%95%8C%EA%B3%A0-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EC%9E%91%EC%84%B1%ED%95%98%EA%B8%B0---%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C\" aria-label=\"os의 캐시 구조를 알고 애플리케이션 작성하기   페이지 캐시 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>OS의 캐시 구조를 알고 애플리케이션 작성하기 - 페이지 캐시</h2>\n<ul>\n<li>OS는 메모리를 이용해서 캐시 구조를 갖추고 디스크 액세스를 줄인다.</li>\n</ul>\n<h3 id=\"linuxx86-페이징-구조\" style=\"position:relative;\"><a href=\"#linuxx86-%ED%8E%98%EC%9D%B4%EC%A7%95-%EA%B5%AC%EC%A1%B0\" aria-label=\"linuxx86 페이징 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Linux(x86) 페이징 구조</h3>\n<p>OS는 가장 메모리 구조를 가지고 있는데 논리적인 선형 어드레스를 물리적인 어드레스로 변환한다. </p>\n<h2 id=\"가상-메모리-구조\" style=\"position:relative;\"><a href=\"#%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0\" aria-label=\"가상 메모리 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>가상 메모리 구조</h2>\n<p>기본적인 OS 구조를 보면 OS에서 관리하고 있는 메모리 구조 있고, OS가 있으며 OS에서 돌아가는 프로세스가 존재한다. 프로세스에서 메모리가 필요한 경우 메모리에 직접 접근해서 주소를 가져오는 것이 아니라, OS를 통해서 비어있는 주소와 다른 주소를 반환한다. </p>\n<h3 id=\"왜-가상-주소를-반환할까\" style=\"position:relative;\"><a href=\"#%EC%99%9C-%EA%B0%80%EC%83%81-%EC%A3%BC%EC%86%8C%EB%A5%BC-%EB%B0%98%ED%99%98%ED%95%A0%EA%B9%8C\" aria-label=\"왜 가상 주소를 반환할까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>왜 가상 주소를 반환할까?</h3>\n<p>개별 프로세스가 실제로 메모리의 어느 부분을 사용하는지 스스로 알고 있을 필요가 없고, 특정 번지에서 통일해서 시작하는 것으로 다루면 더 쉽기 때문이다. </p>\n<ul>\n<li>예) 유닉스에서 공유 라이브러리는 프로세스 내에서 지정된 주소로 할당이 되어 있는데 프로세스 내에서 이 특정 어드레스는 예약에 되어 있음. 따라서 시작주소가 다 다르면 메모리를 확보할 주소위치를 찾기가 어려움</li>\n</ul>\n<p>어쨌든 OS 커널에서 메모리를 추상화해서 넘기고 있다 !!! </p>\n<p>또한 OS에서 메모리를 확보할 때도 단일 바이트 만큼씩 액세스 하는 것이 아니라 4KB 정도의 블록을 확보해서 프로세스에 넘긴다. <strong>블록 = 페이지 (즉, OS가 메모리를 확보하는 단위)</strong> </p>\n<p>OS는 메모리 요청을 받을 때 필요한 만큼의 페이지를 확보해서 프로세스에 넘긴다.  </p>\n<h2 id=\"linux-페이지-캐시의-원리\" style=\"position:relative;\"><a href=\"#linux-%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C%EC%9D%98-%EC%9B%90%EB%A6%AC\" aria-label=\"linux 페이지 캐시의 원리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Linux 페이지 캐시의 원리</h2>\n<p>OS는 확보한 페이지를 메모리상에 캐싱해둔다. </p>\n<h3 id=\"프로세스가-디스크에서-데이터를-읽어내는-과정\" style=\"position:relative;\"><a href=\"#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EA%B0%80-%EB%94%94%EC%8A%A4%ED%81%AC%EC%97%90%EC%84%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A5%BC-%EC%9D%BD%EC%96%B4%EB%82%B4%EB%8A%94-%EA%B3%BC%EC%A0%95\" aria-label=\"프로세스가 디스크에서 데이터를 읽어내는 과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>프로세스가 디스크에서 데이터를 읽어내는 과정</h3>\n<p>첫번째, 우선 디스크로부터 4KB 정도의 블록을 읽어냄</p>\n<p>두번째, 우선 메모리에 해당 읽어낸 데이터를 위치시킴 </p>\n<ul>\n<li>프로세스는 디스크에서 데이터를 직접 읽을 수는 없다 ! 프로세스가 액세스 할 수 있는 것은 가상 메모리 주소이기 때문이다.</li>\n</ul>\n<p>세번째, OS는 메모리에 쓰인 블록의 해당 주소를 프로세스에 가상 주소로 변환해서 알려준다. </p>\n<p>네번째, 프로세스는 해당 가상 주소로 메모리에 액세스 하게 된다. </p>\n<p align=\"center\"><img width=\"85%\" src=\"https://user-images.githubusercontent.com/63405904/136983984-be05b727-15c4-485c-8cf8-9f349a1d3fff.png\"><br>이미지 출처: 대용량 서비스를 지탱하는 기술</p>\n<p><strong>페이지 캐시 등장 -</strong> 이후에 더이상 프로세스가 데이터가 필요하지 않더라도 메모리에 쓰인 블럭을 해제하지 않고 남겨둔다. 그럼 다음 프로세스가 같은 디스크에 액세스할 때 해당 페이지를 재사용한다. </p>\n<h3 id=\"페이지-캐시의-효과\" style=\"position:relative;\"><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C%EC%9D%98-%ED%9A%A8%EA%B3%BC\" aria-label=\"페이지 캐시의 효과 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>페이지 캐시의 효과</h3>\n<p>리눅스의 페이지 캐시는 모든 I/O에 작용(예외를 제외하고)하여 디스크를 최초 읽은 이후 두번째 액세스부터 빨라진다. (OS를 계속 가동시켜두면 빨라진다. 재부팅 시 메모리에 캐시된 데이터는 없어진다.) </p>\n<h2 id=\"vfs\" style=\"position:relative;\"><a href=\"#vfs\" aria-label=\"vfs permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>VFS</h2>\n<p>리눅스의 구조는 다음과 같다. </p>\n<ul>\n<li>최하위에 하드디스크를 조작하는 디바이스 드라이버 → 위에 여러 파일 시스템 (리눅스의 경우 ext3, ext2, ext4, 등등) → vfs (virtual file system)</li>\n<li>파일시스템은 다양한 함수를 갖추고 있는데 인터페이스를 통일하기 위해 있는 것이 vfs 이다.</li>\n</ul>\n<p>VFS가 페이지 캐시 구조를 가지고 있다. → 어떤 파일 시스템을 이용하여 어떤 디스크를 읽어도 vfs를 통해서 동일한 구조로 캐싱이 된다. </p>\n<p><strong>한마디로, VFS의 역할은 파일시스템 추상화와 성능에 관여하는 페이지 캐시 부분이다.</strong> </p>\n<h2 id=\"리눅스는-페이지-단위로-디스크를-캐싱\" style=\"position:relative;\"><a href=\"#%EB%A6%AC%EB%88%85%EC%8A%A4%EB%8A%94-%ED%8E%98%EC%9D%B4%EC%A7%80-%EB%8B%A8%EC%9C%84%EB%A1%9C-%EB%94%94%EC%8A%A4%ED%81%AC%EB%A5%BC-%EC%BA%90%EC%8B%B1\" aria-label=\"리눅스는 페이지 단위로 디스크를 캐싱 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>리눅스는 페이지 단위로 디스크를 캐싱</h2>\n<h3 id=\"왜-파일-캐시가-아니라-페이지-캐시일까-\" style=\"position:relative;\"><a href=\"#%EC%99%9C-%ED%8C%8C%EC%9D%BC-%EC%BA%90%EC%8B%9C%EA%B0%80-%EC%95%84%EB%8B%88%EB%9D%BC-%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C%EC%9D%BC%EA%B9%8C-\" aria-label=\"왜 파일 캐시가 아니라 페이지 캐시일까  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>왜 파일 캐시가 아니라 페이지 캐시일까 ?</h3>\n<p>만일 메모리에 남은 여유 메모리 공간이 1.5 GB이고 필요한 파일이 4GB 일 경우 문제가 발생한다. </p>\n<p>OS는 파일(현재 4GB 단위) 기준으로 캐싱하는 것이 아니라 블록 단위(4KB 단위)만으로 캐싱한다. 특정 파일의 읽어낸 일부분만 캐싱한다. </p>\n<ul>\n<li><strong>페이지 == 가상 메모리의 최소단위</strong></li>\n</ul>\n<h3 id=\"lru\" style=\"position:relative;\"><a href=\"#lru\" aria-label=\"lru permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>LRU</h3>\n<p>만일 적은 여유분의 메모리에 4GB 파일을 모두 읽게 된다면 LRU(Least Recently Used) 방식으로 캐싱이 최신화 된다. 따라서 DB 서버도 계속 구동시키면 캐시가 최적화되어 I/O 부하가 내려간다. </p>\n<h3 id=\"어떻게-캐싱이-될까\" style=\"position:relative;\"><a href=\"#%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%BA%90%EC%8B%B1%EC%9D%B4-%EB%90%A0%EA%B9%8C\" aria-label=\"어떻게 캐싱이 될까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>어떻게 캐싱이 될까</h3>\n<p>리눅스는 파일을 i노드 번호라는 번호로 식별하고 어느 위치에서 시작하는 오프셋을 제공하여 두가지 정보를 함께 캐싱한다. 따라서 파일 전체가 아닌 일부분을 캐싱할 수 있다.</p>\n<p>이 키가 너무 많으면 파일이 클 경우 데이터 찾는 것이 어렵다고 여겨질 수 있는 데이터 구조는 <strong>Radix Tree</strong>라는 구조로 탐색 속도가 떨어지지 않는다. </p>\n<h2 id=\"메모리가-비어있으면-캐싱\" style=\"position:relative;\"><a href=\"#%EB%A9%94%EB%AA%A8%EB%A6%AC%EA%B0%80-%EB%B9%84%EC%96%B4%EC%9E%88%EC%9C%BC%EB%A9%B4-%EC%BA%90%EC%8B%B1\" aria-label=\"메모리가 비어있으면 캐싱 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>메모리가 비어있으면 캐싱</h2>\n<p>리눅스는 메모리가 비어있으면 모두 캐싱 → 프로세스에 메모리가 필요하면 오래돈 캐시를 버리고 메모리 확보</p>\n<ul>\n<li>\n<p>메모리 상황 알아보기</p>\n<p><code class=\"language-text\">sar -r</code> 명령어를 통해서 <code class=\"language-text\">kbcached</code>(kilo byte cached) 부분과 <code class=\"language-text\">%memused</code> 부분으로 확인할 수 있다. 주로 꽉찬 메모리를 확인할 수 있는데 이것은 문제가 아니다. 본래 리눅스는 가용 가능한 메모리에 조금씩 디스크를 모두 캐싱하고 추가 메모리가 필요하면 오래된 캐시를 파기한다. </p>\n</li>\n</ul>\n<h2 id=\"메모리-늘려서-io-부하-줄이기\" style=\"position:relative;\"><a href=\"#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%8A%98%EB%A0%A4%EC%84%9C-io-%EB%B6%80%ED%95%98-%EC%A4%84%EC%9D%B4%EA%B8%B0\" aria-label=\"메모리 늘려서 io 부하 줄이기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>메모리 늘려서 I/O 부하 줄이기</h2>\n<p>메모리보다 디스크에 저장된 용량이 적으면 디스크의 모든 파일이 메모리에 캐싱되어 디스크 액세스가 일어나지 않게 된다. 따라서 메모리가 늘어날 수록 I/O 부하가 줄어든다. </p>\n<h2 id=\"페이지-캐시는-투과적으로-작용\" style=\"position:relative;\"><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C%EB%8A%94-%ED%88%AC%EA%B3%BC%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%9E%91%EC%9A%A9\" aria-label=\"페이지 캐시는 투과적으로 작용 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>페이지 캐시는 투과적으로 작용</h2>\n<p>부팅 직후 파일을 그렇게 많이 읽지 않았을 때 그 이후 갑자기 큰 파일을 읽으면 해당 파일이 캐싱이 되기 때문에 갑자기 메모리 사용 용량이 높아진다. </p>\n<h2 id=\"code-classlanguage-textsarcode-명령어로-os-지표-확인하기\" style=\"position:relative;\"><a href=\"#code-classlanguage-textsarcode-%EB%AA%85%EB%A0%B9%EC%96%B4%EB%A1%9C-os-%EC%A7%80%ED%91%9C-%ED%99%95%EC%9D%B8%ED%95%98%EA%B8%B0\" aria-label=\"code classlanguage textsarcode 명령어로 os 지표 확인하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"language-text\">sar</code> 명령어로 os 지표 확인하기</h2>\n<ol>\n<li>\n<p>과거 OS 데이터 확인하기  - <code class=\"language-text\">sar -f {/var/log/sa/sa04} | head</code> 명령어로 과거 데이터의 로그 파일을 확인하여 장애 발생 원인을 확인 할 수 있다.  </p>\n<ul>\n<li>프로그램 교체 후 전후 비교를 위해서 위 sar 데이터를 활용할 수 있음</li>\n</ul>\n</li>\n<li>\n<p>현재 데이터 확인하기 - <code class=\"language-text\">sar 1 3</code> </p>\n<ul>\n<li>1초 간격으로 3회 동안 OS 데이터를 확인</li>\n<li>지금 이 순간 시스템에서 일어나고 있는지 확인할 수 있음</li>\n</ul>\n</li>\n<li>멀티 코어일 경우 <code class=\"language-text\">sar -p</code> 옵션으로 CPU 별 데이터 확인 가능 </li>\n<li>\n<p>디폴트 <code class=\"language-text\">sar</code> (<code class=\"language-text\">sar -u</code>에 해당함) - </p>\n<p align=\"center\"><img width=\"85%\" src=\"https://user-images.githubusercontent.com/63405904/136984234-20945113-1236-42e4-b23b-3a9289e74d83.png\"><br>이미지 출처: 대용량 서비스를 지탱하는 기술</p>\n<ul>\n<li>user → 사용자 모드에서 CPU가 소비된 시간 비율</li>\n<li>nice → nice로 스캐줄링의 우선도 변경한 프로세스가 사용자모드에서 CPU를 소비한 비율</li>\n<li>system → 시스템 모드에서 CPU가 소비된 시간 비율</li>\n<li>iowait → CPU가 디스크 I/O대기 위해 Idle 상태로 소비한 시간 비율</li>\n<li>steal → OS 가상화 이용시 다른 가상 CPU 계산으로 대기된 시간 비율</li>\n<li>idle → CPU가 디스크 I/O 등으로 대기되지 않고 Idle 상대로 소비한 시간 비율 (프로세스가 실행하고 있지 않은 상태)</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">sar -q</code> - Load Average 확인   </p>\n<ul>\n<li>실행큐에 쌓여있는 프로세스 수, 시스템상의 프로세스 사이즈, load average 참조 가능</li>\n<li>시간 흐름에 따른 값의 추이를 추척 가능</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">sar -r</code> - 메모리 사용 현황 확인 </p>\n<ul>\n<li>시간 추이에 따른 메모리 정도, 용도 확인 가능</li>\n<li><code class=\"language-text\">sar -W</code>와 조합해 스왑 발생 시간대의 메모리 사용 상황 확인 가능</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">sar -W</code>- 스왑 발생상황 확인 </p>\n<ul>\n<li>pswpin/s → 1초 동안 스왑인 되고 있는 페이지 수</li>\n<li>pswpout/s → 1초 동안 스왑아웃 되고 있는 페이지 수</li>\n<li>스왑이 발생하면 서버 전송량이 떨어진다. 만일 메모리 부족으로 잦은 스왑이 발생하고 있는지 확인할 수 있다.</li>\n</ul>\n</li>\n</ol>\n<br>\n<h2 id=\"강의9-io-부하를-줄이는-방법\" style=\"position:relative;\"><a href=\"#%EA%B0%95%EC%9D%989-io-%EB%B6%80%ED%95%98%EB%A5%BC-%EC%A4%84%EC%9D%B4%EB%8A%94-%EB%B0%A9%EB%B2%95\" aria-label=\"강의9 io 부하를 줄이는 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[강의9] I/O 부하를 줄이는 방법</h2>\n<h2 id=\"캐시를-전제로-한-io-줄이는-방법\" style=\"position:relative;\"><a href=\"#%EC%BA%90%EC%8B%9C%EB%A5%BC-%EC%A0%84%EC%A0%9C%EB%A1%9C-%ED%95%9C-io-%EC%A4%84%EC%9D%B4%EB%8A%94-%EB%B0%A9%EB%B2%95\" aria-label=\"캐시를 전제로 한 io 줄이는 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>캐시를 전제로 한 I/O 줄이는 방법</h2>\n<p>I/O 대책의 기본은 캐시이다 !! </p>\n<ul>\n<li>첫번째 접근법 → 데이터 크기보다 물리 메모리 사이즈가 크다면 모두 캐싱할 수 있다.</li>\n</ul>\n<p>대규모 데이터에 데이터 압축이 중요하다. 압축해서 저장할 경우 디스크 전부를 메모리에 캐싱해둘 수도 있다. </p>\n<ul>\n<li>두번째 접근법 → 경제적 비용과 밸런스 고려</li>\n</ul>\n<p>점점 서버와 높은 용량의 메모리 가격이 내려가면서 압축 알고리즘에 지나친 에너지를 쏟을 필요가 없는 경우도 많다. 밸런스를 고려하는 것이 중요하다. </p>\n<h2 id=\"복수-서버로-확장---캐시로-해결-안되는-규모인-경우\" style=\"position:relative;\"><a href=\"#%EB%B3%B5%EC%88%98-%EC%84%9C%EB%B2%84%EB%A1%9C-%ED%99%95%EC%9E%A5---%EC%BA%90%EC%8B%9C%EB%A1%9C-%ED%95%B4%EA%B2%B0-%EC%95%88%EB%90%98%EB%8A%94-%EA%B7%9C%EB%AA%A8%EC%9D%B8-%EA%B2%BD%EC%9A%B0\" aria-label=\"복수 서버로 확장   캐시로 해결 안되는 규모인 경우 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>복수 서버로 확장 - 캐시로 해결 안되는 규모인 경우</h2>\n<p>현재 인프라의 구조가 프록시 ↔ WAS ↔ DB 인 경우에 다음과 같이 서버를 확장할 수 있다. </p>\n<ol>\n<li>\n<p>WAS 서버를 늘린다.</p>\n<ul>\n<li>CPU 부하를 낮추고 분산시키기 위해서이다.</li>\n<li>단순히 늘리면 된다.</li>\n</ul>\n</li>\n<li>\n<p>DB 서버를 늘린다.</p>\n<ul>\n<li>캐싱 용량을 늘리거나 효율을 높이고자 할 때 늘린다.</li>\n<li>하지만 I/O 분산에는 국소성을 고려해야하며 마냥 늘려서 좋은 것은 아니다.</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"대수만-늘려서-확정성-확보할-수-없다\" style=\"position:relative;\"><a href=\"#%EB%8C%80%EC%88%98%EB%A7%8C-%EB%8A%98%EB%A0%A4%EC%84%9C-%ED%99%95%EC%A0%95%EC%84%B1-%ED%99%95%EB%B3%B4%ED%95%A0-%EC%88%98-%EC%97%86%EB%8B%A4\" aria-label=\"대수만 늘려서 확정성 확보할 수 없다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>대수만 늘려서 확정성 확보할 수 없다.</h2>\n<ul>\n<li>\n<p>캐시 용량이 부족해서 DB 서버 대수를 확보했지만 부족한 캐싱 용량의 상황까지 그대로 복제될 수 있다.</p>\n<ul>\n<li>A 서버에서 조회하며 캐싱했는데 부족한 것이 B 서버에서도 동일하게 일어남</li>\n<li>어느정도 빨라질 수는 있겠지만 증설비용대비 성능향상은 좋지 않다.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"-io-부하-줄이기와-페이지-캐시\" style=\"position:relative;\"><a href=\"#-io-%EB%B6%80%ED%95%98-%EC%A4%84%EC%9D%B4%EA%B8%B0%EC%99%80-%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C\" aria-label=\" io 부하 줄이기와 페이지 캐시 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>+ I/O 부하 줄이기와 페이지 캐시</h2>\n<p>리눅스에서 sar 명령어로 메모리 상황을 확인했을 때 항상 메모리가 부족해보일수도 있다. 하지만 리눅스의 페이지 캐시 원리는 <code class=\"language-text\">리눅스는 가능한 남아있는 메모리를 페이지 캐시로 활용한다</code> 라는 것이다. 따라서 부팅 후 시간이 지날수록 sar의 <code class=\"language-text\">kbmemfree</code> 는 줄어들 수밖에 없다. </p>\n<h3 id=\"페이지-캐시에-의한-io-부하-경감-효과\" style=\"position:relative;\"><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C%EC%97%90-%EC%9D%98%ED%95%9C-io-%EB%B6%80%ED%95%98-%EA%B2%BD%EA%B0%90-%ED%9A%A8%EA%B3%BC\" aria-label=\"페이지 캐시에 의한 io 부하 경감 효과 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>페이지 캐시에 의한 I/O 부하 경감 효과</h3>\n<ul>\n<li>많은 데이터가 있는 상황에서 메모리를 증설하고 <code class=\"language-text\">sar -P</code> 로 확인해보면 <code class=\"language-text\">%iowait</code> 의 확연한 차이를 볼 수 있다.</li>\n<li>\n<p><code class=\"language-text\">sar -r</code> 를 사용하면 커널이 캐시를 확보하고 있는 정도를 확인할 수 있다. 커널이 확보하고 있는 캐시용량과 어플리케이션에서 다루는 데이터의 용량을 비교하여 데이터량이 더 많을 경우 메모리 증설을 검토하여 디스크 액세스를 줄인다.</p>\n<p><code class=\"language-text\">vmstat</code>을 사용하면 디스크 액세스 정도를 확인할 수 있다.   </p>\n</li>\n<li>메모리 증설이 어려운 경우 데이터 분할하여 각각 서버에 위치한다. → 캐시 올릴 데이터 비율이 올라가고 I/O 횟수가 줄어든다.</li>\n</ul>\n<h3 id=\"페이지-캐시는-한번의-read에서-시작된다\" style=\"position:relative;\"><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C%EB%8A%94-%ED%95%9C%EB%B2%88%EC%9D%98-read%EC%97%90%EC%84%9C-%EC%8B%9C%EC%9E%91%EB%90%9C%EB%8B%A4\" aria-label=\"페이지 캐시는 한번의 read에서 시작된다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>페이지 캐시는 한번의 read에서 시작된다.</h3>\n<ul>\n<li>캐싱하지 못한 데이터는 직접 디스크에서 읽는다. 서버를 재부팅한 경우 메모리의 캐시는 초기화 되므로 모든 액세스에 I/O를 발생시킨다.</li>\n<li>대규모 DB 서버인 경우 모든 DB 액세스마다 디스크 I/O가 발생해서 DB가 lock에 걸리는 경우도 많다.</li>\n<li>따라서 필요한 경우 필요데이터를 전체 한번 전체적으로 읽어 다시 캐싱하는 방법도 필요하다.</li>\n<li>I/O 바운드가 높은 서버인 경우 페이지 캐시가 최적화 되었는지 확인한다.</li>\n</ul>\n<br>\n<h2 id=\"강의10-국소성을-살리는-분산\" style=\"position:relative;\"><a href=\"#%EA%B0%95%EC%9D%9810-%EA%B5%AD%EC%86%8C%EC%84%B1%EC%9D%84-%EC%82%B4%EB%A6%AC%EB%8A%94-%EB%B6%84%EC%82%B0\" aria-label=\"강의10 국소성을 살리는 분산 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[강의10] 국소성을 살리는 분산</h2>\n<h2 id=\"국소성을-고려한-분산이란\" style=\"position:relative;\"><a href=\"#%EA%B5%AD%EC%86%8C%EC%84%B1%EC%9D%84-%EA%B3%A0%EB%A0%A4%ED%95%9C-%EB%B6%84%EC%82%B0%EC%9D%B4%EB%9E%80\" aria-label=\"국소성을 고려한 분산이란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>국소성을 고려한 분산이란</h2>\n<p>서버를 여러대 확장해서 캐시 용량을 늘리기 위해서는 국소성(locality)을 고려해서 분산시켜야한다. </p>\n<ul>\n<li>\n<p>DB의 경우 서비스 패턴과 처리방식에 따라 데이터 액세스 경향이 한쪽으로 치우친다.</p>\n<ul>\n<li>어떤 서비스 패턴이 엔트리 A에 많이 접근하고 다른 서비스는 테이블B에 많이 접근한다면 1, 2를 분산하여 한쪽에만 액세스 하도록 할 수 있다.</li>\n<li>이것을 고려하지 않으면 여전히 서버 1에서 두 패턴이 모두 일어나게 되므로 캐시를 위한 메모리 용량이 부족하게 된다.</li>\n<li>즉, 액세스 패턴을 고려하여 국소성을 적용한 분산을 하라!!</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"파티셔닝---국소성-분산1\" style=\"position:relative;\"><a href=\"#%ED%8C%8C%ED%8B%B0%EC%85%94%EB%8B%9D---%EA%B5%AD%EC%86%8C%EC%84%B1-%EB%B6%84%EC%82%B01\" aria-label=\"파티셔닝   국소성 분산1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>파티셔닝 - 국소성 분산1</h2>\n<p>한 대였던 DB를 여러대의 서버로 분할하는 방법이다. → 제일 간단한 분할 방법은 테이블 단위 분할</p>\n<ul>\n<li><strong>테이블 단위 분할</strong> - 같이 액세스 하는 경우가 많은 테이블을 같은 서버에 위치시키고 그 밖의 것들을 다른 서버에 위치</li>\n<li>\n<p><strong>테이블 데이터 분할 -</strong> 하나의 테이블을 여러 테이블로 분할</p>\n<ul>\n<li>예를 들어 책에 나온 예시로는 하나의 테이블을 앞 알파벳에 따라서 데이터를 분할함</li>\n<li>국소성이 올라가 캐싱이 잘됨</li>\n<li>단점: 분할이 너무 작게 된다면 데이터를 한번 병합해야 함</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"요청-패턴을-섬으로-분할---국소성-분산2\" style=\"position:relative;\"><a href=\"#%EC%9A%94%EC%B2%AD-%ED%8C%A8%ED%84%B4%EC%9D%84-%EC%84%AC%EC%9C%BC%EB%A1%9C-%EB%B6%84%ED%95%A0---%EA%B5%AD%EC%86%8C%EC%84%B1-%EB%B6%84%EC%82%B02\" aria-label=\"요청 패턴을 섬으로 분할   국소성 분산2 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>요청 패턴을 ‘섬’으로 분할 - 국소성 분산2</h2>\n<p>요청의 종류에 따라서 요청을 보내는 서버를 나누는 것이다. - 특이한 경우이기는 함</p>\n<p align=\"center\"><img width=\"85%\" src=\"https://user-images.githubusercontent.com/63405904/136984334-66cc4ba2-bb5a-4b92-aacd-1067c92f5765.png\"><br>이미지 출처: 대용량 서비스를 지탱하는 기술</p>\n<ul>\n<li>캐싱하기 쉬운 요청, 캐싱하기 어려운 요청을 처리하는 섬을 나눔 → 전자는 국소성으로 높은 캐시 적중률을 냄</li>\n</ul>\n<h2 id=\"페이지-캐시를-고려한-운용의-기본-원칙\" style=\"position:relative;\"><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C%EB%A5%BC-%EA%B3%A0%EB%A0%A4%ED%95%9C-%EC%9A%B4%EC%9A%A9%EC%9D%98-%EA%B8%B0%EB%B3%B8-%EC%9B%90%EC%B9%99\" aria-label=\"페이지 캐시를 고려한 운용의 기본 원칙 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>페이지 캐시를 고려한 운용의 기본 원칙</h2>\n<ol>\n<li>\n<p>OS를 가동한 직후에 서버를 투입하지 않는다 → 캐시가 쌓여있지 않기 때문이다. </p>\n<ul>\n<li>OS를 기동하고 자주 사용하는 DB의 파일을 한번 cat 하여 메모리에 올린다. 이후 로드밸런서에 편입한다.</li>\n</ul>\n</li>\n<li>성능 테스트를 할 경우 초기값은 버려야한다. → 최초 캐시가 최적화 되어 있지 않은 단계이므로 속도가 확연히 차이가 나게 된다. </li>\n</ol>\n<h2 id=\"-부하분산과-os의-동작원리\" style=\"position:relative;\"><a href=\"#-%EB%B6%80%ED%95%98%EB%B6%84%EC%82%B0%EA%B3%BC-os%EC%9D%98-%EB%8F%99%EC%9E%91%EC%9B%90%EB%A6%AC\" aria-label=\" 부하분산과 os의 동작원리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>+ 부하분산과 OS의 동작원리</h2>\n<ul>\n<li>OS 캐시, 멀티스레드나 멀티프로세스, 가상 메모리구조, 파일시스템 등과 같은 OS 지식이 있어야 부하분산을 잘 할 수 있음.</li>\n<li>요청 분배에는 LVS 사용법, MySQL 아파치와 같은 미들웨어 사용법 등이 있다.</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#%EA%B0%95%EC%9D%988-os-%EC%BA%90%EC%8B%9C-%EA%B5%AC%EC%A1%B0\">강의8 OS 캐시 구조</a></li>\n<li>\n<p><a href=\"#os%EC%9D%98-%EC%BA%90%EC%8B%9C-%EA%B5%AC%EC%A1%B0%EB%A5%BC-%EC%95%8C%EA%B3%A0-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EC%9E%91%EC%84%B1%ED%95%98%EA%B8%B0---%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C\">OS의 캐시 구조를 알고 애플리케이션 작성하기 - 페이지 캐시</a></p>\n<ul>\n<li><a href=\"#linuxx86-%ED%8E%98%EC%9D%B4%EC%A7%95-%EA%B5%AC%EC%A1%B0\">Linux(x86) 페이징 구조</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0\">가상 메모리 구조</a></p>\n<ul>\n<li><a href=\"#%EC%99%9C-%EA%B0%80%EC%83%81-%EC%A3%BC%EC%86%8C%EB%A5%BC-%EB%B0%98%ED%99%98%ED%95%A0%EA%B9%8C\">왜 가상 주소를 반환할까?</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#linux-%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C%EC%9D%98-%EC%9B%90%EB%A6%AC\">Linux 페이지 캐시의 원리</a></p>\n<ul>\n<li><a href=\"#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EA%B0%80-%EB%94%94%EC%8A%A4%ED%81%AC%EC%97%90%EC%84%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A5%BC-%EC%9D%BD%EC%96%B4%EB%82%B4%EB%8A%94-%EA%B3%BC%EC%A0%95\">프로세스가 디스크에서 데이터를 읽어내는 과정</a></li>\n<li><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C%EC%9D%98-%ED%9A%A8%EA%B3%BC\">페이지 캐시의 효과</a></li>\n</ul>\n</li>\n<li><a href=\"#vfs\">VFS</a></li>\n<li>\n<p><a href=\"#%EB%A6%AC%EB%88%85%EC%8A%A4%EB%8A%94-%ED%8E%98%EC%9D%B4%EC%A7%80-%EB%8B%A8%EC%9C%84%EB%A1%9C-%EB%94%94%EC%8A%A4%ED%81%AC%EB%A5%BC-%EC%BA%90%EC%8B%B1\">리눅스는 페이지 단위로 디스크를 캐싱</a></p>\n<ul>\n<li><a href=\"#%EC%99%9C-%ED%8C%8C%EC%9D%BC-%EC%BA%90%EC%8B%9C%EA%B0%80-%EC%95%84%EB%8B%88%EB%9D%BC-%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C%EC%9D%BC%EA%B9%8C-\">왜 파일 캐시가 아니라 페이지 캐시일까 ?</a></li>\n<li><a href=\"#lru\">LRU</a></li>\n<li><a href=\"#%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%BA%90%EC%8B%B1%EC%9D%B4-%EB%90%A0%EA%B9%8C\">어떻게 캐싱이 될까</a></li>\n</ul>\n</li>\n<li><a href=\"#%EB%A9%94%EB%AA%A8%EB%A6%AC%EA%B0%80-%EB%B9%84%EC%96%B4%EC%9E%88%EC%9C%BC%EB%A9%B4-%EC%BA%90%EC%8B%B1\">메모리가 비어있으면 캐싱</a></li>\n<li><a href=\"#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%8A%98%EB%A0%A4%EC%84%9C-io-%EB%B6%80%ED%95%98-%EC%A4%84%EC%9D%B4%EA%B8%B0\">메모리 늘려서 I/O 부하 줄이기</a></li>\n<li><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C%EB%8A%94-%ED%88%AC%EA%B3%BC%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%9E%91%EC%9A%A9\">페이지 캐시는 투과적으로 작용</a></li>\n<li><a href=\"#sar-%EB%AA%85%EB%A0%B9%EC%96%B4%EB%A1%9C-os-%EC%A7%80%ED%91%9C-%ED%99%95%EC%9D%B8%ED%95%98%EA%B8%B0\"><code class=\"language-text\">sar</code> 명령어로 os 지표 확인하기</a></li>\n<li><a href=\"#%EA%B0%95%EC%9D%989-io-%EB%B6%80%ED%95%98%EB%A5%BC-%EC%A4%84%EC%9D%B4%EB%8A%94-%EB%B0%A9%EB%B2%95\">강의9 I/O 부하를 줄이는 방법</a></li>\n<li><a href=\"#%EC%BA%90%EC%8B%9C%EB%A5%BC-%EC%A0%84%EC%A0%9C%EB%A1%9C-%ED%95%9C-io-%EC%A4%84%EC%9D%B4%EB%8A%94-%EB%B0%A9%EB%B2%95\">캐시를 전제로 한 I/O 줄이는 방법</a></li>\n<li><a href=\"#%EB%B3%B5%EC%88%98-%EC%84%9C%EB%B2%84%EB%A1%9C-%ED%99%95%EC%9E%A5---%EC%BA%90%EC%8B%9C%EB%A1%9C-%ED%95%B4%EA%B2%B0-%EC%95%88%EB%90%98%EB%8A%94-%EA%B7%9C%EB%AA%A8%EC%9D%B8-%EA%B2%BD%EC%9A%B0\">복수 서버로 확장 - 캐시로 해결 안되는 규모인 경우</a></li>\n<li><a href=\"#%EB%8C%80%EC%88%98%EB%A7%8C-%EB%8A%98%EB%A0%A4%EC%84%9C-%ED%99%95%EC%A0%95%EC%84%B1-%ED%99%95%EB%B3%B4%ED%95%A0-%EC%88%98-%EC%97%86%EB%8B%A4\">대수만 늘려서 확정성 확보할 수 없다.</a></li>\n<li>\n<p><a href=\"#-io-%EB%B6%80%ED%95%98-%EC%A4%84%EC%9D%B4%EA%B8%B0%EC%99%80-%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C\">+ I/O 부하 줄이기와 페이지 캐시</a></p>\n<ul>\n<li><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C%EC%97%90-%EC%9D%98%ED%95%9C-io-%EB%B6%80%ED%95%98-%EA%B2%BD%EA%B0%90-%ED%9A%A8%EA%B3%BC\">페이지 캐시에 의한 I/O 부하 경감 효과</a></li>\n<li><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C%EB%8A%94-%ED%95%9C%EB%B2%88%EC%9D%98-read%EC%97%90%EC%84%9C-%EC%8B%9C%EC%9E%91%EB%90%9C%EB%8B%A4\">페이지 캐시는 한번의 read에서 시작된다.</a></li>\n</ul>\n</li>\n<li><a href=\"#%EA%B0%95%EC%9D%9810-%EA%B5%AD%EC%86%8C%EC%84%B1%EC%9D%84-%EC%82%B4%EB%A6%AC%EB%8A%94-%EB%B6%84%EC%82%B0\">강의10 국소성을 살리는 분산</a></li>\n<li><a href=\"#%EA%B5%AD%EC%86%8C%EC%84%B1%EC%9D%84-%EA%B3%A0%EB%A0%A4%ED%95%9C-%EB%B6%84%EC%82%B0%EC%9D%B4%EB%9E%80\">국소성을 고려한 분산이란</a></li>\n<li><a href=\"#%ED%8C%8C%ED%8B%B0%EC%85%94%EB%8B%9D---%EA%B5%AD%EC%86%8C%EC%84%B1-%EB%B6%84%EC%82%B01\">파티셔닝 - 국소성 분산1</a></li>\n<li><a href=\"#%EC%9A%94%EC%B2%AD-%ED%8C%A8%ED%84%B4%EC%9D%84-%EC%84%AC%EC%9C%BC%EB%A1%9C-%EB%B6%84%ED%95%A0---%EA%B5%AD%EC%86%8C%EC%84%B1-%EB%B6%84%EC%82%B02\">요청 패턴을 ‘섬’으로 분할 - 국소성 분산2</a></li>\n<li><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C%EB%A5%BC-%EA%B3%A0%EB%A0%A4%ED%95%9C-%EC%9A%B4%EC%9A%A9%EC%9D%98-%EA%B8%B0%EB%B3%B8-%EC%9B%90%EC%B9%99\">페이지 캐시를 고려한 운용의 기본 원칙</a></li>\n<li><a href=\"#-%EB%B6%80%ED%95%98%EB%B6%84%EC%82%B0%EA%B3%BC-os%EC%9D%98-%EB%8F%99%EC%9E%91%EC%9B%90%EB%A6%AC\">+ 부하분산과 OS의 동작원리</a></li>\n</ul>\n</div>","frontmatter":{"date":"September 24, 2021","title":"대규모 서비스를 지탱하는 기술 - OS 캐시와 분산","categories":"웹 인프라 책","author":"코다","emoji":"📚"},"fields":{"slug":"/high-traffic-service_3/"}},"prev":{"id":"3bc20ab6-0d89-51b0-94a9-01a69ba97f70","html":"<blockquote>\n<p>다음은 웹 개발자를 위한 대규모 서비스를 지탱하는 기술을 읽고 정리한 내용입니다 🙌</p>\n</blockquote>\n<br>\n<ul>\n<li>검색엔진의 노하우를 알아두면 용도특화형 인덱스를 직접 만들어서 대규모 데이터에 대한 문제를 해결할 수 있다.</li>\n</ul>\n<br>\n<h2 id=\"강의24-전문-검색기술의-응용범위\" style=\"position:relative;\"><a href=\"#%EA%B0%95%EC%9D%9824-%EC%A0%84%EB%AC%B8-%EA%B2%80%EC%83%89%EA%B8%B0%EC%88%A0%EC%9D%98-%EC%9D%91%EC%9A%A9%EB%B2%94%EC%9C%84\" aria-label=\"강의24 전문 검색기술의 응용범위 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[강의24] 전문 검색기술의 응용범위</h2>\n<ul>\n<li>\n<p>키워드</p>\n<ul>\n<li>역 인덱스</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"전문-검색의-종류\" style=\"position:relative;\"><a href=\"#%EC%A0%84%EB%AC%B8-%EA%B2%80%EC%83%89%EC%9D%98-%EC%A2%85%EB%A5%98\" aria-label=\"전문 검색의 종류 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>전문 검색의 종류</h2>\n<h3 id=\"grep-형\" style=\"position:relative;\"><a href=\"#grep-%ED%98%95\" aria-label=\"grep 형 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>grep 형</h3>\n<ul>\n<li>전부 읽어가면서 검색하는 것</li>\n<li>시간이 오래 걸린다.</li>\n<li>즉시성이 좋다 → 문서가 갱신되더라도 바로 검색할 수 있으며 검색누락이 없다.</li>\n<li>병렬화 하기가 간단하다 → 분할해서 검색하기 편리하다</li>\n</ul>\n<h3 id=\"suffix-형\" style=\"position:relative;\"><a href=\"#suffix-%ED%98%95\" aria-label=\"suffix 형 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>suffix 형</h3>\n<ul>\n<li>검색 가능한 형태로 검색 대상 전문을 보유한다.</li>\n<li>구현이 어렵다.</li>\n</ul>\n<h3 id=\"역-인덱스형\" style=\"position:relative;\"><a href=\"#%EC%97%AD-%EC%9D%B8%EB%8D%B1%EC%8A%A4%ED%98%95\" aria-label=\"역 인덱스형 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>역 인덱스형</h3>\n<ul>\n<li>단어와 문서를 연관짓는 것</li>\n<li>문서와 별도로 역 인덱스를 만들어야 한다. → 즉 전처리가 필요하다. 즉시성이 떨어진다.</li>\n<li>인덱스를 압축함으로 컴팩트하게 가져갈 수 있다. 대규모화 하기 가 쉽다.</li>\n</ul>\n<br>\n<h2 id=\"강의26검색엔진의-내부구조\" style=\"position:relative;\"><a href=\"#%EA%B0%95%EC%9D%9826%EA%B2%80%EC%83%89%EC%97%94%EC%A7%84%EC%9D%98-%EB%82%B4%EB%B6%80%EA%B5%AC%EC%A1%B0\" aria-label=\"강의26검색엔진의 내부구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[강의26]검색엔진의 내부구조</h2>\n<h2 id=\"역-인덱스의-구조---dictionary--postings\" style=\"position:relative;\"><a href=\"#%EC%97%AD-%EC%9D%B8%EB%8D%B1%EC%8A%A4%EC%9D%98-%EA%B5%AC%EC%A1%B0---dictionary--postings\" aria-label=\"역 인덱스의 구조   dictionary  postings permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>역 인덱스의 구조 - Dictionary + Postings</h2>\n<ul>\n<li>어떠한 단어 (dictionary 형태)에서 연결되어 있는 문서(postings)를 바로 찾을 수 있는 것.</li>\n<li>Postings의 경우 문서 ID만을 공유하고 있기도 한데, 문서의 어느 위치에 출현하는지도 보유하기도 한다.</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#%EA%B0%95%EC%9D%9824-%EC%A0%84%EB%AC%B8-%EA%B2%80%EC%83%89%EA%B8%B0%EC%88%A0%EC%9D%98-%EC%9D%91%EC%9A%A9%EB%B2%94%EC%9C%84\">강의24 전문 검색기술의 응용범위</a></li>\n<li>\n<p><a href=\"#%EC%A0%84%EB%AC%B8-%EA%B2%80%EC%83%89%EC%9D%98-%EC%A2%85%EB%A5%98\">전문 검색의 종류</a></p>\n<ul>\n<li><a href=\"#grep-%ED%98%95\">grep 형</a></li>\n<li><a href=\"#suffix-%ED%98%95\">suffix 형</a></li>\n<li><a href=\"#%EC%97%AD-%EC%9D%B8%EB%8D%B1%EC%8A%A4%ED%98%95\">역 인덱스형</a></li>\n</ul>\n</li>\n<li><a href=\"#%EA%B0%95%EC%9D%9826%EA%B2%80%EC%83%89%EC%97%94%EC%A7%84%EC%9D%98-%EB%82%B4%EB%B6%80%EA%B5%AC%EC%A1%B0\">강의26검색엔진의 내부구조</a></li>\n<li><a href=\"#%EC%97%AD-%EC%9D%B8%EB%8D%B1%EC%8A%A4%EC%9D%98-%EA%B5%AC%EC%A1%B0---dictionary--postings\">역 인덱스의 구조 - Dictionary + Postings</a></li>\n</ul>\n</div>","frontmatter":{"date":"September 27, 2021","title":"대규모 서비스를 지탱하는 기술 - 전문 검색기술","categories":"웹 인프라 책","author":"코다","emoji":"📚"},"fields":{"slug":"/high-traffic-service_7/"}},"site":{"siteMetadata":{"siteUrl":"https://yjksw.github.io","comments":{"utterances":{"repo":"yjksw/yjksw.github.io"}}}}},"pageContext":{"slug":"/db-replication-binary-log/","nextSlug":"/high-traffic-service_3/","prevSlug":"/high-traffic-service_7/"}},"staticQueryHashes":["1073350324","2938748437"]}
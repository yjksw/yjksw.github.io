{"componentChunkName":"component---src-templates-blog-template-js","path":"/operating-system-3/","result":{"data":{"cur":{"id":"c8678391-1095-5db1-99f3-e36da5f03ed2","html":"<blockquote>\n<p>다음은 반효경 교수님의 ‘운영체제와 정보기술의 원리’ <em>CH4. 프로그램의 구조와 실행</em>를 읽고 정리한 내용입니다 🙌</p>\n</blockquote>\n<br>\n<br>\n<h2 id=\"-1-프로그램의-구조와-인터럽트\" style=\"position:relative;\"><a href=\"#-1-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EC%9D%98-%EA%B5%AC%EC%A1%B0%EC%99%80-%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8\" aria-label=\" 1 프로그램의 구조와 인터럽트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 1. 프로그램의 구조와 인터럽트</h2>\n<ul>\n<li>\n<p>CPU에서 프로그램 명령을 실행하기 위해서는 프로그램 명령을 담은 주소 영역이 메모리에 올라가야한다.</p>\n<ul>\n<li>주소 영역은 code(프로그램 함수들이 기계어로 변환되어 저장), data(전역 변수 등 프로그램이 사용하는 데이터 저장), stack(함수 복귀 주소 및 데이터 임시 저장)으로 구분된다.</li>\n<li>함수를 호출하여 새로운 함수 위치로 점프할 때 다시 돌아올 주소를 스택 영역에 저장한다.</li>\n</ul>\n</li>\n<li>\n<p>인터럽트 동작 원리도 함수의 호출과 비슷하다.</p>\n<ul>\n<li>인터럽트 발생시 실행중이던 명령어의 위치를 저장한다. 처리루틴 후 해당 주소로 돌아와서 수행을 이어간다.</li>\n<li>이 주소는 운영체제가 관리하는 PCB에 저장된다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-2-컴퓨터-시스템의-작동-개요\" style=\"position:relative;\"><a href=\"#-2-%EC%BB%B4%ED%93%A8%ED%84%B0-%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98-%EC%9E%91%EB%8F%99-%EA%B0%9C%EC%9A%94\" aria-label=\" 2 컴퓨터 시스템의 작동 개요 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 2. 컴퓨터 시스템의 작동 개요</h2>\n<ul>\n<li>CPU는 매 시점 특정 주소에 존재하는 명령을 읽어서 그대로 실행한다.</li>\n<li>\n<p>CPU가 실행해야할 명령의 메모리 위치는 Program Counter라는 레지스터에 저장된다. 주로 PC는 바로 다음 주소를 가리켜 코드가 순차적으로 실행되도록 한다.</p>\n<ul>\n<li>반복문이나 함수호출 등의 주소이동이 있는 경우는 해당 주소를 가리키게 된다.</li>\n</ul>\n</li>\n<li>프로그램 실행 중 입출력 등의 다른 연산이 이루어지면 각 장치의 컨트롤러와 로컬버퍼가 함게 동작하여 연산을 처리한다.</li>\n<li>만일 PC가 메모리의 운영체제 부분을 가리키고 있다면 CPU는 커널 모드에서 수행중이라고 한다.</li>\n<li>\n<p>CPU가 실행하는 명령은 일반명령과 특권명령을 나뉜다.</p>\n<ul>\n<li>일반명령은 모든 프로그램에서 수행하는 명령이다. 메모리 자료를 읽어서 CPU 연산 후 결과를 메모리에 쓴다.</li>\n<li>특권명령은 보안이 필요한 명령으로 각종 장치에 접근한다. 운영체제만 수행하며 모드비트로 구분된다.</li>\n</ul>\n</li>\n<li>\n<p>특권명령은 디스크파일접근, 화면출력 등을 수행할 수 있다. 사용자는 운영체제에 이 명령을 요청하여 대행하도록 system call을 한다.</p>\n<ul>\n<li>system call이 호출되면 CPU는 해당 장치의 컨트롤러에 요청을 하고 데이터가 해당 장치의 로컬 버퍼에 담기면 컨트롤러가 CPU에 인터럽트를 발생시켜 작업 완료를 알린다.</li>\n</ul>\n</li>\n<li>\n<p>CPU는 매 명령 수행 후 인터럽트 라인을 체크해 인터럽트가 일어났는지 확인한다.</p>\n<ul>\n<li>인터럽트 라인은 종류마다 다르다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-3-프로그램의-실행\" style=\"position:relative;\"><a href=\"#-3-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EC%9D%98-%EC%8B%A4%ED%96%89\" aria-label=\" 3 프로그램의 실행 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 3. 프로그램의 실행</h2>\n<ul>\n<li>\n<p>프로그램이 실행된다는 것은</p>\n<ol>\n<li>실행파일이 메모리에 적재된다. </li>\n<li>프로그램이 CPU를 할당받고 명령을 수행하고 있다. </li>\n</ol>\n<p>라는 두가지 의미를 가진다. </p>\n</li>\n<li>1번째 의미로 여러가지 프로그램이 메모리에 올라가 있을 수 있으니 <strong>여러 프로그램이 동시에 실행된다</strong>라고 할 수 있다.</li>\n<li>프로그램이 메모리에 적재될 때 일부분만 메모리에 나머지는 디스크에 내려가 있다.</li>\n<li>\n<p><strong>프로그램마다 독자적</strong>으로 주소공간을 가져 코드, 데이터, 스택 영역등으로 나뉜다.</p>\n<ul>\n<li>해당 공간을 가상메모리 virtual memory, 논리적 메모리 logical memory 라고 부른다.</li>\n</ul>\n</li>\n<li>\n<p>운영체제의 경우도 하나의 프로그램이다.</p>\n<ul>\n<li>각각의 코드, 데이터 스택주소 공간을 가지고 있다.</li>\n<li>하드웨어와 사용자의 중간이기 때문에 1) CPU, 메모리 자원을 관리하는 부분과 2) 사용자에게 편리한 인터페이스 제공하기위한 부분이 나뉜다.</li>\n<li>시스템 콜, 인터럽트 처리 부분도 포함된다.</li>\n</ul>\n</li>\n<li>\n<p>커널의 데이터 영역 - 각종 자원을 관리하는 자료구조가 저장</p>\n<ul>\n<li>CPU, 메모리 하드웨어 자원 관리</li>\n<li>\n<p>수행 중인 프로그램(소프트웨어) 관리 ⇒ 수행중인 프로그램을 프로세스라고 부른다.</p>\n<ul>\n<li>각 프로세스의 상태, CPU 사용 정보, 메모리 사용 정보 등을 담은 PCB를 둔다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>커널의 스택 영역 - 함수호출 시 복귀 주소를 저장</p>\n<ul>\n<li>\n<p>현재 수행 중인 프로세스마다 별도의 스택을 두어 관리</p>\n<ul>\n<li>프로세스마다 특권명령을 수행하려고 system call을 하고 system call 안에서 다른 함수를 호출할 경우 복귀 주소가 커널 내 주소가 되기 때문</li>\n<li>커널은 공유 코드이므로 각 사용자 프로그램이 커널 함수에 접근할 수 있으므로 일관성 유지를 위해 각 프로세스마다 스택을 따로 둠.</li>\n</ul>\n</li>\n<li>\n<p>요약</p>\n<ul>\n<li>사용자 프로그램 내에서 함수호출 시 해당 프로그램의 스택에 복귀 주소를 저장</li>\n<li>시스템 콜이나 인터럽트 발생으로 운영체제가 제어하면 프로그램 복귀 정보를 PCB에 저장</li>\n<li>\n<p>커널 내에서 이루어지는 함수호출은 각 프로세스의 커널스택에 복귀 정보를 저장</p>\n<ul>\n<li>직전에 수행중이던 프로세스의 커널스택에 저장</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-4-사용자-프로그램이-사용하는-함수\" style=\"position:relative;\"><a href=\"#-4-%EC%82%AC%EC%9A%A9%EC%9E%90-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EC%9D%B4-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%ED%95%A8%EC%88%98\" aria-label=\" 4 사용자 프로그램이 사용하는 함수 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 4. 사용자 프로그램이 사용하는 함수</h2>\n<ol>\n<li>\n<p>사용자정의 함수 - 프로그래머 본인이 작성</p>\n<ol>\n<li>코드 영역에 기계어 형태 </li>\n</ol>\n</li>\n<li>\n<p>라이브러리 함수 - 다른 누군가 미리 작성</p>\n<ol>\n<li>코드 영역에 기계어 형태 </li>\n</ol>\n</li>\n<li>\n<p>커널 함수 - 운영체제 커널의 코드에 정의된 함수 </p>\n<ul>\n<li>system call 함수, 인터럽트 처리 함수</li>\n<li>printf()와 같은 함수는 라이브러리 함수고 내부에서 system call을 한다.</li>\n<li>system call은 사용자가 운영체제 CPU를 넘겨서 실행하는 것이다.</li>\n<li>system call 또한 인터럽트 라인을 세팅하는 방법을 사용한다.</li>\n</ul>\n</li>\n</ol>\n<br>\n<h2 id=\"-5-인터럽트\" style=\"position:relative;\"><a href=\"#-5-%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8\" aria-label=\" 5 인터럽트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 5. 인터럽트</h2>\n<ul>\n<li>CPU는 대부분 명령을 순차적으로 진행한다. 매 명령마다 인터럽트 라인을 체크하고 발생했다면 제어권을 운영체제에게 넘겨 인터럽트 처리루틴에 따라 처리하고 다시 돌아온다.</li>\n<li>\n<p>인터럽트 처리 중 다른 인터럽트가 발생 한 경우</p>\n<ul>\n<li>원칙적으로 위 경우는 데이터 일관성을 위해 허용하지 않는다.</li>\n<li>예외적인 경우는 인터럽트 처리루틴 중 더 시급하거나 CPU가 당장 필요한 일이 발생한 경우이다.</li>\n</ul>\n</li>\n<li>인터럽트마다 중요도가 다르므로 중요도가 더 높은 인터럽트는 발생을 허용해 우선순위가 높은 인터럽트부터 처리하도록 한다.</li>\n</ul>\n<br>\n<h2 id=\"-6-시스템-콜\" style=\"position:relative;\"><a href=\"#-6-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%BD%9C\" aria-label=\" 6 시스템 콜 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 6. 시스템 콜</h2>\n<ul>\n<li>\n<p>시스템 콜은 프로세스가 가지고 있는 자신의 주소 공간 내의 호출이 아닌 커널 (다른 프로그램 주소 공간) 함수를 호출하는 것이다.</p>\n<ul>\n<li>이 경우 프로그램 자신이 스스로 인터럽트 라인을 세팅한다.</li>\n</ul>\n</li>\n<li>입출력 시스템 콜인 경우 CPU 명령 수행보다 많은 시간이 소요되므로 CPU가 그 시간동안 대기하고 있는 것은 자원의 낭비이다.</li>\n<li>또한 입출력을 요청한 프로그램에게 CPU를 다시 넘겨주는 것은 필요한 데이터가 없으므로 옳지 않다.</li>\n<li>따라서 한 프로그램이 입출력을 요청한다면 다른 프로그램에게 제어권을 넘겨주어 실행되도록 한다.</li>\n<li>\n<p>입출력 작업이 완료되었을 경우 인터럽트 처리루틴</p>\n<ul>\n<li>해당 인터럽트는 하드웨어 인터럽트이다.</li>\n<li>로컬버퍼의 내용을 메모리로 복사하고 해당 프로세스가 다시 CPU를 획득할 수 있는 권한을 준다.</li>\n<li>해당 프로세스가 작업 큐에 삽입되어 제어권이 돌아오게 한다.</li>\n</ul>\n</li>\n<li>\n<p>정리 - 프로세스가 CPU를 빼앗기는 경우 2가지</p>\n<ol>\n<li>타이머에 의한 인터럽트 발생 → 한 프로세스의 독점을 방지</li>\n<li>시스템 콜에 의한 인터럽트 발생 → 운영체제 함수 호출이 필요한 경우 실행 </li>\n</ol>\n</li>\n</ul>\n<br>\n<h2 id=\"-7-프로세스의-두-가지-실행-상태\" style=\"position:relative;\"><a href=\"#-7-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%9D%98-%EB%91%90-%EA%B0%80%EC%A7%80-%EC%8B%A4%ED%96%89-%EC%83%81%ED%83%9C\" aria-label=\" 7 프로세스의 두 가지 실행 상태 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 7. 프로세스의 두 가지 실행 상태</h2>\n<ul>\n<li>사용자 모드에서 실행상태 (user mode running) - 자신의 주소 공간의 코드 실행</li>\n<li>\n<p>커널 모드에서 실행상태 (kernel mode running) - 커널의 시스템 콜 함수 실행</p>\n<ul>\n<li>이 경우에도 커널이 실행 상태에 있다고 하는 것이 아니라 해당 프로세스가 실행상태에 있다고 한다.</li>\n<li>해당 프로세스가 필요한 일을 처리하는 것이기 때문이다.</li>\n<li><em>프로세스 A가 커널모드에 실행 중</em> 이라고 표현한다.</li>\n</ul>\n</li>\n<li>프로그램 실행이 끝날 때는 커널 모드로 프로그램을 종료한다.</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#-1-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EC%9D%98-%EA%B5%AC%EC%A1%B0%EC%99%80-%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8\">🌩 1. 프로그램의 구조와 인터럽트</a></li>\n<li><a href=\"#-2-%EC%BB%B4%ED%93%A8%ED%84%B0-%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98-%EC%9E%91%EB%8F%99-%EA%B0%9C%EC%9A%94\">🌩 2. 컴퓨터 시스템의 작동 개요</a></li>\n<li><a href=\"#-3-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EC%9D%98-%EC%8B%A4%ED%96%89\">🌩 3. 프로그램의 실행</a></li>\n<li><a href=\"#-4-%EC%82%AC%EC%9A%A9%EC%9E%90-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EC%9D%B4-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%ED%95%A8%EC%88%98\">🌩 4. 사용자 프로그램이 사용하는 함수</a></li>\n<li><a href=\"#-5-%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8\">🌩 5. 인터럽트</a></li>\n<li><a href=\"#-6-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%BD%9C\">🌩 6. 시스템 콜</a></li>\n<li><a href=\"#-7-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%9D%98-%EB%91%90-%EA%B0%80%EC%A7%80-%EC%8B%A4%ED%96%89-%EC%83%81%ED%83%9C\">🌩 7. 프로세스의 두 가지 실행 상태</a></li>\n</ul>\n</div>","excerpt":"다음은 반효경 교수님의 ‘운영체제와 정보기술의 원리’ CH4. 프로그램의 구조와 실행를 읽고 정리한 내용입니다 🙌 🌩 1. 프로그램의 구조와 인터럽트 CPU에서 프로그램 명령을 실행하기 위해서는 프로그램 명령을 담은 주소 영역이 메모리에 올라가야한다. 주소 영역은 code(프로그램 함수들이 기계어로 변환되어 저장), data(전역 변수 등 프로그램이 사용하는 데이터 저장), stack(함수 복귀 주소 및 데이터 임시 저장)으로 구분된다. 함수를 호출하여 새로운 함수 위치로 점프할 때 다시 돌아올 주소를 스택 영역에 저장한다. 인터럽트 동작 원리도 함수의 호출과 비슷하다. 인터럽트 발생시 실행중이던 명령어의 위치를 저장한다. 처리루틴 후 해당 주소로 돌아와서 수행을 이어간다. 이 주소는 운영체제가 관리하는 PCB에 저장된다. 🌩 2. 컴퓨터 시스템의 작동 개요 CPU는 매 시점 특정 주소에 존재하는 명령을 읽어서 그대로 실행한다. CPU가 실행해야할 명령의 메모리 위치는 Progra…","frontmatter":{"date":"October 12, 2021","title":"운영체제와 정보기술의 원리 - CH4. 프로그램의 구조와 실행","categories":"운영체제 책","author":"코다","emoji":"🧁"},"fields":{"slug":"/operating-system-3/"}},"next":{"id":"0515d110-b29d-5c41-a700-b62f2f2aee0f","html":"<blockquote>\n<p>다음은 반효경 교수님의 ‘운영체제와 정보기술의 원리’ <em>CH3. 컴퓨터 시스템의 동작원리</em>를 읽고 정리한 내용입니다 🙌</p>\n</blockquote>\n<br>\n<br>\n<h2 id=\"-1-컴퓨터-시스템의-구조\" style=\"position:relative;\"><a href=\"#-1-%EC%BB%B4%ED%93%A8%ED%84%B0-%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98-%EA%B5%AC%EC%A1%B0\" aria-label=\" 1 컴퓨터 시스템의 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 1. 컴퓨터 시스템의 구조</h2>\n<ul>\n<li>내부 장치 - CPU, 메모리</li>\n<li>\n<p>외부 장치 - 디스크, 키보드, 마우스, 모니터, 네트워크 장치 등등</p>\n<ul>\n<li>입출력장치라고 한다.</li>\n<li>각 하드웨어 장치를 각각의 컨트롤러가 제어한다.</li>\n</ul>\n</li>\n<li>\n<p><strong>컴퓨터는 외부장치에서 내부장치로 데이터를 읽어 연산한 후 결과를 외부장치로 내보내는 방식으로 동작한다.</strong></p>\n<ul>\n<li>input - 내부로 들어오는 것</li>\n<li>output - 외부로 내보내는 것</li>\n</ul>\n</li>\n<li>여러 프로그램을 동시에 수행할 수 있도록 하는 것이 운영체제이기 때문에 항상 메모리에 상주한다.</li>\n<li>전체가 상주하기엔 너무 낭비이기 때문에 꼭 필요한 부분만 항상 메모리에 상주하고 그 부분을 <strong>커널(kernel)</strong>이라고 한다.</li>\n</ul>\n<br>\n<h2 id=\"-2-cpu-연산과-io-연산\" style=\"position:relative;\"><a href=\"#-2-cpu-%EC%97%B0%EC%82%B0%EA%B3%BC-io-%EC%97%B0%EC%82%B0\" aria-label=\" 2 cpu 연산과 io 연산 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 2. CPU 연산과 I/O 연산</h2>\n<ul>\n<li>\n<p>I/O 연산들은 <strong>입출력 컨트롤러</strong>가 담당하고 컴퓨터 내부의 연산은 <strong>메인 CPU</strong>가 담당한다.</p>\n<ul>\n<li>입출력 장치와 메인 CPU는 동시 수행이 가능하다.</li>\n</ul>\n</li>\n<li>각 장치마다 들어오고 나가는 데이터를 로컬버퍼(local buffer)라는 작은 메모리에 저장한다.</li>\n<li>컨트롤러가 로컬버퍼로 읽어오는 일을 담당한다. 버퍼에 데이터가 다 들어왔으면 컨트롤러가 CPU에게 인터럽트로 알린다.</li>\n<li>\n<p>CPU는 매 시점 메모리에서 명령(instruction)을 하나씩 읽어서 수행하는데, 옆에 인터럽트 라인(interrupt line)이 있어서 인터럽트 신호가 중간에 들어오면 작업을 멈추고 인터럽트 작업을 먼저 처리한다.</p>\n<ul>\n<li>즉, 매 명령 수행마다 인터럽트 발생 여부를 확인한다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-3-인터럽트의-일반적-기능\" style=\"position:relative;\"><a href=\"#-3-%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8%EC%9D%98-%EC%9D%BC%EB%B0%98%EC%A0%81-%EA%B8%B0%EB%8A%A5\" aria-label=\" 3 인터럽트의 일반적 기능 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 3. 인터럽트의 일반적 기능</h2>\n<ul>\n<li>\n<p>운영체제에는 인터럽트가 들어왔을때 따라야하는 인터럽트 루틴이 저장되어 있다.</p>\n<ul>\n<li>각각의 인터럽트에 따라서 다르며 운영체제 개발자가 미리 구현하여 커널에 포함해둔다.</li>\n</ul>\n</li>\n<li>\n<p>디스크 컨트롤러의 인터럽트 루틴에서 수행하는 일</p>\n<ul>\n<li>디스크의 로컬버퍼에 있는 내용을 사용자 프로그램 메모리로 전달하고 프로그램의 다음 명령을 수행할 수 있도록 표시</li>\n</ul>\n</li>\n<li>\n<p><strong>하드웨어 인터럽트</strong> - 컨트롤러 등 하드웨어 장치가 CPU의 인터럽트 라인을 세팅 (통상적인 인터럽트)</p>\n<ul>\n<li>\n<p>CPU는 인터럽트가 발생하면 인터럽트 벡터(interrupt vector)에서 인터럽트 처리를 위한 루틴 코드를 커널에서 찾는다.</p>\n<ul>\n<li>인터럽트 종류 번호에 따른 처리 코드가 위치한 부분을 가리키는 자료구조이다.</li>\n<li>실제 처리 코드는 인터럽트 처리 루틴(interrupt service routine) 또는 인터럽트 핸들러(interrupt handler)라고 불리는 곳에 정의된다.</li>\n</ul>\n</li>\n<li>CPU가 인터럽트 처리 후 돌아갈 위치를 알기 위해 수행중이던 작업을 저장하는 장소를 운영체제가 별도로 가지고 있다.</li>\n</ul>\n</li>\n<li>\n<p><strong>소프트웨어 인터럽트</strong> - 소프트웨어가 세팅</p>\n<ul>\n<li>\n<p>트랩(trap)이라는 용어로 불리며 예외상황(exception)과 시스템 콜(system call)이 있다.</p>\n<ul>\n<li>예외상황 - 0으로 나누거나, 메모리 영역 바깥에 접근하려는 시도 등</li>\n<li>시스템 콜 - 운영체제에 서비스를 요청하는 경우로 화면출력, 키보드 입력 등의 커널 코드를 호출하여 CPU 제어권을 넘겨야하는 경우</li>\n</ul>\n</li>\n<li>프로그램 코드가 인터럽트 라인을 세팅하는 명령을 실행하여 인터럽트를 발생시키고 CPU의 제어권을 운영체제에 넘기는 것이다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-4-인터럽트-핸들링\" style=\"position:relative;\"><a href=\"#-4-%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8-%ED%95%B8%EB%93%A4%EB%A7%81\" aria-label=\" 4 인터럽트 핸들링 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 4. 인터럽트 핸들링</h2>\n<p>인터럽트 발생한 후 처리해야할 절차를 의미한다. </p>\n<ul>\n<li>\n<p>현재 진행중이던 프로그램의 상태를 저장한다.</p>\n<ul>\n<li>실행 중이던 명령어 메모리 주소 및 부가정보 등등</li>\n<li>CPU에서 명령을 실행할 때 CPU 내부의 임시기억장치 레지스터의 데이터를 사용하는 데 이 값들을 미리 저장함</li>\n<li>프로그램을 관리하는 PCB에 현재 프로그램의 실행 상태를 저장하고 CPU의 제어권이 넘어간다.</li>\n<li>다시 실행될 경우 PCB에서 상태를 복원하고 실행을 이어한다.</li>\n</ul>\n</li>\n<li>오늘날은 운영체제(커널)이 인터럽트가 발생할 때만 실행된다. 인터럽트가 발생하지 않으면 사용자 프로그램이 CPU를 계속 점유한다.</li>\n</ul>\n<br>\n<h2 id=\"-5-입출력-구조\" style=\"position:relative;\"><a href=\"#-5-%EC%9E%85%EC%B6%9C%EB%A0%A5-%EA%B5%AC%EC%A1%B0\" aria-label=\" 5 입출력 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 5. 입출력 구조</h2>\n<p>컴퓨터 시스템이 외부 입출력 장치들과 데이터를 주고받는 것을 말한다. </p>\n<h3 id=\"동기식-입출력-vs-비동기식-입출력\" style=\"position:relative;\"><a href=\"#%EB%8F%99%EA%B8%B0%EC%8B%9D-%EC%9E%85%EC%B6%9C%EB%A0%A5-vs-%EB%B9%84%EB%8F%99%EA%B8%B0%EC%8B%9D-%EC%9E%85%EC%B6%9C%EB%A0%A5\" aria-label=\"동기식 입출력 vs 비동기식 입출력 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>동기식 입출력 vs. 비동기식 입출력</h3>\n<ul>\n<li>\n<p>동기식 입출력 (Synchronous I/O) - 어떤 프로그램이 입출력을 요청했을 때 입출력 작업이 완료해야 해당 프로그램의 다음 작업을 할 수 있는 것.</p>\n<ul>\n<li>\n<p>입출력이 완료 되어야 인터럽트를 통해 CPU에게 알려 제어권이 다시 프로그램에게 넘어간다. 따라서 CPU는 입출력 연산이 끝날 때까지 인터럽트를 기다리며 자원을 낭비한다.</p>\n<ul>\n<li>CPU 연산은 빠르지만 입출력 연산은 느리기 때문에 그동안 CPU를 사용하지 못하는 것은 자원의 낭비이다.</li>\n<li>또한 한번에 하나의 입출력만 수행될 수 있어 비효율적이다.</li>\n</ul>\n</li>\n<li>\n<p>따라서 주로 그 동안 다른 프로그램에게 CPU를 할당하고 이전에 입출력 연산중인 프로그램에는 CPU를 할당하지 않는다.</p>\n<ul>\n<li><strong>이것을 관리하기 위해 입출력 중인 프로그램을 blocked state로 전환시켜 CPU를 할당하지 않도록  관리한다.</strong></li>\n</ul>\n</li>\n<li>\n<p>동기식으로 입출력이 연산되면 동기화가 자동으로 이루어진다. 하지만 그 사이 다른 프로그램이 CPU에 실행되면 동일한 데이터를 입출력할 때 결과가 틀어진다.</p>\n<ul>\n<li>해결하기 위해 입출력 요청을 순서대로 실행하기 위한 큐(queue)가 장치별로 있어서 동기화한다.</li>\n<li>입출력 연산이 끝나면 인터럽트로 CPU에 알리면 인터럽트 처리루틴에 따라서 해당 프로그램이 CPU를 할당받을 수 있도록 blocked state에서 해제시킨다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>비동기식 입출력 (asynchronous I/O) - CPU 제어권을 입출력 연산을 호출한 프로그램에게 바로 다시 부여하는 것</p>\n<ul>\n<li>입출력 데이터와 상관없이 다음 명령이 수행될 수 있는 경우는 입출력 연산과 상관없이 바로 수행하고 결과가 필요한 연산일 경우에만 기다렸다가 수행한다.</li>\n<li>쓰기 작업인 경우 다음 명령어 수행이 가능하므로 비동기식 입출력이 사용될 수 있다.</li>\n<li>입출력 연산이 완료되면 인터럽트로 알리고 그때부터 CPU는 읽어온 데이터를 필요로 하는 명령어를 수행한다.</li>\n</ul>\n</li>\n<li>\n<p>입출력을 요청할 때, 완료했을 때 두번 인터럽트가 발생한다.</p>\n<ul>\n<li>요청할 때 인터럽트 처리루틴 - 진행중이던 프로세스의 상태를 저장하고 해당 컨트롤러에 입출력 요청을 한다. 해당 프로세스를 blocked state로 바꾸고 CPU를 다른 프로세스에게 할당한다.</li>\n<li>완료했을 때 인터럽트 처리루틴 - 진행중이던 프로세스의 상태를 저장하고 (디스크 입출력인 경우) 로컬 버퍼의 데이터를 메모리 영역으로 읽어온다. 해당 프로세스의 blocked state를 해제하고 CPU에 할당될 수 있도록 한다.</li>\n</ul>\n</li>\n<li>일반적으로는 동기식 입출력을 사용하며 동기화를 통해 queue를 사용한다.</li>\n</ul>\n<br>\n<h2 id=\"-6-dma\" style=\"position:relative;\"><a href=\"#-6-dma\" aria-label=\" 6 dma permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 6. DMA</h2>\n<ul>\n<li>메모리는 본래 CPU에서만 접근할 수 있는데 이렇다면 메모리 접근 연산이 모두 CPU의 인터럽트를 통해서 이루어지면서 CPU 작업이 중단되어 효율성이 떨어지는 문제가 발생한다.</li>\n<li>\n<p>DMA (Direct Memory Access) - 위 문제를 해결하기 위한 컨트롤러로 메모리에 접근할 수 있는 장치</p>\n<ul>\n<li>로컬버퍼에서 데이터를 읽어오는 작업을 DMA가 CPU 대신 대행하여 CPU가 작업을 멈출 필요가 없다.</li>\n<li>DMA는 바이트 단위가 아니라 블록(block)이라는 큰 단위로 정보를 메모리로 읽어온다.</li>\n<li>작업을 완료하면 CPU에 인터럽트로 알려준다.</li>\n<li>CPU에 발생하는 인터럽트 빈도를 줄여 더 효율적으로 작업을 처리할 수 있도록 한다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-7-저장장치의-구조\" style=\"position:relative;\"><a href=\"#-7-%EC%A0%80%EC%9E%A5%EC%9E%A5%EC%B9%98%EC%9D%98-%EA%B5%AC%EC%A1%B0\" aria-label=\" 7 저장장치의 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 7. 저장장치의 구조</h2>\n<ul>\n<li>\n<p>주기억장치</p>\n<ul>\n<li>메모리라고 부르며 휘발성이다.</li>\n<li>RAM을 매체로 사용하는 경우가 대부분이다.</li>\n</ul>\n</li>\n<li>\n<p>보조기억장치</p>\n<ul>\n<li>비휘발성이며</li>\n<li>마크네틱 디스크를 주로 사용한다.</li>\n</ul>\n</li>\n<li>\n<p>보조기억장치의 용도</p>\n<ol>\n<li>전원이 나가도 유지해야할 파일 시스템용 (file system)</li>\n<li>\n<p>메모리의 연장 공간인 스왑 영역 (swap area)</p>\n<ul>\n<li>운영체제는 당장 필요한 부분을 메모리에 올려놓고, 그렇지 않은 부분을 디스크의 스왑 영역에 내려놓는다 ⇒ swap out</li>\n<li>스왑 영역에 있는 부분을 필요할 때 다시 메모리 영역으로 가져온다 ⇒ swap in</li>\n<li>스왑 영역은 프로그램이 실행될 때 내용을 저장했다가 프로그램 종료될 때 삭제하는 메모리의 연장 공간이다.</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<br>\n<h2 id=\"-8-저장장치의-계층-구조\" style=\"position:relative;\"><a href=\"#-8-%EC%A0%80%EC%9E%A5%EC%9E%A5%EC%B9%98%EC%9D%98-%EA%B3%84%EC%B8%B5-%EA%B5%AC%EC%A1%B0\" aria-label=\" 8 저장장치의 계층 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 8. 저장장치의 계층 구조</h2>\n<ul>\n<li>\n<p>primary 저장장치는 작고 빠르지만 비싸다.</p>\n<ul>\n<li>레지스터 → 캐시 메모리 → 메모리</li>\n<li>용량이 적지만 필요한 것만을 올리면서 용량이 큰 저장장치를 가지고 있는 것과 마찬가지로 성능효과를 낼 수 있다.</li>\n</ul>\n</li>\n<li>\n<p>secondary 저장장치는 크고 느리지만 싸다.</p>\n<ul>\n<li>마그네틱 디스크 → 광디스크 → 마그네틱 테이프</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-9-하드웨어의-보안\" style=\"position:relative;\"><a href=\"#-9-%ED%95%98%EB%93%9C%EC%9B%A8%EC%96%B4%EC%9D%98-%EB%B3%B4%EC%95%88\" aria-label=\" 9 하드웨어의 보안 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 9. 하드웨어의 보안</h2>\n<ul>\n<li>운영체제에서는 여러 프로그램이 동시에 실행되는 다중 프로그래밍 환경에서 동작하기 때문에 다른 프로그램을 방해하거나 충돌하지 않도록 하드웨어적인 보안유지가 필요하다.</li>\n<li>\n<p>이것을 위해 운영체제는 <strong>1) 커널모드</strong>와 <strong>2) 사용자모드</strong> 두 가지를 지원한다.</p>\n<ul>\n<li>커널모드는 운영체제가 CPU의 제어권을 가지고 운영체제 코드를 실행하는 것이다.</li>\n<li>중요정보에 접근해 위험한 상황을 초래할 수 있는 연산은 커널모드에서만 실행되도록 한다.</li>\n<li>일반 사용자 프로그램은 시스템에 위험한 연산을 하지 못하도록 통제한다.</li>\n</ul>\n</li>\n<li>\n<p>일반 사용자가 운영체제 내부의 코드를 실행하지 못하도록 하드웨어적인 지원을 한다.</p>\n<ul>\n<li>CPU 내부에 mode bit 를 두어 사용자 프로그램을  통제한다.</li>\n<li>mode bit = 0 ⇒ 커널모드이므로 모든 명령 수행 가능</li>\n<li>mode bit = 1 ⇒ 사용자모드 이므로 제한된 명령 수행 가능</li>\n<li>사용자 프로그램 시 모드 비트를 1로 세팅해 넘겨준다. 만일 사용자 프로그램에서 제한된 명령을 수행하고자 할 때는 시스템 콜을 통해서 운영체제에 위임하여 해당 명령을 하도록 요청한다.</li>\n<li>인터럽트 발생시에는 모드 비트가 자동으로 0으로 세팅되며 요청이 끝나면 다시 1로 세팅된다.</li>\n<li>모드 비트 0일때만 수행가능한 명령을 <strong>특권명령</strong>이라고 한다.</li>\n</ul>\n</li>\n<li>\n<p>각종 장치에서 특권 명령</p>\n<ul>\n<li>디스크에 저장된 파일에 자유롭게 접근하여 문제가 일어나지 않도록 모든 임출력 명령은 특권명령 규정을 사용한다.</li>\n<li>사용자 프로그램이 입출력을 하고 싶으면 system call로 운영체제에 요청을 한다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-10-메모리-보안\" style=\"position:relative;\"><a href=\"#-10-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%B3%B4%EC%95%88\" aria-label=\" 10 메모리 보안 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 10. 메모리 보안</h2>\n<ul>\n<li>\n<p>여러 프로그램이 메모리에 한꺼번에 올라가서 실행되기 때문에 메모리도 보안이 필요하다.</p>\n<ul>\n<li>사용자 프로그램에서 다른 프로그램의 메모리에 잘못 접근해서 변경할 수 있다.</li>\n<li>인터러트 벡터와 인터럽트 처리루틴이 있는 곳을 변경하여 보안성이 침해될 수 있다.</li>\n</ul>\n</li>\n<li>\n<p>메모리 보호를 위해 2가지 레지스터를 사용한다.</p>\n<ul>\n<li>\n<p>기준 레지스터 (base register)</p>\n<ul>\n<li>해당 프로그램이 접근할 수 있는 가장 작은 주소</li>\n</ul>\n</li>\n<li>\n<p>한계 레지스터 (limit register)</p>\n<ul>\n<li>기준 레지스터로부터 접근할 수 있는 메모리 범위</li>\n</ul>\n</li>\n<li>이 두 범위를 넘어가면 소프트웨어적인 인터럽트로 예외가 발생한다.</li>\n<li><strong>프로그램이 메모리의 한 영역에 연속적으로 위치하는 경우에만 가능한 메모리 관리 기법이다.</strong></li>\n<li>메모리를 페이징 할 경우 다른 메모리 보호 기법이 필요하다.</li>\n</ul>\n</li>\n<li>메모리 접근 연산은 특권명령이 아니지만 두 레지스터 값을 지정하는 것은 특권명령이다.</li>\n<li>입출력 연산은 모두 특권 명령이나 메모리 연산은 가능한 범위안에서는 사용자 모드에서 연산할 수 있다.</li>\n</ul>\n<br>\n<h2 id=\"-11-cpu-보호\" style=\"position:relative;\"><a href=\"#-11-cpu-%EB%B3%B4%ED%98%B8\" aria-label=\" 11 cpu 보호 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 11. CPU 보호</h2>\n<ul>\n<li>CPU가 하나의 프로그램에 독점되는 것을 막기 위해 타이머라는 하드웨어를 사용한다.</li>\n<li>CPU는 일정시간이 지나면 인터럽트를 발생시켜 운영체제가 CPU 제어하도록 하여 CPU를 다른 프로그램에게 이양한다.</li>\n<li>타이머는 일정 시간 단위로 세팅되어 매 클럭마다 1씩 감소하며 0이 되면 인터럽트가 발생한다.</li>\n<li>타이머 값 세팅은 load timer 명령이며 특권 명령이다.</li>\n<li>타이머를 통해서 시분할 시스템에서 현재 시간을 계산하기도 한다.</li>\n</ul>\n<br>\n<h2 id=\"-12-시스템-콜을-이용한-입출력-실행\" style=\"position:relative;\"><a href=\"#-12-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%BD%9C%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%9E%85%EC%B6%9C%EB%A0%A5-%EC%8B%A4%ED%96%89\" aria-label=\" 12 시스템 콜을 이용한 입출력 실행 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 12. 시스템 콜을 이용한 입출력 실행</h2>\n<ul>\n<li>디스크 파일 입출력, 키보드입출력 등은 모두 특권명령인 입출력 명령이다.</li>\n<li>운영체제의 system call이라는 서비스를 이용하여 입출력 명령을 대신 요쳥해야한다.</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#-1-%EC%BB%B4%ED%93%A8%ED%84%B0-%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98-%EA%B5%AC%EC%A1%B0\">🌩 1. 컴퓨터 시스템의 구조</a></li>\n<li><a href=\"#-2-cpu-%EC%97%B0%EC%82%B0%EA%B3%BC-io-%EC%97%B0%EC%82%B0\">🌩 2. CPU 연산과 I/O 연산</a></li>\n<li><a href=\"#-3-%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8%EC%9D%98-%EC%9D%BC%EB%B0%98%EC%A0%81-%EA%B8%B0%EB%8A%A5\">🌩 3. 인터럽트의 일반적 기능</a></li>\n<li><a href=\"#-4-%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8-%ED%95%B8%EB%93%A4%EB%A7%81\">🌩 4. 인터럽트 핸들링</a></li>\n<li>\n<p><a href=\"#-5-%EC%9E%85%EC%B6%9C%EB%A0%A5-%EA%B5%AC%EC%A1%B0\">🌩 5. 입출력 구조</a></p>\n<ul>\n<li><a href=\"#%EB%8F%99%EA%B8%B0%EC%8B%9D-%EC%9E%85%EC%B6%9C%EB%A0%A5-vs-%EB%B9%84%EB%8F%99%EA%B8%B0%EC%8B%9D-%EC%9E%85%EC%B6%9C%EB%A0%A5\">동기식 입출력 vs. 비동기식 입출력</a></li>\n</ul>\n</li>\n<li><a href=\"#-6-dma\">🌩 6. DMA</a></li>\n<li><a href=\"#-7-%EC%A0%80%EC%9E%A5%EC%9E%A5%EC%B9%98%EC%9D%98-%EA%B5%AC%EC%A1%B0\">🌩 7. 저장장치의 구조</a></li>\n<li><a href=\"#-8-%EC%A0%80%EC%9E%A5%EC%9E%A5%EC%B9%98%EC%9D%98-%EA%B3%84%EC%B8%B5-%EA%B5%AC%EC%A1%B0\">🌩 8. 저장장치의 계층 구조</a></li>\n<li><a href=\"#-9-%ED%95%98%EB%93%9C%EC%9B%A8%EC%96%B4%EC%9D%98-%EB%B3%B4%EC%95%88\">🌩 9. 하드웨어의 보안</a></li>\n<li><a href=\"#-10-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%B3%B4%EC%95%88\">🌩 10. 메모리 보안</a></li>\n<li><a href=\"#-11-cpu-%EB%B3%B4%ED%98%B8\">🌩 11. CPU 보호</a></li>\n<li><a href=\"#-12-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%BD%9C%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%9E%85%EC%B6%9C%EB%A0%A5-%EC%8B%A4%ED%96%89\">🌩 12. 시스템 콜을 이용한 입출력 실행</a></li>\n</ul>\n</div>","frontmatter":{"date":"October 11, 2021","title":"운영체제와 정보기술의 원리 - CH3. 컴퓨터 시스템의 동작원리","categories":"운영체제 책","author":"코다","emoji":"🧁"},"fields":{"slug":"/operating-system-2/"}},"prev":{"id":"729d1153-237f-5fde-a73b-e4781e4d31d3","html":"<blockquote>\n<p>다음은 반효경 교수님의 ‘운영체제와 정보기술의 원리’ <em>CH5. 프로세스 관리</em>를 읽고 정리한 내용입니다 🙌</p>\n</blockquote>\n<br>\n<br>\n<h2 id=\"-1-프로세스의-개념\" style=\"position:relative;\"><a href=\"#-1-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%9D%98-%EA%B0%9C%EB%85%90\" aria-label=\" 1 프로세스의 개념 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 1. 프로세스의 개념</h2>\n<ul>\n<li><strong>프로세스란 실행 중인 프로그램</strong>이다.</li>\n<li>프로세스는 CPU를 획득해서 코드를 수행하고 CPU를 반환하고 입출력 작업을 수행하기도 한다.</li>\n<li>\n<p>프로세스 문맥 (context) - 프로세스가 현재 어떤 상태에서 수행되고 있는 규명하기 위해 필요한 정보</p>\n<ul>\n<li>여러 프로세스가 CPU를 사용하면서 중간에 CPU를 다른 프로세스에게 넘겨야 한다.</li>\n<li>이때 다시 이어서하기 위한 필요 정보가 있는데 그것을 <strong>프로세스 문맥</strong>이라고 한다.</li>\n<li>프로세스의 주소 공간, 레지스터의 값, 시스템 콜을 통해 커널에서 수행한 일의 상태, 프로세스에 대해 커널이 관리하고 있는 여러 정보들을 포함한다.</li>\n</ul>\n</li>\n<li>\n<p>프로세스 문맥은 3가지로 나뉜다.</p>\n<ol>\n<li>\n<p>하드웨어 문맥</p>\n<ol>\n<li>CPU의 수행 상태를 나타낸다. </li>\n<li>프로그램 카운터 값, 각종 레지스터에 저장하고 있는 값들이다. </li>\n</ol>\n</li>\n<li>\n<p>프로세스의 주소 공간</p>\n<ol>\n<li>코드, 데이터, 스택으로 이루어진 프로세스의 독자적인 주소 공간이다. </li>\n</ol>\n</li>\n<li>\n<p>커널상의 문맥 </p>\n<ol>\n<li>PCB 와 커널스택이 프로세스에 대한 커널에 위치하는 자료구조이다. </li>\n</ol>\n</li>\n</ol>\n</li>\n</ul>\n<br>\n<h2 id=\"-2-프로세스의-상태\" style=\"position:relative;\"><a href=\"#-2-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%9D%98-%EC%83%81%ED%83%9C\" aria-label=\" 2 프로세스의 상태 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 2. 프로세스의 상태</h2>\n<ul>\n<li><strong>실행(running), 준비(ready), 봉쇄(blocked, wait, sleep)</strong></li>\n<li>\n<p>실행 - 프로세스가 CPU를 봉하고 기계어 명령을 실행하고 있는 상태</p>\n<ul>\n<li>실제로 실행 상태에 있는 프로세스는 매 시점 하나이다.</li>\n</ul>\n</li>\n<li>준비 - 프로세스가 CPU만 보유하면 명령을 실행할 수 있지만 CPU를 획득하지 못한 상태</li>\n<li>\n<p>봉쇄 - CPU를 할당 받더라도 명령을 실행할 수 없는 프로세스의 상태</p>\n<ul>\n<li>입출력 작업이 진행 중인 경우</li>\n</ul>\n</li>\n<li>프로세스의 상태를 나누는 이유는 컴퓨터의 자원을 효율적으로 관리하기 위해서다.</li>\n<li>\n<p>이외에도 <strong>시작과 종료</strong> 상태가 있다.</p>\n<ul>\n<li>시작 - 프로세스에 대한 자료구조는 생성 되었지만 메모리 획득을 승인받지 못한 상태</li>\n<li>종료 - 프로세스가 종료되었으나 운영체제가 관련된 자료구조를 완전히 정리하지 못한 상태</li>\n</ul>\n</li>\n<li>프로세스는 앞의 상태 중 하나에 머물러 있으며, 시간의 흐름에 따라서 변한다.</li>\n</ul>\n<h3 id=\"프로세스의-상태-흐름\" style=\"position:relative;\"><a href=\"#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%9D%98-%EC%83%81%ED%83%9C-%ED%9D%90%EB%A6%84\" aria-label=\"프로세스의 상태 흐름 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>프로세스의 상태 흐름</h3>\n<ul>\n<li>\n<p>프로세스의 문맥이 교환되는 것을 Context switching이라고 한다.</p>\n<ul>\n<li>한 프로세스가 진행 중일 때 타이머 인터럽트가 발생한다.</li>\n<li>타이머 인터럽트 처리루틴에 따라서 현재 진행중이던 프로세스의 문맥을 저장하고 준비 상태의 프로세스 중 하나를 선택한다.</li>\n<li>본래 수행 중이던 프로세스를 준비 상태로 내리고 새로운 프로세스가 실행 상태가 된다.</li>\n<li>실행할 프로세스에 대한 문맥을 세팅한다.</li>\n</ul>\n</li>\n<li><strong>CPU 디스패치(dispatch)</strong> - 준비 상태에 있는 프로세스 중 CPU를 할당받을 프로세스를 선택하고 제어권을 넘겨받는 과정</li>\n</ul>\n<h3 id=\"입출력을-요청한-프로세스의-상태변화\" style=\"position:relative;\"><a href=\"#%EC%9E%85%EC%B6%9C%EB%A0%A5%EC%9D%84-%EC%9A%94%EC%B2%AD%ED%95%9C-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%9D%98-%EC%83%81%ED%83%9C%EB%B3%80%ED%99%94\" aria-label=\"입출력을 요청한 프로세스의 상태변화 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>입출력을 요청한 프로세스의 상태변화</h3>\n<ul>\n<li>디스크 입출력은 오랜 시간이 걸리기 때문에 이 시간동안 해당 프로세스는 봉쇄 상태가 된다.</li>\n<li>그 동안 준비 상태의 프로세스 들을 CPU 스캐줄러가 선정해 CPU를 할당하고 해당 프로세스는 실행 상태로 변경이 된다.</li>\n<li>입출력 요청 프로세스는 디스크 입출력 큐에 대기하다가 디스크 컨트롤러부터 서비스를 받는다.</li>\n<li>완료 후 디스크 컨트롤러가 CPU에게 인터럽트로 입출력 완료를 알린다.</li>\n<li>\n<p>CPU는 인터럽에 대한 루틴을 수행한다.</p>\n<ul>\n<li>이때 당시에 CPU에서 진행중이던 프로세스가 사용자모드에서 커널 모드로 바뀐다.</li>\n<li>관련이 없는 프로세스지만 해당 프로세스 중 인터럽트가 발생했기 때문에 해당 프로세스가 커널 모드로 진입했다고 판단하도록 한다.</li>\n</ul>\n</li>\n<li>봉쇄 상태의 프로세스는 준비 상태로 바뀌고, 로컬버퍼에 있는 내용을 메모리로 이동시키는 업무를 수행한다.</li>\n<li>인터럽트 처리 루틴이 완료되면 직전 프로세스가 다시 수행되거나 입출력 완료 프로세스의 우선순위가 높다면 해당 프로세스가 수행된다.</li>\n</ul>\n<br>\n<h2 id=\"-3-프로세스-제어블록\" style=\"position:relative;\"><a href=\"#-3-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%A0%9C%EC%96%B4%EB%B8%94%EB%A1%9D\" aria-label=\" 3 프로세스 제어블록 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 3. 프로세스 제어블록</h2>\n<ul>\n<li>\n<p>Process Control Block - 운영체제가 시스템 내의 프로세스들을 관리하기 위해 프로세스마다 유지하는 정보들을 담는 <strong>커널 내 자료구조</strong></p>\n<ul>\n<li>커널 메모리의 데이터 영역에 위치한다.</li>\n</ul>\n</li>\n<li>\n<p>다음 요소들로 구성되어 있다.</p>\n<ul>\n<li>\n<p>프로세스의 상태</p>\n<ul>\n<li>CPU를 할당해도 되는지 여부를 결정</li>\n</ul>\n</li>\n<li>\n<p>프로세스 카운터 값</p>\n<ul>\n<li>다음 수행할 명령어 위치 가리킴</li>\n</ul>\n</li>\n<li>\n<p>CPU 레지스터 값</p>\n<ul>\n<li>CPU 연산을 위해서 현 시점에서 레지스터에 특정 값을 저장</li>\n</ul>\n</li>\n<li>\n<p>CPU 스캐줄링 정보</p>\n<ul>\n<li>스캐줄링에 필요한 정보</li>\n</ul>\n</li>\n<li>\n<p>메모리 관리 정보</p>\n<ul>\n<li>메모리 할당에 필요한 정보</li>\n</ul>\n</li>\n<li>\n<p>자원 사용 정보</p>\n<ul>\n<li>사용자에게 자원 사용 요금을 계산하여 청구</li>\n</ul>\n</li>\n<li>\n<p>입출력 상태 정보</p>\n<ul>\n<li>프로세스가 오픈한 파일 정보 등 프로세스의 입출력 관련 상태 정보</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-4-문맥교환\" style=\"position:relative;\"><a href=\"#-4-%EB%AC%B8%EB%A7%A5%EA%B5%90%ED%99%98\" aria-label=\" 4 문맥교환 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 4. 문맥교환</h2>\n<ul>\n<li>\n<p>Context Switch - 하나의 사용자 프로세스로부터 다른 사용자 프로세스로 CPU의 제어권이 이양되는 과정</p>\n<ul>\n<li>타이머 인터럽트가 발생하면 직전 수행 프로세스의 문맥을 저장하고 새로운 프로세스에게 CPU를 이양한다.</li>\n</ul>\n</li>\n<li>\n<p>기존에 보유하고 있던 프로세스의 문맥 저장</p>\n<ul>\n<li>PC 값 등을 자신의 PCB에 저장</li>\n</ul>\n</li>\n<li>\n<p>새로 할당받은 프로세스</p>\n<ul>\n<li>저장했던 문맥을 PCB에서 하드웨어로 복원</li>\n</ul>\n</li>\n<li>타이머 인터럽트 외에도 실행 중이던 프로세스가 입출력 요청이나 다른 조건을 충족하지 못해서 CPU를 뺏기고 봉쇄상태가 될 때도 문맥교환이 발생한다.</li>\n<li>\n<p><strong>프로세스 실행 상태 중 인터럽트나 시스템 콜로 인해 CPU의 제어권이 운영체제로 넘어가면 실행 중이던 프로세스의 문맥을 일부 PCB에 저장하지만 이 과정은 문맥교환이라고 하지 않는다.</strong></p>\n<ul>\n<li>단순히 해당 프로세스의 모드가 사용자모드에서 커널모드로 바뀌는 것 뿐이다.</li>\n</ul>\n</li>\n<li>\n<p>모드변경보다 문맥교환이 훨씬 많은 오버헤드가 발생한다. 따라서 타이머의 단위가 작아 문맥교환이 지나치게 자주 일어나면 오버헤드가 커진다.</p>\n<ul>\n<li>하지만 단위가 너무 크면 시분할 시스템의 의미가 퇴색되므로 적절한 시간 할당이 중요하다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-5-프로세스를-스케줄링하기-위한-큐\" style=\"position:relative;\"><a href=\"#-5-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EB%A5%BC-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81%ED%95%98%EA%B8%B0-%EC%9C%84%ED%95%9C-%ED%81%90\" aria-label=\" 5 프로세스를 스케줄링하기 위한 큐 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 5. 프로세스를 스케줄링하기 위한 큐</h2>\n<ul>\n<li>\n<p>운영체제는 준비상태에 있는 프로세스들을 ready queue에 두고 줄 앞에 프로세스에게 CPU를 할당한다.</p>\n<ul>\n<li>줄을 세우는 방식은 CPU 스캐줄링 방식에 따라서 달라진다.</li>\n</ul>\n</li>\n<li>\n<p>운영체제 하드웨어 자원을 기다리는 프로세스를 위한 자원별 장치 큐 device queue가 있다.</p>\n<ul>\n<li>ex. 디스크 입출력 큐 disk I/O queue, 키보드 입출력 큐 등등</li>\n</ul>\n</li>\n<li>\n<p>소프트웨어 자원을 기다리기 위한 자원 큐도 있다.</p>\n<ul>\n<li>어떤 공유 데이터에 대한 접근 권한 등등</li>\n<li>일관성을 위해 해당 공유 데이터에 접근 중인 프로세스가 다 사용하고 반납할 때까지 접근 권한을 주면 안된다.</li>\n<li>이 관리를 자원 큐를 통해서 한다.</li>\n</ul>\n</li>\n<li>\n<p>이 모든 큐들은 커널의 데이터 영역에 둔다.</p>\n<ul>\n<li>프로세스의 CPU 대기, 입출력 대기 등의 정보를 커널이 총체적으로 관리한다.</li>\n</ul>\n</li>\n<li>\n<p>작업 큐 (job queue) - 시스템 내의 모든 프로세스를 관리하기 위한 큐로 프로세스의 상태와 무관하게 현재 시스템 내에 있는 모든 프로세스가 작업 큐에 속한다.</p>\n<ul>\n<li>작업 큐에 있다고 반드시 메모리가 있는 것은 아니다.</li>\n<li>작업 큐가 가장 넓은 개념이고 준비 큐와 장치큐이 있는 프로세스는 모두 작업 큐에 속해있다.</li>\n</ul>\n</li>\n<li>큐는 각 프로세스의 PCB를 연결 리스크 형태로 관리하고 포인터로 순서를 정한다.</li>\n</ul>\n<br>\n<h2 id=\"-6-스케줄러\" style=\"position:relative;\"><a href=\"#-6-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%9F%AC\" aria-label=\" 6 스케줄러 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 6. 스케줄러</h2>\n<ul>\n<li>\n<p>스캐줄러 - 어떤 프로세스에게 자원을 할당할지 결정하는 운영체제 커널의 코드</p>\n<ul>\n<li>장기 스캐줄러와 단기 스케줄러</li>\n</ul>\n</li>\n<li>\n<p>장기 스캐줄러 (long term scheduler) - 작업 스캐줄러 (job scheduler) 이며 어떤 프로세스를 준비 큐에 진입시킬지 결정</p>\n<ul>\n<li>CPU에 실행되기 위해서는 프로세스가 메모리를 보유해야하므로 장기 스캐줄러는 프로세스에 메모리 보유 문제에 관여한다.</li>\n<li>수십 초 내지 수 분 단위로 가끔 호출되므로 상대적으로 느린 것이 허용된다.</li>\n<li>메모리에 동시에 올라가 있는 프로세스의 수 (degree of multiprogramming)을 조절한다.</li>\n<li>하지만 현대의 시분할 시스템은 메모리가 훨씬 커서 장기 스케줄러 없어 바로 프로세스에 메모리를 할당해 준비큐에 넣어준다.</li>\n</ul>\n</li>\n<li>\n<p>단기 스캐줄러 (short term scheduler) - 준비 프로세스 중 어떤 프로세스를 다음에 실행상태로 만들지 결정</p>\n<ul>\n<li>준비 큐에 있는 것들 중 어떤 프로세스에게 CPU를 할당할지 결정하는 것</li>\n<li>타이머 인터럽트 발생시 단기 스캐줄러가 호출된다.</li>\n<li>밀리초 단위로 빈번하게 호출이 되므로 수행 속도가 빨라야 한다.</li>\n</ul>\n</li>\n<li>\n<p>중기 스캐줄러 (medium term scheduling) - 메모리에 적재된 프로세스의 수를 동적으로 조절</p>\n<ul>\n<li>너무 많은 프로세스가 메모리에 적재되어 시스템 효율이 떨어지는 것을 관리한다.</li>\n<li>메모리에 당장 필요한 프로세스의 주소 공간도 모자라면 디스크 입출력이 수시로 발생하여 시스템의 성능이 저하된다.</li>\n<li>중기 스캐줄러는 이 경우 메모리의 프로세스 중 일부를 선정 해 메모리를 뺏고 해당 내용을 스왑 영역에 저장한다 ⇒ swap out</li>\n<li>프로세스당 보유 메모리가 지나치게 적다면 일부 프로세스를 메모리에게 디스크로 스왑 아웃시키는 역할을 수행한다.</li>\n<li>\n<p>봉쇄 상태에 있는 프로세스들이 가장 먼저 스왑 아웃된다. 그럼에도 부족하다면 타이머 인터럽트 발생 후 준비 큐로 이동하는 프로세스들을 추가적으로 스왑 아웃한다.</p>\n<ul>\n<li>다시 CPU를 할당 받을 때까지 시간이 걸리기 때문이다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>프로세스의 중지(suspended, stopped) 상태</p>\n<ul>\n<li>외부적인 이유로 프로세스의 수행이 정지된 상태</li>\n<li>디스크로 스왑 아웃된 프로세스의 상태이다.</li>\n<li>중지준비 상태 - 준비 상태의 프로세스가 디스크로 스왑 아웃된 것</li>\n<li>\n<p>중지봉쇄 상태 - 봉쇄 상태의 프로세스가 디스크로 스왑 아웃된 것</p>\n<ul>\n<li>중지봉쇄 상태에서 해당 작업이 끝나면 중지준비 상태로 변경된다.</li>\n</ul>\n</li>\n<li>이 경우들은 프로세스가 메모리를 보유하지 않고 통째로 디스크로 스왑 아웃 된 상태이다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-7-프로세스의-생성\" style=\"position:relative;\"><a href=\"#-7-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%9D%98-%EC%83%9D%EC%84%B1\" aria-label=\" 7 프로세스의 생성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 7. 프로세스의 생성</h2>\n<ul>\n<li>시스템 부팅된 후 최초 프로세스는 운영체제가 직접 생성한다.</li>\n<li>\n<p>이후부터는 이미 존재하는 프로세스가 다른 프로세스를 복제 생성한다.</p>\n<ul>\n<li>생성하는 프로세스를 부모 프로세스, 생성되는 프로세스를 자식 프로세스라고 한다.</li>\n</ul>\n</li>\n<li>\n<p>자식 프로세스가 먼저 죽고 부모 프로세스가 이에 대한 처리를 한다.</p>\n<ul>\n<li>부모 프로세스가 종료되기 위해서는 생성된 자식 프로세스가 모두 종료된 후에야 종료될 수 있다.</li>\n</ul>\n</li>\n<li>\n<p>프로세스의 자원</p>\n<ul>\n<li>\n<p>운영체제와 자원의 종료에 따라 획득하는 방식이 다르다.</p>\n<ul>\n<li>운영체제로 직접 자원 할당</li>\n<li>부모 프로세스와 자원을 공유하여 사용</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>프로세스 수행 모델</p>\n<ul>\n<li>\n<p>부모와 자식이 공존하며 수행</p>\n<ul>\n<li>부모와 자식이 CPU를 획득하기 위해 경쟁함</li>\n</ul>\n</li>\n<li>\n<p>자식이 종료(terminated) 될 때까지 부모가 기다리는(wait) 모델</p>\n<ul>\n<li>자식이 종료될 때까지 부모 프로세스는 봉쇄 상태에 머물다가 자식 종료 후 부모 프로세스가 준비 상태가 되어 CPU를 획득할 수 있음</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>프로세스가 생성될 때 독자적인 주소 공간을 갖는다.</p>\n<ul>\n<li>\n<p>자식 프로세스가 생성될 때 부모 프로세스의 주소 공간을 복사하여 별도의 주소 공간을 생성하고 새로운 프로그램 내용을 덮어씌워 실행한다.</p>\n<ul>\n<li>유닉스에서 <code class=\"language-text\">fork()</code> 시 자식 프로세스가 생성되고 부모와 똑같은 커널 내 정보와 주소 공간 정보를 가진 상태로 복사된다. (프로세스 id는 다르다)</li>\n<li>이후 <code class=\"language-text\">exec()</code> 시 새로운 주소 공간을 덮어씌운다.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"프로세스의-종료\" style=\"position:relative;\"><a href=\"#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%9D%98-%EC%A2%85%EB%A3%8C\" aria-label=\"프로세스의 종료 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>프로세스의 종료</h3>\n<ul>\n<li>\n<p>자발적 종료</p>\n<ul>\n<li>코드의 마지막에 <code class=\"language-text\">exit()</code>라는 시스템 콜을 통해 (없다면 컴파일러가 자동으로 삽입) 종료하고 운영체제는 해당 프로세스로부터 자원을 회수한다.</li>\n</ul>\n</li>\n<li>\n<p>비자발적 종료</p>\n<ul>\n<li>부모 프로세스가 자식 프로세스의 수행을 강제로 종료하며 <code class=\"language-text\">abort()</code>로 이루어진다.</li>\n<li>자식 프로세스가 할당 자원의 한계 이상의 자원을 요구할 때 </li>\n<li>자식 프로세스에게 할당된 작업이 필요하지 않을 때 </li>\n<li>부모 프로세스가 종료(exit) 되는 경우에 발생한다. </li>\n</ul>\n</li>\n<li>종료되는 프로세스는 자식 프로세스를 계속 실행하기 위해서 종료되지 않을 다른 프로세스의 양자로 보내어 계속 수행할 수 있도록 할 수 있다.</li>\n</ul>\n<h3 id=\"자식-프로세스-생성\" style=\"position:relative;\"><a href=\"#%EC%9E%90%EC%8B%9D-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%83%9D%EC%84%B1\" aria-label=\"자식 프로세스 생성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>자식 프로세스 생성</h3>\n<ul>\n<li>\n<p><code class=\"language-text\">fork()</code> 시스템 콜로 CPU제어권을 커널로 넘겨 fork() 호출 프로세스를 복제해 자식 프로세스를 생성</p>\n<ul>\n<li>\n<p>부모와 모든 문맥(주소 공간, PC, 레지스터 상태, PCB, 커널스택 등)을 동일하게 가진 자식 프로세스 생성한다.</p>\n<ul>\n<li>따라서 자식 프로세스는 부모 프로세스의 현재 수행 시점부터 수행하게 된다. (PC 등의 값을 그대로 복제하므로)</li>\n</ul>\n</li>\n<li>식별자는 부모 프로세스와 다르다.</li>\n<li>함수의 결과값은 자식은 0, 부모는 양수이다. 이 값으로 자식과 부모 프로세스를 분기할 수 있다. 하지만 여전히 분기문을 가진 코드 또한 동일한 것을 지닌 상태이다.</li>\n</ul>\n</li>\n<li>자식에게 독자적인 프로그램 수행이 가능하도록 유닉스에서 새로운 주소 공간에 새로운 프로그램을 <code class=\"language-text\">exec()</code> 를 통해 덮어씌울 수 있도록 한다.</li>\n<li>\n<p><code class=\"language-text\">fork()</code>, <code class=\"language-text\">exec()</code>, <code class=\"language-text\">exit()</code> , <code class=\"language-text\">wait()</code>는 모두 특권명령이다.</p>\n<ul>\n<li><code class=\"language-text\">wait()</code>은 자식 프로세스가 종료될 때까지 부모 프로세스를 봉쇄 상태에 머무르게 하는 것이다.</li>\n<li>이것으로 자식과 부모의 동기화 (synchronization)이 가능하다.</li>\n<li>자식 프로세스가 종료되면 다시 준비 큐에 삽입되어 CPU 할당 받을 수 있다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"-8-프로세스-간의-협력\" style=\"position:relative;\"><a href=\"#-8-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EA%B0%84%EC%9D%98-%ED%98%91%EB%A0%A5\" aria-label=\" 8 프로세스 간의 협력 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 8. 프로세스 간의 협력</h2>\n<ul>\n<li>부모 프로세스와 자식 프로세스는 독자적인 메모리 구조를 가지므로 독립적인 관계가 된다.</li>\n<li>프로세스간 협력할 때 서로 주소 공간을 참조하지 않으면서 정보를 주고받을 수 있는 매커니즘이 필요하다.</li>\n<li>\n<p>IPC(Inter-Process Communication) - 운영체제가 제공하는 하나의 컴퓨터 안에서 실행 중인 프로세스 간 협력 매커니즘</p>\n<ul>\n<li>프로세스간의 통신(communication)과 함께 공유 데이터의 일관성을 위한 동기화를 보장해주어야 한다.</li>\n<li>\n<p>메세지 전달(message passing)과 공유메모리(shared memory) 방식이 있다.</p>\n<ul>\n<li>차이는 shared data가 있는 것과 없는 것이다.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"메세지-전달\" style=\"position:relative;\"><a href=\"#%EB%A9%94%EC%84%B8%EC%A7%80-%EC%A0%84%EB%8B%AC\" aria-label=\"메세지 전달 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>메세지 전달</h3>\n<ul>\n<li>프로세스간 공유 데이터가 없이 메세지를 주고받으며 통신한다. 메세지 전달은 직접하지 못하고 커널이 전달한다.</li>\n<li>커널이 제공하는 send(), receive() 연산으로 시스템 콜 방식으로 요청해 메세지를 전달한다.</li>\n<li>메세지를 전달하는 연산은 특권명령이다.</li>\n<li>\n<p>통신하기 원하는 두 프로세스는 communication link를 생성하고 send(), receive()를 통해 메세지를 주고 받는다.</p>\n<ul>\n<li>communication link는 물리적인 방법, 논리적인 방법 두 가지로 구현할 수 있다.</li>\n</ul>\n</li>\n<li>\n<p>직접 프로세스에게 전달하는 방식과 메일 박스를 통해 간접적으로 전달하는 방식으로 나뉜다.</p>\n<ol>\n<li>\n<p>직접 통신 (direct communication)</p>\n<ol>\n<li>통신하려는 프로세스를 직접 명시하고 받는 프로세스도 직접 명시한다. </li>\n<li>커뮤니케이션 링크는 자동으로 생성되고 하나의 링크는 한 쌍의 프로세스에게 할당된다. </li>\n<li>대부분의 링크는 양방향이며 단 하나의 링크만 서로 존재한다. </li>\n</ol>\n</li>\n<li>\n<p>간접 통신 (indirect communication)</p>\n<ol>\n<li>메일박스 또는 포트로 메시지를 전달받는다. 메일박스는 고유의 id가 있어서 해당 메일박스를 공유하는 프로세스들끼리만 통신을 할 수 있다. </li>\n<li>커뮤니케이션 링크는 메일박스를 공유하는 경우에만 생성된다. </li>\n<li>하나의 링크가 여러 프로세스에게 할당될 수 있고, 각 프로세스 쌍은 여러 링크를 공유할 수 있다. </li>\n<li>링크는 단방향, 양방향일 수 있다. </li>\n<li>새로운 메일박스를 생성하는 연산, 메세지 send(), receive() 연산, 메일박스 삭제 연산을 할 수 있다. </li>\n<li>간접통신에서 메세지 대상 및 수신자는 A라는 메일박스로 통일된다. </li>\n<li>\n<p>메일박스 공유로 수신 대상의 혼란을 제어하기 위해 2개의 프로세스에게만 링크를 할당할 수 있다. </p>\n<ul>\n<li>또는 링크의 receive() 연산을 매 시점 하나의 프로세스만 수행할 수 있도록 한다.</li>\n<li>시스템이 메세지 수신자를 임의로 결정해 누가 받았는지 송신자에게 통신해준다.</li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"공유메모리-shared-memory\" style=\"position:relative;\"><a href=\"#%EA%B3%B5%EC%9C%A0%EB%A9%94%EB%AA%A8%EB%A6%AC-shared-memory\" aria-label=\"공유메모리 shared memory permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>공유메모리 shared memory</h3>\n<ul>\n<li>프로세스들의 메모리 주소 공간 일부를 공유한다.</li>\n<li>각 프로세스는 독립된 주소 공간을 가지고 있다. 이 주소 공간(가상 메모리)가 물리 메모리로 매핑될 때 공유메모리 주소 영역은 동일한 물리 메모리 영역으로 매핑된다.</li>\n<li>통신이 쉬운 인터페이스이지만 데이터 일관성 문제가 발생할 수 있다. 이 문제는 커널이 책임지지 않으며 프로세스들끼리 직접 동기화 문제를 해결해야 한다.</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#-1-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%9D%98-%EA%B0%9C%EB%85%90\">🌩 1. 프로세스의 개념</a></li>\n<li>\n<p><a href=\"#-2-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%9D%98-%EC%83%81%ED%83%9C\">🌩 2. 프로세스의 상태</a></p>\n<ul>\n<li><a href=\"#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%9D%98-%EC%83%81%ED%83%9C-%ED%9D%90%EB%A6%84\">프로세스의 상태 흐름</a></li>\n<li><a href=\"#%EC%9E%85%EC%B6%9C%EB%A0%A5%EC%9D%84-%EC%9A%94%EC%B2%AD%ED%95%9C-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%9D%98-%EC%83%81%ED%83%9C%EB%B3%80%ED%99%94\">입출력을 요청한 프로세스의 상태변화</a></li>\n</ul>\n</li>\n<li><a href=\"#-3-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%A0%9C%EC%96%B4%EB%B8%94%EB%A1%9D\">🌩 3. 프로세스 제어블록</a></li>\n<li><a href=\"#-4-%EB%AC%B8%EB%A7%A5%EA%B5%90%ED%99%98\">🌩 4. 문맥교환</a></li>\n<li><a href=\"#-5-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EB%A5%BC-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81%ED%95%98%EA%B8%B0-%EC%9C%84%ED%95%9C-%ED%81%90\">🌩 5. 프로세스를 스케줄링하기 위한 큐</a></li>\n<li><a href=\"#-6-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%9F%AC\">🌩 6. 스케줄러</a></li>\n<li>\n<p><a href=\"#-7-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%9D%98-%EC%83%9D%EC%84%B1\">🌩 7. 프로세스의 생성</a></p>\n<ul>\n<li><a href=\"#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%9D%98-%EC%A2%85%EB%A3%8C\">프로세스의 종료</a></li>\n<li><a href=\"#%EC%9E%90%EC%8B%9D-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%83%9D%EC%84%B1\">자식 프로세스 생성</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-8-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EA%B0%84%EC%9D%98-%ED%98%91%EB%A0%A5\">🌩 8. 프로세스 간의 협력</a></p>\n<ul>\n<li><a href=\"#%EB%A9%94%EC%84%B8%EC%A7%80-%EC%A0%84%EB%8B%AC\">메세지 전달</a></li>\n<li><a href=\"#%EA%B3%B5%EC%9C%A0%EB%A9%94%EB%AA%A8%EB%A6%AC-shared-memory\">공유메모리 shared memory</a></li>\n</ul>\n</li>\n</ul>\n</div>","frontmatter":{"date":"October 13, 2021","title":"운영체제와 정보기술의 원리 - CH5. 프로세스 관리","categories":"운영체제 책","author":"코다","emoji":"🧁"},"fields":{"slug":"/operating-system-4/"}},"site":{"siteMetadata":{"siteUrl":"https://yjksw.github.io","comments":{"utterances":{"repo":"yjksw/yjksw.github.io"}}}}},"pageContext":{"slug":"/operating-system-3/","nextSlug":"/operating-system-2/","prevSlug":"/operating-system-4/"}},"staticQueryHashes":["1073350324","2938748437"]}
{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/effective-java-7-8/",
    "result": {"data":{"cur":{"id":"91f9dc7c-7202-5fed-be27-7d0cf0c9d41a","html":"<blockquote>\n<p>이 글은 몇몇 크루들과 이펙티브 자바 스터디를 하며 정리한 내용입니다. 🙌</p>\n</blockquote>\n<h2 id=\"-아이템-7-다-쓴-객체-참조를-해제하라\" style=\"position:relative;\"><a href=\"#-%EC%95%84%EC%9D%B4%ED%85%9C-7-%EB%8B%A4-%EC%93%B4-%EA%B0%9D%EC%B2%B4-%EC%B0%B8%EC%A1%B0%EB%A5%BC-%ED%95%B4%EC%A0%9C%ED%95%98%EB%9D%BC\" aria-label=\" 아이템 7 다 쓴 객체 참조를 해제하라 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 [아이템 7] 다 쓴 객체 참조를 해제하라</h2>\n<p>JVM 언어를 사용한다면 GC가 알아서 사용되지 않는 객체를 해제할텐데 왜 이런 항목이 있는걸까?</p>\n<p>다음과 같은 경우에는 GC가 해당 객체가 다 쓴 객체인지 아닌지 판단할 수가 없다.</p>\n<p>Stack 자료구조를 구현한 예시이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Stack</span> <span class=\"token punctuation\">{</span>\n\t\n\t<span class=\"token keyword\">private</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> elements'\n\t<span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> size <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token comment\">// 이외 필드 및 메서드</span>\n\n\t<span class=\"token keyword\">public</span> <span class=\"token class-name\">Object</span> <span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>size <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t\t<span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">EmptyStackException</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t\t\n\t\t<span class=\"token keyword\">return</span> elements<span class=\"token punctuation\">[</span><span class=\"token operator\">--</span>size<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>다음과 같은 경우 다시 참조되지 않을 객체에 대한 해제가 이루어지지 않았기 때문에 ‘메모리 누수’가 발생한다. 이 프로그램이 오랜시간 실행이 되다보면 메모리 사용량이 늘어나 성능이 저하되거나 심하면 <code class=\"language-text\">OutOfMemoryError</code>를 일으킬수도 있다.</p>\n<p>위 코드와 같은 경우 <code class=\"language-text\">elements</code> 배열에 더이상 사용되지 않는 영역의 객체 참조를 배열이 여전히 가지고 있다. 예를 들면 <code class=\"language-text\">size</code> 바깥에 존재하는 객체들에 대해서 말이다.</p>\n<p>이렇게 GC에게 객체 처리를 맡기는 언어에서 이러한 메모리 누수를 찾기가 매우 어렵다. 또한 쓰이지 않지만 참조되고 있는 객체의 영향이 해당 객체에서 끝이 나는 것이 아니라 해당 객체들을 췸조하는 다른 여러 객체들도 회수할 수 없다.</p>\n<p>따라서 다음과 같이 null 처리를 통해 참조 해제를 해야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token class-name\">Object</span> <span class=\"token function\">pop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>size <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">EmptyStackException</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\t\n\t<span class=\"token class-name\">Object</span> result <span class=\"token operator\">=</span> elements<span class=\"token punctuation\">[</span><span class=\"token operator\">--</span>size<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\telement<span class=\"token punctuation\">[</span>size<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<br>\n<h3 id=\"객체-참조를-직접-해제해야-하는-경우\" style=\"position:relative;\"><a href=\"#%EA%B0%9D%EC%B2%B4-%EC%B0%B8%EC%A1%B0%EB%A5%BC-%EC%A7%81%EC%A0%91-%ED%95%B4%EC%A0%9C%ED%95%B4%EC%95%BC-%ED%95%98%EB%8A%94-%EA%B2%BD%EC%9A%B0\" aria-label=\"객체 참조를 직접 해제해야 하는 경우 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>객체 참조를 직접 해제해야 하는 경우</h3>\n<p>그렇다고 항상 객체 참조를 하나하나 null 처리 해야한다는 것은 아니다. 이 로직은 가독성을 저하시키고 프로그램을 지저분하게 만든다. 객체 참조를 null 처리를 통해 직접 해제해야하는 경우는 <strong>자기 메모리를 직접 관리하는 클래스</strong>인 경우이다.</p>\n<p>예를 들어 <code class=\"language-text\">Stack</code> 클래스의 경우를 살펴보자. 이 클래스의 경우 객체가 아니라 객체 참조를 담는 element 배열을 사용한다. 그러니까 JVM에서 직접 객체 참조를 관리하는 것이 아니라 관리하는 영역을 따로 만든 것이다. 그렇기 때문에 어디부터 어디까지가 유효한 참조범위인지 GC는 알 수 없다.</p>\n<br>\n<h3 id=\"메모리-누수가-자주-발생하는-상황\" style=\"position:relative;\"><a href=\"#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%88%84%EC%88%98%EA%B0%80-%EC%9E%90%EC%A3%BC-%EB%B0%9C%EC%83%9D%ED%95%98%EB%8A%94-%EC%83%81%ED%99%A9\" aria-label=\"메모리 누수가 자주 발생하는 상황 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>메모리 누수가 자주 발생하는 상황</h3>\n<p>또 다른 예로는 캐시가 있다. 캐시에 특정 객체를 넣어놓고 인지하지 못하면 메모리 누수가 발생한다. 이 경우 저자가 제안하는 몇가지 해결방법이 있다.</p>\n<p>첫 번째는 WeakHashMap을 사용하여 해당 캐시의 key 값이 더 이상 참조되지 않는다면 해당 엔트리를 삭제하는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token class-name\">WeakHashMap</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> map <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">WeakHashMap</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token class-name\">Integer</span> key1 <span class=\"token operator\">=</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Integer</span> key2 <span class=\"token operator\">=</span> <span class=\"token number\">2000</span><span class=\"token punctuation\">;</span>\n\nmap<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>key1<span class=\"token punctuation\">,</span> <span class=\"token string\">\"값1\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nmap<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>key2<span class=\"token punctuation\">,</span> <span class=\"token string\">\"값2\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nkey1 <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이렇게 사용할 경우 key1에 대한 엔트리 값이 자동으로 GC에 의해 수거된다.</p>\n<br>\n<blockquote>\n<p>다음 단락은 개인적인 의견 입니다 !!</p>\n</blockquote>\n<p>위 방법은 추천하지 않는다. 우선 Map 자료구조의 <code class=\"language-text\">key</code>나 <code class=\"language-text\">value</code>의 값이 불변과 <code class=\"language-text\">final</code>이 아닐 경우 찾기 매우 어려운 버그가 발생하기 너무 쉽다고 생각한다. 특히나 <code class=\"language-text\">key</code>와 같은 경우는 불변이나 <code class=\"language-text\">final</code>이 아닐 경우 개발자가 예상하지 못하는 시점에 변경이 일어나고 의도하지 않은 <code class=\"language-text\">key</code>와 <code class=\"language-text\">value</code>가 매핑되어 있을 수 있다.</p>\n<p>두 번째 방법은 엔트리의 가치를 시간에 따라 점점 떨어뜨리고 오래된 엔트리를 주기적으로 청소해주는 것이다. <code class=\"language-text\">ScheduledThreadPoolExecutor</code>를 사용하여 백그라운드 스레드로 유효기간이 지난 엔트리를 삭제하는 로직을 실행할 수 있다. 또는 <code class=\"language-text\">LinkedHashMap</code> 자료그조의 <code class=\"language-text\">removeEldestEntry()</code> 를 사용하여 오래된 엔트리를 삭제할 수 있다. (추가로 복잡한 캐시 처리에는 <code class=\"language-text\">java.lang.ref</code> 패키지를 사용하라고 제안한다. 여러 종류의 객체 참조에 대한 패키지인데 자세한 것을 이 <a href=\"%5Bhttps://d2.naver.com/helloworld/329631%5D(https://d2.naver.com/helloworld/329631)\">링크</a>를 참고해보자.)</p>\n<p>메모리 누수가 자주 발생할 수 있는 마지막 경우는 리스너(Listener) 혹은 콜백(callback)이다. 콜백을 등록하고 해제하지 않으면 콜백이 쌓이며 메모리 누수가 발생한다.</p>\n<br>\n<h2 id=\"-아이템-8-finalizer와-cleaner-사용을-피하라\" style=\"position:relative;\"><a href=\"#-%EC%95%84%EC%9D%B4%ED%85%9C-8-finalizer%EC%99%80-cleaner-%EC%82%AC%EC%9A%A9%EC%9D%84-%ED%94%BC%ED%95%98%EB%9D%BC\" aria-label=\" 아이템 8 finalizer와 cleaner 사용을 피하라 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 [아이템 8] finalizer와 cleaner 사용을 피하라</h2>\n<h3 id=\"수행-시점을-보장할-수-없다\" style=\"position:relative;\"><a href=\"#%EC%88%98%ED%96%89-%EC%8B%9C%EC%A0%90%EC%9D%84-%EB%B3%B4%EC%9E%A5%ED%95%A0-%EC%88%98-%EC%97%86%EB%8B%A4\" aria-label=\"수행 시점을 보장할 수 없다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>수행 시점을 보장할 수 없다</h3>\n<p>finalizer와 cleaner의 큰 단점은 어느 시점에 수행되는지 보장할 수 없다는 것이다. 따라서 반드시 닫아야 하는 파일 닫기와 같은 로직을 finalizer 혹은 cleaner로 수행한다면 파일이 언제 닫힐지 몰라 열어두게 되고 한계를 넘으면 프로그램이 실패한다.</p>\n<p>finalizer의 스레드는 다른 스레드에 비해 우선순위가 낮아서 오랜시간 처리가 되지 않을 수도 있다. 반면 cleaner는 해당 스레드를 제어할 수 있지만 여전히 GC의 통제하에 수행하기 때문에 실제로 수행하는 시점을 알기 어렵다.</p>\n<br>\n<h3 id=\"수행-여부를-보장할-수-없다\" style=\"position:relative;\"><a href=\"#%EC%88%98%ED%96%89-%EC%97%AC%EB%B6%80%EB%A5%BC-%EB%B3%B4%EC%9E%A5%ED%95%A0-%EC%88%98-%EC%97%86%EB%8B%A4\" aria-label=\"수행 여부를 보장할 수 없다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>수행 여부를 보장할 수 없다</h3>\n<p>수행 시간도 큰 단점이지만 수행 여부에 대한 보장도 되지 않는다. 해당 작업이 종료되었는지와 상관없이 프로그램이 종료될 수 있기 때문에 프로그램 내부의 일시적인 것이 아닌 영구적은 수정 작업에서 finalizer나 cleaner를 사용하게 되면 시스템 자체가 서서히 죽어갈 수도 있다.</p>\n<ul>\n<li>예를 들면 DB와 관련된 공유 자원의 lock 해제 등의 로직 등이 제대로 이루어졌는지 확인되지 않고 프로그램이 종료될 수 있는 것이다. 그러면 엄청난 성능 저하가 일어나고 시간이 지나면 왜인지 모른체 시스템이 다운 될 수 있다.</li>\n</ul>\n<br>\n<h3 id=\"예외-발생시-알-수-없다\" style=\"position:relative;\"><a href=\"#%EC%98%88%EC%99%B8-%EB%B0%9C%EC%83%9D%EC%8B%9C-%EC%95%8C-%EC%88%98-%EC%97%86%EB%8B%A4\" aria-label=\"예외 발생시 알 수 없다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>예외 발생시 알 수 없다</h3>\n<p>또 다른 큰 단점은 finalizer 수행 중 예외가 발생하면 <strong>1) 예외는 무시되지만 2) 작업은 순간 종료된다</strong>(남은 작업을 처리하지 않는다). 예외가 발생해도 경고도 출력되지 않고 무시되며 프로그램은 여전히 실행되기 때문에 어떤 객체가 중단되었고 훼손 되었는지 알 수 없다. cleaner는 자신의 스레드를 통제하기 때문에 관련 문제가 적게 발생한다.</p>\n<br>\n<h3 id=\"성능-문제가-발생한다\" style=\"position:relative;\"><a href=\"#%EC%84%B1%EB%8A%A5-%EB%AC%B8%EC%A0%9C%EA%B0%80-%EB%B0%9C%EC%83%9D%ED%95%9C%EB%8B%A4\" aria-label=\"성능 문제가 발생한다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>성능 문제가 발생한다</h3>\n<p>try-with-resources를 사용한 경우 객체 생성 후 GC가 수거하기까지 12ns가 걸리지만 finalizer를 사용하면 550ns 가 걸린다. 즉, 50배의 성능저하가 일어나는 것이다. 안전망 형태 (추후 설명)로 사용하면 빨라지지만 여전히 5배가 느려진다. GC의 성능 저하를 초래하는 것이다.</p>\n<br>\n<h3 id=\"finalizer-공격에-노출된다\" style=\"position:relative;\"><a href=\"#finalizer-%EA%B3%B5%EA%B2%A9%EC%97%90-%EB%85%B8%EC%B6%9C%EB%90%9C%EB%8B%A4\" aria-label=\"finalizer 공격에 노출된다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>finalizer 공격에 노출된다</h3>\n<p>예를 들어 다음과 같은 경우이다.</p>\n<ul>\n<li>생성자나 직렬화 과정에서 예외가 발생하여 불완전한 객체가 생긴다.</li>\n<li>이때 악의적인 하위 클래스의 finalizer에서 정적 필드에 자기 자신을 참조하여 GC가 불완전한 해당 클래스를 수집하지 못하게 된다.</li>\n<li>이렇게 일그러진 객체가 생성되어 일반적으로 허용되지 못하는 작업을 수행하게 될 수도 있다.</li>\n</ul>\n<p>위 상황을 예방하기 위해서는 다음 방법들을 사용해보자.</p>\n<ul>\n<li>객체를 final로 설정하여 하위 클래스 생성을 막자. (하지만 이것은 하위 클래스로의 확장 가능성 자체를 막아버리는 단점이 존재한다)</li>\n<li>final이 아닌 클래스라면 아무일을 하지 않는 finalize 메서드를 만들고 final로 선언한다.</li>\n</ul>\n<br>\n<h3 id=\"가장-좋은-해결-방법\" style=\"position:relative;\"><a href=\"#%EA%B0%80%EC%9E%A5-%EC%A2%8B%EC%9D%80-%ED%95%B4%EA%B2%B0-%EB%B0%A9%EB%B2%95\" aria-label=\"가장 좋은 해결 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>가장 좋은 해결 방법</h3>\n<ul>\n<li><code class=\"language-text\">AutoCloseable</code>을 구현하고 close 메서드를 호출해라.</li>\n<li>혹은 <code class=\"language-text\">try-with-resource</code>를 사용해라.</li>\n<li>번외로 각 객체는 자신이 닫혔는지를 항상 확인 하는 것이 좋다.  <code class=\"language-text\">close()</code> 메서드 내부에서 닫힐 때 필드에 저장하고 해당 객체를 호출할 때 필드를 검사해 만일 닫힌 객체였다면 <code class=\"language-text\">IllegalStateException</code>을 던져야 한다.</li>\n</ul>\n<br>\n<h3 id=\"그럼-언제-finalizercleaner를-사용하면-좋을까\" style=\"position:relative;\"><a href=\"#%EA%B7%B8%EB%9F%BC-%EC%96%B8%EC%A0%9C-finalizercleaner%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%A9%B4-%EC%A2%8B%EC%9D%84%EA%B9%8C\" aria-label=\"그럼 언제 finalizercleaner를 사용하면 좋을까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>그럼 언제 finalizer/cleaner를 사용하면 좋을까</h3>\n<ul>\n<li>\n<p>close를 호출하지 않은 것에 대한 안전망 역할</p>\n<ul>\n<li>자바의 경우 <code class=\"language-text\">FileInputStream</code>, <code class=\"language-text\">FileOutputStream</code>, <code class=\"language-text\">ThreadPoolExecutor</code> 는 안전망 finalizer를 제공한다.</li>\n</ul>\n</li>\n<li>\n<p>네이티브 피어(native peer)와 연결된 객체 관련 메모리 해제</p>\n<ul>\n<li>네이티브 피어는 네이티브 메서드로 기능을 위임한 네이티브 객체이다.</li>\n<li>자바 객체가 아니므로 GC는 그 존재를 알지 못한다.</li>\n<li>하지만 당장 자원이 회수되거나 성능 저하를 감수하지 않으려면 close 메서드를 사용해야 한다.</li>\n</ul>\n</li>\n<li>\n<p>cleaner 같은 경우는 Autocloseable의 안전망으로 많이 사용된다.</p>\n<ul>\n<li>예를 들어 아래 같은 경우에는 cleaner가 반드시 회수해야할 자원인 <code class=\"language-text\">numJunkPiles</code>를 청소한 후 객체를 닫는 것이다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Romm</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">AutoCloseable</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">Cleaner</span> cleaner <span class=\"token operator\">=</span> <span class=\"token class-name\">Cleaner</span><span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">State</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Runnable</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">//static class로 선언 !! </span>\n\t\t<span class=\"token keyword\">int</span> numJunkPiles<span class=\"token punctuation\">;</span>\n\n\t\t<span class=\"token class-name\">State</span><span class=\"token punctuation\">(</span>numJunkPiles<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t\t<span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>numJunkPiles <span class=\"token operator\">=</span> numJunkPiles<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 본래는 이 부분이 native peer 참조를 담는 final long 변수</span>\n\t\t<span class=\"token punctuation\">}</span>\n\n\t\t<span class=\"token annotation punctuation\">@Override</span>\n\t\t<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t\t<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"방 청소\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\tnumJunkPiles <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token punctuation\">}</span>\n\n\t<span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">State</span> state<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">Cleaner<span class=\"token punctuation\">.</span>Cleanable</span> cleanable<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">public</span> <span class=\"token class-name\">Room</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> numJunkPiles<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\tstate <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">State</span><span class=\"token punctuation\">(</span>numJunkPiles<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\tcleanable <span class=\"token operator\">=</span> cleaner<span class=\"token punctuation\">.</span><span class=\"token function\">register</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> state<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\n\t<span class=\"token annotation punctuation\">@Override</span>\n\t<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\tcleanable<span class=\"token punctuation\">.</span><span class=\"token function\">clean</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\t</code></pre></div>\n<ul>\n<li>위 코드에서 run 메서드가 호출되는 경우는 Room의 close 메서드를 호출하거나 cleaner가 State의 run 메서드를 호출하는 경우이다. (안정망)</li>\n<li><strong>여기서 주의할 점은 State 인스턴스가 Room 인스턴스를 참조하지 않는 것이다.</strong> 만일 참조하게 된다면 순환참조가 생겨서 GC가 Room 인스턴스를 절대로 회수 할 수 없다. 따라서 위 코드에서는 State가 정적 중첩 클래스로 구현이 되어 있다. 정적이 아닌 중첩 클래스는 자동으로 바깥 객체의 참조를 갖는다. (람다도 마찬가지이므로 조심해야 한다.)</li>\n<li>Cleaner는 단순한 안전망이기 때문에 반드시 <code class=\"language-text\">try-with-resource</code>를 사용하여 즉각적으로 <code class=\"language-text\">close()</code> 메서드가 호출되도록 구현하는 것이 가장 좋다.</li>\n</ul>\n</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#-%EC%95%84%EC%9D%B4%ED%85%9C-7-%EB%8B%A4-%EC%93%B4-%EA%B0%9D%EC%B2%B4-%EC%B0%B8%EC%A1%B0%EB%A5%BC-%ED%95%B4%EC%A0%9C%ED%95%98%EB%9D%BC\">🌩 [아이템 7] 다 쓴 객체 참조를 해제하라</a></p>\n<ul>\n<li><a href=\"#%EA%B0%9D%EC%B2%B4-%EC%B0%B8%EC%A1%B0%EB%A5%BC-%EC%A7%81%EC%A0%91-%ED%95%B4%EC%A0%9C%ED%95%B4%EC%95%BC-%ED%95%98%EB%8A%94-%EA%B2%BD%EC%9A%B0\">객체 참조를 직접 해제해야 하는 경우</a></li>\n<li><a href=\"#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%88%84%EC%88%98%EA%B0%80-%EC%9E%90%EC%A3%BC-%EB%B0%9C%EC%83%9D%ED%95%98%EB%8A%94-%EC%83%81%ED%99%A9\">메모리 누수가 자주 발생하는 상황</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-%EC%95%84%EC%9D%B4%ED%85%9C-8-finalizer%EC%99%80-cleaner-%EC%82%AC%EC%9A%A9%EC%9D%84-%ED%94%BC%ED%95%98%EB%9D%BC\">🌩 [아이템 8] finalizer와 cleaner 사용을 피하라</a></p>\n<ul>\n<li><a href=\"#%EC%88%98%ED%96%89-%EC%8B%9C%EC%A0%90%EC%9D%84-%EB%B3%B4%EC%9E%A5%ED%95%A0-%EC%88%98-%EC%97%86%EB%8B%A4\">수행 시점을 보장할 수 없다</a></li>\n<li><a href=\"#%EC%88%98%ED%96%89-%EC%97%AC%EB%B6%80%EB%A5%BC-%EB%B3%B4%EC%9E%A5%ED%95%A0-%EC%88%98-%EC%97%86%EB%8B%A4\">수행 여부를 보장할 수 없다</a></li>\n<li><a href=\"#%EC%98%88%EC%99%B8-%EB%B0%9C%EC%83%9D%EC%8B%9C-%EC%95%8C-%EC%88%98-%EC%97%86%EB%8B%A4\">예외 발생시 알 수 없다</a></li>\n<li><a href=\"#%EC%84%B1%EB%8A%A5-%EB%AC%B8%EC%A0%9C%EA%B0%80-%EB%B0%9C%EC%83%9D%ED%95%9C%EB%8B%A4\">성능 문제가 발생한다</a></li>\n<li><a href=\"#finalizer-%EA%B3%B5%EA%B2%A9%EC%97%90-%EB%85%B8%EC%B6%9C%EB%90%9C%EB%8B%A4\">finalizer 공격에 노출된다</a></li>\n<li><a href=\"#%EA%B0%80%EC%9E%A5-%EC%A2%8B%EC%9D%80-%ED%95%B4%EA%B2%B0-%EB%B0%A9%EB%B2%95\">가장 좋은 해결 방법</a></li>\n<li><a href=\"#%EA%B7%B8%EB%9F%BC-%EC%96%B8%EC%A0%9C-finalizercleaner%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%A9%B4-%EC%A2%8B%EC%9D%84%EA%B9%8C\">그럼 언제 finalizer/cleaner를 사용하면 좋을까</a></li>\n</ul>\n</li>\n</ul>\n</div>","excerpt":"이 글은 몇몇 크루들과 이펙티브 자바 스터디를 하며 정리한 내용입니다. 🙌 🌩 [아이템 7] 다 쓴 객체 참조를 해제하라 JVM 언어를 사용한다면 GC가 알아서 사용되지 않는 객체를 해제할텐데 왜 이런 항목이 있는걸까? 다음과 같은 경우에는 GC가 해당 객체가 다 쓴 객체인지 아닌지 판단할 수가 없다. Stack 자료구조를 구현한 예시이다. 다음과 같은 경우 다시 참조되지 않을 객체에 대한 해제가 이루어지지 않았기 때문에 ‘메모리 누수’가 발생한다. 이 프로그램이 오랜시간 실행이 되다보면 메모리 사용량이 늘어나 성능이 저하되거나 심하면 를 일으킬수도 있다. 위 코드와 같은 경우  배열에 더이상 사용되지 않는 영역의 객체 참조를 배열이 여전히 가지고 있다. 예를 들면  바깥에 존재하는 객체들에 대해서 말이다. 이렇게 GC에게 객체 처리를 맡기는 언어에서 이러한 메모리 누수를 찾기가 매우 어렵다. 또한 쓰이지 않지만 참조되고 있는 객체의 영향이 해당 객체에서 끝이 나는 것이 아니라 해…","frontmatter":{"date":"December 17, 2021","title":"이펙티브 자바 - 아이템 7 & 8","categories":"책 자바","author":"코다","emoji":"🐡"},"fields":{"slug":"/effective-java-7-8/"}},"next":{"id":"a5553174-ae11-5345-ad78-f1dd71b83e72","html":"<blockquote>\n<p>이 글은 몇몇 크루들과 이펙티브 자바 스터디를 하며 정리한 내용입니다. 🙌</p>\n</blockquote>\n<h2 id=\"-아이템-5-자원을-직접-명시하지-말고-의존-객체-주입을-사용하라\" style=\"position:relative;\"><a href=\"#-%EC%95%84%EC%9D%B4%ED%85%9C-5-%EC%9E%90%EC%9B%90%EC%9D%84-%EC%A7%81%EC%A0%91-%EB%AA%85%EC%8B%9C%ED%95%98%EC%A7%80-%EB%A7%90%EA%B3%A0-%EC%9D%98%EC%A1%B4-%EA%B0%9D%EC%B2%B4-%EC%A3%BC%EC%9E%85%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC\" aria-label=\" 아이템 5 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 [아이템 5] 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라</h2>\n<p>하나의 클래스에서 다른 자원에 의존하는 경우가 많다. 또한 해당 클래스가 유틸리티 클래스라면 싱글톤이나 정적 클래스로 사용되는 경우가 많다.</p>\n<blockquote>\n<p>정적 클래스로 구현한 경우</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">SpellChecker</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">Lexicon</span> dictionary <span class=\"token operator\">=</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">;</span>\n\t\n\tpriavte <span class=\"token class-name\">SpellChecker</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n\t<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">isValid</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> word<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<br>\n<blockquote>\n<p>싱글톤으로 구현한 경우</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">SpellChecker</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">Lexicon</span> dictionary <span class=\"token operator\">=</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">SpellChecker</span> INSTANCE <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SpellChecker</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\n\tpriavte <span class=\"token class-name\">SpellChecker</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n\t<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">isValid</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> word<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>그런 경우 여러 단점이 발생한다.</p>\n<ol>\n<li>유연하지 않다.\n<ul>\n<li>안에 의존하고 있는 객체를 런타임 시점에 바꾸거나 조작하기가 어렵다.</li>\n<li>여러 다른 사전들을 이용하고 싶을 때 변경에 자유롭지 못하다.</li>\n</ul>\n</li>\n<li>테스트하기 어렵다.\n<ul>\n<li>정적으로 의존 객체를 내부에서 생성하므로 모킹하거나 해당 객체에 대한 조작으로 테스트를 하기 어렵다.</li>\n</ul>\n</li>\n</ol>\n<br>\n<h3 id=\"의존성-주입di을-통해-해결하기\" style=\"position:relative;\"><a href=\"#%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%A3%BC%EC%9E%85di%EC%9D%84-%ED%86%B5%ED%95%B4-%ED%95%B4%EA%B2%B0%ED%95%98%EA%B8%B0\" aria-label=\"의존성 주입di을 통해 해결하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>의존성 주입(DI)을 통해 해결하기</h3>\n<p>위 문제에 대한 가능한 해결방법이 DI 말고 하나가 더 있다.</p>\n<ul>\n<li>변경에 대한 유연성을 부여하기 위해 <code class=\"language-text\">final</code>을 제거하고 여러 사전들을 바꿔서 사용할 수 있도록 한다.\n<ul>\n<li>이렇게 할 경우 멀티스레드 환경에 취약하고 오류를 내기가 쉽다.</li>\n</ul>\n</li>\n</ul>\n<p>따라서 DI를 통해서 문제를 해결해본다.</p>\n<p>DI란 클래스에서 필요한 자원을 내부에서 생성하는 것이 아니라 인스턴스를 생성할 때 생성자에 필요한 자원을 넘겨주는 방식으로 구현하는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">SpellChecker</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">Lexicon</span> dictionary<span class=\"token punctuation\">;</span>\n\t\n\tpriavte <span class=\"token class-name\">SpellChecker</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Lexicon</span> dictionary<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>dictionary <span class=\"token operator\">=</span> <span class=\"token class-name\">Objects</span><span class=\"token punctuation\">.</span><span class=\"token function\">requireNonNul</span><span class=\"token punctuation\">(</span>dictionary<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\n\t<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">isValid</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> word<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>여러 자원에 대한 의존 관계에 자유로우며 유연하다.</li>\n<li>불변을 보장하여 여러 클라이언트에 대한 공유에 안정적이다.</li>\n</ul>\n<p>추가적으로 특정 자원을 직접 넘겨주기보다 팩터리를 넘겨주어 필요시 자원을 클래스 내부에서 직접 생성할 수 있도록 할 수도 있다. 이때 <code class=\"language-text\">Supplier&lt;T></code> 처럼 한정적 와일드카드 타입(타입 안정성을 지원하는 Generic을 사용)을 통해 팩터리 매개변수를 넘겨서 필요한 자원을 생성하도록 한다.</p>\n<br>\n<h3 id=\"요약\" style=\"position:relative;\"><a href=\"#%EC%9A%94%EC%95%BD\" aria-label=\"요약 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>요약</h3>\n<ul>\n<li>클래스가 다른 자원에 의존한다면 그것을 직접 싱글톤이나 정적 클래스로 구현하는 것은 좋은 방법이 아니다.</li>\n<li>또한 그 자원들을 그 클래스가 직접 생성하도록 하지 않는 것이 더 좋다.</li>\n<li>대신 의존 객체 주입으로 외부에서 해당 자원이나 팩터리를 생성자나 정적 팩터리에 넘겨주도록 하자.</li>\n</ul>\n<br>\n<h2 id=\"-아이템-6-불필요한-객체-생성을-피하라\" style=\"position:relative;\"><a href=\"#-%EC%95%84%EC%9D%B4%ED%85%9C-6-%EB%B6%88%ED%95%84%EC%9A%94%ED%95%9C-%EA%B0%9D%EC%B2%B4-%EC%83%9D%EC%84%B1%EC%9D%84-%ED%94%BC%ED%95%98%EB%9D%BC\" aria-label=\" 아이템 6 불필요한 객체 생성을 피하라 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 [아이템 6] 불필요한 객체 생성을 피하라</h2>\n<p>현재 JVM의 성능이 좋아져 객체 생성이 이전만큼 비싼 작업은 아니지만 여전히 매번 생성하기에 무겁거나 지나치게 반복적으로 생성하여 성능에 안좋은 영향을 미치는 경우가 있다.</p>\n<p><strong>따라서 객체는 (특히 불변 객체는) 재사용할 수 있다면 재사용하는 것이 좋다.</strong></p>\n<br>\n<h3 id=\"string을-재사용-하자\" style=\"position:relative;\"><a href=\"#string%EC%9D%84-%EC%9E%AC%EC%82%AC%EC%9A%A9-%ED%95%98%EC%9E%90\" aria-label=\"string을 재사용 하자 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>String을 재사용 하자</h3>\n<ul>\n<li><code class=\"language-text\">new String(\"woowa\")</code> 는 만들때마다 heap영역에 새로운 객체를 생성한다. 만일 <code class=\"language-text\">new String(\"woowa\")</code> 를 두번 호출한다면 두개의 객체가 생성된다.</li>\n<li>반면 <code class=\"language-text\">String s = \"woowa\"</code> 를 호출한다면 heap영역 내부에 String constant pool에 객체가 생성되고 동일한 스트링이라면 재사용 한다.</li>\n</ul>\n<br>\n<h3 id=\"불변-클래스의-정적-팩터리-메서드로-객체를-재사용-하자\" style=\"position:relative;\"><a href=\"#%EB%B6%88%EB%B3%80-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%9D%98-%EC%A0%95%EC%A0%81-%ED%8C%A9%ED%84%B0%EB%A6%AC-%EB%A9%94%EC%84%9C%EB%93%9C%EB%A1%9C-%EA%B0%9D%EC%B2%B4%EB%A5%BC-%EC%9E%AC%EC%82%AC%EC%9A%A9-%ED%95%98%EC%9E%90\" aria-label=\"불변 클래스의 정적 팩터리 메서드로 객체를 재사용 하자 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>불변 클래스의 정적 팩터리 메서드로 객체를 재사용 하자</h3>\n<p>예를 들어 <code class=\"language-text\">Boolean(String)</code> 보다 <code class=\"language-text\">Boolean.valueOf(String)</code>을 사용하여 불변 객체를 재사용 하는 것이 더 빠르고 세련된 구현 방식이다.</p>\n<br>\n<h3 id=\"객체-생성이-비싼-객체라면-재사용-하자\" style=\"position:relative;\"><a href=\"#%EA%B0%9D%EC%B2%B4-%EC%83%9D%EC%84%B1%EC%9D%B4-%EB%B9%84%EC%8B%BC-%EA%B0%9D%EC%B2%B4%EB%9D%BC%EB%A9%B4-%EC%9E%AC%EC%82%AC%EC%9A%A9-%ED%95%98%EC%9E%90\" aria-label=\"객체 생성이 비싼 객체라면 재사용 하자 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>객체 생성이 비싼 객체라면 재사용 하자</h3>\n<p><code class=\"language-text\">String.matches()</code> 내부에서 사용되는 <code class=\"language-text\">Pattern</code> 객체는 매우 생성이 비싼 객체이다. 이 메서드를 반복해서 사용하면 내부에서 위 객체를 계속 생성하여 사용한다. 따라서 필요하다면 비교하고자 하는 정규식에 대한 <code class=\"language-text\">Pattern</code>을 미리 만들어두고 그것을 재사용하는 형식으로 사용하는 것이 훨씬 성능이 좋다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">RomanNumerals</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">Pattern</span> ROMAN <span class=\"token operator\">=</span> <span class=\"token class-name\">Pattern</span><span class=\"token punctuation\">.</span><span class=\"token function\">compile</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"정규식 ..\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">isRomanNumeral</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> s<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">return</span> ROMAN<span class=\"token punctuation\">.</span><span class=\"token function\">matcher</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">matches</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<br>\n<h3 id=\"오토박싱으로-생성되는-불필요한-객체를-주의하자\" style=\"position:relative;\"><a href=\"#%EC%98%A4%ED%86%A0%EB%B0%95%EC%8B%B1%EC%9C%BC%EB%A1%9C-%EC%83%9D%EC%84%B1%EB%90%98%EB%8A%94-%EB%B6%88%ED%95%84%EC%9A%94%ED%95%9C-%EA%B0%9D%EC%B2%B4%EB%A5%BC-%EC%A3%BC%EC%9D%98%ED%95%98%EC%9E%90\" aria-label=\"오토박싱으로 생성되는 불필요한 객체를 주의하자 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>오토박싱으로 생성되는 불필요한 객체를 주의하자</h3>\n<p>오토박싱으로 기본타입을 자동적으로 박싱된 타입으로 변환시켜준다. 하지만 명시적으로 객체를 생성하는 부분이 개발자에게 노출되지는 않기 때문에 예기치 않게 굉장히 많은 객체를 생성하고 있을 수도 있다. 따라서 성능에 큰 영향을 미칠수도 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">long</span> <span class=\"token function\">sum</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token class-name\">Long</span> sum <span class=\"token operator\">=</span> <span class=\"token number\">0L</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">long</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">.</span>MAX_VALUE<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\tsum <span class=\"token operator\">+=</span> i<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\n\t<span class=\"token keyword\">return</span> sum<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>예를 들어 위와 같은 코드는 sum 이라는 변수가 박싱타입으로 선언되어 있으므로 누적되는 <code class=\"language-text\">i</code>는 매번 <code class=\"language-text\">Long</code>으로 오토박싱되며 새로운 객체가 2^31개나 생성되는 일이 발생한다.</p>\n<p>이런 의도치 않은 오토박싱을 주의하고 되도록 기본타입을 사용하기를 추천한다.</p>\n<br>\n<h3 id=\"주의할-점\" style=\"position:relative;\"><a href=\"#%EC%A3%BC%EC%9D%98%ED%95%A0-%EC%A0%90\" aria-label=\"주의할 점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>주의할 점</h3>\n<p>객체 생성을 최대한 안하기 위해서 지나친 재사용을 하라는 뜻이 아니다. JVM에서 객체를 생성하는 것이 대부분 크게 부담되는 일이 아니기 때문에 프로그램의 안정성, 명확성, 간결성을 위해서 객체를 자주 생성하는 것은 바람직한 것이다.</p>\n<p>객체를 재사용하기 위해 무리하여 pool을 생성하는 것을 지양하자. 코드에서 직관적이지 않고 오히려 메모리 사용량을 늘릴 수 있다. 다만 엄청 비싼 자원이라면(DB 커넥션과 같이) pool을 사용하는 것이 적합하다.</p>\n<p>객체를 새로 생성하는 것이(예를 들면 방어적 복사) 프로그램 안정성 측면에서 훨씬 좋을 수 있다. 이럴때는 주저없이 객체를 재사용하기보다 새로 생성하는 것이 훨씬 좋다.</p>\n<br>\n<h3 id=\"느낀-점\" style=\"position:relative;\"><a href=\"#%EB%8A%90%EB%82%80-%EC%A0%90\" aria-label=\"느낀 점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>느낀 점</h3>\n<p>불필요하다고 명확히 느낄 때만 객체 생성을 지양하라는 것이지 무조건 객체를 재사용하기 위해서 무리하라는 것이 아니다. 마지막 부분에서 저자가 강조한 것처럼 트레이드 오프를 고려하고 지혜로운 결정을 내리는 것이 매우 중요하다.</p>\n<p>가끔 개발을 하다가 보면 “어디서 이렇게 하라고 했다.” 라고 이야기하면서 특정 방식을 적용하자고 하는 말을 자주 듣곤 한다. 하지만 대부분 그 지령은 절대 진리는 아니다. 상황에 따라서 적합한 것을 선택하는 것이 매우 중요한 개발자 역량이라고 생각한다.</p>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#-%EC%95%84%EC%9D%B4%ED%85%9C-5-%EC%9E%90%EC%9B%90%EC%9D%84-%EC%A7%81%EC%A0%91-%EB%AA%85%EC%8B%9C%ED%95%98%EC%A7%80-%EB%A7%90%EA%B3%A0-%EC%9D%98%EC%A1%B4-%EA%B0%9D%EC%B2%B4-%EC%A3%BC%EC%9E%85%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC\">🌩 [아이템 5] 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라</a></p>\n<ul>\n<li><a href=\"#%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%A3%BC%EC%9E%85di%EC%9D%84-%ED%86%B5%ED%95%B4-%ED%95%B4%EA%B2%B0%ED%95%98%EA%B8%B0\">의존성 주입(DI)을 통해 해결하기</a></li>\n<li><a href=\"#%EC%9A%94%EC%95%BD\">요약</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-%EC%95%84%EC%9D%B4%ED%85%9C-6-%EB%B6%88%ED%95%84%EC%9A%94%ED%95%9C-%EA%B0%9D%EC%B2%B4-%EC%83%9D%EC%84%B1%EC%9D%84-%ED%94%BC%ED%95%98%EB%9D%BC\">🌩 [아이템 6] 불필요한 객체 생성을 피하라</a></p>\n<ul>\n<li><a href=\"#string%EC%9D%84-%EC%9E%AC%EC%82%AC%EC%9A%A9-%ED%95%98%EC%9E%90\">String을 재사용 하자</a></li>\n<li><a href=\"#%EB%B6%88%EB%B3%80-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%9D%98-%EC%A0%95%EC%A0%81-%ED%8C%A9%ED%84%B0%EB%A6%AC-%EB%A9%94%EC%84%9C%EB%93%9C%EB%A1%9C-%EA%B0%9D%EC%B2%B4%EB%A5%BC-%EC%9E%AC%EC%82%AC%EC%9A%A9-%ED%95%98%EC%9E%90\">불변 클래스의 정적 팩터리 메서드로 객체를 재사용 하자</a></li>\n<li><a href=\"#%EA%B0%9D%EC%B2%B4-%EC%83%9D%EC%84%B1%EC%9D%B4-%EB%B9%84%EC%8B%BC-%EA%B0%9D%EC%B2%B4%EB%9D%BC%EB%A9%B4-%EC%9E%AC%EC%82%AC%EC%9A%A9-%ED%95%98%EC%9E%90\">객체 생성이 비싼 객체라면 재사용 하자</a></li>\n<li><a href=\"#%EC%98%A4%ED%86%A0%EB%B0%95%EC%8B%B1%EC%9C%BC%EB%A1%9C-%EC%83%9D%EC%84%B1%EB%90%98%EB%8A%94-%EB%B6%88%ED%95%84%EC%9A%94%ED%95%9C-%EA%B0%9D%EC%B2%B4%EB%A5%BC-%EC%A3%BC%EC%9D%98%ED%95%98%EC%9E%90\">오토박싱으로 생성되는 불필요한 객체를 주의하자</a></li>\n<li><a href=\"#%EC%A3%BC%EC%9D%98%ED%95%A0-%EC%A0%90\">주의할 점</a></li>\n<li><a href=\"#%EB%8A%90%EB%82%80-%EC%A0%90\">느낀 점</a></li>\n</ul>\n</li>\n</ul>\n</div>","frontmatter":{"date":"December 16, 2021","title":"이펙티브 자바 - 아이템 5 & 6","categories":"책 자바","author":"코다","emoji":"🐡"},"fields":{"slug":"/effective-java-5-6/"}},"prev":{"id":"f03042d6-9c85-5531-bfa4-8dd1a2797b05","html":"<blockquote>\n<p>이 글은 몇몇 크루들과 이펙티브 자바 스터디를 하며 정리한 내용입니다. 🙌</p>\n</blockquote>\n<h2 id=\"-아이템-9-try-finally-보다는-try-with-resources를-사용하라\" style=\"position:relative;\"><a href=\"#-%EC%95%84%EC%9D%B4%ED%85%9C-9-try-finally-%EB%B3%B4%EB%8B%A4%EB%8A%94-try-with-resources%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC\" aria-label=\" 아이템 9 try finally 보다는 try with resources를 사용하라 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 [아이템 9] try-finally 보다는 try-with-resources를 사용하라</h2>\n<p>자바에서 close 메서드를 직접 호출해서 닫아주어야하는 자원들</p>\n<ul>\n<li><code class=\"language-text\">InputStream</code>, <code class=\"language-text\">OutputStream</code>, <code class=\"language-text\">java.sql.Connection</code> 등등</li>\n</ul>\n<br>\n<h3 id=\"try-finally-사용시-단점\" style=\"position:relative;\"><a href=\"#try-finally-%EC%82%AC%EC%9A%A9%EC%8B%9C-%EB%8B%A8%EC%A0%90\" aria-label=\"try finally 사용시 단점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>try-finally 사용시 단점</h3>\n<ul>\n<li>try-finally를 사용한다면 닫아야 하는 자원이 많아질수록 매우 복잡해진다.</li>\n<li>try 블록과 finally 블록에서 모두 예외가 발생할 수 있는데, 만일 둘다 예외가 발생했을 경우 이후에 일어난 예외가 첫번째 예외를 삼켜서 디버깅을 어렵게 한다.</li>\n</ul>\n<br>\n<h3 id=\"try-with-resources로-해결\" style=\"position:relative;\"><a href=\"#try-with-resources%EB%A1%9C-%ED%95%B4%EA%B2%B0\" aria-label=\"try with resources로 해결 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>try-with-resources로 해결</h3>\n<ul>\n<li>짧고 간결하여 읽기가 수월하다.</li>\n<li>try 내부와 <code class=\"language-text\">close()</code>에서 모두 예외가 발생 하더라도 첫번째 예외만 보여지고 두번째 예외는 <code class=\"language-text\">suppressed</code> 되어 출력된다.</li>\n<li>catch 블록을 함께 사용하여 여러 예외를 처리할 수 있다.</li>\n</ul>\n<br>\n<h2 id=\"-아이템-10-equals는-일반-규약을-지켜-재정의하라\" style=\"position:relative;\"><a href=\"#-%EC%95%84%EC%9D%B4%ED%85%9C-10-equals%EB%8A%94-%EC%9D%BC%EB%B0%98-%EA%B7%9C%EC%95%BD%EC%9D%84-%EC%A7%80%EC%BC%9C-%EC%9E%AC%EC%A0%95%EC%9D%98%ED%95%98%EB%9D%BC\" aria-label=\" 아이템 10 equals는 일반 규약을 지켜 재정의하라 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌩 [아이템 10] equals는 일반 규약을 지켜 재정의하라</h2>\n<p>대부분은 <code class=\"language-text\">equals</code>를 재정의 하지 않는 것이 가장 좋다. 책에서는 특히나 다음과 같은 경우면 재정의 하지 않는 것을 추천한다.</p>\n<ol>\n<li>각 인스턴스가 본질적으로 고유하다.</li>\n<li>인스턴스의 ‘논리적 동치성(logical equality)‘를 검사할 일이 없다.</li>\n<li>상위 클래스의 equals가 하위 클래스에도 적합하게 구현되어 있다.</li>\n<li>클래스가 private이거나 package-private이고 equals를 호출할 일이 없다.</li>\n<li>인스턴스가 하나만 만들어지도록 통제되는 싱글톤이나 enum 인 경우이다.</li>\n</ol>\n<p><strong>다음과 같은 경우는 equals를 재정의 하는 것이 좋다.</strong></p>\n<ul>\n<li>객체의 식별성(identity)가 아닌 논리적 동치성을 확인해야 할 때 (VO 같은 경우)</li>\n</ul>\n<br>\n<h3 id=\"object-명세에-적힌-일반-규약\" style=\"position:relative;\"><a href=\"#object-%EB%AA%85%EC%84%B8%EC%97%90-%EC%A0%81%ED%9E%8C-%EC%9D%BC%EB%B0%98-%EA%B7%9C%EC%95%BD\" aria-label=\"object 명세에 적힌 일반 규약 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Object 명세에 적힌 일반 규약</h3>\n<blockquote>\n<p>equals는 동치관계(equivalence relation)을 구현하며 다음을 만족한다.</p>\n</blockquote>\n<p><code class=\"language-text\">Object</code> 명세에서 말하는 <strong>동치관계</strong>란 무엇일까?</p>\n<ul>\n<li>집합을 서로 같은 원소의 부분집합으로 나누고 같은 집합 속에 있는 원소는 서로 언제나 교환될 수 있어야 하는 것이다.</li>\n</ul>\n<br>\n<p>첫 번째 조건, <strong>반사성</strong></p>\n<ul>\n<li>객체는 자기 자신과 같아야 한다.</li>\n<li><code class=\"language-text\">x.equals(x) == true</code></li>\n</ul>\n<br>\n<p>두 번째 조건, <strong>대칭성</strong></p>\n<ul>\n<li>\n<p>두 객체의 동치 여부는 같아야 한다.</p>\n</li>\n<li>\n<p><code class=\"language-text\">x.equals(y) == true</code>면 <code class=\"language-text\">y.equals(x) == true</code></p>\n</li>\n<li>\n<p>다음 예에서는 대칭성이 만족되지 않은 경우이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">CasInsensitiveString</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">String</span> s<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">public</span> <span class=\"token class-name\">CasInsensitiveString</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> s<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>s <span class=\"token operator\">=</span> <span class=\"token class-name\">Objects</span><span class=\"token punctuation\">.</span><span class=\"token function\">requireNonNull</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\n\t<span class=\"token annotation punctuation\">@Override</span>\n\t<span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">equals</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> o<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>o <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">CasInsensitiveString</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t\t<span class=\"token keyword\">return</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">equalsIgnoreCase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">CasInsensitiveString</span><span class=\"token punctuation\">)</span> o<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>s<span class=\"token punctuation\">;</span>\n\n\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>o <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">// 문제가 되는 지점 !!! </span>\n\t\t\t<span class=\"token keyword\">return</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">equalsIgnoreCase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">)</span> o<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">}</span>\n\n\t\t<span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>위 코드에서는 <code class=\"language-text\">CasInsensitiveString</code> 클래스 인스턴스 뿐 아니라 String에 대해서도 equals 메서드를 지원한다. 여기서 문제는 <code class=\"language-text\">CasInsensitiveString**.**equals(String)</code> 의 경우는 잘 성립하는데 <code class=\"language-text\">String.equals(CasInsensitiveString)</code>는 성립하지 않는다.</li>\n<li>이렇게 대칭성이 성립되지 않으면 해당 객체를 사용하는 다른 객체들의 결과를 예측하기가 어렵다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<p>세 번째 조건, <strong>추이성</strong></p>\n<ul>\n<li>\n<p>a, b가 동치고 b, c가 동치면 a, c도 동치이다.</p>\n</li>\n<li>\n<p>주로 구체 클래스의 하위 클래스에서 추가가 된 필드에 대해서 equals를 추가하려고 할 때 발생한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token comment\">// 추이성이 깨지는 경우</span>\n<span class=\"token class-name\">ColorPoint</span> p1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ColorPoint</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Color</span><span class=\"token punctuation\">.</span>RED<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token class-name\">Point</span> p2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Point</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n<span class=\"token class-name\">ColorPoint</span> p3 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ColorPoint</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Color</span><span class=\"token punctuation\">.</span>BLUE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\np1<span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>p2<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 위치만 비교</span>\np2<span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>p3<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 위치만 비교</span>\n\np1<span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>p3<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 색상까지 비교 </span></code></pre></div>\n</li>\n<li>\n<p><code class=\"language-text\">ColorPoint</code>의 <code class=\"language-text\">equals()</code> 내부 구현을 보면 다음과 같이 되어 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Override</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">equals</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> o<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token punctuation\">(</span>o <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Point</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\n\t<span class=\"token comment\">// 만일 o가 Point면 좌표만 비교한다. </span>\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token punctuation\">(</span>o <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">ColorPoint</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> \n\t\t<span class=\"token keyword\">return</span> o<span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\n\t<span class=\"token keyword\">return</span> <span class=\"token keyword\">super</span><span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>o<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ColorPoint</span> o<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>color <span class=\"token operator\">=</span> color<span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li>이런 식으로 구현이 되었을 때 주의할 점은 무한 재귀에 빠질 수도 있다는 것이다. 위와 같이 구현된 <code class=\"language-text\">SmellPoint</code> 를 만들고 <code class=\"language-text\">myColorPoint.equals(mySmellPoint)</code>를 호출하면 무한 재귀로 인해 <code class=\"language-text\">StackOverflowError</code>를 일으킨다.</li>\n<li><code class=\"language-text\">instanceof</code> 대신 <code class=\"language-text\">getClass()</code> 를 쓸수 있지만 이것은 LSP를 위반하여 하위 클래스가 상위 클래스 대신 대체될 수 없다.</li>\n</ul>\n</li>\n<li>\n<p>가능한 해결 방법은 추상 클래스의 하위 클래스를 활용하던지 상속보다 컴포지션 룰을 적용하던지이다.</p>\n</li>\n</ul>\n<br>\n<p>네 번째 조건, <strong>일관성</strong></p>\n<p>두 객체가 같다면 수정이 되기 전까지 앞으로도 같아야 한다는 뜻이다. 특히 불변 클래스라면 한번 같다면 영원히 같아야 한다.</p>\n<p><strong>일관성</strong> 조건을 만족시키기 위해서는 equals에 신뢰할 수 있는 자원만 들어와야 한다. 예를 들어서 특정 URL의 IP주소가 그 자원 중 하나라면 이것은 네트워크에 따라서 매번 달라질 수 있기 때문에 항상 결과가 같지 않다.</p>\n<br>\n<p>다섯 번째 조건, <strong>null-아님</strong></p>\n<p>모든 객체가 null과 같지 않아야 한다는 뜻이다. 동치성을 검사하기 위해서 받은 객체를 적절히 형변환 하여 필드 값을 알아내기 때문에 여기서 <code class=\"language-text\">instanceof</code> 로 검사할 때 <code class=\"language-text\">ClassCastException</code>으로 예외를 발생시킨다.</p>\n<br>\n<h3 id=\"좋은-equals-메서드-구현하기\" style=\"position:relative;\"><a href=\"#%EC%A2%8B%EC%9D%80-equals-%EB%A9%94%EC%84%9C%EB%93%9C-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0\" aria-label=\"좋은 equals 메서드 구현하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>좋은 equals 메서드 구현하기</h3>\n<ol>\n<li><code class=\"language-text\">==</code> 를 통해 자기 자신이면 <code class=\"language-text\">true</code> 반환한다.</li>\n<li><code class=\"language-text\">instanceof</code> 로 입력의 타입을 검증한다.</li>\n<li>입력을 올바른 타입으로 형변환 한다.</li>\n<li>입력 객체와 자신의 <strong>핵심 필드</strong>는 모두 일치하는지 검사한다.</li>\n</ol>\n<ul>\n<li>자바에서 float와 double 같은 경우는 정적 메서드인 <code class=\"language-text\">Float.compare</code>와 <code class=\"language-text\">Double.compare</code>로 비교한다. 특수한 부동소수 값 때문이다.</li>\n<li>null을 정상값으로 취급하는 참조 타입 필드가 있다면 <code class=\"language-text\">Objects.equals(Object, Object)</code>를 사용하여 NPE를 방지하자.</li>\n<li><code class=\"language-text\">CaseInsensitiveString</code> 처럼 다루기 복잡한 클래스라면 해당 필드의 표준형(canonical form)을 저장하여 표준형 끼리 비교하자. 가변이라면 이 표준형을 매번 갱신해야해서 어렵지만 불변이라면 더욱 적합하다.</li>\n</ul>\n<br>\n<h3 id=\"equals의-성능-고려하기\" style=\"position:relative;\"><a href=\"#equals%EC%9D%98-%EC%84%B1%EB%8A%A5-%EA%B3%A0%EB%A0%A4%ED%95%98%EA%B8%B0\" aria-label=\"equals의 성능 고려하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>equals의 성능 고려하기</h3>\n<ul>\n<li>다를 가능성이 크거나 비교하는 비용이 싼 필드를 먼저 비교하는 것이 좋다.</li>\n<li>객체의 논리적 상태와 관련이 없는 필드(락 필드 등등)는 비교하지 않도록 한다.</li>\n<li>equals를 재정의할 때 hashCode도 함께 재정의 해야 한다.</li>\n<li>필드의 동치성만 검사해도 equals 규약이 대부분 만족되니 너무 복잡하게 구현하지 않는 것이 좋다.</li>\n<li>equals의 매개변수는 반드시 Object 이도록 한다.</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#-%EC%95%84%EC%9D%B4%ED%85%9C-9-try-finally-%EB%B3%B4%EB%8B%A4%EB%8A%94-try-with-resources%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC\">🌩 [아이템 9] try-finally 보다는 try-with-resources를 사용하라</a></p>\n<ul>\n<li><a href=\"#try-finally-%EC%82%AC%EC%9A%A9%EC%8B%9C-%EB%8B%A8%EC%A0%90\">try-finally 사용시 단점</a></li>\n<li><a href=\"#try-with-resources%EB%A1%9C-%ED%95%B4%EA%B2%B0\">try-with-resources로 해결</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-%EC%95%84%EC%9D%B4%ED%85%9C-10-equals%EB%8A%94-%EC%9D%BC%EB%B0%98-%EA%B7%9C%EC%95%BD%EC%9D%84-%EC%A7%80%EC%BC%9C-%EC%9E%AC%EC%A0%95%EC%9D%98%ED%95%98%EB%9D%BC\">🌩 [아이템 10] equals는 일반 규약을 지켜 재정의하라</a></p>\n<ul>\n<li><a href=\"#object-%EB%AA%85%EC%84%B8%EC%97%90-%EC%A0%81%ED%9E%8C-%EC%9D%BC%EB%B0%98-%EA%B7%9C%EC%95%BD\">Object 명세에 적힌 일반 규약</a></li>\n<li><a href=\"#%EC%A2%8B%EC%9D%80-equals-%EB%A9%94%EC%84%9C%EB%93%9C-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0\">좋은 equals 메서드 구현하기</a></li>\n<li><a href=\"#equals%EC%9D%98-%EC%84%B1%EB%8A%A5-%EA%B3%A0%EB%A0%A4%ED%95%98%EA%B8%B0\">equals의 성능 고려하기</a></li>\n</ul>\n</li>\n</ul>\n</div>","frontmatter":{"date":"December 18, 2021","title":"이펙티브 자바 - 아이템 9 & 10","categories":"책 자바","author":"코다","emoji":"🐡"},"fields":{"slug":"/effective-java-9-10/"}},"site":{"siteMetadata":{"siteUrl":"https://yjksw.github.io","comments":{"utterances":{"repo":"yjksw/yjksw.github.io"}}}}},"pageContext":{"slug":"/effective-java-7-8/","nextSlug":"/effective-java-5-6/","prevSlug":"/effective-java-9-10/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}
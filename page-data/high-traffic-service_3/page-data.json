{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/high-traffic-service_3/",
    "result": {"data":{"cur":{"id":"fe08b31d-d1b9-5132-8265-561e8d82be9a","html":"<blockquote>\n<p>다음은 웹 개발자를 위한 대규모 서비스를 지탱하는 기술을 읽고 정리한 내용입니다 🙌</p>\n</blockquote>\n<br>\n<h2 id=\"강의8-os-캐시-구조\" style=\"position:relative;\"><a href=\"#%EA%B0%95%EC%9D%988-os-%EC%BA%90%EC%8B%9C-%EA%B5%AC%EC%A1%B0\" aria-label=\"강의8 os 캐시 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[강의8] OS 캐시 구조</h2>\n<h2 id=\"os의-캐시-구조를-알고-애플리케이션-작성하기---페이지-캐시\" style=\"position:relative;\"><a href=\"#os%EC%9D%98-%EC%BA%90%EC%8B%9C-%EA%B5%AC%EC%A1%B0%EB%A5%BC-%EC%95%8C%EA%B3%A0-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EC%9E%91%EC%84%B1%ED%95%98%EA%B8%B0---%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C\" aria-label=\"os의 캐시 구조를 알고 애플리케이션 작성하기   페이지 캐시 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>OS의 캐시 구조를 알고 애플리케이션 작성하기 - 페이지 캐시</h2>\n<ul>\n<li>OS는 메모리를 이용해서 캐시 구조를 갖추고 디스크 액세스를 줄인다.</li>\n</ul>\n<h3 id=\"linuxx86-페이징-구조\" style=\"position:relative;\"><a href=\"#linuxx86-%ED%8E%98%EC%9D%B4%EC%A7%95-%EA%B5%AC%EC%A1%B0\" aria-label=\"linuxx86 페이징 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Linux(x86) 페이징 구조</h3>\n<p>OS는 가장 메모리 구조를 가지고 있는데 논리적인 선형 어드레스를 물리적인 어드레스로 변환한다.</p>\n<h2 id=\"가상-메모리-구조\" style=\"position:relative;\"><a href=\"#%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0\" aria-label=\"가상 메모리 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>가상 메모리 구조</h2>\n<p>기본적인 OS 구조를 보면 OS에서 관리하고 있는 메모리 구조 있고, OS가 있으며 OS에서 돌아가는 프로세스가 존재한다. 프로세스에서 메모리가 필요한 경우 메모리에 직접 접근해서 주소를 가져오는 것이 아니라, OS를 통해서 비어있는 주소와 다른 주소를 반환한다.</p>\n<h3 id=\"왜-가상-주소를-반환할까\" style=\"position:relative;\"><a href=\"#%EC%99%9C-%EA%B0%80%EC%83%81-%EC%A3%BC%EC%86%8C%EB%A5%BC-%EB%B0%98%ED%99%98%ED%95%A0%EA%B9%8C\" aria-label=\"왜 가상 주소를 반환할까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>왜 가상 주소를 반환할까?</h3>\n<p>개별 프로세스가 실제로 메모리의 어느 부분을 사용하는지 스스로 알고 있을 필요가 없고, 특정 번지에서 통일해서 시작하는 것으로 다루면 더 쉽기 때문이다.</p>\n<ul>\n<li>예) 유닉스에서 공유 라이브러리는 프로세스 내에서 지정된 주소로 할당이 되어 있는데 프로세스 내에서 이 특정 어드레스는 예약에 되어 있음. 따라서 시작주소가 다 다르면 메모리를 확보할 주소위치를 찾기가 어려움</li>\n</ul>\n<p>어쨌든 OS 커널에서 메모리를 추상화해서 넘기고 있다 !!!</p>\n<p>또한 OS에서 메모리를 확보할 때도 단일 바이트 만큼씩 액세스 하는 것이 아니라 4KB 정도의 블록을 확보해서 프로세스에 넘긴다. <strong>블록 = 페이지 (즉, OS가 메모리를 확보하는 단위)</strong></p>\n<p>OS는 메모리 요청을 받을 때 필요한 만큼의 페이지를 확보해서 프로세스에 넘긴다.</p>\n<h2 id=\"linux-페이지-캐시의-원리\" style=\"position:relative;\"><a href=\"#linux-%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C%EC%9D%98-%EC%9B%90%EB%A6%AC\" aria-label=\"linux 페이지 캐시의 원리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Linux 페이지 캐시의 원리</h2>\n<p>OS는 확보한 페이지를 메모리상에 캐싱해둔다.</p>\n<h3 id=\"프로세스가-디스크에서-데이터를-읽어내는-과정\" style=\"position:relative;\"><a href=\"#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EA%B0%80-%EB%94%94%EC%8A%A4%ED%81%AC%EC%97%90%EC%84%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A5%BC-%EC%9D%BD%EC%96%B4%EB%82%B4%EB%8A%94-%EA%B3%BC%EC%A0%95\" aria-label=\"프로세스가 디스크에서 데이터를 읽어내는 과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>프로세스가 디스크에서 데이터를 읽어내는 과정</h3>\n<p>첫번째, 우선 디스크로부터 4KB 정도의 블록을 읽어냄</p>\n<p>두번째, 우선 메모리에 해당 읽어낸 데이터를 위치시킴</p>\n<ul>\n<li>프로세스는 디스크에서 데이터를 직접 읽을 수는 없다 ! 프로세스가 액세스 할 수 있는 것은 가상 메모리 주소이기 때문이다.</li>\n</ul>\n<p>세번째, OS는 메모리에 쓰인 블록의 해당 주소를 프로세스에 가상 주소로 변환해서 알려준다.</p>\n<p>네번째, 프로세스는 해당 가상 주소로 메모리에 액세스 하게 된다.</p>\n<p align=\"center\"><img width=\"85%\" src=\"https://user-images.githubusercontent.com/63405904/136983984-be05b727-15c4-485c-8cf8-9f349a1d3fff.png\"><br>이미지 출처: 대용량 서비스를 지탱하는 기술</p>\n<p><strong>페이지 캐시 등장 -</strong> 이후에 더이상 프로세스가 데이터가 필요하지 않더라도 메모리에 쓰인 블럭을 해제하지 않고 남겨둔다. 그럼 다음 프로세스가 같은 디스크에 액세스할 때 해당 페이지를 재사용한다.</p>\n<h3 id=\"페이지-캐시의-효과\" style=\"position:relative;\"><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C%EC%9D%98-%ED%9A%A8%EA%B3%BC\" aria-label=\"페이지 캐시의 효과 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>페이지 캐시의 효과</h3>\n<p>리눅스의 페이지 캐시는 모든 I/O에 작용(예외를 제외하고)하여 디스크를 최초 읽은 이후 두번째 액세스부터 빨라진다. (OS를 계속 가동시켜두면 빨라진다. 재부팅 시 메모리에 캐시된 데이터는 없어진다.)</p>\n<h2 id=\"vfs\" style=\"position:relative;\"><a href=\"#vfs\" aria-label=\"vfs permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>VFS</h2>\n<p>리눅스의 구조는 다음과 같다.</p>\n<ul>\n<li>최하위에 하드디스크를 조작하는 디바이스 드라이버 → 위에 여러 파일 시스템 (리눅스의 경우 ext3, ext2, ext4, 등등) → vfs (virtual file system)</li>\n<li>파일시스템은 다양한 함수를 갖추고 있는데 인터페이스를 통일하기 위해 있는 것이 vfs 이다.</li>\n</ul>\n<p>VFS가 페이지 캐시 구조를 가지고 있다. → 어떤 파일 시스템을 이용하여 어떤 디스크를 읽어도 vfs를 통해서 동일한 구조로 캐싱이 된다.</p>\n<p><strong>한마디로, VFS의 역할은 파일시스템 추상화와 성능에 관여하는 페이지 캐시 부분이다.</strong></p>\n<h2 id=\"리눅스는-페이지-단위로-디스크를-캐싱\" style=\"position:relative;\"><a href=\"#%EB%A6%AC%EB%88%85%EC%8A%A4%EB%8A%94-%ED%8E%98%EC%9D%B4%EC%A7%80-%EB%8B%A8%EC%9C%84%EB%A1%9C-%EB%94%94%EC%8A%A4%ED%81%AC%EB%A5%BC-%EC%BA%90%EC%8B%B1\" aria-label=\"리눅스는 페이지 단위로 디스크를 캐싱 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>리눅스는 페이지 단위로 디스크를 캐싱</h2>\n<h3 id=\"왜-파일-캐시가-아니라-페이지-캐시일까-\" style=\"position:relative;\"><a href=\"#%EC%99%9C-%ED%8C%8C%EC%9D%BC-%EC%BA%90%EC%8B%9C%EA%B0%80-%EC%95%84%EB%8B%88%EB%9D%BC-%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C%EC%9D%BC%EA%B9%8C-\" aria-label=\"왜 파일 캐시가 아니라 페이지 캐시일까  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>왜 파일 캐시가 아니라 페이지 캐시일까 ?</h3>\n<p>만일 메모리에 남은 여유 메모리 공간이 1.5 GB이고 필요한 파일이 4GB 일 경우 문제가 발생한다.</p>\n<p>OS는 파일(현재 4GB 단위) 기준으로 캐싱하는 것이 아니라 블록 단위(4KB 단위)만으로 캐싱한다. 특정 파일의 읽어낸 일부분만 캐싱한다.</p>\n<ul>\n<li><strong>페이지 == 가상 메모리의 최소단위</strong></li>\n</ul>\n<h3 id=\"lru\" style=\"position:relative;\"><a href=\"#lru\" aria-label=\"lru permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>LRU</h3>\n<p>만일 적은 여유분의 메모리에 4GB 파일을 모두 읽게 된다면 LRU(Least Recently Used) 방식으로 캐싱이 최신화 된다. 따라서 DB 서버도 계속 구동시키면 캐시가 최적화되어 I/O 부하가 내려간다.</p>\n<h3 id=\"어떻게-캐싱이-될까\" style=\"position:relative;\"><a href=\"#%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%BA%90%EC%8B%B1%EC%9D%B4-%EB%90%A0%EA%B9%8C\" aria-label=\"어떻게 캐싱이 될까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>어떻게 캐싱이 될까</h3>\n<p>리눅스는 파일을 i노드 번호라는 번호로 식별하고 어느 위치에서 시작하는 오프셋을 제공하여 두가지 정보를 함께 캐싱한다. 따라서 파일 전체가 아닌 일부분을 캐싱할 수 있다.</p>\n<p>이 키가 너무 많으면 파일이 클 경우 데이터 찾는 것이 어렵다고 여겨질 수 있는 데이터 구조는 <strong>Radix Tree</strong>라는 구조로 탐색 속도가 떨어지지 않는다.</p>\n<h2 id=\"메모리가-비어있으면-캐싱\" style=\"position:relative;\"><a href=\"#%EB%A9%94%EB%AA%A8%EB%A6%AC%EA%B0%80-%EB%B9%84%EC%96%B4%EC%9E%88%EC%9C%BC%EB%A9%B4-%EC%BA%90%EC%8B%B1\" aria-label=\"메모리가 비어있으면 캐싱 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>메모리가 비어있으면 캐싱</h2>\n<p>리눅스는 메모리가 비어있으면 모두 캐싱 → 프로세스에 메모리가 필요하면 오래돈 캐시를 버리고 메모리 확보</p>\n<ul>\n<li>\n<p>메모리 상황 알아보기</p>\n<p><code class=\"language-text\">sar -r</code> 명령어를 통해서 <code class=\"language-text\">kbcached</code>(kilo byte cached) 부분과 <code class=\"language-text\">%memused</code> 부분으로 확인할 수 있다. 주로 꽉찬 메모리를 확인할 수 있는데 이것은 문제가 아니다. 본래 리눅스는 가용 가능한 메모리에 조금씩 디스크를 모두 캐싱하고 추가 메모리가 필요하면 오래된 캐시를 파기한다.</p>\n</li>\n</ul>\n<h2 id=\"메모리-늘려서-io-부하-줄이기\" style=\"position:relative;\"><a href=\"#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%8A%98%EB%A0%A4%EC%84%9C-io-%EB%B6%80%ED%95%98-%EC%A4%84%EC%9D%B4%EA%B8%B0\" aria-label=\"메모리 늘려서 io 부하 줄이기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>메모리 늘려서 I/O 부하 줄이기</h2>\n<p>메모리보다 디스크에 저장된 용량이 적으면 디스크의 모든 파일이 메모리에 캐싱되어 디스크 액세스가 일어나지 않게 된다. 따라서 메모리가 늘어날 수록 I/O 부하가 줄어든다.</p>\n<h2 id=\"페이지-캐시는-투과적으로-작용\" style=\"position:relative;\"><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C%EB%8A%94-%ED%88%AC%EA%B3%BC%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%9E%91%EC%9A%A9\" aria-label=\"페이지 캐시는 투과적으로 작용 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>페이지 캐시는 투과적으로 작용</h2>\n<p>부팅 직후 파일을 그렇게 많이 읽지 않았을 때 그 이후 갑자기 큰 파일을 읽으면 해당 파일이 캐싱이 되기 때문에 갑자기 메모리 사용 용량이 높아진다.</p>\n<h2 id=\"code-classlanguage-textsarcode-명령어로-os-지표-확인하기\" style=\"position:relative;\"><a href=\"#code-classlanguage-textsarcode-%EB%AA%85%EB%A0%B9%EC%96%B4%EB%A1%9C-os-%EC%A7%80%ED%91%9C-%ED%99%95%EC%9D%B8%ED%95%98%EA%B8%B0\" aria-label=\"code classlanguage textsarcode 명령어로 os 지표 확인하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"language-text\">sar</code> 명령어로 os 지표 확인하기</h2>\n<ol>\n<li>\n<p>과거 OS 데이터 확인하기  - <code class=\"language-text\">sar -f {/var/log/sa/sa04} | head</code> 명령어로 과거 데이터의 로그 파일을 확인하여 장애 발생 원인을 확인 할 수 있다.</p>\n<ul>\n<li>프로그램 교체 후 전후 비교를 위해서 위 sar 데이터를 활용할 수 있음</li>\n</ul>\n</li>\n<li>\n<p>현재 데이터 확인하기 - <code class=\"language-text\">sar 1 3</code></p>\n<ul>\n<li>1초 간격으로 3회 동안 OS 데이터를 확인</li>\n<li>지금 이 순간 시스템에서 일어나고 있는지 확인할 수 있음</li>\n</ul>\n</li>\n<li>\n<p>멀티 코어일 경우 <code class=\"language-text\">sar -p</code> 옵션으로 CPU 별 데이터 확인 가능</p>\n</li>\n<li>\n<p>디폴트 <code class=\"language-text\">sar</code> (<code class=\"language-text\">sar -u</code>에 해당함) -</p>\n<p align=\"center\"><img width=\"85%\" src=\"https://user-images.githubusercontent.com/63405904/136984234-20945113-1236-42e4-b23b-3a9289e74d83.png\"><br>이미지 출처: 대용량 서비스를 지탱하는 기술</p>\n<ul>\n<li>user → 사용자 모드에서 CPU가 소비된 시간 비율</li>\n<li>nice → nice로 스캐줄링의 우선도 변경한 프로세스가 사용자모드에서 CPU를 소비한 비율</li>\n<li>system → 시스템 모드에서 CPU가 소비된 시간 비율</li>\n<li>iowait → CPU가 디스크 I/O대기 위해 Idle 상태로 소비한 시간 비율</li>\n<li>steal → OS 가상화 이용시 다른 가상 CPU 계산으로 대기된 시간 비율</li>\n<li>idle → CPU가 디스크 I/O 등으로 대기되지 않고 Idle 상대로 소비한 시간 비율 (프로세스가 실행하고 있지 않은 상태)</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">sar -q</code> - Load Average 확인</p>\n<ul>\n<li>실행큐에 쌓여있는 프로세스 수, 시스템상의 프로세스 사이즈, load average 참조 가능</li>\n<li>시간 흐름에 따른 값의 추이를 추척 가능</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">sar -r</code> - 메모리 사용 현황 확인</p>\n<ul>\n<li>시간 추이에 따른 메모리 정도, 용도 확인 가능</li>\n<li><code class=\"language-text\">sar -W</code>와 조합해 스왑 발생 시간대의 메모리 사용 상황 확인 가능</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">sar -W</code>- 스왑 발생상황 확인</p>\n<ul>\n<li>pswpin/s → 1초 동안 스왑인 되고 있는 페이지 수</li>\n<li>pswpout/s → 1초 동안 스왑아웃 되고 있는 페이지 수</li>\n<li>스왑이 발생하면 서버 전송량이 떨어진다. 만일 메모리 부족으로 잦은 스왑이 발생하고 있는지 확인할 수 있다.</li>\n</ul>\n</li>\n</ol>\n<br>\n<h2 id=\"강의9-io-부하를-줄이는-방법\" style=\"position:relative;\"><a href=\"#%EA%B0%95%EC%9D%989-io-%EB%B6%80%ED%95%98%EB%A5%BC-%EC%A4%84%EC%9D%B4%EB%8A%94-%EB%B0%A9%EB%B2%95\" aria-label=\"강의9 io 부하를 줄이는 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[강의9] I/O 부하를 줄이는 방법</h2>\n<h2 id=\"캐시를-전제로-한-io-줄이는-방법\" style=\"position:relative;\"><a href=\"#%EC%BA%90%EC%8B%9C%EB%A5%BC-%EC%A0%84%EC%A0%9C%EB%A1%9C-%ED%95%9C-io-%EC%A4%84%EC%9D%B4%EB%8A%94-%EB%B0%A9%EB%B2%95\" aria-label=\"캐시를 전제로 한 io 줄이는 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>캐시를 전제로 한 I/O 줄이는 방법</h2>\n<p>I/O 대책의 기본은 캐시이다 !!</p>\n<ul>\n<li>첫번째 접근법 → 데이터 크기보다 물리 메모리 사이즈가 크다면 모두 캐싱할 수 있다.</li>\n</ul>\n<p>대규모 데이터에 데이터 압축이 중요하다. 압축해서 저장할 경우 디스크 전부를 메모리에 캐싱해둘 수도 있다.</p>\n<ul>\n<li>두번째 접근법 → 경제적 비용과 밸런스 고려</li>\n</ul>\n<p>점점 서버와 높은 용량의 메모리 가격이 내려가면서 압축 알고리즘에 지나친 에너지를 쏟을 필요가 없는 경우도 많다. 밸런스를 고려하는 것이 중요하다.</p>\n<h2 id=\"복수-서버로-확장---캐시로-해결-안되는-규모인-경우\" style=\"position:relative;\"><a href=\"#%EB%B3%B5%EC%88%98-%EC%84%9C%EB%B2%84%EB%A1%9C-%ED%99%95%EC%9E%A5---%EC%BA%90%EC%8B%9C%EB%A1%9C-%ED%95%B4%EA%B2%B0-%EC%95%88%EB%90%98%EB%8A%94-%EA%B7%9C%EB%AA%A8%EC%9D%B8-%EA%B2%BD%EC%9A%B0\" aria-label=\"복수 서버로 확장   캐시로 해결 안되는 규모인 경우 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>복수 서버로 확장 - 캐시로 해결 안되는 규모인 경우</h2>\n<p>현재 인프라의 구조가 프록시 ↔ WAS ↔ DB 인 경우에 다음과 같이 서버를 확장할 수 있다.</p>\n<ol>\n<li>WAS 서버를 늘린다.\n<ul>\n<li>CPU 부하를 낮추고 분산시키기 위해서이다.</li>\n<li>단순히 늘리면 된다.</li>\n</ul>\n</li>\n<li>DB 서버를 늘린다.\n<ul>\n<li>캐싱 용량을 늘리거나 효율을 높이고자 할 때 늘린다.</li>\n<li>하지만 I/O 분산에는 국소성을 고려해야하며 마냥 늘려서 좋은 것은 아니다.</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"대수만-늘려서-확정성-확보할-수-없다\" style=\"position:relative;\"><a href=\"#%EB%8C%80%EC%88%98%EB%A7%8C-%EB%8A%98%EB%A0%A4%EC%84%9C-%ED%99%95%EC%A0%95%EC%84%B1-%ED%99%95%EB%B3%B4%ED%95%A0-%EC%88%98-%EC%97%86%EB%8B%A4\" aria-label=\"대수만 늘려서 확정성 확보할 수 없다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>대수만 늘려서 확정성 확보할 수 없다.</h2>\n<ul>\n<li>캐시 용량이 부족해서 DB 서버 대수를 확보했지만 부족한 캐싱 용량의 상황까지 그대로 복제될 수 있다.\n<ul>\n<li>A 서버에서 조회하며 캐싱했는데 부족한 것이 B 서버에서도 동일하게 일어남</li>\n<li>어느정도 빨라질 수는 있겠지만 증설비용대비 성능향상은 좋지 않다.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"-io-부하-줄이기와-페이지-캐시\" style=\"position:relative;\"><a href=\"#-io-%EB%B6%80%ED%95%98-%EC%A4%84%EC%9D%B4%EA%B8%B0%EC%99%80-%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C\" aria-label=\" io 부하 줄이기와 페이지 캐시 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>+ I/O 부하 줄이기와 페이지 캐시</h2>\n<p>리눅스에서 sar 명령어로 메모리 상황을 확인했을 때 항상 메모리가 부족해보일수도 있다. 하지만 리눅스의 페이지 캐시 원리는 <code class=\"language-text\">리눅스는 가능한 남아있는 메모리를 페이지 캐시로 활용한다</code> 라는 것이다. 따라서 부팅 후 시간이 지날수록 sar의 <code class=\"language-text\">kbmemfree</code> 는 줄어들 수밖에 없다.</p>\n<h3 id=\"페이지-캐시에-의한-io-부하-경감-효과\" style=\"position:relative;\"><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C%EC%97%90-%EC%9D%98%ED%95%9C-io-%EB%B6%80%ED%95%98-%EA%B2%BD%EA%B0%90-%ED%9A%A8%EA%B3%BC\" aria-label=\"페이지 캐시에 의한 io 부하 경감 효과 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>페이지 캐시에 의한 I/O 부하 경감 효과</h3>\n<ul>\n<li>\n<p>많은 데이터가 있는 상황에서 메모리를 증설하고 <code class=\"language-text\">sar -P</code> 로 확인해보면 <code class=\"language-text\">%iowait</code> 의 확연한 차이를 볼 수 있다.</p>\n</li>\n<li>\n<p><code class=\"language-text\">sar -r</code> 를 사용하면 커널이 캐시를 확보하고 있는 정도를 확인할 수 있다. 커널이 확보하고 있는 캐시용량과 어플리케이션에서 다루는 데이터의 용량을 비교하여 데이터량이 더 많을 경우 메모리 증설을 검토하여 디스크 액세스를 줄인다.</p>\n<p><code class=\"language-text\">vmstat</code>을 사용하면 디스크 액세스 정도를 확인할 수 있다.</p>\n</li>\n<li>\n<p>메모리 증설이 어려운 경우 데이터 분할하여 각각 서버에 위치한다. → 캐시 올릴 데이터 비율이 올라가고 I/O 횟수가 줄어든다.</p>\n</li>\n</ul>\n<h3 id=\"페이지-캐시는-한번의-read에서-시작된다\" style=\"position:relative;\"><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C%EB%8A%94-%ED%95%9C%EB%B2%88%EC%9D%98-read%EC%97%90%EC%84%9C-%EC%8B%9C%EC%9E%91%EB%90%9C%EB%8B%A4\" aria-label=\"페이지 캐시는 한번의 read에서 시작된다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>페이지 캐시는 한번의 read에서 시작된다.</h3>\n<ul>\n<li>캐싱하지 못한 데이터는 직접 디스크에서 읽는다. 서버를 재부팅한 경우 메모리의 캐시는 초기화 되므로 모든 액세스에 I/O를 발생시킨다.</li>\n<li>대규모 DB 서버인 경우 모든 DB 액세스마다 디스크 I/O가 발생해서 DB가 lock에 걸리는 경우도 많다.</li>\n<li>따라서 필요한 경우 필요데이터를 전체 한번 전체적으로 읽어 다시 캐싱하는 방법도 필요하다.</li>\n<li>I/O 바운드가 높은 서버인 경우 페이지 캐시가 최적화 되었는지 확인한다.</li>\n</ul>\n<br>\n<h2 id=\"강의10-국소성을-살리는-분산\" style=\"position:relative;\"><a href=\"#%EA%B0%95%EC%9D%9810-%EA%B5%AD%EC%86%8C%EC%84%B1%EC%9D%84-%EC%82%B4%EB%A6%AC%EB%8A%94-%EB%B6%84%EC%82%B0\" aria-label=\"강의10 국소성을 살리는 분산 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[강의10] 국소성을 살리는 분산</h2>\n<h2 id=\"국소성을-고려한-분산이란\" style=\"position:relative;\"><a href=\"#%EA%B5%AD%EC%86%8C%EC%84%B1%EC%9D%84-%EA%B3%A0%EB%A0%A4%ED%95%9C-%EB%B6%84%EC%82%B0%EC%9D%B4%EB%9E%80\" aria-label=\"국소성을 고려한 분산이란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>국소성을 고려한 분산이란</h2>\n<p>서버를 여러대 확장해서 캐시 용량을 늘리기 위해서는 국소성(locality)을 고려해서 분산시켜야한다.</p>\n<ul>\n<li>DB의 경우 서비스 패턴과 처리방식에 따라 데이터 액세스 경향이 한쪽으로 치우친다.\n<ul>\n<li>어떤 서비스 패턴이 엔트리 A에 많이 접근하고 다른 서비스는 테이블B에 많이 접근한다면 1, 2를 분산하여 한쪽에만 액세스 하도록 할 수 있다.</li>\n<li>이것을 고려하지 않으면 여전히 서버 1에서 두 패턴이 모두 일어나게 되므로 캐시를 위한 메모리 용량이 부족하게 된다.</li>\n<li>즉, 액세스 패턴을 고려하여 국소성을 적용한 분산을 하라!!</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"파티셔닝---국소성-분산1\" style=\"position:relative;\"><a href=\"#%ED%8C%8C%ED%8B%B0%EC%85%94%EB%8B%9D---%EA%B5%AD%EC%86%8C%EC%84%B1-%EB%B6%84%EC%82%B01\" aria-label=\"파티셔닝   국소성 분산1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>파티셔닝 - 국소성 분산1</h2>\n<p>한 대였던 DB를 여러대의 서버로 분할하는 방법이다. → 제일 간단한 분할 방법은 테이블 단위 분할</p>\n<ul>\n<li><strong>테이블 단위 분할</strong> - 같이 액세스 하는 경우가 많은 테이블을 같은 서버에 위치시키고 그 밖의 것들을 다른 서버에 위치</li>\n<li><strong>테이블 데이터 분할 -</strong> 하나의 테이블을 여러 테이블로 분할\n<ul>\n<li>예를 들어 책에 나온 예시로는 하나의 테이블을 앞 알파벳에 따라서 데이터를 분할함</li>\n<li>국소성이 올라가 캐싱이 잘됨</li>\n<li>단점: 분할이 너무 작게 된다면 데이터를 한번 병합해야 함</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"요청-패턴을-섬으로-분할---국소성-분산2\" style=\"position:relative;\"><a href=\"#%EC%9A%94%EC%B2%AD-%ED%8C%A8%ED%84%B4%EC%9D%84-%EC%84%AC%EC%9C%BC%EB%A1%9C-%EB%B6%84%ED%95%A0---%EA%B5%AD%EC%86%8C%EC%84%B1-%EB%B6%84%EC%82%B02\" aria-label=\"요청 패턴을 섬으로 분할   국소성 분산2 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>요청 패턴을 ‘섬’으로 분할 - 국소성 분산2</h2>\n<p>요청의 종류에 따라서 요청을 보내는 서버를 나누는 것이다. - 특이한 경우이기는 함</p>\n<p align=\"center\"><img width=\"85%\" src=\"https://user-images.githubusercontent.com/63405904/136984334-66cc4ba2-bb5a-4b92-aacd-1067c92f5765.png\"><br>이미지 출처: 대용량 서비스를 지탱하는 기술</p>\n<ul>\n<li>캐싱하기 쉬운 요청, 캐싱하기 어려운 요청을 처리하는 섬을 나눔 → 전자는 국소성으로 높은 캐시 적중률을 냄</li>\n</ul>\n<h2 id=\"페이지-캐시를-고려한-운용의-기본-원칙\" style=\"position:relative;\"><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C%EB%A5%BC-%EA%B3%A0%EB%A0%A4%ED%95%9C-%EC%9A%B4%EC%9A%A9%EC%9D%98-%EA%B8%B0%EB%B3%B8-%EC%9B%90%EC%B9%99\" aria-label=\"페이지 캐시를 고려한 운용의 기본 원칙 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>페이지 캐시를 고려한 운용의 기본 원칙</h2>\n<ol>\n<li>OS를 가동한 직후에 서버를 투입하지 않는다 → 캐시가 쌓여있지 않기 때문이다.\n<ul>\n<li>OS를 기동하고 자주 사용하는 DB의 파일을 한번 cat 하여 메모리에 올린다. 이후 로드밸런서에 편입한다.</li>\n</ul>\n</li>\n<li>성능 테스트를 할 경우 초기값은 버려야한다. → 최초 캐시가 최적화 되어 있지 않은 단계이므로 속도가 확연히 차이가 나게 된다.</li>\n</ol>\n<h2 id=\"-부하분산과-os의-동작원리\" style=\"position:relative;\"><a href=\"#-%EB%B6%80%ED%95%98%EB%B6%84%EC%82%B0%EA%B3%BC-os%EC%9D%98-%EB%8F%99%EC%9E%91%EC%9B%90%EB%A6%AC\" aria-label=\" 부하분산과 os의 동작원리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>+ 부하분산과 OS의 동작원리</h2>\n<ul>\n<li>OS 캐시, 멀티스레드나 멀티프로세스, 가상 메모리구조, 파일시스템 등과 같은 OS 지식이 있어야 부하분산을 잘 할 수 있음.</li>\n<li>요청 분배에는 LVS 사용법, MySQL 아파치와 같은 미들웨어 사용법 등이 있다.</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#%EA%B0%95%EC%9D%988-os-%EC%BA%90%EC%8B%9C-%EA%B5%AC%EC%A1%B0\">[강의8] OS 캐시 구조</a></p>\n</li>\n<li>\n<p><a href=\"#os%EC%9D%98-%EC%BA%90%EC%8B%9C-%EA%B5%AC%EC%A1%B0%EB%A5%BC-%EC%95%8C%EA%B3%A0-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EC%9E%91%EC%84%B1%ED%95%98%EA%B8%B0---%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C\">OS의 캐시 구조를 알고 애플리케이션 작성하기 - 페이지 캐시</a></p>\n<ul>\n<li><a href=\"#linuxx86-%ED%8E%98%EC%9D%B4%EC%A7%95-%EA%B5%AC%EC%A1%B0\">Linux(x86) 페이징 구조</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0\">가상 메모리 구조</a></p>\n<ul>\n<li><a href=\"#%EC%99%9C-%EA%B0%80%EC%83%81-%EC%A3%BC%EC%86%8C%EB%A5%BC-%EB%B0%98%ED%99%98%ED%95%A0%EA%B9%8C\">왜 가상 주소를 반환할까?</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#linux-%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C%EC%9D%98-%EC%9B%90%EB%A6%AC\">Linux 페이지 캐시의 원리</a></p>\n<ul>\n<li><a href=\"#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EA%B0%80-%EB%94%94%EC%8A%A4%ED%81%AC%EC%97%90%EC%84%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A5%BC-%EC%9D%BD%EC%96%B4%EB%82%B4%EB%8A%94-%EA%B3%BC%EC%A0%95\">프로세스가 디스크에서 데이터를 읽어내는 과정</a></li>\n<li><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C%EC%9D%98-%ED%9A%A8%EA%B3%BC\">페이지 캐시의 효과</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#vfs\">VFS</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%A6%AC%EB%88%85%EC%8A%A4%EB%8A%94-%ED%8E%98%EC%9D%B4%EC%A7%80-%EB%8B%A8%EC%9C%84%EB%A1%9C-%EB%94%94%EC%8A%A4%ED%81%AC%EB%A5%BC-%EC%BA%90%EC%8B%B1\">리눅스는 페이지 단위로 디스크를 캐싱</a></p>\n<ul>\n<li><a href=\"#%EC%99%9C-%ED%8C%8C%EC%9D%BC-%EC%BA%90%EC%8B%9C%EA%B0%80-%EC%95%84%EB%8B%88%EB%9D%BC-%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C%EC%9D%BC%EA%B9%8C-\">왜 파일 캐시가 아니라 페이지 캐시일까 ?</a></li>\n<li><a href=\"#lru\">LRU</a></li>\n<li><a href=\"#%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%BA%90%EC%8B%B1%EC%9D%B4-%EB%90%A0%EA%B9%8C\">어떻게 캐싱이 될까</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EB%A9%94%EB%AA%A8%EB%A6%AC%EA%B0%80-%EB%B9%84%EC%96%B4%EC%9E%88%EC%9C%BC%EB%A9%B4-%EC%BA%90%EC%8B%B1\">메모리가 비어있으면 캐싱</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%8A%98%EB%A0%A4%EC%84%9C-io-%EB%B6%80%ED%95%98-%EC%A4%84%EC%9D%B4%EA%B8%B0\">메모리 늘려서 I/O 부하 줄이기</a></p>\n</li>\n<li>\n<p><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C%EB%8A%94-%ED%88%AC%EA%B3%BC%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%9E%91%EC%9A%A9\">페이지 캐시는 투과적으로 작용</a></p>\n</li>\n<li>\n<p><a href=\"#sar-%EB%AA%85%EB%A0%B9%EC%96%B4%EB%A1%9C-os-%EC%A7%80%ED%91%9C-%ED%99%95%EC%9D%B8%ED%95%98%EA%B8%B0\"><code class=\"language-text\">sar</code> 명령어로 os 지표 확인하기</a></p>\n</li>\n<li>\n<p><a href=\"#%EA%B0%95%EC%9D%989-io-%EB%B6%80%ED%95%98%EB%A5%BC-%EC%A4%84%EC%9D%B4%EB%8A%94-%EB%B0%A9%EB%B2%95\">[강의9] I/O 부하를 줄이는 방법</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%BA%90%EC%8B%9C%EB%A5%BC-%EC%A0%84%EC%A0%9C%EB%A1%9C-%ED%95%9C-io-%EC%A4%84%EC%9D%B4%EB%8A%94-%EB%B0%A9%EB%B2%95\">캐시를 전제로 한 I/O 줄이는 방법</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%B3%B5%EC%88%98-%EC%84%9C%EB%B2%84%EB%A1%9C-%ED%99%95%EC%9E%A5---%EC%BA%90%EC%8B%9C%EB%A1%9C-%ED%95%B4%EA%B2%B0-%EC%95%88%EB%90%98%EB%8A%94-%EA%B7%9C%EB%AA%A8%EC%9D%B8-%EA%B2%BD%EC%9A%B0\">복수 서버로 확장 - 캐시로 해결 안되는 규모인 경우</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%8C%80%EC%88%98%EB%A7%8C-%EB%8A%98%EB%A0%A4%EC%84%9C-%ED%99%95%EC%A0%95%EC%84%B1-%ED%99%95%EB%B3%B4%ED%95%A0-%EC%88%98-%EC%97%86%EB%8B%A4\">대수만 늘려서 확정성 확보할 수 없다.</a></p>\n</li>\n<li>\n<p><a href=\"#-io-%EB%B6%80%ED%95%98-%EC%A4%84%EC%9D%B4%EA%B8%B0%EC%99%80-%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C\">+ I/O 부하 줄이기와 페이지 캐시</a></p>\n<ul>\n<li><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C%EC%97%90-%EC%9D%98%ED%95%9C-io-%EB%B6%80%ED%95%98-%EA%B2%BD%EA%B0%90-%ED%9A%A8%EA%B3%BC\">페이지 캐시에 의한 I/O 부하 경감 효과</a></li>\n<li><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C%EB%8A%94-%ED%95%9C%EB%B2%88%EC%9D%98-read%EC%97%90%EC%84%9C-%EC%8B%9C%EC%9E%91%EB%90%9C%EB%8B%A4\">페이지 캐시는 한번의 read에서 시작된다.</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EA%B0%95%EC%9D%9810-%EA%B5%AD%EC%86%8C%EC%84%B1%EC%9D%84-%EC%82%B4%EB%A6%AC%EB%8A%94-%EB%B6%84%EC%82%B0\">[강의10] 국소성을 살리는 분산</a></p>\n</li>\n<li>\n<p><a href=\"#%EA%B5%AD%EC%86%8C%EC%84%B1%EC%9D%84-%EA%B3%A0%EB%A0%A4%ED%95%9C-%EB%B6%84%EC%82%B0%EC%9D%B4%EB%9E%80\">국소성을 고려한 분산이란</a></p>\n</li>\n<li>\n<p><a href=\"#%ED%8C%8C%ED%8B%B0%EC%85%94%EB%8B%9D---%EA%B5%AD%EC%86%8C%EC%84%B1-%EB%B6%84%EC%82%B01\">파티셔닝 - 국소성 분산1</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%9A%94%EC%B2%AD-%ED%8C%A8%ED%84%B4%EC%9D%84-%EC%84%AC%EC%9C%BC%EB%A1%9C-%EB%B6%84%ED%95%A0---%EA%B5%AD%EC%86%8C%EC%84%B1-%EB%B6%84%EC%82%B02\">요청 패턴을 ‘섬’으로 분할 - 국소성 분산2</a></p>\n</li>\n<li>\n<p><a href=\"#%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%BA%90%EC%8B%9C%EB%A5%BC-%EA%B3%A0%EB%A0%A4%ED%95%9C-%EC%9A%B4%EC%9A%A9%EC%9D%98-%EA%B8%B0%EB%B3%B8-%EC%9B%90%EC%B9%99\">페이지 캐시를 고려한 운용의 기본 원칙</a></p>\n</li>\n<li>\n<p><a href=\"#-%EB%B6%80%ED%95%98%EB%B6%84%EC%82%B0%EA%B3%BC-os%EC%9D%98-%EB%8F%99%EC%9E%91%EC%9B%90%EB%A6%AC\">+ 부하분산과 OS의 동작원리</a></p>\n</li>\n</ul>\n</div>","excerpt":"다음은 웹 개발자를 위한 대규모 서비스를 지탱하는 기술을 읽고 정리한 내용입니다 🙌 [강의8] OS 캐시 구조 OS의 캐시 구조를 알고 애플리케이션 작성하기 - 페이지 캐시 OS는 메모리를 이용해서 캐시 구조를 갖추고 디스크 액세스를 줄인다. Linux(x86) 페이징 구조 OS는 가장 메모리 구조를 가지고 있는데 논리적인 선형 어드레스를 물리적인 어드레스로 변환한다. 가상 메모리 구조 기본적인 OS 구조를 보면 OS에서 관리하고 있는 메모리 구조 있고, OS가 있으며 OS에서 돌아가는 프로세스가 존재한다. 프로세스에서 메모리가 필요한 경우 메모리에 직접 접근해서 주소를 가져오는 것이 아니라, OS를 통해서 비어있는 주소와 다른 주소를 반환한다. 왜 가상 주소를 반환할까? 개별 프로세스가 실제로 메모리의 어느 부분을 사용하는지 스스로 알고 있을 필요가 없고, 특정 번지에서 통일해서 시작하는 것으로 다루면 더 쉽기 때문이다. 예) 유닉스에서 공유 라이브러리는 프로세스 내에서 지정된 …","frontmatter":{"date":"September 24, 2021","title":"대규모 서비스를 지탱하는 기술 - OS 캐시와 분산","categories":"웹 인프라 책 성능테스트","author":"코다","emoji":"📚"},"fields":{"slug":"/high-traffic-service_3/"}},"next":{"id":"b9fd9f8d-cdec-50ab-ad11-588460d309b6","html":"<blockquote>\n<p>다음은 웹 개발자를 위한 대규모 서비스를 지탱하는 기술을 읽고 정리한 내용입니다 🙌</p>\n</blockquote>\n<br>\n<p>이번장은 레이어를 DB로 옮겨서 DB의 스케일아웃 전략에 대해서 살펴본다.</p>\n<h2 id=\"강의11-인덱스-올바르게-운용하기\" style=\"position:relative;\"><a href=\"#%EA%B0%95%EC%9D%9811-%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EC%98%AC%EB%B0%94%EB%A5%B4%EA%B2%8C-%EC%9A%B4%EC%9A%A9%ED%95%98%EA%B8%B0\" aria-label=\"강의11 인덱스 올바르게 운용하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[강의11] 인덱스 올바르게 운용하기</h2>\n<h2 id=\"분산을-고려한-mysql-운용-세-가지-포인트\" style=\"position:relative;\"><a href=\"#%EB%B6%84%EC%82%B0%EC%9D%84-%EA%B3%A0%EB%A0%A4%ED%95%9C-mysql-%EC%9A%B4%EC%9A%A9-%EC%84%B8-%EA%B0%80%EC%A7%80-%ED%8F%AC%EC%9D%B8%ED%8A%B8\" aria-label=\"분산을 고려한 mysql 운용 세 가지 포인트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>분산을 고려한 MySQL 운용, 세 가지 포인트</h2>\n<ol>\n<li>OS 캐시 활용</li>\n<li>인덱스를 적절하게 설정</li>\n<li>확장을 전제로 한 설계</li>\n</ol>\n<h2 id=\"os-캐시-활용\" style=\"position:relative;\"><a href=\"#os-%EC%BA%90%EC%8B%9C-%ED%99%9C%EC%9A%A9\" aria-label=\"os 캐시 활용 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>OS 캐시 활용</h2>\n<p>전체 데이터 크기가 물리 메모리보다 가능한 적도록 유지한다.</p>\n<ul>\n<li>상황: 대규모 서비스일 경우 (3억건의 데이터), 테이블에 칼럼을 한 개 (약 8바이트)를 추가하더라도 3GB 가 추가된다. → 스키마도 신경써서 설계해야한다.</li>\n<li>따라서 테이블의 레코드를 컴팩트하게 설계해야한다. (int형 32비트, 문자열 8비트 같은 수치에 대한 감각 필요)</li>\n</ul>\n<h3 id=\"db-테이블의-데이터를-정규화하는-것은-\" style=\"position:relative;\"><a href=\"#db-%ED%85%8C%EC%9D%B4%EB%B8%94%EC%9D%98-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A5%BC-%EC%A0%95%EA%B7%9C%ED%99%94%ED%95%98%EB%8A%94-%EA%B2%83%EC%9D%80-\" aria-label=\"db 테이블의 데이터를 정규화하는 것은  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>DB 테이블의 데이터를 정규화하는 것은 ?</h3>\n<ul>\n<li>예를 들어서 필수적으로 필요한 데이터만 테이블에 남기고, flag로 사용되는 데이터들을 테이블 분리하여 필요할 때만 사용할 수도 있다. 대규모 데이터인 경우 이것만 분리를 하더라도 엄청난 용량이 줄어든다.</li>\n<li>하지만 쿼리가 복잡해져서 속도가 떨어질 수 있으므로 <strong>속도와 데이터 크기 간 트레이드 오프</strong>가 있다는 것도 생각해야한다. !!!</li>\n</ul>\n<h2 id=\"인덱스의-중요성---b트리\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%EB%8D%B1%EC%8A%A4%EC%9D%98-%EC%A4%91%EC%9A%94%EC%84%B1---b%ED%8A%B8%EB%A6%AC\" aria-label=\"인덱스의 중요성   b트리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>인덱스의 중요성 - B+트리</h2>\n<p>DB의 인덱스는 탐색이 매우 빠른 B+트리 구조를 사용한다.</p>\n<p>이분탐색과 비교해서 더 디스크에 최적화 되어 있다 → 더 알아보아야겠지만 하나의 노드에 있는 내용들은 디스크 액세스를 하지 않아도 된다.</p>\n<h2 id=\"인덱스의-효과\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%EB%8D%B1%EC%8A%A4%EC%9D%98-%ED%9A%A8%EA%B3%BC\" aria-label=\"인덱스의 효과 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>인덱스의 효과</h2>\n<p>4000만건의 테이블이 있을때를 고려해보면,</p>\n<ul>\n<li>만일 인덱스가 없다면 선형탐색을 함 → O(n) 최대 4000만번 탐색</li>\n<li>인덱스 있다면 → O(logn) 최대 25.5번</li>\n</ul>\n<p>하지만 데이터가 작은 경우 트리를 순회하는 오버헤트가 더 클수도 있으므로 잘 판단하여 인덱스를 사용한다.</p>\n<h2 id=\"-mysql-특성에-따른-인덱스의-작용\" style=\"position:relative;\"><a href=\"#-mysql-%ED%8A%B9%EC%84%B1%EC%97%90-%EB%94%B0%EB%A5%B8-%EC%9D%B8%EB%8D%B1%EC%8A%A4%EC%9D%98-%EC%9E%91%EC%9A%A9\" aria-label=\" mysql 특성에 따른 인덱스의 작용 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>+ MySQL 특성에 따른 인덱스의 작용</h2>\n<p>특정 칼럼에 인덱스를 걸어놓더라도 사용하는 쿼리에 따라서 사용하지 않을수도 있다.</p>\n<ul>\n<li>기본적으로 where, order by, group by 조건문이 지정되는 칼럼에 인덱스를 사용한다.</li>\n<li>인덱스를 명시적으로 추가한 것 이외에 pk, unique 제약조건에 인덱스를 가지고 있다. (show index로 인덱스 내용 확인 가능)</li>\n<li>조건문에 여러 인덱스 칼럼이 사용되도, 하나의 인덱스만 사용된다. (따라서 여러 칼럼이 한꺼번에 조건으로 될 경우 복합 인덱스를 설정해야한다)</li>\n<li><strong>인덱스 설정에 대해서는 더 알아보자 !!</strong></li>\n<li><code class=\"language-text\">explain</code> 명령어로 인덱스 작용을 확인할 수 있다.</li>\n</ul>\n<br>\n<h2 id=\"인덱스의-간과\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%EB%8D%B1%EC%8A%A4%EC%9D%98-%EA%B0%84%EA%B3%BC\" aria-label=\"인덱스의 간과 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>인덱스의 간과</h2>\n<ul>\n<li>나도 모르게 인덱스가 작용하지 않은 쿼리를 사용하고 있을수도 있다.\n<ul>\n<li>자동으로 쿼리를 생성해주는 툴을 사용하면서 이것을 간과하게 된다.</li>\n<li>감시방안을 늘려서 대응해야한다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h2 id=\"강의12-mysql의-분산\" style=\"position:relative;\"><a href=\"#%EA%B0%95%EC%9D%9812-mysql%EC%9D%98-%EB%B6%84%EC%82%B0\" aria-label=\"강의12 mysql의 분산 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[강의12] MySQL의 분산</h2>\n<h2 id=\"mysql-replication-기능\" style=\"position:relative;\"><a href=\"#mysql-replication-%EA%B8%B0%EB%8A%A5\" aria-label=\"mysql replication 기능 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>MySQL replication 기능</h2>\n<ul>\n<li>Master, slave 구조이며 slave가 master의 replica가 되는 것이다.</li>\n<li>갱신은 마스터에서만 이루어지며 slave는 조회 쿼리만 담당한다.</li>\n</ul>\n<h2 id=\"masterslave의-특징\" style=\"position:relative;\"><a href=\"#masterslave%EC%9D%98-%ED%8A%B9%EC%A7%95\" aria-label=\"masterslave의 특징 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Master/Slave의 특징</h2>\n<ul>\n<li>select는 분산할 수 있지만 갱신은 분산할 수 없으므로 마스터의 다중화의 문제가 발생한다.</li>\n<li>하지만 대부분 쓰기보다 읽기가 훨씬 많으므로 읽기용 slave가 많은 것이 분산에 큰 효과를 낸다.</li>\n</ul>\n<h3 id=\"갱신-및-쓰기-확장\" style=\"position:relative;\"><a href=\"#%EA%B0%B1%EC%8B%A0-%EB%B0%8F-%EC%93%B0%EA%B8%B0-%ED%99%95%EC%9E%A5\" aria-label=\"갱신 및 쓰기 확장 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>갱신 및 쓰기 확장</h3>\n<p>이런 경우에는 테이블을 분할해서 그 크기를 매우 작게 한다. 이것으로 쓰기 작업이 분산된다.</p>\n<ul>\n<li>테이블 파일이 분산 될 경우 동일 호스트 내에서 여러 디스크를 가지고 분산할 수 있고, 다른 서버로 분산할 수도 있다.</li>\n<li>쓰기 작업이 너무 많다면 RDBMS를 사용하지 않고 KVS 방식을 사용하는 것도 고려할 수 있다. (오버헤드가 적고 빠르며 확장이 쉽다)</li>\n</ul>\n<br>\n<h2 id=\"강의13-mysql의-스케일아웃과-파티셔닝\" style=\"position:relative;\"><a href=\"#%EA%B0%95%EC%9D%9813-mysql%EC%9D%98-%EC%8A%A4%EC%BC%80%EC%9D%BC%EC%95%84%EC%9B%83%EA%B3%BC-%ED%8C%8C%ED%8B%B0%EC%85%94%EB%8B%9D\" aria-label=\"강의13 mysql의 스케일아웃과 파티셔닝 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[강의13] MySQL의 스케일아웃과 파티셔닝</h2>\n<h2 id=\"mysql의-스케일아웃-전략\" style=\"position:relative;\"><a href=\"#mysql%EC%9D%98-%EC%8A%A4%EC%BC%80%EC%9D%BC%EC%95%84%EC%9B%83-%EC%A0%84%EB%9E%B5\" aria-label=\"mysql의 스케일아웃 전략 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>MySQL의 스케일아웃 전략</h2>\n<ul>\n<li>일단 데이터가 메모리에 올라가는 크기면 메모리에 올리고, 올라가지 않으면 메모리를 증설한다.</li>\n<li>그리고 인덱스를 걸자 !!</li>\n<li>하지만 만일 메모리 증설이 어렵다면 파티셔닝을 한다.</li>\n</ul>\n<h2 id=\"파티셔닝에-관한-보충-테이블-분할\" style=\"position:relative;\"><a href=\"#%ED%8C%8C%ED%8B%B0%EC%85%94%EB%8B%9D%EC%97%90-%EA%B4%80%ED%95%9C-%EB%B3%B4%EC%B6%A9-%ED%85%8C%EC%9D%B4%EB%B8%94-%EB%B6%84%ED%95%A0\" aria-label=\"파티셔닝에 관한 보충 테이블 분할 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>파티셔닝에 관한 보충 (테이블 분할)</h2>\n<ul>\n<li>테이블A와 테이블B를 다른 서버에 놓아서 분산하는 것.</li>\n<li>국소성을 활용해서 분산할 수 있고 캐싱이 유효하기 때문에 효과적이다.</li>\n</ul>\n<h2 id=\"파티셔닝을-전제로-한-설계\" style=\"position:relative;\"><a href=\"#%ED%8C%8C%ED%8B%B0%EC%85%94%EB%8B%9D%EC%9D%84-%EC%A0%84%EC%A0%9C%EB%A1%9C-%ED%95%9C-%EC%84%A4%EA%B3%84\" aria-label=\"파티셔닝을 전제로 한 설계 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>파티셔닝을 전제로 한 설계</h2>\n<ul>\n<li>상황: 두 테이블 사이에 연관관계가 존재하여 join 쿼리를 던져야하는 경우 두 테이블을 분할 수는 없다.</li>\n<li>두 개의 테이블이 다른 서버로 분할되면 JOIN을 할 수 없지만 이것을 두 개의 쿼리로 나눠서 질의하면 가능하게 만들 수 있다. → 그러면 파티셔닝이 가능하게 된다.\n<ul>\n<li>하지만 너무 밀접할 경우 같은 서버에 놓고 join을 하는 것이 더 효율적이다.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"join-배제---where-in-활용\" style=\"position:relative;\"><a href=\"#join-%EB%B0%B0%EC%A0%9C---where-in-%ED%99%9C%EC%9A%A9\" aria-label=\"join 배제   where in 활용 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JOIN 배제 - where, in 활용</h2>\n<ul>\n<li>위에 말한 경우이다. 먼저 어떤 테이블에 관련 Id를 질의하고 해당 id를 가지고 원하는 데이터를 뽑아내도록 한다. (JPA를 활용할 경우는 어떻게 하는 것이 좋을까)</li>\n<li>다수의 DB를 찔려서 하나의 쿼리에서 다수의 DB 서버 액세스 가능? (키워드 MSA)</li>\n</ul>\n<h2 id=\"파티셔닝의-상반관계---단점\" style=\"position:relative;\"><a href=\"#%ED%8C%8C%ED%8B%B0%EC%85%94%EB%8B%9D%EC%9D%98-%EC%83%81%EB%B0%98%EA%B4%80%EA%B3%84---%EB%8B%A8%EC%A0%90\" aria-label=\"파티셔닝의 상반관계   단점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>파티셔닝의 상반관계 - 단점</h2>\n<ol>\n<li>운용이 복잡해진다. → 다른 용도의 서버가 생긴다.</li>\n<li>고장률이 높아진다 → 대수가 늘어나므로 고장률 또한 증가한다.</li>\n<li>어플리케이션 용도와 서버 대수\n<ol>\n<li>무정지가 되려면 여러개의 서버대수가 필요하고 해당 서버를 분할하면 기하급수적으로 많아진다.</li>\n</ol>\n</li>\n</ol>\n<p>파티셔닝은 언제나 마지막 카드이다 !!!</p>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#%EA%B0%95%EC%9D%9811-%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EC%98%AC%EB%B0%94%EB%A5%B4%EA%B2%8C-%EC%9A%B4%EC%9A%A9%ED%95%98%EA%B8%B0\">[강의11] 인덱스 올바르게 운용하기</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%B6%84%EC%82%B0%EC%9D%84-%EA%B3%A0%EB%A0%A4%ED%95%9C-mysql-%EC%9A%B4%EC%9A%A9-%EC%84%B8-%EA%B0%80%EC%A7%80-%ED%8F%AC%EC%9D%B8%ED%8A%B8\">분산을 고려한 MySQL 운용, 세 가지 포인트</a></p>\n</li>\n<li>\n<p><a href=\"#os-%EC%BA%90%EC%8B%9C-%ED%99%9C%EC%9A%A9\">OS 캐시 활용</a></p>\n<ul>\n<li><a href=\"#db-%ED%85%8C%EC%9D%B4%EB%B8%94%EC%9D%98-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A5%BC-%EC%A0%95%EA%B7%9C%ED%99%94%ED%95%98%EB%8A%94-%EA%B2%83%EC%9D%80-\">DB 테이블의 데이터를 정규화하는 것은 ?</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%9D%B8%EB%8D%B1%EC%8A%A4%EC%9D%98-%EC%A4%91%EC%9A%94%EC%84%B1---b%ED%8A%B8%EB%A6%AC\">인덱스의 중요성 - B+트리</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%9D%B8%EB%8D%B1%EC%8A%A4%EC%9D%98-%ED%9A%A8%EA%B3%BC\">인덱스의 효과</a></p>\n</li>\n<li>\n<p><a href=\"#-mysql-%ED%8A%B9%EC%84%B1%EC%97%90-%EB%94%B0%EB%A5%B8-%EC%9D%B8%EB%8D%B1%EC%8A%A4%EC%9D%98-%EC%9E%91%EC%9A%A9\">+ MySQL 특성에 따른 인덱스의 작용</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%9D%B8%EB%8D%B1%EC%8A%A4%EC%9D%98-%EA%B0%84%EA%B3%BC\">인덱스의 간과</a></p>\n</li>\n<li>\n<p><a href=\"#%EA%B0%95%EC%9D%9812-mysql%EC%9D%98-%EB%B6%84%EC%82%B0\">[강의12] MySQL의 분산</a></p>\n</li>\n<li>\n<p><a href=\"#mysql-replication-%EA%B8%B0%EB%8A%A5\">MySQL replication 기능</a></p>\n</li>\n<li>\n<p><a href=\"#masterslave%EC%9D%98-%ED%8A%B9%EC%A7%95\">Master/Slave의 특징</a></p>\n<ul>\n<li><a href=\"#%EA%B0%B1%EC%8B%A0-%EB%B0%8F-%EC%93%B0%EA%B8%B0-%ED%99%95%EC%9E%A5\">갱신 및 쓰기 확장</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EA%B0%95%EC%9D%9813-mysql%EC%9D%98-%EC%8A%A4%EC%BC%80%EC%9D%BC%EC%95%84%EC%9B%83%EA%B3%BC-%ED%8C%8C%ED%8B%B0%EC%85%94%EB%8B%9D\">[강의13] MySQL의 스케일아웃과 파티셔닝</a></p>\n</li>\n<li>\n<p><a href=\"#mysql%EC%9D%98-%EC%8A%A4%EC%BC%80%EC%9D%BC%EC%95%84%EC%9B%83-%EC%A0%84%EB%9E%B5\">MySQL의 스케일아웃 전략</a></p>\n</li>\n<li>\n<p><a href=\"#%ED%8C%8C%ED%8B%B0%EC%85%94%EB%8B%9D%EC%97%90-%EA%B4%80%ED%95%9C-%EB%B3%B4%EC%B6%A9-%ED%85%8C%EC%9D%B4%EB%B8%94-%EB%B6%84%ED%95%A0\">파티셔닝에 관한 보충 (테이블 분할)</a></p>\n</li>\n<li>\n<p><a href=\"#%ED%8C%8C%ED%8B%B0%EC%85%94%EB%8B%9D%EC%9D%84-%EC%A0%84%EC%A0%9C%EB%A1%9C-%ED%95%9C-%EC%84%A4%EA%B3%84\">파티셔닝을 전제로 한 설계</a></p>\n</li>\n<li>\n<p><a href=\"#join-%EB%B0%B0%EC%A0%9C---where-in-%ED%99%9C%EC%9A%A9\">JOIN 배제 - where, in 활용</a></p>\n</li>\n<li>\n<p><a href=\"#%ED%8C%8C%ED%8B%B0%EC%85%94%EB%8B%9D%EC%9D%98-%EC%83%81%EB%B0%98%EA%B4%80%EA%B3%84---%EB%8B%A8%EC%A0%90\">파티셔닝의 상반관계 - 단점</a></p>\n</li>\n</ul>\n</div>","frontmatter":{"date":"September 24, 2021","title":"대규모 서비스를 지탱하는 기술 - 분산을 고려한 MySQL 운용","categories":"웹 인프라 책 성능테스트","author":"코다","emoji":"📚"},"fields":{"slug":"/high-traffic-service_4/"}},"prev":{"id":"0b8de3f2-07af-5ce2-8ced-e55579a73288","html":"<blockquote>\n<p>다음은 <em>성공과 실패를 결정하는 1%의 네트워크 원리</em> 를 읽고 정리한 내용입니다. 본 글은 CH1. 웹 브라우저가 메시지를 만든다 입니다 🙌</p>\n</blockquote>\n<br>\n<h2 id=\"-개요\" style=\"position:relative;\"><a href=\"#-%EA%B0%9C%EC%9A%94\" aria-label=\" 개요 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>💡 개요</h2>\n<ol>\n<li>HTTP 리퀘스트 메세지를 작성한다.\n<ul>\n<li>URL을 해독하는 곳에서 브라우저의 동작이 시작된다.</li>\n<li>이 URL의 의미에 따라서 요청 메세지를 작성하고 요청 내용을 만든다.</li>\n<li>이때 HTTP 라는 프로토콜이 사용된다.</li>\n</ul>\n</li>\n<li>웹 서버의 IP 주소를 DNS 서버에 조회\n<ul>\n<li>OS에 의뢰해서 요청 메세지를 송신할 때 송신대상의 IP주소를 알아야한다.</li>\n<li>URL의 웹 도메인명으로 DNS 서버를 조회해서 IP 주소를 조사한다.</li>\n</ul>\n</li>\n<li>전세계 DNS 서버 연대\n<ul>\n<li>다수의 DNS 서버가 연대하여 IP 주소를 조사한다.</li>\n</ul>\n</li>\n<li>프로토콜 스택에 메시지 송신을 의뢰\n<ul>\n<li>OS에 메세지를 송신하는 동작을 의뢰한다.</li>\n<li>OS에서 제공하는 규칙에 따라서 의뢰를 해야한다.</li>\n<li>해당 프로그램을 직접 구현하는 것이 아니더라도 규칙의 큰 흐름을 알는 것이 중요하다.</li>\n</ul>\n</li>\n</ol>\n<br>\n<h2 id=\"-story1-http-리퀘스트-메세지를-작성한다\" style=\"position:relative;\"><a href=\"#-story1-http-%EB%A6%AC%ED%80%98%EC%8A%A4%ED%8A%B8-%EB%A9%94%EC%84%B8%EC%A7%80%EB%A5%BC-%EC%9E%91%EC%84%B1%ED%95%9C%EB%8B%A4\" aria-label=\" story1 http 리퀘스트 메세지를 작성한다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🛺 [STORY1] HTTP 리퀘스트 메세지를 작성한다</h2>\n<h3 id=\"url-입력\" style=\"position:relative;\"><a href=\"#url-%EC%9E%85%EB%A0%A5\" aria-label=\"url 입력 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>URL 입력</h3>\n<ul>\n<li>URL은 우리가 알고 있는 http 뿐 아니라 ftp, file, 등등 여러가지가 존재한다.\n<ul>\n<li>브라우저에 여러 프로토콜 존재한다\n<ul>\n<li>브라우저는 여러 클라이언트 기능을 가지고 있는 복합적인 소프트웨어이기 때문</li>\n</ul>\n</li>\n<li>브라우저에서 http 요청 뿐 아니라 파일 다운로드/업로드 등의 기능도 있다.</li>\n<li>어느 기능을 사용하는지 url 에 명시된 프로토콜로 판단할 수 있다.</li>\n</ul>\n</li>\n<li>URL에 엑세스 대상에 따라서 여러 정보를 담는다.\n<ul>\n<li>웹 서버 요청일 경우 파일 경로, 포트 번호 등을 담아서 보낼 수 있다.</li>\n<li>모든 URL에는 앞에 엑세스 대상에 따라서 다른 프로토콜을 명시하고 있다. (http, ftp 등등)</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"브라우저의-url-해독\" style=\"position:relative;\"><a href=\"#%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EC%9D%98-url-%ED%95%B4%EB%8F%85\" aria-label=\"브라우저의 url 해독 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>브라우저의 URL 해독</h3>\n<p>우선 웹 서버에 엑세스 하는 경우를 기반으로 설명한다.</p>\n<ul>\n<li>URL에 파일 경로가 포함되어 있을 수 있다 → / 를 기준으로 디렉토리 구조와 파일명을 명시하여 url에 포함한다.</li>\n<li>마지막에 파일명을 명시하지 않는 경우\n<ul>\n<li>기본 파일명을 서버측에 설정하여 생략된 경우 사용한다. (index.html, default.htm 등등)</li>\n</ul>\n</li>\n<li>마지막에 디렉토리를 생략한 경우\n<ul>\n<li>루트 디렉토리의 기본 파일을 읽는 것으로 간주한다.</li>\n</ul>\n</li>\n<li>마지막에 경로에 /가 생략된 경우 (ex. <a href=\"http://www.web.com/path\">http://www.web.com/path</a>)\n<ul>\n<li>이 경우 마지막 값이 파일명인지 디렉토리인지 알 수 없다.</li>\n<li>다음과 같은 경우 우선 매칭되는 <strong>파일명</strong>이 있는지 확인하고, 없다면 매칭되는 <strong>디렉토리명</strong>이 있는지 확인한다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"http기본-개념\" style=\"position:relative;\"><a href=\"#http%EA%B8%B0%EB%B3%B8-%EA%B0%9C%EB%85%90\" aria-label=\"http기본 개념 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>HTTP기본 개념</h3>\n<ul>\n<li>URL 해독 후 액세스 해야하는 위치가 판단된다. 그때부터 명시된 프로토콜 (이 경우에는 HTTP)에 따라서 액세스를 진행한다.</li>\n<li>HTTP 프로토콜의 요청 메세지가 담고 있는 내용\n<ol>\n<li>무엇을 - URI 데이터를 저장한 경로만 쓰거나 URL을 그대로 쓸 수도 있다.</li>\n<li>어떻게 - 메소드 (GET, POST, PUT 등등)</li>\n</ol>\n</li>\n<li>응답 메세지가 담고 있는 내용\n<ol>\n<li>결과 데이터</li>\n<li>status code - 실행 결과의 상태에 대한 정보</li>\n</ol>\n</li>\n<li>PUT 이나 DELETE를 사용하면 파일 서버 대신 웹 서버를 사용할 수도 있긴 하다. (???) p. 45</li>\n</ul>\n<h3 id=\"http-리쿼스트-메세지를-만든다\" style=\"position:relative;\"><a href=\"#http-%EB%A6%AC%EC%BF%BC%EC%8A%A4%ED%8A%B8-%EB%A9%94%EC%84%B8%EC%A7%80%EB%A5%BC-%EB%A7%8C%EB%93%A0%EB%8B%A4\" aria-label=\"http 리쿼스트 메세지를 만든다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>HTTP 리쿼스트 메세지를 만든다</h3>\n<ul>\n<li>우선 URL을 판단하여 웹 서버와 파일 경로 및 파일명을 해석한 후에 HTTP 요청 메세지를 만든다.</li>\n<li>첫번째 행 - Request Line\n<ul>\n<li>메소드 - 여러 종류의 메소드 중 웹 서버에 어떻게 전달할지 메소드에 담아서 판단한다.</li>\n<li>URI - 파일이나 경로명</li>\n<li>HTTP 버전</li>\n</ul>\n</li>\n<li>두번째 부터 - Headers\n<ul>\n<li>부가적인 자세한 정보를 헤더에 추가한다.</li>\n<li>날짜, 데이터 종류, 언어, 압축 형식 등등</li>\n</ul>\n</li>\n<li>공백 라인 이후 - Request Body\n<ul>\n<li>송신할 데이터를 메세지 본문에 기재한다.</li>\n<li>주로 POST 요청인 경우 바디에 데이터를 담아서 요청한다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"리퀘스트-메세지를-보낸-이후-응답이-돌아온다\" style=\"position:relative;\"><a href=\"#%EB%A6%AC%ED%80%98%EC%8A%A4%ED%8A%B8-%EB%A9%94%EC%84%B8%EC%A7%80%EB%A5%BC-%EB%B3%B4%EB%82%B8-%EC%9D%B4%ED%9B%84-%EC%9D%91%EB%8B%B5%EC%9D%B4-%EB%8F%8C%EC%95%84%EC%98%A8%EB%8B%A4\" aria-label=\"리퀘스트 메세지를 보낸 이후 응답이 돌아온다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>리퀘스트 메세지를 보낸 이후 응답이 돌아온다.</h3>\n<ul>\n<li>기본적으로 첫번째 행을 제외하고 요청 메세지와 비슷한 형태를 지닌다.</li>\n<li>첫번째 행 -\n<ul>\n<li>요청 실행 결과 status code</li>\n<li>status 코드의 응답 문구 (Not Found)</li>\n</ul>\n</li>\n<li>응답이 오면 메세지를 추출해서 화면에 표시한다.</li>\n<li>문장만 이루어진 응답 데이터가 아닌 경우\n<ul>\n<li>추가적으로 이미지나 영상을 담고 있는 경우 응답 문장에 tag를 추가하여 명시한다.\n<ul>\n<li>ex. <code class=\"language-text\">&lt;img src=\"{이미지경로}\" /></code></li>\n</ul>\n</li>\n<li>tag가 존재한다면\n<ul>\n<li>우선 공백으로 비워둔다.</li>\n<li>이후 추가 웹 서버 액세스하여 태그에 쓰여있는 경로로 URI를 만들어서 요청 메세지를 보낸다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>하나의 요청 메세지에는 하나의 URI 만 쓰기 때문에 여러 파일이 필요하면 매번 요청을 보내야 한다.</li>\n</ul>\n<br>\n<h2 id=\"-story2-웹-서버의-ip주소를-dns-서버에-조회한다\" style=\"position:relative;\"><a href=\"#-story2-%EC%9B%B9-%EC%84%9C%EB%B2%84%EC%9D%98-ip%EC%A3%BC%EC%86%8C%EB%A5%BC-dns-%EC%84%9C%EB%B2%84%EC%97%90-%EC%A1%B0%ED%9A%8C%ED%95%9C%EB%8B%A4\" aria-label=\" story2 웹 서버의 ip주소를 dns 서버에 조회한다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🛺 [STORY2] 웹 서버의 IP주소를 DNS 서버에 조회한다.</h2>\n<h3 id=\"ip-주소의-기본\" style=\"position:relative;\"><a href=\"#ip-%EC%A3%BC%EC%86%8C%EC%9D%98-%EA%B8%B0%EB%B3%B8\" aria-label=\"ip 주소의 기본 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>IP 주소의 기본</h3>\n<ul>\n<li>브라우저가 담당하는 일 → URL 해독, HTTP 메세지 만들기</li>\n<li>OS가 담당하는 일 → 메세지를 네트워크로 송출\n<ul>\n<li>따라서 브라우저가 위 업무는 OS에 위임하여 메세지를 송신한다.</li>\n</ul>\n</li>\n<li>이때 URL에서 해석한 도메인명의 IP 주소를 조사해야 한다.</li>\n</ul>\n<h4 id=\"tcpip-기본-개념\" style=\"position:relative;\"><a href=\"#tcpip-%EA%B8%B0%EB%B3%B8-%EA%B0%9C%EB%85%90\" aria-label=\"tcpip 기본 개념 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TCP/IP 기본 개념</h4>\n<ul>\n<li>\n<p>서브넷 - 여러 PC가 하나의 허브에 연결되어 있는 단위</p>\n</li>\n<li>\n<p><strong>여러 서브넷을 라우터로 연결하여 네트워크 전체를 구성한다.</strong></p>\n<p align=\"center\"><img width=\"85%\" src=\"https://user-images.githubusercontent.com/63405904/141642594-d563a745-1eb7-4378-8b1e-2d94c45a4545.png\"></p>\n</li>\n<li>\n<p>네트워크 주소를 00동 00번지의 단위로 표현할 수 있다.</p>\n<ul>\n<li>00동 → 서브넷에 할당된 네트워크 번호</li>\n<li>00번지 → 호스트 번호</li>\n</ul>\n</li>\n<li>\n<p><strong>네트워크 번호 + 호스트 번호</strong>가 IP 주소를 구성한다.</p>\n</li>\n<li>\n<p>라우터와 허브를 통해서 <strong>네트워크 주소를 계속 중계</strong>하면서 액세스 대상을 찾아간다.</p>\n</li>\n<li>\n<p><strong>기본적인 흐름</strong></p>\n<ul>\n<li>송신측이 메세지를 보냄 → 가까운 허브가 운반하여 가까운 라우터에 송신 → 라우터에서 다음 라우터를 판단 → 서브넷의 허브가 해당 라우터까지 메세지를 송신함 → 반복하여 최종 도착지에 데이터가 도착</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"ip의-구조\" style=\"position:relative;\"><a href=\"#ip%EC%9D%98-%EA%B5%AC%EC%A1%B0\" aria-label=\"ip의 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>IP의 구조</h4>\n<ul>\n<li>32비트 디지털 데이터</li>\n<li>8비트씩 . 으로 구분하여 10진수로 표기 - 255.255.255.255</li>\n<li>네트워크 번호(서브넷 번호)와 호스트 번호를 판단하기 위해 넷마스크 정보를 IP에 더한다.</li>\n<li>넷마스크 번호도 동일하게 32비트 디지털 데이터이다.\n<ul>\n<li>1로 표기된 비트까지가 네트워크 번호</li>\n<li>0으로 표기된 비트를 호스트 번호로 판단한다.</li>\n<li>바이트 단위로 반드시 맞아 떨어지지는 않는다.</li>\n</ul>\n</li>\n<li>호스트 번호가 모두 0인 경우 - 서브넷 자체를 나타냄</li>\n<li>호스트 번호가 모두 1인 경우 - 서브넷 기기 전체에 대한 브로드캐스트를 나타냄</li>\n</ul>\n<h3 id=\"도메인명과-ip-주소를-구분하는-이유\" style=\"position:relative;\"><a href=\"#%EB%8F%84%EB%A9%94%EC%9D%B8%EB%AA%85%EA%B3%BC-ip-%EC%A3%BC%EC%86%8C%EB%A5%BC-%EA%B5%AC%EB%B6%84%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0\" aria-label=\"도메인명과 ip 주소를 구분하는 이유 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>도메인명과 IP 주소를 구분하는 이유</h3>\n<ul>\n<li>반드시 IP 주소가 있어야지 수신 상대와 연결될 수 있는데 번호로 구성된 IP를 기억하기는 어렵기 때문에 도메인명을 쓰도록 한다.</li>\n<li>도메인명 만으로 네트워크 통신을 하게 된다면 주소에 대한 바이트가 균일하지 않고 지나치게 클 수 있다.\n<ul>\n<li>데이터 운반 동작에 더 많은 시간이 걸려 속도가 느려진다.</li>\n</ul>\n</li>\n<li>따라서 사용자는 도메인명만 기억하면 해당 IP 주소를 알아서 찾아주는 <strong>DNS</strong>를 사용한다.</li>\n</ul>\n<h3 id=\"socket-라이브러리가-ip-주소-찾는-기능을-제공\" style=\"position:relative;\"><a href=\"#socket-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC%EA%B0%80-ip-%EC%A3%BC%EC%86%8C-%EC%B0%BE%EB%8A%94-%EA%B8%B0%EB%8A%A5%EC%9D%84-%EC%A0%9C%EA%B3%B5\" aria-label=\"socket 라이브러리가 ip 주소 찾는 기능을 제공 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Socket 라이브러리가 IP 주소 찾는 기능을 제공</h3>\n<ul>\n<li>DNS 동일하게 요청 메세지 + 응답 메세지의 구조로 데이터를 찾아내는 것이다.</li>\n<li>DNS 서버에 요청 메세지를 보내어 도메인명을 의뢰하는 DNS 클라이언트는 <strong>DNS 리졸버</strong>이다.</li>\n<li>DNS resolution → DNS 원리로 IP 주소를 조사하는 것 (DNS 리졸버가 수행함)</li>\n<li><strong>DBS 리졸버는 Socket 라이브러리에 내장된 프로그램이다.</strong>\n<ul>\n<li>Socket 라이브러리에는 네트워크 기능과 관련된 프로그램이 집합해 있다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"리졸버를-이용하여-dns-서버를-조회한다\" style=\"position:relative;\"><a href=\"#%EB%A6%AC%EC%A1%B8%EB%B2%84%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-dns-%EC%84%9C%EB%B2%84%EB%A5%BC-%EC%A1%B0%ED%9A%8C%ED%95%9C%EB%8B%A4\" aria-label=\"리졸버를 이용하여 dns 서버를 조회한다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>리졸버를 이용하여 DNS 서버를 조회한다</h3>\n<ul>\n<li>Socket 라이브러리에 리졸버 메소드에 의뢰하고자 하는 도메인 명을 명시하면 IP 주소를 조회할 수 있다.</li>\n</ul>\n<h3 id=\"리졸버-내부의-작동\" style=\"position:relative;\"><a href=\"#%EB%A6%AC%EC%A1%B8%EB%B2%84-%EB%82%B4%EB%B6%80%EC%9D%98-%EC%9E%91%EB%8F%99\" aria-label=\"리졸버 내부의 작동 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>리졸버 내부의 작동</h3>\n<ul>\n<li>어플리케이션(브라우저)에서 리졸버를 호출하면서 어플리케이션은 잠시 대기한다. (리졸버로 제어가 넘어가 실행된다. 이때부터 실행주체는 Socket 라이브러리의 리졸버이다)</li>\n<li>DNS 서버에 응답 메세지를 만들어 보낸다.</li>\n<li><strong>메세지 송신 동작은 OS의 프로토콜 스택이 수행한다. LAN 어댑터를 경유하여 목표서버에 메세지가 전달된다.</strong></li>\n<li>DNS 서버가 해당 메세지를 해석하여 결과를 찾는다.</li>\n<li>응답이 오면 <code class=\"language-text\">프로토콜 스택 → 리졸버가 내용을 해독하여 IP 주소 추출 → 어플리케이션에 주소전달</code> 하는 단계를 밟는다.</li>\n<li>DNS 서버 주소 정보는 ?\n<ul>\n<li>TCP/IP 설정 항목으로 컴퓨터에 미리 설정되어 있다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<br>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[용어]\n\nURL - Uniform Resource Locater\n\nFTP - File Transfer Protocol\n\nURI - Unifor Resource Identifier\n\nCGI 프로그램 - 웹 서버 소프트웨어에서 프로그램을 호출할 때 정한 규칙(CGI)에 따라 움직이는 프로그램  \n\n라우터 - 패킷을 중계하는 장치 \n\n허브 - 패킷을 중계하는 장치 (리피터 허브 &amp; 스위칭 허브) \n\nDNS - Domain Name System 서버명과 IP주소를 대응, 메일 주소와 메일 서버를 대응 등등 \n\n프로토콜 스택 - OS 에 내장되어 있는 네트워크 제어 소프트웨어</code></pre></div>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#-%EA%B0%9C%EC%9A%94\">💡 개요</a></p>\n</li>\n<li>\n<p><a href=\"#-story1-http-%EB%A6%AC%ED%80%98%EC%8A%A4%ED%8A%B8-%EB%A9%94%EC%84%B8%EC%A7%80%EB%A5%BC-%EC%9E%91%EC%84%B1%ED%95%9C%EB%8B%A4\">🛺 [STORY1] HTTP 리퀘스트 메세지를 작성한다</a></p>\n<ul>\n<li><a href=\"#url-%EC%9E%85%EB%A0%A5\">URL 입력</a></li>\n<li><a href=\"#%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EC%9D%98-url-%ED%95%B4%EB%8F%85\">브라우저의 URL 해독</a></li>\n<li><a href=\"#http%EA%B8%B0%EB%B3%B8-%EA%B0%9C%EB%85%90\">HTTP기본 개념</a></li>\n<li><a href=\"#http-%EB%A6%AC%EC%BF%BC%EC%8A%A4%ED%8A%B8-%EB%A9%94%EC%84%B8%EC%A7%80%EB%A5%BC-%EB%A7%8C%EB%93%A0%EB%8B%A4\">HTTP 리쿼스트 메세지를 만든다</a></li>\n<li><a href=\"#%EB%A6%AC%ED%80%98%EC%8A%A4%ED%8A%B8-%EB%A9%94%EC%84%B8%EC%A7%80%EB%A5%BC-%EB%B3%B4%EB%82%B8-%EC%9D%B4%ED%9B%84-%EC%9D%91%EB%8B%B5%EC%9D%B4-%EB%8F%8C%EC%95%84%EC%98%A8%EB%8B%A4\">리퀘스트 메세지를 보낸 이후 응답이 돌아온다.</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-story2-%EC%9B%B9-%EC%84%9C%EB%B2%84%EC%9D%98-ip%EC%A3%BC%EC%86%8C%EB%A5%BC-dns-%EC%84%9C%EB%B2%84%EC%97%90-%EC%A1%B0%ED%9A%8C%ED%95%9C%EB%8B%A4\">🛺 [STORY2] 웹 서버의 IP주소를 DNS 서버에 조회한다.</a></p>\n<ul>\n<li>\n<p><a href=\"#ip-%EC%A3%BC%EC%86%8C%EC%9D%98-%EA%B8%B0%EB%B3%B8\">IP 주소의 기본</a></p>\n<ul>\n<li><a href=\"#tcpip-%EA%B8%B0%EB%B3%B8-%EA%B0%9C%EB%85%90\">TCP/IP 기본 개념</a></li>\n<li><a href=\"#ip%EC%9D%98-%EA%B5%AC%EC%A1%B0\">IP의 구조</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EB%8F%84%EB%A9%94%EC%9D%B8%EB%AA%85%EA%B3%BC-ip-%EC%A3%BC%EC%86%8C%EB%A5%BC-%EA%B5%AC%EB%B6%84%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0\">도메인명과 IP 주소를 구분하는 이유</a></p>\n</li>\n<li>\n<p><a href=\"#socket-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC%EA%B0%80-ip-%EC%A3%BC%EC%86%8C-%EC%B0%BE%EB%8A%94-%EA%B8%B0%EB%8A%A5%EC%9D%84-%EC%A0%9C%EA%B3%B5\">Socket 라이브러리가 IP 주소 찾는 기능을 제공</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%A6%AC%EC%A1%B8%EB%B2%84%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-dns-%EC%84%9C%EB%B2%84%EB%A5%BC-%EC%A1%B0%ED%9A%8C%ED%95%9C%EB%8B%A4\">리졸버를 이용하여 DNS 서버를 조회한다</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%A6%AC%EC%A1%B8%EB%B2%84-%EB%82%B4%EB%B6%80%EC%9D%98-%EC%9E%91%EB%8F%99\">리졸버 내부의 작동</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</div>","frontmatter":{"date":"September 24, 2021","title":"성공과 실패를 결정하는 1%의 네트워크 원리_1","categories":"네트워크 책","author":"코다","emoji":"⚡️"},"fields":{"slug":"/one-percent-network-1/"}},"site":{"siteMetadata":{"siteUrl":"https://yjksw.github.io","comments":{"utterances":{"repo":"yjksw/yjksw.github.io"}}}}},"pageContext":{"slug":"/high-traffic-service_3/","nextSlug":"/high-traffic-service_4/","prevSlug":"/one-percent-network-1/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}
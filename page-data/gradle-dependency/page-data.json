{"componentChunkName":"component---src-templates-blog-template-js","path":"/gradle-dependency/","result":{"data":{"cur":{"id":"3ff22722-319b-55d8-82ed-b7434e408311","html":"<p>웹 UI/DB 를 적용한 온라인 체스 게임을 구현하는 중 리뷰어가 다음과 같은 질문을 했다. 처음 웹 개발을 해보는 것이라서 우선 돌아가기 위해 인터넷과 크루들이 추가한 <code class=\"language-text\">dependency</code> 를 우선 가져와 추가했었는데 리뷰어의 질문을 받고 해당 개념을 찾아보았다. </p>\n<p><a href=\"%5Bhttps://tomgregory.com/gradle-implementation-vs-compile-dependencies/#:~:text=The%20compile%20dependency%20configuration%20is,the%20same%20functionality%20as%20compile.&#x26;text=You%20should%20always%20use%20implementation,as%20compile%20is%20now%20deprecated%5D(https://tomgregory.com/gradle-implementation-vs-compile-dependencies/#:~:text=The%20compile%20dependency%20configuration%20is,the%20same%20functionality%20as%20compile.&#x26;text=You%20should%20always%20use%20implementation,as%20compile%20is%20now%20deprecated).\">참고 링크</a></p>\n<p align=\"center\"><img width=\"90%\" src=\"https://user-images.githubusercontent.com/63405904/134770516-da835d13-928a-4cf9-95fc-61b73542173c.png\"></p> \n<p>결론부터 말해서 다음을 기억하면 될 것 같다. </p>\n<ul>\n<li><code class=\"language-text\">compile</code> 은 Gradle 7.0 부터 depracated 되므로 대부분의 상황에서 <code class=\"language-text\">implementation</code> 을 사용하도록 한다.</li>\n</ul>\n<p><code class=\"language-text\">Compile</code>과 <code class=\"language-text\">implementation</code>은 거의 같은 가능을 하기 때문에 서로가 대체 되어도 상관없다. </p>\n<h3 id=\"그렇다면-implementation-의존성-주입은-무엇일까\" style=\"position:relative;\"><a href=\"#%EA%B7%B8%EB%A0%87%EB%8B%A4%EB%A9%B4-implementation-%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%A3%BC%EC%9E%85%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C\" aria-label=\"그렇다면 implementation 의존성 주입은 무엇일까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>그렇다면 implementation 의존성 주입은 무엇일까?</h3>\n<p>Java 프로젝트가 실행이 될 때 2개의 classpath가 존재한다. </p>\n<ol>\n<li>Complie classpath </li>\n<li>Runtime classpath </li>\n</ol>\n<p>Gradle dependency를 추가할 때 위 두가지 경우에 필요한 의존성들이 나누어지고 둘다 필요한 경우도 있다. 따라서 각각 필요한 경우에 추가할 수 있는 경우들과 두가지 경우 모두 필요할 경우 추가할 수 있는 키워드가 따로 있다. </p>\n<ol>\n<li>compileOnly : compile classpath에서 필요한 경우</li>\n<li>runtimeOnly : runtime classpath에서 필요한 경우</li>\n<li>implementation : 위 두가지에 모두 필요한 경우</li>\n</ol>\n<p>위 경우들을 나누어서 의존성을 추가했을 때, 각각의 경우에 dependencies와 classpaths의 간결함으로 컴파일 시간이 단축되고 프로그램 복잡도를 낮출 수 있다.</p>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#%EA%B7%B8%EB%A0%87%EB%8B%A4%EB%A9%B4-implementation-%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%A3%BC%EC%9E%85%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C\">그렇다면 implementation 의존성 주입은 무엇일까?</a></li>\n</ul>\n</div>","excerpt":"웹 UI/DB 를 적용한 온라인 체스 게임을 구현하는 중 리뷰어가 다음과 같은 질문을 했다. 처음 웹 개발을 해보는 것이라서 우선 돌아가기 위해 인터넷과 크루들이 추가한  를 우선 가져와 추가했었는데 리뷰어의 질문을 받고 해당 개념을 찾아보았다.  참고 링크 결론부터 말해서 다음을 기억하면 될 것 같다.   은 Gradle 7.0 부터 depracated 되므로 대부분의 상황에서  을 사용하도록 한다. 과 은 거의 같은 가능을 하기 때문에 서로가 대체 되어도 상관없다.  그렇다면 implementation 의존성 주입은 무엇일까? Java 프로젝트가 실행이 될 때 2개의 classpath가 존재한다.  Complie classpath  Runtime classpath  Gradle dependency를 추가할 때 위 두가지 경우에 필요한 의존성들이 나누어지고 둘다 필요한 경우도 있다. 따라서 각각 필요한 경우에 추가할 수 있는 경우들과 두가지 경우 모두 필요할 경우 추가할 수 있는…","frontmatter":{"date":"March 02, 2021","title":"Gradle 의존성 주입 시 implementation vs. compile","categories":"빌드","author":"코다","emoji":"🏡"},"fields":{"slug":"/gradle-dependency/"}},"next":{"id":"d6ed2c46-51b8-5365-a4ce-bb6cc111355c","html":"<p>아직 잘 모르는 분야라서 우선 두개의 차이점에 대해서만 기록해본다. 둘 중 어느 것을 어느 때에 사용해야 하는지에 대한 판단은 잘 모르겠지만 이 <a href=\"%5Bhttps://www.yegor256.com/2016/06/27/singletons-must-die.html%5D(https://www.yegor256.com/2016/06/27/singletons-must-die.html)\">링크</a> 를  확인해보면 singleton 사용을 지양하라고 했고, 또 정적 메소드도 객체지향에서는 지양하는 것이 좋다고 한다. </p>\n<h3 id=\"싱글톤\" style=\"position:relative;\"><a href=\"#%EC%8B%B1%EA%B8%80%ED%86%A4\" aria-label=\"싱글톤 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>싱글톤</h3>\n<ul>\n<li>단 하나의 객체만을 생성할 수 있는 패턴이다. 객체를 생성하려고 할 때마다 이미 생성된 것을 반환하거나 없다면 해당 시간에 처음 생성하도록 한다.</li>\n<li>정적 클래스와는 달리 싱클톤 클래스는 <code class=\"language-text\">확장</code>과 <code class=\"language-text\">인터페이스 구현</code>이 가능하다.</li>\n<li>언제 생성하는지에 대한 시점을 조정할 수 있다.</li>\n<li>객체이기 때문에 힙에 싱글톤 객체가 저장된다. 따라서 쓰레드간 공유가 가능하다.</li>\n<li>싱글톤은 구현으로 단 하나만 생성되게 보장한 것이지만 그 자체로는 클래스 객체이기 때문에 직렬화가 가능하다.</li>\n</ul>\n<h3 id=\"static-클래스\" style=\"position:relative;\"><a href=\"#static-%ED%81%B4%EB%9E%98%EC%8A%A4\" aria-label=\"static 클래스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Static 클래스</h3>\n<ul>\n<li>Static 메소드를 가지는 클래스를 말한다.</li>\n<li>어플리케이션이 메모리에 로드 될 때 정적 스택에 바로 초기화 된다.</li>\n<li>표준 클래스라고 보기는 어렵고 <code class=\"language-text\">함수와 변수가 있는 네임스페이스</code> 라고 볼 수 있다.</li>\n<li>정적 스택에 저장이 되기 때문에 쓰레드 관리가 어렵다.</li>\n</ul>\n<h3 id=\"차이\" style=\"position:relative;\"><a href=\"#%EC%B0%A8%EC%9D%B4\" aria-label=\"차이 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>차이</h3>\n<ul>\n<li>\n<p>엘레강트 오브젝트 발췌</p>\n<ul>\n<li>싱클톤 패턴과 정적 클래스의 가장 큰 차이는 싱클톤은 분리 가능한 의존성으로 연결되어 있지만 정적 클래스는 하드코딩의 결정체라는 것이다.</li>\n<li>싱글톤 패턴을 사용하면 내부에 선언된 정적 객체를 교체해서 변경할 수 있다.</li>\n<li>정적 메소드로 구현된 유틸리티 클래스는 분리할 수 없는 하드코딩된 의존성이다.</li>\n<li>따라서 OOP 관점에서는 정적 클래스가 싱글톤 패턴보다 더 안좋다.</li>\n</ul>\n</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#%EC%8B%B1%EA%B8%80%ED%86%A4\">싱글톤</a></li>\n<li><a href=\"#static-%ED%81%B4%EB%9E%98%EC%8A%A4\">Static 클래스</a></li>\n<li><a href=\"#%EC%B0%A8%EC%9D%B4\">차이</a></li>\n</ul>\n</div>","frontmatter":{"date":"Invalid date","title":"싱글톤 vs. Static","categories":"설계","author":"코다","emoji":"🛠"},"fields":{"slug":"/singleton-vs-static/"}},"prev":{"id":"93c8960d-fd12-539f-93d8-ad36d2740d7c","html":"<p>데이터의 흐름 또는 코드가 책임지는 부분의 유사도에 따라서 계층별로 나누어서 대규모 웹 어플리케이션을 구현한다. 이때의 이점은 각 계층이 담당하고 있는 책임을 알 수 있기 때문에 대량의 코드에서도 필요한 부분을 찾아서 수정하기 다소 쉽다. 또한 구조적으로 정리되어 있는 이점이 있다. <br></p>\n<p>웹 어플리케이션을 구현할 때 이러한 계층들에 대한 제대로 된 정의를 가지고 각자가 담당하는 기능을 구현하는 것이 좋다. 함께 일하는 동료 개발자나 이후에 레거시 코드로 받을 다른 개발자들과의 의사소통 비용을 크게 감소하고 쉽게 코드와 구조를 이해할 수 있기 때문이다. <br></p>\n<ul>\n<li>총 5개의 계층이 있다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token number\">1.</span> 프레젠테이션 계층 <span class=\"token punctuation\">(</span>Presentation Layer<span class=\"token punctuation\">)</span>\n<span class=\"token number\">2.</span> 제어 계층 <span class=\"token punctuation\">(</span>Control Layer<span class=\"token punctuation\">)</span>\n<span class=\"token number\">3.</span> 비지니스 로직 계층 <span class=\"token punctuation\">(</span>Business Logic Layer<span class=\"token punctuation\">)</span>\n<span class=\"token number\">4.</span> 퍼시스턴스 계층 <span class=\"token punctuation\">(</span>Persistence Layer<span class=\"token punctuation\">)</span>\n<span class=\"token number\">5.</span> 도메인 모델 계층 <span class=\"token punctuation\">(</span>Domain Model Layer<span class=\"token punctuation\">)</span> </code></pre></div>\n<h2 id=\"presentation-layer\" style=\"position:relative;\"><a href=\"#presentation-layer\" aria-label=\"presentation layer permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Presentation Layer</h2>\n<ul>\n<li>식당에서 <code class=\"language-text\">메뉴판</code> 역할</li>\n<li>\n<p>UI를 담당하는 계층이다.</p>\n<ul>\n<li>User에게 보여지는 화면 담당</li>\n<li>User의 입력을 받는 담당</li>\n<li>입력에 따른 결과를 서버로부터 받아서 다시 화면에 띄우는 담당</li>\n</ul>\n</li>\n<li>다른 계층과의 접촉이 없고 Control layer를 통해서 다른 계층과 협업한다. 따라서 presentation layer의 모든 요청과 응답은 control layer를 통해서 이루어진다.</li>\n<li>UI에서 직접적인 비지니스 로직을 수행해서 일을 처리하지 않는다!</li>\n</ul>\n<h2 id=\"control-layer\" style=\"position:relative;\"><a href=\"#control-layer\" aria-label=\"control layer permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Control Layer</h2>\n<ul>\n<li>식당에서 <code class=\"language-text\">지배원</code> 역할</li>\n<li>Presentation layer와 비지니스 로직을 담당하는 계층 분리하는 연결 계층이다. UI에서 직접적으로 핵심 비지니스 로직에 접근하지 않도록 UI에서 온 요청에 대해 한차례 필터링 한다.</li>\n<li>\n<p>즉, 사용자 화면에서 온 요청을 분석해서 비지니스 로직에 해당 요청에 대한 처리(핵심적인 일 수행)을 결정하고 그에 따른 결과를 다시 사용자 화면으로 응답한다.</p>\n<ul>\n<li>다르게 이해하면, 핵심 비지니스 로직을 처리하는 계층은 어떠한 요청인지, 누구로부터의 요청인지를 알지 못한다.</li>\n</ul>\n</li>\n<li>UI 입력 검증, 요청/응답 전달, 예외 핸들링, Domain에서 처리된 로직 뷰와 연결 등의 기능을 담당한다.</li>\n</ul>\n<h2 id=\"business-layer\" style=\"position:relative;\"><a href=\"#business-layer\" aria-label=\"business layer permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Business Layer</h2>\n<ul>\n<li>식당에서 <code class=\"language-text\">요리사</code> 역할</li>\n<li>핵심 업무를 처리하는 로직을 담당하는 계층이다.</li>\n<li>즉, 어플리케이션의 핵심 기능이 어떻게 처리될 것인지에 대한 코드 구현이 모두 포함되어 있다.</li>\n<li>웹 어플리케이션의 핵심 부분이기 때문에 다른 요소들(사용자 화면, 연결하는 컨트롤러 등)은 변경이 잦을 수 있지만 비지니스 계층은 핵심 기능의 변경 요청이 있지 않은 이상 대체로 변경되지 않는다.</li>\n<li>서버의 주를 이루기 때문에 재사용 가능성이 높고 따라서 잘 설계되어야 한다.</li>\n<li>Business layer 로직은 다른 계층들과 특별히 더 분리되어 있는 것이 좋다. 그래야 유지보수가 쉽고 응집성이 높아진다.</li>\n<li>추가로 Business layer 의 코드는 뷰와 persitence layer(다음 설명 계층) 의 연결고리 역할도 한다.</li>\n</ul>\n<h2 id=\"persistence-layer\" style=\"position:relative;\"><a href=\"#persistence-layer\" aria-label=\"persistence layer permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Persistence Layer</h2>\n<ul>\n<li>식당에서 <code class=\"language-text\">재료</code> 역할</li>\n<li>데이터 처리를 담당하는 계층으로 CRUD를 담당한다.</li>\n<li>관계형 정보를 저장 및 업데이트, 삭제 등등의 역할을 수행하는데, 서버에서 생성되는 정보에 <code class=\"language-text\">영속성</code>을 부여한다는 측면에서 persistence layer라고 부른다.</li>\n<li>반대로 DB에서 가져온 정보를 객체화 하는 역할도 수행한다.</li>\n</ul>\n<h2 id=\"domain-model-layer\" style=\"position:relative;\"><a href=\"#domain-model-layer\" aria-label=\"domain model layer permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Domain Model Layer</h2>\n<ul>\n<li>식당에서 <code class=\"language-text\">그릇</code> 역할</li>\n<li>계층 사이에 전달되는 <strong>비지니스 객체</strong>이다.</li>\n<li>DTO의 형태로 계층간 전달이 되며 핵심 데이터를 보관하여 전달된다.</li>\n</ul>\n<p><strong>[참고자료]</strong> : <a href=\"https://postitforhooney.tistory.com/entry/Spring-MVC-%ED%8C%A8%ED%84%B4%EC%97%90%EC%84%9C%EC%9D%98-5%EA%B0%80%EC%A7%80-%EA%B3%84%EC%B8%B5%EC%97%90-%EB%8C%80%ED%95%9C-%EC%A0%95%EB%B3%B4-%ED%8D%BC%EC%98%B4\">https://postitforhooney.tistory.com/entry/Spring-MVC-패턴에서의-5가지-계층에-대한-정보-퍼옴</a></p>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#presentation-layer\">Presentation Layer</a></li>\n<li><a href=\"#control-layer\">Control Layer</a></li>\n<li><a href=\"#business-layer\">Business Layer</a></li>\n<li><a href=\"#persistence-layer\">Persistence Layer</a></li>\n<li><a href=\"#domain-model-layer\">Domain Model Layer</a></li>\n</ul>\n</div>","frontmatter":{"date":"March 05, 2021","title":"웹 Layers에 대해","categories":"웹","author":"코다","emoji":"🖥"},"fields":{"slug":"/web-layer/"}},"site":{"siteMetadata":{"siteUrl":"https://yjksw.github.io","comments":{"utterances":{"repo":"yjksw/yjksw.github.io"}}}}},"pageContext":{"slug":"/gradle-dependency/","nextSlug":"/singleton-vs-static/","prevSlug":"/web-layer/"}},"staticQueryHashes":["1073350324","2938748437"]}